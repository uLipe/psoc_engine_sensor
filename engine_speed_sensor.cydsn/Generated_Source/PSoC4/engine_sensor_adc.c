/***************************************************************************//**
* \file     engine_sensor_adc.c
* \version  1.20
*
* \brief
* Provides the source code to the API for the engine_sensor_adc Component.
*
********************************************************************************
* \copyright
* (c) 2015-2016, Cypress Semiconductor Corporation. All rights reserved.
* This software, including source code, documentation and related
* materials ("Software"), is owned by Cypress Semiconductor
* Corporation ("Cypress") and is protected by and subject to worldwide
* patent protection (United States and foreign), United States copyright
* laws and international treaty provisions. Therefore, you may use this
* Software only as provided in the license agreement accompanying the
* software package from which you obtained this Software ("EULA").
* If no EULA applies, Cypress hereby grants you a personal, nonexclusive,
* non-transferable license to copy, modify, and compile the
* Software source code solely for use in connection with Cypress's
* integrated circuit products. Any reproduction, modification, translation,
* compilation, or representation of this Software except as specified
* above is prohibited without the express written permission of Cypress.
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO
* WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING,
* BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
* PARTICULAR PURPOSE. Cypress reserves the right to make
* changes to the Software without notice. Cypress does not assume any
* liability arising out of the application or use of the Software or any
* product or circuit described in the Software. Cypress does not
* authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer
* of such system or application assumes all risk of such use and in doing
* so agrees to indemnify Cypress against all liability.
*******************************************************************************/
#include "engine_sensor_adc.h"

#include <stdlib.h>

static int32 engine_sensor_adc_IsChannelSigned(uint32 chan);
#if(engine_sensor_adc_ANY_CONFIG_USES_FILTER	!= 0u)
static void engine_sensor_adc_SetupComparatorTrim(void);
static void engine_sensor_adc_UndoComparatorTrimSetup(void);
static uint32 engine_sensor_adc_RaiseOpampTrimToCrossing(uint32 startTrim);
static uint32 engine_sensor_adc_LowerOpampTrimToCrossing(uint32 startTrim);
static uint32 engine_sensor_adc_RaiseAgndTrimToCrossing(uint32 startTrim);
static uint32 engine_sensor_adc_LowerAgndTrimToCrossing(uint32 startTrim);
static uint32 engine_sensor_adc_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim);
static uint32 engine_sensor_adc_SetOpampTrim(uint32 opampTrim);
static uint32 engine_sensor_adc_SetAgndTrim(uint32 agndTrim);
static uint32 engine_sensor_adc_IncOpampTrim(uint32 trim);
static uint32 engine_sensor_adc_DecOpampTrim(uint32 trim);
static uint32 engine_sensor_adc_IncAgndTrim(uint32 trim);
static uint32 engine_sensor_adc_DecAgndTrim(uint32 trim);
#define OFFSET_SAMPLES (30)
#endif

uint8 engine_sensor_adc_initVar = 0u; 

uint8 engine_sensor_adc_selected = 0u; /* 0 if no configuration selected. 1 otherwise. */
volatile int16 engine_sensor_adc_offset[engine_sensor_adc_TOTAL_CHANNELS_NUM]; 
volatile int32 engine_sensor_adc_countsPer10Volt[engine_sensor_adc_TOTAL_CHANNELS_NUM]; 

static uint32 engine_sensor_adc_currentConfig = 0u; /* Currently active configuration */

/*******************************************************************************
* Local data allocation
*******************************************************************************/
/* Channels configuration generated by customiser */
static const uint32 CYCODE engine_sensor_adc_channelsConfig[] = { 0x00000100UL,  };

/* Filter init */
#if(engine_sensor_adc_ANY_CONFIG_USES_FILTER	!= 0u)
    #if (0u != engine_sensor_adc_CFG0_FILTER_PRESENT)
        #define engine_sensor_adc_CFG0_UABH_A_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair engine_sensor_adc_CFG0_UABH_A_FILTER_initPairs[engine_sensor_adc_CFG0_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_A_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_A_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_A_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG0_UABH_A_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG0_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG0_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG0_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG0_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        #define engine_sensor_adc_CFG0_UABH_B_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair engine_sensor_adc_CFG0_UABH_B_FILTER_initPairs[engine_sensor_adc_CFG0_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_B_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)engine_sensor_adc_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_B_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_B_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_B_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG0_UABH_B_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG0_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG0_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG0_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG0_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG0_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (engine_sensor_adc_CFG0_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config engine_sensor_adc_CFG0_UABH_A_FILTER_config = {
            engine_sensor_adc_UABH_A_waveConfig,
            engine_sensor_adc_CFG0_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_A_PARAM_REF_TIED,engine_sensor_adc_UABH_A_PARAM_AGND_TIED,
                engine_sensor_adc_UABH_A_PARAM_SW_CC,engine_sensor_adc_UABH_A_PARAM_SW_BB,engine_sensor_adc_UABH_A_PARAM_SW_AA),
            engine_sensor_adc_UABH_A_NUM_STEPS,
            (uint8)(engine_sensor_adc_UABH_A_ELEMENT_COUNT(engine_sensor_adc_CFG0_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config engine_sensor_adc_CFG0_UABH_B_FILTER_config = {
        engine_sensor_adc_UABH_B_waveConfig,
        engine_sensor_adc_CFG0_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_B_PARAM_REF_TIED,engine_sensor_adc_UABH_B_PARAM_AGND_TIED,
            engine_sensor_adc_UABH_B_PARAM_SW_CC,engine_sensor_adc_UABH_B_PARAM_SW_BB,engine_sensor_adc_UABH_B_PARAM_SW_AA),
        engine_sensor_adc_UABH_B_NUM_STEPS,
        (uint8)(engine_sensor_adc_UABH_B_ELEMENT_COUNT(engine_sensor_adc_CFG0_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != engine_sensor_adc_CFG0_FILTER_PRESENT) */
    #if (0u != engine_sensor_adc_CFG1_FILTER_PRESENT)
        #define engine_sensor_adc_CFG1_UABH_A_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair engine_sensor_adc_CFG1_UABH_A_FILTER_initPairs[engine_sensor_adc_CFG1_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_A_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_A_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_A_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG1_UABH_A_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG1_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG1_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG1_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG1_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        #define engine_sensor_adc_CFG1_UABH_B_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair engine_sensor_adc_CFG1_UABH_B_FILTER_initPairs[engine_sensor_adc_CFG1_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_B_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)engine_sensor_adc_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_B_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_B_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_B_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG1_UABH_B_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG1_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG1_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG1_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG1_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG1_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (engine_sensor_adc_CFG1_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config engine_sensor_adc_CFG1_UABH_A_FILTER_config = {
            engine_sensor_adc_UABH_A_waveConfig,
            engine_sensor_adc_CFG1_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_A_PARAM_REF_TIED,engine_sensor_adc_UABH_A_PARAM_AGND_TIED,
                engine_sensor_adc_UABH_A_PARAM_SW_CC,engine_sensor_adc_UABH_A_PARAM_SW_BB,engine_sensor_adc_UABH_A_PARAM_SW_AA),
            engine_sensor_adc_UABH_A_NUM_STEPS,
            (uint8)(engine_sensor_adc_UABH_A_ELEMENT_COUNT(engine_sensor_adc_CFG1_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config engine_sensor_adc_CFG1_UABH_B_FILTER_config = {
        engine_sensor_adc_UABH_B_waveConfig,
        engine_sensor_adc_CFG1_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_B_PARAM_REF_TIED,engine_sensor_adc_UABH_B_PARAM_AGND_TIED,
            engine_sensor_adc_UABH_B_PARAM_SW_CC,engine_sensor_adc_UABH_B_PARAM_SW_BB,engine_sensor_adc_UABH_B_PARAM_SW_AA),
        engine_sensor_adc_UABH_B_NUM_STEPS,
        (uint8)(engine_sensor_adc_UABH_B_ELEMENT_COUNT(engine_sensor_adc_CFG1_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != engine_sensor_adc_CFG1_FILTER_PRESENT) */
    #if (0u != engine_sensor_adc_CFG2_FILTER_PRESENT)
        #define engine_sensor_adc_CFG2_UABH_A_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair engine_sensor_adc_CFG2_UABH_A_FILTER_initPairs[engine_sensor_adc_CFG2_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_A_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_A_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_A_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG2_UABH_A_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG2_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG2_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG2_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG2_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        #define engine_sensor_adc_CFG2_UABH_B_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair engine_sensor_adc_CFG2_UABH_B_FILTER_initPairs[engine_sensor_adc_CFG2_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_B_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)engine_sensor_adc_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_B_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_B_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_B_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG2_UABH_B_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG2_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG2_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG2_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG2_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG2_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (engine_sensor_adc_CFG2_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config engine_sensor_adc_CFG2_UABH_A_FILTER_config = {
            engine_sensor_adc_UABH_A_waveConfig,
            engine_sensor_adc_CFG2_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_A_PARAM_REF_TIED,engine_sensor_adc_UABH_A_PARAM_AGND_TIED,
                engine_sensor_adc_UABH_A_PARAM_SW_CC,engine_sensor_adc_UABH_A_PARAM_SW_BB,engine_sensor_adc_UABH_A_PARAM_SW_AA),
            engine_sensor_adc_UABH_A_NUM_STEPS,
            (uint8)(engine_sensor_adc_UABH_A_ELEMENT_COUNT(engine_sensor_adc_CFG2_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config engine_sensor_adc_CFG2_UABH_B_FILTER_config = {
        engine_sensor_adc_UABH_B_waveConfig,
        engine_sensor_adc_CFG2_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_B_PARAM_REF_TIED,engine_sensor_adc_UABH_B_PARAM_AGND_TIED,
            engine_sensor_adc_UABH_B_PARAM_SW_CC,engine_sensor_adc_UABH_B_PARAM_SW_BB,engine_sensor_adc_UABH_B_PARAM_SW_AA),
        engine_sensor_adc_UABH_B_NUM_STEPS,
        (uint8)(engine_sensor_adc_UABH_B_ELEMENT_COUNT(engine_sensor_adc_CFG2_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != engine_sensor_adc_CFG2_FILTER_PRESENT) */
    #if (0u != engine_sensor_adc_CFG3_FILTER_PRESENT)
        #define engine_sensor_adc_CFG3_UABH_A_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair engine_sensor_adc_CFG3_UABH_A_FILTER_initPairs[engine_sensor_adc_CFG3_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_A_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_A_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_A_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_A_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG3_UABH_A_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_A_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG3_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG3_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_A_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_A_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_A_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_A_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_A_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG3_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_A_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG3_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        #define engine_sensor_adc_CFG3_UABH_B_FILTER_INITPAIRSSIZE ((engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair engine_sensor_adc_CFG3_UABH_B_FILTER_initPairs[engine_sensor_adc_CFG3_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {engine_sensor_adc_UABH_B_OA_CTRL_PTR        , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_OA_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_STATIC_PTR      , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_STATIC)}
            ,{engine_sensor_adc_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)engine_sensor_adc_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{engine_sensor_adc_UABH_B_SRAM_CTRL_PTR      , ((uint32)engine_sensor_adc_UABH_B_INVAR_SRAM_CTRL)} 
            ,{engine_sensor_adc_UABH_B_STARTUP_DELAY_PTR  , ((uint32)engine_sensor_adc_CFG3_UABH_B_STARTUP_DELAY)}
            ,{engine_sensor_adc_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{engine_sensor_adc_UABH_B_SW_OTHER_PTR  , ((uint32)engine_sensor_adc_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG3_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG3_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{engine_sensor_adc_UABH_B_SW_CA_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CA_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CA_TOP_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CB_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN0_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{engine_sensor_adc_UABH_B_SW_CC_IN1_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{engine_sensor_adc_UABH_B_SW_CF_BOT_PTR      , ((uint32)engine_sensor_adc_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{engine_sensor_adc_UABH_B_CAP_CTRL_PTR       , ((uint32)engine_sensor_adc_CFG3_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{engine_sensor_adc_UABH_B_SW_CB_TOP_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{engine_sensor_adc_UABH_B_SW_CC_TOP_PTR      , ((uint32)engine_sensor_adc_CFG3_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{engine_sensor_adc_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)engine_sensor_adc_CFG3_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (engine_sensor_adc_CFG3_FILTERTYPE_USED == engine_sensor_adc_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config engine_sensor_adc_CFG3_UABH_A_FILTER_config = {
            engine_sensor_adc_UABH_A_waveConfig,
            engine_sensor_adc_CFG3_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_A_PARAM_REF_TIED,engine_sensor_adc_UABH_A_PARAM_AGND_TIED,
                engine_sensor_adc_UABH_A_PARAM_SW_CC,engine_sensor_adc_UABH_A_PARAM_SW_BB,engine_sensor_adc_UABH_A_PARAM_SW_AA),
            engine_sensor_adc_UABH_A_NUM_STEPS,
            (uint8)(engine_sensor_adc_UABH_A_ELEMENT_COUNT(engine_sensor_adc_CFG3_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config engine_sensor_adc_CFG3_UABH_B_FILTER_config = {
        engine_sensor_adc_UABH_B_waveConfig,
        engine_sensor_adc_CFG3_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(engine_sensor_adc_UABH_B_PARAM_REF_TIED,engine_sensor_adc_UABH_B_PARAM_AGND_TIED,
            engine_sensor_adc_UABH_B_PARAM_SW_CC,engine_sensor_adc_UABH_B_PARAM_SW_BB,engine_sensor_adc_UABH_B_PARAM_SW_AA),
        engine_sensor_adc_UABH_B_NUM_STEPS,
        (uint8)(engine_sensor_adc_UABH_B_ELEMENT_COUNT(engine_sensor_adc_CFG3_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != engine_sensor_adc_CFG3_FILTER_PRESENT) */
    
    
#endif /* (engine_sensor_adc_ANY_CONFIG_USES_FILTER	!= 0u)	*/

/*******************************************************************************
* Function Name: engine_sensor_adc_Start
****************************************************************************//**
*
* \brief Performs all required initialization for this component and enables the 
*  power. The power will be set to the appropriate power based on the clock 
*  frequency.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
* \globalvars
*  \ref engine_sensor_adc_initVar (RW)
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_Start
*
*******************************************************************************/
void engine_sensor_adc_Start(void)
{
    if (engine_sensor_adc_INIT_VAR_INIT_FLAG != (engine_sensor_adc_INIT_VAR_INIT_FLAG & engine_sensor_adc_initVar))
    {
        engine_sensor_adc_Init();
        engine_sensor_adc_initVar |= engine_sensor_adc_INIT_VAR_INIT_FLAG;
    }
    
    engine_sensor_adc_Enable();
    
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_StartEx
****************************************************************************//**
*
* \brief This function starts the engine_sensor_adc and sets the Interrupt 
* Service Routine to the provided address using the 
* engine_sensor_adc_IRQ_StartEx() function. Refer to the Interrupt component 
* datasheet for more information on the engine_sensor_adc_IRQ_StartEx() function.
* 
* \param address This is the address of a user defined function for the ISR.
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_StartEx
*
*******************************************************************************/
void engine_sensor_adc_StartEx(cyisraddress address)
{
    engine_sensor_adc_Start();
    engine_sensor_adc_IRQ_StartEx(address);
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_Stop
****************************************************************************//**
*
* \brief This function stops ADC conversions and puts the ADC into its lowest 
* power mode.
* 
* \param None
* 
* \return None
* 
* \sideeffect
* Do not use the engine_sensor_adc_Stop() API to halt conversions. Instead use the 
* engine_sensor_adc_StopConvert() API. If you use the engine_sensor_adc_Stop() API 
* to halt conversions then later use the engine_sensor_adc_Start() and 
* engine_sensor_adc_StartConvert() APIs to resume conversions, the first channel 
* of the scan may be corrupt. The engine_sensor_adc_StopConvert() API will enable 
* the engine_sensor_adc to complete the current scan of channels. After the 
* channel scan is complete, the engine_sensor_adc will stop all conversions, which 
* can be detected by the use of an ISR or the engine_sensor_adc_IsEndConversion() 
* flag.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_Stop
*
*******************************************************************************/
void engine_sensor_adc_Stop(void)
{	
    #if(0u != engine_sensor_adc_ANY_CONFIG_USES_FILTER)	
    	if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].miscConfig 
    	   & engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	   == engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
    		engine_sensor_adc_UABH_A_Stop();
    		engine_sensor_adc_UABH_B_Stop();
            engine_sensor_adc_FILTERAGND2SAR_BUFFER_Stop();
    	}
    #endif /* engine_sensor_adc_ANY_CONFIG_USES_FILTER != 0u */
    engine_sensor_adc_SAR_CTRL_REG &= (uint32)~engine_sensor_adc_SAR_CTRL_ENABLED_MSK;
    return;
}

/* ****************************************************************************
* Function Name: engine_sensor_adc_InitConfig
****************************************************************************//*
*
* \brief Configures all of the registers for a given configuration for scanning.
*
* \param scan Number of scan defined in the engine_sensor_adc.
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_InitConfig
*
*******************************************************************************/
void engine_sensor_adc_InitConfig(const engine_sensor_adc_CONFIG_STRUCT *config)
{
	uint32 chNum;
    uint32 tmpRegVal;
	
    #if(0u != engine_sensor_adc_ANY_CONFIG_USES_FILTER)	        
    	if((config->miscConfig & engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            engine_sensor_adc_intUabClock_SetFractionalDividerRegister(config->filterClkDivider, 0u);
            
    	}
    #endif /* engine_sensor_adc_ANY_CONFIG_USES_FILTER != 0u */
    #if (engine_sensor_adc_CLOCK_INTERNAL)
        engine_sensor_adc_intSarClock_SetFractionalDividerRegister(config->clkDivider, 0u);
        
    #endif /* engine_sensor_adc_CLOCK_INTERNAL */
    /* Init SAR and MUX registers */
	engine_sensor_adc_SAR_CTRL_REG = config->ctrl
   
	/* Enable the SAR internal pump when global pump is enabled */
    | (((engine_sensor_adc_PUMP_CTRL_REG & engine_sensor_adc_PUMP_CTRL_ENABLED) != 0u) 
    ? engine_sensor_adc_SAR_CTRL_BOOSTPUMP_EN_MSK : 0u);
	
	engine_sensor_adc_SAR_SAMPLE_CTRL_REG = config->sampleCtrl;
	engine_sensor_adc_SAR_RANGE_THRES_REG = config->rangeThres;	
	engine_sensor_adc_SAR_RANGE_COND_REG = config->rangeCond;
	engine_sensor_adc_SAR_SAMPLE_TIME01_REG = config->sampleTime01;
	engine_sensor_adc_SAR_SAMPLE_TIME23_REG = config->sampleTime23;
    
	/* Connect Vminus to VSSA when even one channel is single-ended or multiple channels configured */
	if(1u == engine_sensor_adc_MUX_SWITCH0_INIT)
	{
		engine_sensor_adc_MUX_SWITCH0_REG |= engine_sensor_adc_MUX_FW_VSSA_VMINUS;
		/* Set MUX_HW_CTRL_VSSA in MUX_SWITCH_HW_CTRL when multiple channels enabled */
		if(1ul < config->numChannels)
		{
			engine_sensor_adc_MUX_SWITCH_HW_CTRL_REG |= engine_sensor_adc_MUX_FW_VSSA_VMINUS;
		}
	}
    
	/* Clear and set interrupt masks */
	engine_sensor_adc_SAR_SATURATE_INTR_MASK_REG = 0u;
    engine_sensor_adc_SAR_RANGE_INTR_MASK_REG = 0u;	
	engine_sensor_adc_SAR_SATURATE_INTR_MASK_REG = config->satIntMask;
	engine_sensor_adc_SAR_RANGE_INTR_MASK_REG = config->rangeIntMask;
	engine_sensor_adc_SAR_INTR_MASK_REG = engine_sensor_adc_EOS_MASK;
    
	/* Double the non-overlap delay and latch enable time when using */
    /* internal reference without bypass cap */
    tmpRegVal = engine_sensor_adc_SAR_DFT_CTRL_REG;
	if(((config->ctrl & engine_sensor_adc__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == engine_sensor_adc__INTERNAL1024) 
	    || ((config->ctrl & engine_sensor_adc__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == engine_sensor_adc__INTERNALVREF))
	{
        tmpRegVal &= ~engine_sensor_adc_SAR_DFT_CTRL_DCEN_MSK;
		tmpRegVal |= engine_sensor_adc_SAR_DFT_CTRL_DLY_INC_MSK;
	}
	else
	{
		tmpRegVal |= engine_sensor_adc_SAR_DFT_CTRL_DCEN_MSK;
        tmpRegVal &= (uint32)~engine_sensor_adc_SAR_DFT_CTRL_DLY_INC_MSK;
	}	
	engine_sensor_adc_SAR_DFT_CTRL_REG = tmpRegVal;
	
	for(chNum = 0u; chNum < config->numChannels; chNum++)
    {
		tmpRegVal = (engine_sensor_adc_channelsConfig[config->channelBase + chNum] 
		& engine_sensor_adc_CHANNEL_CONFIG_MASK);
        
        #if(engine_sensor_adc_TOTAL_CHANNELS_NUM > 1)
            tmpRegVal |= engine_sensor_adc_InputsPlacement[config->channelBase + chNum];
            /*Non-paired differential channels set NEG_ADDR_EN and clear DIFFERENTIAL_EN */
            if(0u != (engine_sensor_adc_InputsPlacement[config->channelBase + chNum] & engine_sensor_adc_CHANNEL_CONFIG_NEG_ADDR_EN_MSK))
            {
                tmpRegVal &= ~engine_sensor_adc_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK;
            }
        #endif
        
		CY_SET_REG32((reg32 *)(engine_sensor_adc_SAR_CHAN_CONFIG_IND + (uint32)(chNum << 2)), tmpRegVal);
	}
	
    return;
}

/* ****************************************************************************
* Function Name: engine_sensor_adc_SelectConfig
****************************************************************************//* 
*
* \brief Selects the predefined configuration for scanning. Disables
* and re-enables the SAR and filter (if filter used).
* 
* \param config Number of configuration  in the engine_sensor_adc.
* 
* \param restart Determines if the engine_sensor_adc should be  restarted after 
* selecting the configuration.
**
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SelectConfig
*
*******************************************************************************/
void engine_sensor_adc_SelectConfig(uint32 config, uint32 restart)
{
    /* Check whether the configuration number is valid or not */
    if(engine_sensor_adc_TOTAL_CONFIGS > config)
    {        
        /* Stop the ADC before changing configurations */
	    engine_sensor_adc_Stop();
        engine_sensor_adc_selected = 1u;
        
    	if(0u == engine_sensor_adc_initVar)
    	{
            engine_sensor_adc_Init();
            engine_sensor_adc_initVar |= engine_sensor_adc_INIT_VAR_INIT_FLAG;
    	}
        #if (engine_sensor_adc_VREF_ROUTED)
            engine_sensor_adc_vrefAMux_DisconnectAll();
        #endif
    	engine_sensor_adc_InitConfig(&engine_sensor_adc_allConfigs[config]);
        #if (engine_sensor_adc_VREF_ROUTED)
            engine_sensor_adc_vrefAMux_Select((uint8)config);
        #endif
        #if(0u != engine_sensor_adc_ANY_CONFIG_USES_FILTER)
            engine_sensor_adc_filterVinMux_Select((uint8)config);
            engine_sensor_adc_filterInit(config);
        #endif
    	engine_sensor_adc_SAR_CHAN_EN_REG = engine_sensor_adc_allConfigs[config].chanEn;
    	engine_sensor_adc_SAR_RANGE_INTR_MASK_REG = engine_sensor_adc_allConfigs[config].rangeIntMask;
    	engine_sensor_adc_SAR_SATURATE_INTR_MASK_REG = engine_sensor_adc_allConfigs[config].satIntMask;
    	engine_sensor_adc_currentConfig = config;
        
        if(1u == restart)
        {
            /* Restart the ADC */    
            engine_sensor_adc_Start();
            
            /* Restart the scan */
            engine_sensor_adc_StartConvert();
        }
    }
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_StartConvert
****************************************************************************//**
*
* \brief In continuous mode, this API starts the conversion process and it runs 
* continuously. 

* In Single Shot mode, the function triggers a single scan and 
* every scan requires a call of this function. The mode is set with the 
* Sample Mode parameter in the customizer. The customizer setting can be 
* overridden at run time with the engine_sensor_adc_SetConvertMode() function.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_StartConvert
*
*******************************************************************************/
void engine_sensor_adc_StartConvert(void)
{
    /* CDT 243358 */
    #if(0u != engine_sensor_adc_ANY_CONFIG_USES_FILTER)
        engine_sensor_adc_Stop();
        engine_sensor_adc_Start();
    #endif
    
	/* Freerunning mode */
	if((engine_sensor_adc_SAR_SAMPLE_CTRL_REG 
		& engine_sensor_adc_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== engine_sensor_adc_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
    {
		engine_sensor_adc_SAR_SAMPLE_CTRL_REG |= engine_sensor_adc_SAR_SAMPLE_CTRL_CONTINUOUS_MSK ;
	}
	else /* Firmware trigger */
	{
		engine_sensor_adc_SAR_START_CTRL_REG = engine_sensor_adc_SAR_START_CTRL_FW_TRIGGER_MSK;
	}
    
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_StopConvert
****************************************************************************//**
*
* \brief Forces the engine_sensor_adc to stop conversions. If a conversion is 
* currently executing, that conversion will complete, but no further conversions 
* will occur.
* 
* \param None
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_StopConvert
*
*******************************************************************************/
void engine_sensor_adc_StopConvert(void)
{
    if((engine_sensor_adc_SAR_SAMPLE_CTRL_REG  
		& engine_sensor_adc_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== engine_sensor_adc_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
	{
        engine_sensor_adc_SAR_SAMPLE_CTRL_REG &= ~engine_sensor_adc_SAR_SAMPLE_CTRL_CONTINUOUS_MSK;
        
        if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].miscConfig 
            & engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            /* Re-synchronize the Filter if a filter is present */
            engine_sensor_adc_Stop();
            engine_sensor_adc_Start();
        }
	}
    
    return;
}
/*******************************************************************************
* Function Name: engine_sensor_adc_SetConvertMode
****************************************************************************//**
*
* \brief Sets the conversion mode to either Single-Shot or continuous. This 
* function overrides the settings applied in the customizer. Changing 
* configurations will restore the values set in the customizer.
*
* \param mode Sets the conversion mode. See table below for details.
* | Options                          | Description                             |
* | :------------------------------- | :-------------------------------------- |
* | engine_sensor_adc_SINGLE_SHOT     | Calling the engine_sensor_adc_StartConvert() function after setting mode this will trigger a single scan. Sets the SOC signal to be edge sensitive, each edge will trigger a single scan. |
* | engine_sensor_adc_CONTINUOUS      | Calling the engine_sensor_adc_StartConvert() function after setting this mode trigger continuous scanning. This mode sets the SOC signal to be level sensitive. The engine_sensor_adc will continuously scan while soc is active. |
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetConvertMode
*
*******************************************************************************/
void engine_sensor_adc_SetConvertMode(uint32 mode)
{
    if(engine_sensor_adc_CONTINUOUS == mode)
    {
        engine_sensor_adc_SAR_SAMPLE_CTRL_REG |= engine_sensor_adc_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
    else
    {
        engine_sensor_adc_SAR_SAMPLE_CTRL_REG &= ~engine_sensor_adc_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
}
/* ****************************************************************************
* Function Name: engine_sensor_adc_IRQ_Enable
****************************************************************************//*
*
* \brief Enables interrupts to occur at the end of a conversion. Global 
* interrupts must also be enabled for the engine_sensor_adc interrupts to occur.
*
* \param None
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_IRQ_Enable
*
*******************************************************************************/


/* ****************************************************************************
* Function Name: engine_sensor_adc_IRQ_Disable
****************************************************************************//* 
*
* \brief Disables end of conversion interrupts. 
*
* \param None
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_IRQ_Disable
*
*******************************************************************************/


/*******************************************************************************
* Function Name: engine_sensor_adc_SetEosMask
****************************************************************************//**
*
* \brief Sets of clears the End of Scan (EOS) interrupt mask. 
*
* \param mask 1 to set the mask, 0 to clear the mask.
*
* \return None
* 
* \sideeffect All other bits in the INTR register are cleared by this function.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetEosMask
*
*******************************************************************************/
void engine_sensor_adc_SetEosMask(uint32 mask)
{
    engine_sensor_adc_SAR_INTR_MASK_REG = mask & engine_sensor_adc_EOS_MASK;
    
    return;
}

/* ****************************************************************************
* Function Name: engine_sensor_adc_SetChanMask
****************************************************************************//*
*
* \brief Sets enable/disable mask for all channels in current configuration.
*
*
* \param enableMask
*  Channel enable/disable mask.
*
* \sideeffect
*  None.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetChanMask
*
*******************************************************************************/
void engine_sensor_adc_SetChanMask(uint32 enableMask)
{
    uint32 chanCount = engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels;
    enableMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    engine_sensor_adc_SAR_CHAN_EN_REG = enableMask;
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_IsEndConversion
****************************************************************************//**
*
* \brief Immediately returns the status of the conversion or does not return 
* (blocking) until the conversion completes, depending on the retMode parameter.
*
* \param retMode Check conversion return mode. See the following table for 
* options.
* | Options                              | Description                             |
* | :-------------------------------     | :-------------------------------------- |
* | engine_sensor_adc_RETURN_STATUS       | Immediately returns the conversion status for sequential channels. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | engine_sensor_adc_WAIT_FOR_RESULT     | Does not return a result until the engine_sensor_adc conversion of all sequential channels is complete. |
* | engine_sensor_adc_RETURN_STATUS_INJ   | Immediately returns the conversion status for the injection channel. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | engine_sensor_adc_WAIT_FOR_RESULT_INJ | Does not return a result until the engine_sensor_adc completes injection channel conversion. |
* 
* \return uint8: If a nonzero value is returned, the last conversion is complete. 
* If the returned value is zero, the engine_sensor_adc is still calculating the last result.
*
* \sideeffect This function reads the end of conversion status, and clears it afterward.
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_IsEndConversion
*
*******************************************************************************/
uint32 engine_sensor_adc_IsEndConversion(uint32 retMode)
{
    uint32 endOfConversion = 0u;
    uint32 wdt = 0x3FFFFFFuL; /* Watchdog timer for blocking while loop */
    if((engine_sensor_adc_RETURN_STATUS == retMode) || (engine_sensor_adc_WAIT_FOR_RESULT == retMode))
    {
        do
        {
            endOfConversion = engine_sensor_adc_SAR_INTR_REG & engine_sensor_adc_EOS_MASK;
            wdt--;
        }while(((0u == endOfConversion) 
            && (((uint32) retMode & engine_sensor_adc_WAIT_FOR_RESULT) != 0u))
            && (0uL != wdt));

        if(0u != endOfConversion)
        {
            /* Clear EOS bit */
            engine_sensor_adc_SAR_INTR_REG = engine_sensor_adc_EOS_MASK;
        }
    }
    
    return endOfConversion;
}
 
/* ****************************************************************************
* Function Name: engine_sensor_adc_IsChannelSigned(uint32 chan)
****************************************************************************//*
*
* Determines if the provided channel is in signed format. 
*
* \param chan The engine_sensor_adc channel to check. 
*
* \return None
* 
* \sideeffect None
*
*
*******************************************************************************/
static int32 engine_sensor_adc_IsChannelSigned(uint32 chan)
{
    int32 isSigned = 0;
    uint32 chanConfig;
    
    chanConfig = CY_GET_REG32((reg32 *)(engine_sensor_adc_SAR_CHAN_CONFIG_IND + (uint32)(chan << 2u)));
    /* If differential mode */
    if(0u != (chanConfig & engine_sensor_adc_CHANNEL_CONFIG_DIFF_ALL_MSK))
    {
        /*If signed differential */
        if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl 
            & engine_sensor_adc_SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    else
    {
        if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl
            & engine_sensor_adc_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    return isSigned;
}
/*******************************************************************************
* Function Name: engine_sensor_adc_GetResult16
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register
*
* \param chan The engine_sensor_adc channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 16-bit integer.
* 
* \sideeffect None
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_GetResult16
*
*******************************************************************************/
int16 engine_sensor_adc_GetResult16(uint32 chan)
{
    uint32 adcResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels);

    if(engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels > chan)
    {   
        adcResult = CY_GET_REG32((reg32 *)(engine_sensor_adc_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            engine_sensor_adc_RESULT_MASK; 
    }
    else
    {
		adcResult = 0u;
    }
    
    return (int16) adcResult;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_GetResult32
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register. 
*
* \param chan The engine_sensor_adc channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 32-bit integer.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_GetResult32
*
*******************************************************************************/
int32 engine_sensor_adc_GetResult32(uint32 chan)
{
    uint32 adcResult;
    int16 adcResult16;
    int32 finalResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels);

    if(engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels > chan)
    {
        adcResult = CY_GET_REG32((reg32 *)(engine_sensor_adc_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            engine_sensor_adc_RESULT_MASK;
    }
    else
    {
        adcResult = 0u;
    }
    /* Sign extend if channel is signed format */
    if(engine_sensor_adc_IsChannelSigned(chan) == 1)
    {
        adcResult16 = (int16) adcResult;
        finalResult = (int32) adcResult16;
    }
    else
    {
        finalResult = (int32) adcResult;
    }
    return finalResult;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_SetLowLimit
****************************************************************************//**
*
* \brief Sets the low limit parameter for a limit condition.
*
* \param lowLimit The low limit for a limit condition.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetLowLimit
*
*******************************************************************************/
void engine_sensor_adc_SetLowLimit(uint32 lowLimit)
{   
    engine_sensor_adc_SAR_RANGE_THRES_REG &= ~(uint32)(engine_sensor_adc_SAR_RANGE_THRES_RANGE_LOW_MSK);
    engine_sensor_adc_SAR_RANGE_THRES_REG |= lowLimit & engine_sensor_adc_SAR_RANGE_THRES_RANGE_LOW_MSK;
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_SetHighLimit
****************************************************************************//**
*
* \brief Sets the high limit parameter for a limit condition.
*
* \param highLimit The high limit for a limit condition.
*
* \return None
* 
* \sideeffect None
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetHighLimit
*
*******************************************************************************/
void engine_sensor_adc_SetHighLimit(uint32 highLimit)
{   
    engine_sensor_adc_SAR_RANGE_THRES_REG &= ~(uint32)(engine_sensor_adc_SAR_RANGE_THRES_RANGE_HIGH_MSK);
    engine_sensor_adc_SAR_RANGE_THRES_REG |= (uint32)(highLimit << engine_sensor_adc_SAR_RANGE_THRES_RANGE_HIGH_SHFT);
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_SetLimitMask
****************************************************************************//**
*
* \brief Sets the channel limit condition mask.
*
*
* \param limitMask Sets which channels that may cause a limit condition interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 6  channels were enabled, setting a mask of 0x0103 would only enable 
* the last two channels (0 and 1).
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetLimitMask
*
*******************************************************************************/
void engine_sensor_adc_SetLimitMask(uint32 limitMask)
{   
    uint32 chanCount = engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels;
    limitMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    engine_sensor_adc_SAR_RANGE_INTR_MASK_REG = limitMask;
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_SetSatMask
****************************************************************************//**
*
* \brief Sets the channel saturation event mask.
*
* \param satMask Sets which channels that may cause a saturation event interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 8 channels were enabled, setting a mask of 0x01C0 would only enable two 
* channels (6 and 7).
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetSatMask
*
*******************************************************************************/
void engine_sensor_adc_SetSatMask(uint32 satMask)
{   
    uint32 chanCount = engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels;
    satMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    engine_sensor_adc_SAR_SATURATE_INTR_MASK_REG = satMask;    
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_SetOffset
****************************************************************************//**
*
* \brief Sets the ADC offset that is used by the functions engine_sensor_adc_CountsTo_uVolts, 
* engine_sensor_adc_CountsTo_mVolts, and engine_sensor_adc_CountsTo_Volts.
* 
* Offset is applied to counts before unit scaling and gain.  All CountsTo_[mV, uV, V]olts()
* functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
* 
* To set channel 0's offset based on known V_offset_mV, use:
*     engine_sensor_adc_SetOffset(0uL, -1 * V_offset_mV * (1uL << (Resolution - 1)) / V_ref_mV);
*
* \param chan engine_sensor_adc channel number. 
* 
* \param offset This value is a measured value when the inputs are shorted or 
* connected to the same input voltage.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetOffset
*
*******************************************************************************/
void engine_sensor_adc_SetOffset(uint32 chan, int16 offset)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels);

    engine_sensor_adc_offset[engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].channelBase + chan] = offset;
    return;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_SetGain
****************************************************************************//**
*
* \brief Sets the engine_sensor_adc gain in counts per 10 volt for the voltage 
* conversion functions. This value is set by default by the reference and 
* input range settings. Gain is applied after offset and unit scaling.  All 
* CountsTo_[mV, uV, V]olts() functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
* 
* To set channel 0's gain based on known V_ref_mV, use:
*     engine_sensor_adc_SetGain(0uL, 10000 * (1uL << (Resolution - 1)) / V_ref_mV);
*  
* \param chan engine_sensor_adc channel number.
* 
* \param adcGain engine_sensor_adc gain in counts per 10 volt.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_SetGain
*
*******************************************************************************/
void engine_sensor_adc_SetGain(uint32 chan, int32 adcGain)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels);

    engine_sensor_adc_countsPer10Volt[engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].channelBase + chan]
	= adcGain;
    return;
}
/*******************************************************************************
* Function Name: engine_sensor_adc_RawCounts2Counts
****************************************************************************//**
*
* \brief Converts the output of the SAR to an idealized count value.
*
* Divides by averaging amount, if needed, and subtracts offset.
*
* \param chan engine_sensor_adc channel number.   
*
* \param adcCounts Result from the engine_sensor_adc conversion.
*
* \return Averaged and offset counts.
* 
* \sideeffect None
*******************************************************************************/
int16 engine_sensor_adc_RawCounts2Counts(uint32 chan, int16 adcCounts)
{
    uint32 temp;
	uint32 averageAdcSamplesDiv;
	uint32 rawChannel;
	rawChannel = engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].channelBase + chan;
	
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].numChannels);

    /* Divide the adcCount when accumulate averaging mode selected */
    /* If Average mode != fixed */
	if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl 
		& engine_sensor_adc_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK) 
		!= engine_sensor_adc_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
	{
        /* If Channel uses averaging */
        if((engine_sensor_adc_channelsConfig[rawChannel] & engine_sensor_adc_SAR_CHAN_CONFIG_AVG_EN_MSK) != 0u)
        {
            /* Divide by 2^(AVG_CNT + 1) */
			averageAdcSamplesDiv = ((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl 
				& engine_sensor_adc_SAR_SAMPLE_CTRL_AVG_CNT_MSK) 
				>> engine_sensor_adc_SAR_SAMPLE_CTRL_AVG_CNT_SHFT);
            averageAdcSamplesDiv = (1uL << (averageAdcSamplesDiv + 1uL));
                        /* When it's "Sequential, Sum", divider limit is 16 */
            /* If Mode is ACCUNDUMP */
            if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl 
    			& engine_sensor_adc_SAR_SAMPLE_CTRL_AVG_MODE_MSK) 
    			!= engine_sensor_adc_SAR_SAMPLE_CTRL_AVG_MODE_MSK)
    		{
                if (averageAdcSamplesDiv > 16uL)
                {
                    averageAdcSamplesDiv = 16uL;
                }
            }
            /* If unsigned format, prevent sign extension */
            if(0 == engine_sensor_adc_IsChannelSigned(chan))
            {
				temp = ((uint16) adcCounts / averageAdcSamplesDiv);
                adcCounts = (int16) temp;
            }
            else
            {
                adcCounts /= (int16) averageAdcSamplesDiv;
            }
        }
    }
    /* Subtract ADC offset */
    adcCounts -= engine_sensor_adc_offset[rawChannel];
    return adcCounts;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_CountsTo_Volts
****************************************************************************//**
*
* \brief Converts the ADC output to Volts as a float32. For example, if the ADC 
* measured 0.534 volts, the return value would be 0.534.
* The calculation of voltage depends on the contents of engine_sensor_adc_offset[],
* engine_sensor_adc_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = engine_sensor_adc_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = engine_sensor_adc_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan engine_sensor_adc channel number.   
*
* \param adcCounts Result from the engine_sensor_adc conversion.
*
* \return Result in Volts.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_CountsTo_Volts
*
*******************************************************************************/
float32 engine_sensor_adc_CountsTo_Volts(uint32 chan, int16 adcCounts)
{   
    float32 result_Volts = 0.0f;
	uint32 rawChannel;
	rawChannel = engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].channelBase + chan;
	
	if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl 
		& engine_sensor_adc_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= engine_sensor_adc_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = engine_sensor_adc_RawCounts2Counts(chan, adcCounts);

        result_Volts = ((float32)adcCounts * engine_sensor_adc_10V_COUNTS) 
			/ (float32)engine_sensor_adc_countsPer10Volt[rawChannel];
	}
	return result_Volts;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_CountsTo_mVolts
****************************************************************************//**
*
* \brief Converts the ADC output to millivolts as an int16. For example, if the ADC 
* measured 0.534 volts, the return value would be 534.
* The calculation of voltage depends on the contents of engine_sensor_adc_offset[],
* engine_sensor_adc_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = engine_sensor_adc_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = engine_sensor_adc_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan engine_sensor_adc channel number. 
*
* \param adcCounts Result from the engine_sensor_adc conversion.
* 
* \return Result in mV.
* 
* \sideeffect None.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_CountsTo_mVolts
*
*******************************************************************************/
int16 engine_sensor_adc_CountsTo_mVolts(uint32 chan, int16 adcCounts)
{   
    int16 result_mVolts = 0;
	uint32 rawChannel;
    
	rawChannel = engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].channelBase + chan;
	
	if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl 
		& engine_sensor_adc_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= engine_sensor_adc_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = engine_sensor_adc_RawCounts2Counts(chan, adcCounts);

	    result_mVolts = (int16)((((int32)adcCounts * engine_sensor_adc_10MV_COUNTS) + ( (adcCounts > 0) ? 
	             (engine_sensor_adc_countsPer10Volt[rawChannel] / 2) 
				: (-(engine_sensor_adc_countsPer10Volt[rawChannel] / 2)) )) 
	             / engine_sensor_adc_countsPer10Volt[rawChannel]);
	}
    return result_mVolts;
}

/*******************************************************************************
* Function Name: engine_sensor_adc_CountsTo_uVolts
****************************************************************************//**
*
* \brief Converts the ADC output to microvolts as an int32. For example, if the ADC 
* measured 0.534 volts, the return value would be 534000.
* The calculation of voltage depends on the contents of engine_sensor_adc_offset[],
* engine_sensor_adc_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = engine_sensor_adc_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = engine_sensor_adc_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan engine_sensor_adc channel number.   
*
* \param adcCounts Result from the engine_sensor_adc conversion.
*
* \return Result in microvolts.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_CountsTo_uVolts
*
*******************************************************************************/
int32 engine_sensor_adc_CountsTo_uVolts(uint32 chan, int16 adcCounts)
{   
    int64 result_uVolts = 0;
	uint32 rawChannel;
	rawChannel = engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].channelBase + chan;

	if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].sampleCtrl 
		& engine_sensor_adc_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= engine_sensor_adc_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = engine_sensor_adc_RawCounts2Counts(chan, adcCounts);

        result_uVolts = ((int64)adcCounts * engine_sensor_adc_10UV_COUNTS) 
			/ engine_sensor_adc_countsPer10Volt[rawChannel];
	}
	return ( (int32)result_uVolts );
}

#if(0u != engine_sensor_adc_ANY_CONFIG_USES_FILTER)
    
    /* ****************************************************************************
    * Function Name: engine_sensor_adc_TrimFilterVos
    ****************************************************************************//*
    *
    * \brief Runs an algorithm to reduce voltage offset using the UAB's opamp trim.
    *
    * \param None
    * 
    * \return None
    *
    * \sideeffect None
    *
    * <b>Code Snippet</b>
    *  \snippet main.c snippet_engine_sensor_adc_TrimFilterVos
    *
    *******************************************************************************/
    void engine_sensor_adc_TrimFilterVos(void)
    {
        uint32 opampTrim = 0uL;
        uint32 agndTrim = 0uL;
        uint32 compStatus = 0uL;
        
        engine_sensor_adc_SetupComparatorTrim();
        
        /* Sweep from center to crossing */
        compStatus = engine_sensor_adc_SetOpampAndAgndTrim(engine_sensor_adc_OPAMP_TRIM_POS_BASE, engine_sensor_adc_AGND_TRIM_POS_BASE);
        if (0uL == compStatus)
        {
            opampTrim = engine_sensor_adc_RaiseOpampTrimToCrossing(engine_sensor_adc_OPAMP_TRIM_POS_BASE);
            agndTrim = engine_sensor_adc_RaiseAgndTrimToCrossing(engine_sensor_adc_AGND_TRIM_POS_BASE);
            if ((agndTrim == (engine_sensor_adc_AGND_TRIM_POS_LIMIT - 1uL))
                && (opampTrim != (engine_sensor_adc_OPAMP_TRIM_POS_LIMIT - 1uL)))
            {
                opampTrim = engine_sensor_adc_IncOpampTrim(opampTrim);
                (void) engine_sensor_adc_SetOpampAndAgndTrim(opampTrim, engine_sensor_adc_AGND_TRIM_POS_BASE);
                (void) engine_sensor_adc_LowerAgndTrimToCrossing(engine_sensor_adc_AGND_TRIM_POS_BASE);
            }
        }
        else
        {
            opampTrim = engine_sensor_adc_LowerOpampTrimToCrossing(engine_sensor_adc_OPAMP_TRIM_POS_BASE);
            agndTrim = engine_sensor_adc_LowerAgndTrimToCrossing(engine_sensor_adc_AGND_TRIM_POS_BASE);
            if ((agndTrim == (engine_sensor_adc_AGND_TRIM_NEG_LIMIT - 1uL))
                && (opampTrim != (engine_sensor_adc_OPAMP_TRIM_NEG_LIMIT - 1uL)))
            {
                opampTrim = engine_sensor_adc_DecOpampTrim(opampTrim);
                (void) engine_sensor_adc_SetOpampAndAgndTrim(opampTrim, engine_sensor_adc_AGND_TRIM_POS_BASE);
                (void) engine_sensor_adc_RaiseAgndTrimToCrossing(engine_sensor_adc_AGND_TRIM_POS_BASE);
            }
        }
        
        engine_sensor_adc_UndoComparatorTrimSetup();
    }
    
    
    static void engine_sensor_adc_SetupComparatorTrim(void)
    {
        /* Set firmware modbit. */
        engine_sensor_adc_UABH_A_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        engine_sensor_adc_UABH_B_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        
        /* Open filter output switch to isolate filter during trim. */
        engine_sensor_adc_UABH_B_SW_CF_BOT_REG &= ~(uint32)(engine_sensor_adc_UABH_B_SW_PO_MASK);
        
        /* Power on the UAB half B reference buffer. */
        engine_sensor_adc_UABH_B_OA_CTRL_REG |= (uint32)engine_sensor_adc_UABH_B_REF_PWR_MASK;
        
        /* Connect the UAB half B reference buffer to the comparator. */
        engine_sensor_adc_UABH_B_SW_STATIC_REG |= (uint32)engine_sensor_adc_UABH_B_SW_RT_MASK;
                        
        /* Clock the UAB half B comparator with phi1. */
        engine_sensor_adc_UABH_B_SW_OTHER_REG &= ~(uint32)engine_sensor_adc_UABH_B_CMP_FF_MASK;
        engine_sensor_adc_UABH_B_SW_OTHER_REG |= (uint32)((uint32)CyUAB_CLK_PHI1 << engine_sensor_adc_UABH_B_CMP_FF_SHIFT);
        
        /* Power on the UAB half B comparator. */
        engine_sensor_adc_UABH_B_OA_CTRL_REG |= (uint32)engine_sensor_adc_UABH_B_CMP_PWR_MASK;
    }
    
    
    static void engine_sensor_adc_UndoComparatorTrimSetup(void)
    {
        /* Power off the UAB half B comparator. */
        engine_sensor_adc_UABH_B_OA_CTRL_REG &= ~(uint32)engine_sensor_adc_UABH_B_CMP_PWR_MASK;
        
        /* Remove clock from the UAB half B comparator. */
        engine_sensor_adc_UABH_B_SW_OTHER_REG &= ~(uint32)engine_sensor_adc_UABH_B_CMP_FF_MASK;
        engine_sensor_adc_UABH_B_SW_OTHER_REG |= (uint32)((uint32)CyUAB_SW_OPEN << engine_sensor_adc_UABH_B_CMP_FF_SHIFT);
        
        /* Disconnect the UAB half B reference buffer from the comparator. */
        engine_sensor_adc_UABH_B_SW_STATIC_REG &= ~(uint32)engine_sensor_adc_UABH_B_SW_RT_MASK;
                        
        /* Power off the UAB half B reference buffer. */
        engine_sensor_adc_UABH_B_OA_CTRL_REG &= ~(uint32)engine_sensor_adc_UABH_B_REF_PWR_MASK;
        
        /* Close filter output switch to connect filter to AROUTE. */
        engine_sensor_adc_UABH_B_SW_CF_BOT_REG &= ~(uint32)(engine_sensor_adc_UABH_B_SW_PO_MASK);
        engine_sensor_adc_UABH_B_SW_CF_BOT_REG |= (uint32)((uint32)CyUAB_CLK_PHI3 << engine_sensor_adc_UABH_B_SW_PO_SHIFT);
        
        /* Clear the modbit */
        engine_sensor_adc_UABH_A_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
        engine_sensor_adc_UABH_B_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
    }
    
    
    static uint32 engine_sensor_adc_RaiseOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != engine_sensor_adc_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = engine_sensor_adc_IncOpampTrim(opampTrim))
        {
            compStatus = engine_sensor_adc_SetOpampAndAgndTrim(opampTrim, engine_sensor_adc_AGND_TRIM_POS_BASE);
            if (0uL != compStatus)
            {
                (void) engine_sensor_adc_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }
        
        return lastOpampTrim;
    }


    static uint32 engine_sensor_adc_LowerOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != engine_sensor_adc_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = engine_sensor_adc_DecOpampTrim(opampTrim))
        {
            compStatus = engine_sensor_adc_SetOpampAndAgndTrim(opampTrim, engine_sensor_adc_AGND_TRIM_POS_BASE);
            if (0uL == compStatus)
            {
                (void) engine_sensor_adc_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }
        
        return lastOpampTrim;
    }


    static uint32 engine_sensor_adc_RaiseAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim;
        uint32 lastAgndTrim;
        uint32 compStatus;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != engine_sensor_adc_AGND_TRIM_NEG_LIMIT;
            agndTrim = engine_sensor_adc_IncAgndTrim(agndTrim))
        {
            compStatus = engine_sensor_adc_SetAgndTrim(agndTrim);
            if (0uL != compStatus)
            {
                (void) engine_sensor_adc_SetAgndTrim(lastAgndTrim); 
                break;
            }
            lastAgndTrim = agndTrim;
        }
        
        return lastAgndTrim;
    }
    
    
    static uint32 engine_sensor_adc_LowerAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim = startTrim;
        uint32 lastAgndTrim = agndTrim;
        uint32 compStatus = 1uL;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != engine_sensor_adc_AGND_TRIM_NEG_LIMIT;
            agndTrim = engine_sensor_adc_DecAgndTrim(agndTrim))
        {
            compStatus = engine_sensor_adc_SetAgndTrim(agndTrim);
            if (0uL == compStatus)
            {
                (void) engine_sensor_adc_SetAgndTrim(lastAgndTrim); 
                break;
            }
            lastAgndTrim = agndTrim;
        }
        
        return lastAgndTrim;
    }
    
    
    static uint32 engine_sensor_adc_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = engine_sensor_adc_UABH_A_OA_TRIM_REG;
        trimRegVal &= ~(engine_sensor_adc_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal &= ~(engine_sensor_adc_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        engine_sensor_adc_UABH_A_OA_TRIM_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = engine_sensor_adc_UABH_B_STAT_REG & engine_sensor_adc_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    
    static uint32 engine_sensor_adc_SetOpampTrim(uint32 opampTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = engine_sensor_adc_UABH_A_OA_TRIM_REG;
        trimRegVal &= ~(engine_sensor_adc_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        engine_sensor_adc_UABH_A_OA_TRIM_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = engine_sensor_adc_UABH_B_STAT_REG & engine_sensor_adc_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    
    static uint32 engine_sensor_adc_SetAgndTrim(uint32 agndTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = engine_sensor_adc_UABH_A_OA_TRIM_REG;
        trimRegVal &= ~(engine_sensor_adc_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        engine_sensor_adc_UABH_A_OA_TRIM_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = engine_sensor_adc_UABH_B_STAT_REG & engine_sensor_adc_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    /* Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 engine_sensor_adc_IncOpampTrim(uint32 trim)
    {
        
        if (trim < (engine_sensor_adc_OPAMP_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((engine_sensor_adc_OPAMP_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = engine_sensor_adc_OPAMP_TRIM_NEG_LIMIT;
        }
        else if (trim <= (engine_sensor_adc_OPAMP_TRIM_NEG_BASE + 1uL))
        {
            trim = engine_sensor_adc_OPAMP_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }
        
        return trim;
    }


    /* Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 engine_sensor_adc_DecOpampTrim(uint32 trim)
    {
        
        if (engine_sensor_adc_OPAMP_TRIM_POS_BASE == trim)
        {
            trim = engine_sensor_adc_OPAMP_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < engine_sensor_adc_OPAMP_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < engine_sensor_adc_OPAMP_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = engine_sensor_adc_OPAMP_TRIM_POS_LIMIT - 1uL;
        }
        
        return trim;
    }


    /* Skips AGND_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 engine_sensor_adc_IncAgndTrim(uint32 trim)
    {
        
        if (trim < (engine_sensor_adc_AGND_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((engine_sensor_adc_AGND_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = engine_sensor_adc_AGND_TRIM_NEG_LIMIT;
        }
        else if (trim <= (engine_sensor_adc_AGND_TRIM_NEG_BASE + 1uL))
        {
            trim = engine_sensor_adc_AGND_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }
        
        return trim;
    }


    /* Skips engine_sensor_adc_AGND_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 engine_sensor_adc_DecAgndTrim(uint32 trim)
    {
        
        if (trim == engine_sensor_adc_AGND_TRIM_POS_BASE)
        {
            trim = engine_sensor_adc_AGND_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < engine_sensor_adc_AGND_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < engine_sensor_adc_AGND_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = engine_sensor_adc_AGND_TRIM_POS_LIMIT - 1uL;
        }
        
        return trim;
    }

    
    void engine_sensor_adc_filterInit(uint32 configNum)
    {
        /* Configure the common filter settings if any configuration filters */
        switch (configNum)
        {
            #if (0u != engine_sensor_adc_CFG0_FILTER_PRESENT)
            case 0u:
    		    engine_sensor_adc_UABH_A_Init(&engine_sensor_adc_CFG0_UABH_A_FILTER_config);
    		    engine_sensor_adc_UABH_B_Init(&engine_sensor_adc_CFG0_UABH_B_FILTER_config);
                
            break;
            #endif
            #if (0u != engine_sensor_adc_CFG1_FILTER_PRESENT)
            case 1u:
    		    engine_sensor_adc_UABH_A_Init(&engine_sensor_adc_CFG1_UABH_A_FILTER_config);
    		    engine_sensor_adc_UABH_B_Init(&engine_sensor_adc_CFG1_UABH_B_FILTER_config);
                
            break;
            #endif
            #if (0u != engine_sensor_adc_CFG2_FILTER_PRESENT)
            case 2u:
    		    engine_sensor_adc_UABH_A_Init(&engine_sensor_adc_CFG2_UABH_A_FILTER_config);
    		    engine_sensor_adc_UABH_B_Init(&engine_sensor_adc_CFG2_UABH_B_FILTER_config);
                
            break;
            #endif
            #if (0u != engine_sensor_adc_CFG3_FILTER_PRESENT)
            case 3u:
    		    engine_sensor_adc_UABH_A_Init(&engine_sensor_adc_CFG3_UABH_A_FILTER_config);
    		    engine_sensor_adc_UABH_B_Init(&engine_sensor_adc_CFG3_UABH_B_FILTER_config);
                
            break;
            #endif
            default:
            break;
        }
        engine_sensor_adc_FILTERAGND2SAR_BUFFER_Init();
    }
#endif /* engine_sensor_adc_ANY_CONFIG_USES_FILTER != 0u */


/* ****************************************************************************
* Function Name: engine_sensor_adc_Init
****************************************************************************//*
*
* \brief Initialize the component according to parameters defined in the 
* customizer.
*
* \param None
* 
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_Init
*
*******************************************************************************/
void engine_sensor_adc_Init(void)
{
	uint32 chNum = 0ul;
	uint32 configNum = 0u;
	int32 counts;
	
	if(0u == engine_sensor_adc_initVar)
	{
		/* Set offset and countsPer10Volt for all channels */
		for(chNum = 0ul; chNum < engine_sensor_adc_TOTAL_CHANNELS_NUM; chNum++)
		{      
			if((engine_sensor_adc_channelsConfig[chNum] & engine_sensor_adc_SAR_CHAN_CONFIG_RESOLUTION_MSK) != 0u)
        	{
				if((engine_sensor_adc_allConfigs[configNum].sampleCtrl 
					& engine_sensor_adc_SAR_SAMPLE_CTRL_SUB_RESOLUTION_MSK) 
					== engine_sensor_adc_SUB_RESOLUTION_10B)
				{
					counts = (int32) engine_sensor_adc_SAR_WRK_MAX_10BIT;
				}
				else
				{
					counts = (int32) engine_sensor_adc_SAR_WRK_MAX_8BIT;
				}
        	}
        	else
        	{
               counts = (int32)engine_sensor_adc_SAR_WRK_MAX_12BIT;
        	}
			
			/* Single Ended Channel */
			if((engine_sensor_adc_channelsConfig[chNum] & engine_sensor_adc_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK) == 0u)
        	{
				if(((engine_sensor_adc_allConfigs[configNum].sampleCtrl 
					& engine_sensor_adc_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) 
					== engine_sensor_adc_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) && 
					((engine_sensor_adc_allConfigs[configNum].ctrl & engine_sensor_adc_SAR_CTRL_NEG_SEL_MSK) 
					== engine_sensor_adc_NEG_VREF_SHIFTED))
				{
					/* Set offset to the minus half scale to convert results to unsigned format */
                	engine_sensor_adc_offset[chNum] = (int16)(counts / -2);		
            	}
				else
				{
                	engine_sensor_adc_offset[chNum] = 0;	
				}
				
			}
			else    /* Differential channel */
        	{
               	engine_sensor_adc_offset[chNum] = 0; 
			}
            
			/* Calculate gain in counts per 10 volts with rounding */
        	engine_sensor_adc_countsPer10Volt[chNum] = (int16)(((counts * engine_sensor_adc_10MV_COUNTS) \
                            + engine_sensor_adc_allConfigs[configNum].vrefMvValue) \
							/ (engine_sensor_adc_allConfigs[configNum].vrefMvValue * 2));
            
            /* Increment configuration number after rolling over to the next configuration*/
			if((engine_sensor_adc_allConfigs[configNum].channelBase
				+ (engine_sensor_adc_allConfigs[configNum].numChannels - 1uL)) == chNum)
			{
				configNum++;
			}
		} /* for(chNum = 0ul; chNum < engine_sensor_adc_TOTAL_CHANNELS_NUM; chNum++) */
        
        #if(engine_sensor_adc_IRQ_REMOVE == 0u)
            /* Start and set interrupt vector */
            CyIntSetPriority(engine_sensor_adc_INTC_NUMBER, engine_sensor_adc_INTC_PRIOR_NUMBER);
            (void)CyIntSetVector(engine_sensor_adc_INTC_NUMBER, &engine_sensor_adc_ISR);
        #endif   /* End engine_sensor_adc_IRQ_REMOVE */
        
        /* Initialize configuration zero if SelectConfig has not been called */
        if(0u == engine_sensor_adc_selected)
	    {
            engine_sensor_adc_selected = 1u;
            configNum = 0u;
            /* Change Vref selection if is was routed by Creator. Break. */
            #if (engine_sensor_adc_VREF_ROUTED)
                engine_sensor_adc_vrefAMux_DisconnectAll();
            #endif
            engine_sensor_adc_InitConfig(&engine_sensor_adc_allConfigs[configNum]);
            /* Change Vref selection if is was routed by Creator. Make. */
            #if (engine_sensor_adc_VREF_ROUTED)
                engine_sensor_adc_vrefAMux_Select((uint8)configNum);
            #endif
            engine_sensor_adc_SAR_CHAN_EN_REG = engine_sensor_adc_allConfigs[configNum].chanEn;
            #if(0u != engine_sensor_adc_ANY_CONFIG_USES_FILTER)	
                engine_sensor_adc_filterVinMux_Select((uint8)configNum);
                engine_sensor_adc_filterInit(configNum);
            #endif
        }           
	}
    return;
}


/* ****************************************************************************
* Function Name: engine_sensor_adc_Enable
****************************************************************************//*
*
* \brief Enables the component. 
*
* \param None
* 
* \return None
* 
* \sideeffect
*  None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_engine_sensor_adc_Enable
*
*******************************************************************************/
void engine_sensor_adc_Enable(void) 
{

    #if(0u != engine_sensor_adc_ANY_CONFIG_USES_FILTER)	
    	if((engine_sensor_adc_allConfigs[engine_sensor_adc_currentConfig].miscConfig
    		& engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK)
    		== engine_sensor_adc_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            engine_sensor_adc_FILTERAGND2SAR_BUFFER_Enable();
    		engine_sensor_adc_UABH_A_Enable();
    		engine_sensor_adc_UABH_B_Enable();
            engine_sensor_adc_UABH_B_Run(1u);
            engine_sensor_adc_UABH_A_Run(1u);
    	}
    #endif /* engine_sensor_adc_ANY_CONFIG_USES_FILTER != 0u */
        
    if (0u == (engine_sensor_adc_SAR_CTRL_REG & engine_sensor_adc_SAR_CTRL_ENABLED_MSK))
    {
        while (0u != (engine_sensor_adc_SAR_STATUS_REG & engine_sensor_adc_BUSY_MSK))
        {
            /* wait for SAR to go idle to avoid deadlock */
        }
        
        engine_sensor_adc_SAR_CTRL_REG |= engine_sensor_adc_SAR_CTRL_ENABLED_MSK;
        
        /* The block is ready to use 10 us after the enable signal is set high. */
        CyDelayUs(engine_sensor_adc_10US_DELAY);
    }
    return;
}


/* [] END OF FILE */
