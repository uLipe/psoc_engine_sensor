ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 1


   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"arm_cmplx_mag_f32.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_fmul
  18              		.global	__aeabi_fadd
  19              		.global	__aeabi_fcmpge
  20              		.section	.text.arm_cmplx_mag_f32,"ax",%progbits
  21              		.align	2
  22              		.global	arm_cmplx_mag_f32
  23              		.code	16
  24              		.thumb_func
  25              		.type	arm_cmplx_mag_f32, %function
  26              	arm_cmplx_mag_f32:
  27              	.LFB82:
  28              		.file 1 "Source\\ComplexMathFunctions\\arm_cmplx_mag_f32.c"
   1:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** /* ----------------------------------------------------------------------
   2:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Project:      CMSIS DSP Library
   3:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Title:        arm_cmplx_mag_f32.c
   4:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Description:  Floating-point complex magnitude
   5:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
   6:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * $Date:        27. January 2017
   7:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * $Revision:    V.1.5.1
   8:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
   9:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Target Processor: Cortex-M cores
  10:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * -------------------------------------------------------------------- */
  11:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** /*
  12:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  14:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * SPDX-License-Identifier: Apache-2.0
  15:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  16:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * not use this file except in compliance with the License.
  18:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * You may obtain a copy of the License at
  19:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  20:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  22:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Unless required by applicable law or agreed to in writing, software
  23:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * See the License for the specific language governing permissions and
  26:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * limitations under the License.
  27:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  */
  28:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  29:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** #include "arm_math.h"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 2


  30:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  31:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** /**
  32:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @ingroup groupCmplxMath
  33:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  */
  34:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  35:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** /**
  36:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @defgroup cmplx_mag Complex Magnitude
  37:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  38:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * Computes the magnitude of the elements of a complex data vector.
  39:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  40:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * The <code>pSrc</code> points to the source data and
  41:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * <code>pDst</code> points to the where the result should be written.
  42:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * <code>numSamples</code> specifies the number of complex samples
  43:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * in the input array and the data is stored in an interleaved fashion
  44:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * (real, imag, real, imag, ...).
  45:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * The input array has a total of <code>2*numSamples</code> values;
  46:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * the output array has a total of <code>numSamples</code> values.
  47:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * The underlying algorithm is used:
  48:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  49:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * <pre>
  50:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * for(n=0; n<numSamples; n++) {
  51:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *     pDst[n] = sqrt(pSrc[(2*n)+0]^2 + pSrc[(2*n)+1]^2);
  52:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * }
  53:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * </pre>
  54:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  55:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * There are separate functions for floating-point, Q15, and Q31 data types.
  56:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  */
  57:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  58:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** /**
  59:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @addtogroup cmplx_mag
  60:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @{
  61:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  */
  62:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** /**
  63:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @brief Floating-point complex magnitude.
  64:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @param[in]       *pSrc points to complex input buffer
  65:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @param[out]      *pDst points to real output buffer
  66:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @param[in]       numSamples number of complex samples in the input vector
  67:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  * @return none.
  68:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  *
  69:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****  */
  70:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  71:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  72:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** void arm_cmplx_mag_f32(
  73:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   float32_t * pSrc,
  74:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   float32_t * pDst,
  75:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   uint32_t numSamples)
  76:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** {
  29              		.loc 1 76 0
  30              		.cfi_startproc
  31 0000 90B5     		push	{r4, r7, lr}
  32              		.cfi_def_cfa_offset 12
  33              		.cfi_offset 4, -12
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 89B0     		sub	sp, sp, #36
  37              		.cfi_def_cfa_offset 48
  38 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 3


  39              		.cfi_def_cfa_register 7
  40 0006 F860     		str	r0, [r7, #12]
  41 0008 B960     		str	r1, [r7, #8]
  42 000a 7A60     		str	r2, [r7, #4]
  77:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   float32_t realIn, imagIn;                      /* Temporary variables to hold input values */
  78:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  79:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** #if defined (ARM_MATH_DSP)
  80:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  81:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
  82:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   uint32_t blkCnt;                               /* loop counter */
  83:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  84:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   /*loop Unrolling */
  85:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   blkCnt = numSamples >> 2u;
  86:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  87:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
  88:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****    ** a second loop below computes the remaining 1 to 3 samples. */
  89:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   while (blkCnt > 0u)
  90:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   {
  91:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  92:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
  93:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     realIn = *pSrc++;
  94:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     imagIn = *pSrc++;
  95:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* store the result in the destination buffer. */
  96:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
  97:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
  98:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     realIn = *pSrc++;
  99:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     imagIn = *pSrc++;
 100:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 101:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 102:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     realIn = *pSrc++;
 103:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     imagIn = *pSrc++;
 104:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 105:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 106:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     realIn = *pSrc++;
 107:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     imagIn = *pSrc++;
 108:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 109:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 110:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 111:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* Decrement the loop counter */
 112:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     blkCnt--;
 113:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   }
 114:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 115:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   /* If the numSamples is not a multiple of 4, compute any remaining output samples here.
 116:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****    ** No loop unrolling is used. */
 117:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   blkCnt = numSamples % 0x4u;
 118:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 119:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   while (blkCnt > 0u)
 120:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   {
 121:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
 122:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     realIn = *pSrc++;
 123:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     imagIn = *pSrc++;
 124:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* store the result in the destination buffer. */
 125:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 126:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 127:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* Decrement the loop counter */
 128:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     blkCnt--;
 129:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 4


 130:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 131:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** #else
 132:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 133:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   /* Run the below code for Cortex-M0 */
 134:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 135:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   while (numSamples > 0u)
  43              		.loc 1 135 0
  44 000c 33E0     		b	.L2
  45              	.L6:
 136:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   {
 137:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* out = sqrt((real * real) + (imag * imag)) */
 138:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     realIn = *pSrc++;
  46              		.loc 1 138 0
  47 000e FB68     		ldr	r3, [r7, #12]
  48 0010 1A1D     		add	r2, r3, #4
  49 0012 FA60     		str	r2, [r7, #12]
  50 0014 1B68     		ldr	r3, [r3]
  51 0016 FB61     		str	r3, [r7, #28]
 139:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     imagIn = *pSrc++;
  52              		.loc 1 139 0
  53 0018 FB68     		ldr	r3, [r7, #12]
  54 001a 1A1D     		add	r2, r3, #4
  55 001c FA60     		str	r2, [r7, #12]
  56 001e 1B68     		ldr	r3, [r3]
  57 0020 BB61     		str	r3, [r7, #24]
 140:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* store the result in the destination buffer. */
 141:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
  58              		.loc 1 141 0
  59 0022 F869     		ldr	r0, [r7, #28]
  60 0024 F969     		ldr	r1, [r7, #28]
  61 0026 FFF7FEFF 		bl	__aeabi_fmul
  62 002a 031C     		add	r3, r0, #0
  63 002c 1C1C     		add	r4, r3, #0
  64 002e B869     		ldr	r0, [r7, #24]
  65 0030 B969     		ldr	r1, [r7, #24]
  66 0032 FFF7FEFF 		bl	__aeabi_fmul
  67 0036 031C     		add	r3, r0, #0
  68 0038 201C     		add	r0, r4, #0
  69 003a 191C     		add	r1, r3, #0
  70 003c FFF7FEFF 		bl	__aeabi_fadd
  71 0040 031C     		add	r3, r0, #0
  72 0042 191C     		add	r1, r3, #0
  73 0044 BB68     		ldr	r3, [r7, #8]
  74 0046 1A1D     		add	r2, r3, #4
  75 0048 BA60     		str	r2, [r7, #8]
  76 004a 7961     		str	r1, [r7, #20]
  77 004c 3B61     		str	r3, [r7, #16]
  78              	.LBB4:
  79              	.LBB5:
  80              		.file 2 ".\\Include/arm_math.h"
   1:.\Include/arm_math.h **** /* ----------------------------------------------------------------------
   2:.\Include/arm_math.h ****  * Project:      CMSIS DSP Library
   3:.\Include/arm_math.h ****  * Title:        arm_math.h
   4:.\Include/arm_math.h ****  * Description:  Public header file for CMSIS DSP Library
   5:.\Include/arm_math.h ****  *
   6:.\Include/arm_math.h ****  * $Date:        27. January 2017
   7:.\Include/arm_math.h ****  * $Revision:    V.1.5.1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 5


   8:.\Include/arm_math.h ****  *
   9:.\Include/arm_math.h ****  * Target Processor: Cortex-M cores
  10:.\Include/arm_math.h ****  * -------------------------------------------------------------------- */
  11:.\Include/arm_math.h **** /*
  12:.\Include/arm_math.h ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:.\Include/arm_math.h ****  *
  14:.\Include/arm_math.h ****  * SPDX-License-Identifier: Apache-2.0
  15:.\Include/arm_math.h ****  *
  16:.\Include/arm_math.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:.\Include/arm_math.h ****  * not use this file except in compliance with the License.
  18:.\Include/arm_math.h ****  * You may obtain a copy of the License at
  19:.\Include/arm_math.h ****  *
  20:.\Include/arm_math.h ****  * www.apache.org/licenses/LICENSE-2.0
  21:.\Include/arm_math.h ****  *
  22:.\Include/arm_math.h ****  * Unless required by applicable law or agreed to in writing, software
  23:.\Include/arm_math.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:.\Include/arm_math.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:.\Include/arm_math.h ****  * See the License for the specific language governing permissions and
  26:.\Include/arm_math.h ****  * limitations under the License.
  27:.\Include/arm_math.h ****  */
  28:.\Include/arm_math.h **** 
  29:.\Include/arm_math.h **** /**
  30:.\Include/arm_math.h ****    \mainpage CMSIS DSP Software Library
  31:.\Include/arm_math.h ****    *
  32:.\Include/arm_math.h ****    * Introduction
  33:.\Include/arm_math.h ****    * ------------
  34:.\Include/arm_math.h ****    *
  35:.\Include/arm_math.h ****    * This user manual describes the CMSIS DSP software library,
  36:.\Include/arm_math.h ****    * a suite of common signal processing functions for use on Cortex-M processor based devices.
  37:.\Include/arm_math.h ****    *
  38:.\Include/arm_math.h ****    * The library is divided into a number of functions each covering a specific category:
  39:.\Include/arm_math.h ****    * - Basic math functions
  40:.\Include/arm_math.h ****    * - Fast math functions
  41:.\Include/arm_math.h ****    * - Complex math functions
  42:.\Include/arm_math.h ****    * - Filters
  43:.\Include/arm_math.h ****    * - Matrix functions
  44:.\Include/arm_math.h ****    * - Transforms
  45:.\Include/arm_math.h ****    * - Motor control functions
  46:.\Include/arm_math.h ****    * - Statistical functions
  47:.\Include/arm_math.h ****    * - Support functions
  48:.\Include/arm_math.h ****    * - Interpolation functions
  49:.\Include/arm_math.h ****    *
  50:.\Include/arm_math.h ****    * The library has separate functions for operating on 8-bit integers, 16-bit integers,
  51:.\Include/arm_math.h ****    * 32-bit integer and 32-bit floating-point values.
  52:.\Include/arm_math.h ****    *
  53:.\Include/arm_math.h ****    * Using the Library
  54:.\Include/arm_math.h ****    * ------------
  55:.\Include/arm_math.h ****    *
  56:.\Include/arm_math.h ****    * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> fold
  57:.\Include/arm_math.h ****    * - arm_cortexM7lfdp_math.lib (Cortex-M7, Little endian, Double Precision Floating Point Unit)
  58:.\Include/arm_math.h ****    * - arm_cortexM7bfdp_math.lib (Cortex-M7, Big endian, Double Precision Floating Point Unit)
  59:.\Include/arm_math.h ****    * - arm_cortexM7lfsp_math.lib (Cortex-M7, Little endian, Single Precision Floating Point Unit)
  60:.\Include/arm_math.h ****    * - arm_cortexM7bfsp_math.lib (Cortex-M7, Big endian and Single Precision Floating Point Unit on
  61:.\Include/arm_math.h ****    * - arm_cortexM7l_math.lib (Cortex-M7, Little endian)
  62:.\Include/arm_math.h ****    * - arm_cortexM7b_math.lib (Cortex-M7, Big endian)
  63:.\Include/arm_math.h ****    * - arm_cortexM4lf_math.lib (Cortex-M4, Little endian, Floating Point Unit)
  64:.\Include/arm_math.h ****    * - arm_cortexM4bf_math.lib (Cortex-M4, Big endian, Floating Point Unit)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 6


  65:.\Include/arm_math.h ****    * - arm_cortexM4l_math.lib (Cortex-M4, Little endian)
  66:.\Include/arm_math.h ****    * - arm_cortexM4b_math.lib (Cortex-M4, Big endian)
  67:.\Include/arm_math.h ****    * - arm_cortexM3l_math.lib (Cortex-M3, Little endian)
  68:.\Include/arm_math.h ****    * - arm_cortexM3b_math.lib (Cortex-M3, Big endian)
  69:.\Include/arm_math.h ****    * - arm_cortexM0l_math.lib (Cortex-M0 / Cortex-M0+, Little endian)
  70:.\Include/arm_math.h ****    * - arm_cortexM0b_math.lib (Cortex-M0 / Cortex-M0+, Big endian)
  71:.\Include/arm_math.h ****    * - arm_ARMv8MBLl_math.lib (ARMv8M Baseline, Little endian)
  72:.\Include/arm_math.h ****    * - arm_ARMv8MMLl_math.lib (ARMv8M Mainline, Little endian)
  73:.\Include/arm_math.h ****    * - arm_ARMv8MMLlfsp_math.lib (ARMv8M Mainline, Little endian, Single Precision Floating Point U
  74:.\Include/arm_math.h ****    * - arm_ARMv8MMLld_math.lib (ARMv8M Mainline, Little endian, DSP instructions)
  75:.\Include/arm_math.h ****    * - arm_ARMv8MMLldfsp_math.lib (ARMv8M Mainline, Little endian, DSP instructions, Single Precisi
  76:.\Include/arm_math.h ****    *
  77:.\Include/arm_math.h ****    * The library functions are declared in the public file <code>arm_math.h</code> which is placed 
  78:.\Include/arm_math.h ****    * Simply include this file and link the appropriate library in the application and begin calling
  79:.\Include/arm_math.h ****    * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endi
  80:.\Include/arm_math.h ****    * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
  81:.\Include/arm_math.h ****    * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
  82:.\Include/arm_math.h ****    * For ARMv8M cores define pre processor MACRO ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
  83:.\Include/arm_math.h ****    * Set Pre processor MACRO __DSP_PRESENT if ARMv8M Mainline core supports DSP instructions.
  84:.\Include/arm_math.h ****    * 
  85:.\Include/arm_math.h ****    *
  86:.\Include/arm_math.h ****    * Examples
  87:.\Include/arm_math.h ****    * --------
  88:.\Include/arm_math.h ****    *
  89:.\Include/arm_math.h ****    * The library ships with a number of examples which demonstrate how to use the library functions
  90:.\Include/arm_math.h ****    *
  91:.\Include/arm_math.h ****    * Toolchain Support
  92:.\Include/arm_math.h ****    * ------------
  93:.\Include/arm_math.h ****    *
  94:.\Include/arm_math.h ****    * The library has been developed and tested with MDK-ARM version 5.14.0.0
  95:.\Include/arm_math.h ****    * The library is being tested in GCC and IAR toolchains and updates on this activity will be mad
  96:.\Include/arm_math.h ****    *
  97:.\Include/arm_math.h ****    * Building the Library
  98:.\Include/arm_math.h ****    * ------------
  99:.\Include/arm_math.h ****    *
 100:.\Include/arm_math.h ****    * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in t
 101:.\Include/arm_math.h ****    * - arm_cortexM_math.uvprojx
 102:.\Include/arm_math.h ****    *
 103:.\Include/arm_math.h ****    *
 104:.\Include/arm_math.h ****    * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecti
 105:.\Include/arm_math.h ****    *
 106:.\Include/arm_math.h ****    * Pre-processor Macros
 107:.\Include/arm_math.h ****    * ------------
 108:.\Include/arm_math.h ****    *
 109:.\Include/arm_math.h ****    * Each library project have differant pre-processor macros.
 110:.\Include/arm_math.h ****    *
 111:.\Include/arm_math.h ****    * - UNALIGNED_SUPPORT_DISABLE:
 112:.\Include/arm_math.h ****    *
 113:.\Include/arm_math.h ****    * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory acces
 114:.\Include/arm_math.h ****    *
 115:.\Include/arm_math.h ****    * - ARM_MATH_BIG_ENDIAN:
 116:.\Include/arm_math.h ****    *
 117:.\Include/arm_math.h ****    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default libra
 118:.\Include/arm_math.h ****    *
 119:.\Include/arm_math.h ****    * - ARM_MATH_MATRIX_CHECK:
 120:.\Include/arm_math.h ****    *
 121:.\Include/arm_math.h ****    * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 7


 122:.\Include/arm_math.h ****    *
 123:.\Include/arm_math.h ****    * - ARM_MATH_ROUNDING:
 124:.\Include/arm_math.h ****    *
 125:.\Include/arm_math.h ****    * Define macro ARM_MATH_ROUNDING for rounding on support functions
 126:.\Include/arm_math.h ****    *
 127:.\Include/arm_math.h ****    * - ARM_MATH_CMx:
 128:.\Include/arm_math.h ****    *
 129:.\Include/arm_math.h ****    * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for build
 130:.\Include/arm_math.h ****    * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building libra
 131:.\Include/arm_math.h ****    * ARM_MATH_CM7 for building the library on cortex-M7.
 132:.\Include/arm_math.h ****    *
 133:.\Include/arm_math.h ****    * - ARM_MATH_ARMV8MxL:
 134:.\Include/arm_math.h ****    *
 135:.\Include/arm_math.h ****    * Define macro ARM_MATH_ARMV8MBL for building the library on ARMv8M Baseline target, ARM_MATH_AR
 136:.\Include/arm_math.h ****    * on ARMv8M Mainline target.
 137:.\Include/arm_math.h ****    *
 138:.\Include/arm_math.h ****    * - __FPU_PRESENT:
 139:.\Include/arm_math.h ****    *
 140:.\Include/arm_math.h ****    * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro f
 141:.\Include/arm_math.h ****    *
 142:.\Include/arm_math.h ****    * - __DSP_PRESENT:
 143:.\Include/arm_math.h ****    *
 144:.\Include/arm_math.h ****    * Initialize macro __DSP_PRESENT = 1 when ARMv8M Mainline core supports DSP instructions.
 145:.\Include/arm_math.h ****    *
 146:.\Include/arm_math.h ****    * <hr>
 147:.\Include/arm_math.h ****    * CMSIS-DSP in ARM::CMSIS Pack
 148:.\Include/arm_math.h ****    * -----------------------------
 149:.\Include/arm_math.h ****    *
 150:.\Include/arm_math.h ****    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directorie
 151:.\Include/arm_math.h ****    * |File/Folder                   |Content                                                       
 152:.\Include/arm_math.h ****    * |------------------------------|--------------------------------------------------------------
 153:.\Include/arm_math.h ****    * |\b CMSIS\\Documentation\\DSP  | This documentation                                           
 154:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                     
 155:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library funct
 156:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                      
 157:.\Include/arm_math.h ****    *
 158:.\Include/arm_math.h ****    * <hr>
 159:.\Include/arm_math.h ****    * Revision History of CMSIS-DSP
 160:.\Include/arm_math.h ****    * ------------
 161:.\Include/arm_math.h ****    * Please refer to \ref ChangeLog_pg.
 162:.\Include/arm_math.h ****    *
 163:.\Include/arm_math.h ****    * Copyright Notice
 164:.\Include/arm_math.h ****    * ------------
 165:.\Include/arm_math.h ****    *
 166:.\Include/arm_math.h ****    * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
 167:.\Include/arm_math.h ****    */
 168:.\Include/arm_math.h **** 
 169:.\Include/arm_math.h **** 
 170:.\Include/arm_math.h **** /**
 171:.\Include/arm_math.h ****  * @defgroup groupMath Basic Math Functions
 172:.\Include/arm_math.h ****  */
 173:.\Include/arm_math.h **** 
 174:.\Include/arm_math.h **** /**
 175:.\Include/arm_math.h ****  * @defgroup groupFastMath Fast Math Functions
 176:.\Include/arm_math.h ****  * This set of functions provides a fast approximation to sine, cosine, and square root.
 177:.\Include/arm_math.h ****  * As compared to most of the other functions in the CMSIS math library, the fast math functions
 178:.\Include/arm_math.h ****  * operate on individual values and not arrays.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 8


 179:.\Include/arm_math.h ****  * There are separate functions for Q15, Q31, and floating-point data.
 180:.\Include/arm_math.h ****  *
 181:.\Include/arm_math.h ****  */
 182:.\Include/arm_math.h **** 
 183:.\Include/arm_math.h **** /**
 184:.\Include/arm_math.h ****  * @defgroup groupCmplxMath Complex Math Functions
 185:.\Include/arm_math.h ****  * This set of functions operates on complex data vectors.
 186:.\Include/arm_math.h ****  * The data in the complex arrays is stored in an interleaved fashion
 187:.\Include/arm_math.h ****  * (real, imag, real, imag, ...).
 188:.\Include/arm_math.h ****  * In the API functions, the number of samples in a complex array refers
 189:.\Include/arm_math.h ****  * to the number of complex values; the array contains twice this number of
 190:.\Include/arm_math.h ****  * real values.
 191:.\Include/arm_math.h ****  */
 192:.\Include/arm_math.h **** 
 193:.\Include/arm_math.h **** /**
 194:.\Include/arm_math.h ****  * @defgroup groupFilters Filtering Functions
 195:.\Include/arm_math.h ****  */
 196:.\Include/arm_math.h **** 
 197:.\Include/arm_math.h **** /**
 198:.\Include/arm_math.h ****  * @defgroup groupMatrix Matrix Functions
 199:.\Include/arm_math.h ****  *
 200:.\Include/arm_math.h ****  * This set of functions provides basic matrix math operations.
 201:.\Include/arm_math.h ****  * The functions operate on matrix data structures.  For example,
 202:.\Include/arm_math.h ****  * the type
 203:.\Include/arm_math.h ****  * definition for the floating-point matrix structure is shown
 204:.\Include/arm_math.h ****  * below:
 205:.\Include/arm_math.h ****  * <pre>
 206:.\Include/arm_math.h ****  *     typedef struct
 207:.\Include/arm_math.h ****  *     {
 208:.\Include/arm_math.h ****  *       uint16_t numRows;     // number of rows of the matrix.
 209:.\Include/arm_math.h ****  *       uint16_t numCols;     // number of columns of the matrix.
 210:.\Include/arm_math.h ****  *       float32_t *pData;     // points to the data of the matrix.
 211:.\Include/arm_math.h ****  *     } arm_matrix_instance_f32;
 212:.\Include/arm_math.h ****  * </pre>
 213:.\Include/arm_math.h ****  * There are similar definitions for Q15 and Q31 data types.
 214:.\Include/arm_math.h ****  *
 215:.\Include/arm_math.h ****  * The structure specifies the size of the matrix and then points to
 216:.\Include/arm_math.h ****  * an array of data.  The array is of size <code>numRows X numCols</code>
 217:.\Include/arm_math.h ****  * and the values are arranged in row order.  That is, the
 218:.\Include/arm_math.h ****  * matrix element (i, j) is stored at:
 219:.\Include/arm_math.h ****  * <pre>
 220:.\Include/arm_math.h ****  *     pData[i*numCols + j]
 221:.\Include/arm_math.h ****  * </pre>
 222:.\Include/arm_math.h ****  *
 223:.\Include/arm_math.h ****  * \par Init Functions
 224:.\Include/arm_math.h ****  * There is an associated initialization function for each type of matrix
 225:.\Include/arm_math.h ****  * data structure.
 226:.\Include/arm_math.h ****  * The initialization function sets the values of the internal structure fields.
 227:.\Include/arm_math.h ****  * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
 228:.\Include/arm_math.h ****  * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
 229:.\Include/arm_math.h ****  *
 230:.\Include/arm_math.h ****  * \par
 231:.\Include/arm_math.h ****  * Use of the initialization function is optional. However, if initialization function is used
 232:.\Include/arm_math.h ****  * then the instance structure cannot be placed into a const data section.
 233:.\Include/arm_math.h ****  * To place the instance structure in a const data
 234:.\Include/arm_math.h ****  * section, manually initialize the data structure.  For example:
 235:.\Include/arm_math.h ****  * <pre>
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 9


 236:.\Include/arm_math.h ****  * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
 237:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
 238:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
 239:.\Include/arm_math.h ****  * </pre>
 240:.\Include/arm_math.h ****  * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
 241:.\Include/arm_math.h ****  * specifies the number of columns, and <code>pData</code> points to the
 242:.\Include/arm_math.h ****  * data array.
 243:.\Include/arm_math.h ****  *
 244:.\Include/arm_math.h ****  * \par Size Checking
 245:.\Include/arm_math.h ****  * By default all of the matrix functions perform size checking on the input and
 246:.\Include/arm_math.h ****  * output matrices.  For example, the matrix addition function verifies that the
 247:.\Include/arm_math.h ****  * two input matrices and the output matrix all have the same number of rows and
 248:.\Include/arm_math.h ****  * columns.  If the size check fails the functions return:
 249:.\Include/arm_math.h ****  * <pre>
 250:.\Include/arm_math.h ****  *     ARM_MATH_SIZE_MISMATCH
 251:.\Include/arm_math.h ****  * </pre>
 252:.\Include/arm_math.h ****  * Otherwise the functions return
 253:.\Include/arm_math.h ****  * <pre>
 254:.\Include/arm_math.h ****  *     ARM_MATH_SUCCESS
 255:.\Include/arm_math.h ****  * </pre>
 256:.\Include/arm_math.h ****  * There is some overhead associated with this matrix size checking.
 257:.\Include/arm_math.h ****  * The matrix size checking is enabled via the \#define
 258:.\Include/arm_math.h ****  * <pre>
 259:.\Include/arm_math.h ****  *     ARM_MATH_MATRIX_CHECK
 260:.\Include/arm_math.h ****  * </pre>
 261:.\Include/arm_math.h ****  * within the library project settings.  By default this macro is defined
 262:.\Include/arm_math.h ****  * and size checking is enabled.  By changing the project settings and
 263:.\Include/arm_math.h ****  * undefining this macro size checking is eliminated and the functions
 264:.\Include/arm_math.h ****  * run a bit faster.  With size checking disabled the functions always
 265:.\Include/arm_math.h ****  * return <code>ARM_MATH_SUCCESS</code>.
 266:.\Include/arm_math.h ****  */
 267:.\Include/arm_math.h **** 
 268:.\Include/arm_math.h **** /**
 269:.\Include/arm_math.h ****  * @defgroup groupTransforms Transform Functions
 270:.\Include/arm_math.h ****  */
 271:.\Include/arm_math.h **** 
 272:.\Include/arm_math.h **** /**
 273:.\Include/arm_math.h ****  * @defgroup groupController Controller Functions
 274:.\Include/arm_math.h ****  */
 275:.\Include/arm_math.h **** 
 276:.\Include/arm_math.h **** /**
 277:.\Include/arm_math.h ****  * @defgroup groupStats Statistics Functions
 278:.\Include/arm_math.h ****  */
 279:.\Include/arm_math.h **** /**
 280:.\Include/arm_math.h ****  * @defgroup groupSupport Support Functions
 281:.\Include/arm_math.h ****  */
 282:.\Include/arm_math.h **** 
 283:.\Include/arm_math.h **** /**
 284:.\Include/arm_math.h ****  * @defgroup groupInterpolation Interpolation Functions
 285:.\Include/arm_math.h ****  * These functions perform 1- and 2-dimensional interpolation of data.
 286:.\Include/arm_math.h ****  * Linear interpolation is used for 1-dimensional data and
 287:.\Include/arm_math.h ****  * bilinear interpolation is used for 2-dimensional data.
 288:.\Include/arm_math.h ****  */
 289:.\Include/arm_math.h **** 
 290:.\Include/arm_math.h **** /**
 291:.\Include/arm_math.h ****  * @defgroup groupExamples Examples
 292:.\Include/arm_math.h ****  */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 10


 293:.\Include/arm_math.h **** #ifndef _ARM_MATH_H
 294:.\Include/arm_math.h **** #define _ARM_MATH_H
 295:.\Include/arm_math.h **** 
 296:.\Include/arm_math.h **** /* ignore some GCC warnings */
 297:.\Include/arm_math.h **** #if defined ( __GNUC__ )
 298:.\Include/arm_math.h **** #pragma GCC diagnostic push
 299:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
 300:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wconversion"
 301:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
 302:.\Include/arm_math.h **** #endif
 303:.\Include/arm_math.h **** 
 304:.\Include/arm_math.h **** #define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
 305:.\Include/arm_math.h **** 
 306:.\Include/arm_math.h **** #if defined(ARM_MATH_CM7)
 307:.\Include/arm_math.h ****   #include "core_cm7.h"
 308:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 309:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM4)
 310:.\Include/arm_math.h ****   #include "core_cm4.h"
 311:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 312:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM3)
 313:.\Include/arm_math.h ****   #include "core_cm3.h"
 314:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0)
 315:.\Include/arm_math.h ****   #include "core_cm0.h"
 316:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 317:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0PLUS)
 318:.\Include/arm_math.h ****   #include "core_cm0plus.h"
 319:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 320:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MBL)
 321:.\Include/arm_math.h ****   #include "core_armv8mbl.h"
 322:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 323:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MML)
 324:.\Include/arm_math.h ****   #include "core_armv8mml.h"
 325:.\Include/arm_math.h ****   #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
 326:.\Include/arm_math.h ****     #define ARM_MATH_DSP
 327:.\Include/arm_math.h ****   #endif
 328:.\Include/arm_math.h **** #else
 329:.\Include/arm_math.h ****   #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_
 330:.\Include/arm_math.h **** #endif
 331:.\Include/arm_math.h **** 
 332:.\Include/arm_math.h **** #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 333:.\Include/arm_math.h **** #include "string.h"
 334:.\Include/arm_math.h **** #include "math.h"
 335:.\Include/arm_math.h **** #ifdef   __cplusplus
 336:.\Include/arm_math.h **** extern "C"
 337:.\Include/arm_math.h **** {
 338:.\Include/arm_math.h **** #endif
 339:.\Include/arm_math.h **** 
 340:.\Include/arm_math.h **** 
 341:.\Include/arm_math.h ****   /**
 342:.\Include/arm_math.h ****    * @brief Macros required for reciprocal calculation in Normalized LMS
 343:.\Include/arm_math.h ****    */
 344:.\Include/arm_math.h **** 
 345:.\Include/arm_math.h **** #define DELTA_Q31          (0x100)
 346:.\Include/arm_math.h **** #define DELTA_Q15          0x5
 347:.\Include/arm_math.h **** #define INDEX_MASK         0x0000003F
 348:.\Include/arm_math.h **** #ifndef PI
 349:.\Include/arm_math.h ****   #define PI               3.14159265358979f
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 11


 350:.\Include/arm_math.h **** #endif
 351:.\Include/arm_math.h **** 
 352:.\Include/arm_math.h ****   /**
 353:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Fast math approximations
 354:.\Include/arm_math.h ****    */
 355:.\Include/arm_math.h **** 
 356:.\Include/arm_math.h **** #define FAST_MATH_TABLE_SIZE  512
 357:.\Include/arm_math.h **** #define FAST_MATH_Q31_SHIFT   (32 - 10)
 358:.\Include/arm_math.h **** #define FAST_MATH_Q15_SHIFT   (16 - 10)
 359:.\Include/arm_math.h **** #define CONTROLLER_Q31_SHIFT  (32 - 9)
 360:.\Include/arm_math.h **** #define TABLE_SPACING_Q31     0x400000
 361:.\Include/arm_math.h **** #define TABLE_SPACING_Q15     0x80
 362:.\Include/arm_math.h **** 
 363:.\Include/arm_math.h ****   /**
 364:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Controller functions
 365:.\Include/arm_math.h ****    */
 366:.\Include/arm_math.h ****   /* 1.31(q31) Fixed value of 2/360 */
 367:.\Include/arm_math.h ****   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 368:.\Include/arm_math.h **** #define INPUT_SPACING         0xB60B61
 369:.\Include/arm_math.h **** 
 370:.\Include/arm_math.h ****   /**
 371:.\Include/arm_math.h ****    * @brief Macro for Unaligned Support
 372:.\Include/arm_math.h ****    */
 373:.\Include/arm_math.h **** #ifndef UNALIGNED_SUPPORT_DISABLE
 374:.\Include/arm_math.h ****     #define ALIGN4
 375:.\Include/arm_math.h **** #else
 376:.\Include/arm_math.h ****   #if defined  (__GNUC__)
 377:.\Include/arm_math.h ****     #define ALIGN4 __attribute__((aligned(4)))
 378:.\Include/arm_math.h ****   #else
 379:.\Include/arm_math.h ****     #define ALIGN4 __align(4)
 380:.\Include/arm_math.h ****   #endif
 381:.\Include/arm_math.h **** #endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 382:.\Include/arm_math.h **** 
 383:.\Include/arm_math.h ****   /**
 384:.\Include/arm_math.h ****    * @brief Error status returned by some functions in the library.
 385:.\Include/arm_math.h ****    */
 386:.\Include/arm_math.h **** 
 387:.\Include/arm_math.h ****   typedef enum
 388:.\Include/arm_math.h ****   {
 389:.\Include/arm_math.h ****     ARM_MATH_SUCCESS = 0,                /**< No error */
 390:.\Include/arm_math.h ****     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
 391:.\Include/arm_math.h ****     ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
 392:.\Include/arm_math.h ****     ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation
 393:.\Include/arm_math.h ****     ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
 394:.\Include/arm_math.h ****     ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is 
 395:.\Include/arm_math.h ****     ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
 396:.\Include/arm_math.h ****   } arm_status;
 397:.\Include/arm_math.h **** 
 398:.\Include/arm_math.h ****   /**
 399:.\Include/arm_math.h ****    * @brief 8-bit fractional data type in 1.7 format.
 400:.\Include/arm_math.h ****    */
 401:.\Include/arm_math.h ****   typedef int8_t q7_t;
 402:.\Include/arm_math.h **** 
 403:.\Include/arm_math.h ****   /**
 404:.\Include/arm_math.h ****    * @brief 16-bit fractional data type in 1.15 format.
 405:.\Include/arm_math.h ****    */
 406:.\Include/arm_math.h ****   typedef int16_t q15_t;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 12


 407:.\Include/arm_math.h **** 
 408:.\Include/arm_math.h ****   /**
 409:.\Include/arm_math.h ****    * @brief 32-bit fractional data type in 1.31 format.
 410:.\Include/arm_math.h ****    */
 411:.\Include/arm_math.h ****   typedef int32_t q31_t;
 412:.\Include/arm_math.h **** 
 413:.\Include/arm_math.h ****   /**
 414:.\Include/arm_math.h ****    * @brief 64-bit fractional data type in 1.63 format.
 415:.\Include/arm_math.h ****    */
 416:.\Include/arm_math.h ****   typedef int64_t q63_t;
 417:.\Include/arm_math.h **** 
 418:.\Include/arm_math.h ****   /**
 419:.\Include/arm_math.h ****    * @brief 32-bit floating-point type definition.
 420:.\Include/arm_math.h ****    */
 421:.\Include/arm_math.h ****   typedef float float32_t;
 422:.\Include/arm_math.h **** 
 423:.\Include/arm_math.h ****   /**
 424:.\Include/arm_math.h ****    * @brief 64-bit floating-point type definition.
 425:.\Include/arm_math.h ****    */
 426:.\Include/arm_math.h ****   typedef double float64_t;
 427:.\Include/arm_math.h **** 
 428:.\Include/arm_math.h ****   /**
 429:.\Include/arm_math.h ****    * @brief definition to read/write two 16 bit values.
 430:.\Include/arm_math.h ****    */
 431:.\Include/arm_math.h **** #if   defined ( __CC_ARM )
 432:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 433:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 434:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 435:.\Include/arm_math.h **** 
 436:.\Include/arm_math.h **** #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 437:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 438:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 439:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 440:.\Include/arm_math.h **** 
 441:.\Include/arm_math.h **** #elif defined ( __GNUC__ )
 442:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 443:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 444:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 445:.\Include/arm_math.h **** 
 446:.\Include/arm_math.h **** #elif defined ( __ICCARM__ )
 447:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 448:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 449:.\Include/arm_math.h ****   #define CMSIS_INLINE
 450:.\Include/arm_math.h **** 
 451:.\Include/arm_math.h **** #elif defined ( __TI_ARM__ )
 452:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 453:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 454:.\Include/arm_math.h ****   #define CMSIS_INLINE
 455:.\Include/arm_math.h **** 
 456:.\Include/arm_math.h **** #elif defined ( __CSMC__ )
 457:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 458:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 459:.\Include/arm_math.h ****   #define CMSIS_INLINE
 460:.\Include/arm_math.h **** 
 461:.\Include/arm_math.h **** #elif defined ( __TASKING__ )
 462:.\Include/arm_math.h ****   #define __SIMD32_TYPE __unaligned int32_t
 463:.\Include/arm_math.h ****   #define CMSIS_UNUSED
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 13


 464:.\Include/arm_math.h ****   #define CMSIS_INLINE
 465:.\Include/arm_math.h **** 
 466:.\Include/arm_math.h **** #else
 467:.\Include/arm_math.h ****   #error Unknown compiler
 468:.\Include/arm_math.h **** #endif
 469:.\Include/arm_math.h **** 
 470:.\Include/arm_math.h **** #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
 471:.\Include/arm_math.h **** #define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
 472:.\Include/arm_math.h **** #define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
 473:.\Include/arm_math.h **** #define __SIMD64(addr)        (*(int64_t **) & (addr))
 474:.\Include/arm_math.h **** 
 475:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 476:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 477:.\Include/arm_math.h ****   /**
 478:.\Include/arm_math.h ****    * @brief definition to pack two 16 bit values.
 479:.\Include/arm_math.h ****    */
 480:.\Include/arm_math.h **** #define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
 481:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
 482:.\Include/arm_math.h **** #define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
 483:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
 484:.\Include/arm_math.h **** 
 485:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 486:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
 487:.\Include/arm_math.h **** 
 488:.\Include/arm_math.h ****    /**
 489:.\Include/arm_math.h ****    * @brief definition to pack four 8 bit values.
 490:.\Include/arm_math.h ****    */
 491:.\Include/arm_math.h **** #ifndef ARM_MATH_BIG_ENDIAN
 492:.\Include/arm_math.h **** 
 493:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
 494:.\Include/arm_math.h ****                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
 495:.\Include/arm_math.h ****                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
 496:.\Include/arm_math.h ****                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 497:.\Include/arm_math.h **** #else
 498:.\Include/arm_math.h **** 
 499:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
 500:.\Include/arm_math.h ****                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
 501:.\Include/arm_math.h ****                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
 502:.\Include/arm_math.h ****                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 503:.\Include/arm_math.h **** 
 504:.\Include/arm_math.h **** #endif
 505:.\Include/arm_math.h **** 
 506:.\Include/arm_math.h **** 
 507:.\Include/arm_math.h ****   /**
 508:.\Include/arm_math.h ****    * @brief Clips Q63 to Q31 values.
 509:.\Include/arm_math.h ****    */
 510:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
 511:.\Include/arm_math.h ****   q63_t x)
 512:.\Include/arm_math.h ****   {
 513:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 514:.\Include/arm_math.h ****       ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
 515:.\Include/arm_math.h ****   }
 516:.\Include/arm_math.h **** 
 517:.\Include/arm_math.h ****   /**
 518:.\Include/arm_math.h ****    * @brief Clips Q63 to Q15 values.
 519:.\Include/arm_math.h ****    */
 520:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 14


 521:.\Include/arm_math.h ****   q63_t x)
 522:.\Include/arm_math.h ****   {
 523:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 524:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
 525:.\Include/arm_math.h ****   }
 526:.\Include/arm_math.h **** 
 527:.\Include/arm_math.h ****   /**
 528:.\Include/arm_math.h ****    * @brief Clips Q31 to Q7 values.
 529:.\Include/arm_math.h ****    */
 530:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
 531:.\Include/arm_math.h ****   q31_t x)
 532:.\Include/arm_math.h ****   {
 533:.\Include/arm_math.h ****     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
 534:.\Include/arm_math.h ****       ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
 535:.\Include/arm_math.h ****   }
 536:.\Include/arm_math.h **** 
 537:.\Include/arm_math.h ****   /**
 538:.\Include/arm_math.h ****    * @brief Clips Q31 to Q15 values.
 539:.\Include/arm_math.h ****    */
 540:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
 541:.\Include/arm_math.h ****   q31_t x)
 542:.\Include/arm_math.h ****   {
 543:.\Include/arm_math.h ****     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
 544:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
 545:.\Include/arm_math.h ****   }
 546:.\Include/arm_math.h **** 
 547:.\Include/arm_math.h ****   /**
 548:.\Include/arm_math.h ****    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
 549:.\Include/arm_math.h ****    */
 550:.\Include/arm_math.h **** 
 551:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
 552:.\Include/arm_math.h ****   q63_t x,
 553:.\Include/arm_math.h ****   q31_t y)
 554:.\Include/arm_math.h ****   {
 555:.\Include/arm_math.h ****     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
 556:.\Include/arm_math.h ****             (((q63_t) (x >> 32) * y)));
 557:.\Include/arm_math.h ****   }
 558:.\Include/arm_math.h **** 
 559:.\Include/arm_math.h **** /*
 560:.\Include/arm_math.h ****   #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
 561:.\Include/arm_math.h ****   #define __CLZ __clz
 562:.\Include/arm_math.h ****   #endif
 563:.\Include/arm_math.h ****  */
 564:.\Include/arm_math.h **** /* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
 565:.\Include/arm_math.h **** #if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
 566:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 567:.\Include/arm_math.h ****   q31_t data);
 568:.\Include/arm_math.h **** 
 569:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 570:.\Include/arm_math.h ****   q31_t data)
 571:.\Include/arm_math.h ****   {
 572:.\Include/arm_math.h ****     uint32_t count = 0;
 573:.\Include/arm_math.h ****     uint32_t mask = 0x80000000;
 574:.\Include/arm_math.h **** 
 575:.\Include/arm_math.h ****     while ((data & mask) == 0)
 576:.\Include/arm_math.h ****     {
 577:.\Include/arm_math.h ****       count += 1u;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 15


 578:.\Include/arm_math.h ****       mask = mask >> 1u;
 579:.\Include/arm_math.h ****     }
 580:.\Include/arm_math.h **** 
 581:.\Include/arm_math.h ****     return (count);
 582:.\Include/arm_math.h ****   }
 583:.\Include/arm_math.h **** #endif
 584:.\Include/arm_math.h **** 
 585:.\Include/arm_math.h ****   /**
 586:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
 587:.\Include/arm_math.h ****    */
 588:.\Include/arm_math.h **** 
 589:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
 590:.\Include/arm_math.h ****   q31_t in,
 591:.\Include/arm_math.h ****   q31_t * dst,
 592:.\Include/arm_math.h ****   q31_t * pRecipTable)
 593:.\Include/arm_math.h ****   {
 594:.\Include/arm_math.h ****     q31_t out;
 595:.\Include/arm_math.h ****     uint32_t tempVal;
 596:.\Include/arm_math.h ****     uint32_t index, i;
 597:.\Include/arm_math.h ****     uint32_t signBits;
 598:.\Include/arm_math.h **** 
 599:.\Include/arm_math.h ****     if (in > 0)
 600:.\Include/arm_math.h ****     {
 601:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ( in) - 1));
 602:.\Include/arm_math.h ****     }
 603:.\Include/arm_math.h ****     else
 604:.\Include/arm_math.h ****     {
 605:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ(-in) - 1));
 606:.\Include/arm_math.h ****     }
 607:.\Include/arm_math.h **** 
 608:.\Include/arm_math.h ****     /* Convert input sample to 1.31 format */
 609:.\Include/arm_math.h ****     in = (in << signBits);
 610:.\Include/arm_math.h **** 
 611:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 612:.\Include/arm_math.h ****     index = (uint32_t)(in >> 24);
 613:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 614:.\Include/arm_math.h **** 
 615:.\Include/arm_math.h ****     /* 1.31 with exp 1 */
 616:.\Include/arm_math.h ****     out = pRecipTable[index];
 617:.\Include/arm_math.h **** 
 618:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 619:.\Include/arm_math.h ****     /* running approximation for two iterations */
 620:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 621:.\Include/arm_math.h ****     {
 622:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q63_t) in * out) >> 31);
 623:.\Include/arm_math.h ****       tempVal = 0x7FFFFFFFu - tempVal;
 624:.\Include/arm_math.h ****       /*      1.31 with exp 1 */
 625:.\Include/arm_math.h ****       /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
 626:.\Include/arm_math.h ****       out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
 627:.\Include/arm_math.h ****     }
 628:.\Include/arm_math.h **** 
 629:.\Include/arm_math.h ****     /* write output */
 630:.\Include/arm_math.h ****     *dst = out;
 631:.\Include/arm_math.h **** 
 632:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 633:.\Include/arm_math.h ****     return (signBits + 1u);
 634:.\Include/arm_math.h ****   }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 16


 635:.\Include/arm_math.h **** 
 636:.\Include/arm_math.h **** 
 637:.\Include/arm_math.h ****   /**
 638:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
 639:.\Include/arm_math.h ****    */
 640:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
 641:.\Include/arm_math.h ****   q15_t in,
 642:.\Include/arm_math.h ****   q15_t * dst,
 643:.\Include/arm_math.h ****   q15_t * pRecipTable)
 644:.\Include/arm_math.h ****   {
 645:.\Include/arm_math.h ****     q15_t out = 0;
 646:.\Include/arm_math.h ****     uint32_t tempVal = 0;
 647:.\Include/arm_math.h ****     uint32_t index = 0, i = 0;
 648:.\Include/arm_math.h ****     uint32_t signBits = 0;
 649:.\Include/arm_math.h **** 
 650:.\Include/arm_math.h ****     if (in > 0)
 651:.\Include/arm_math.h ****     {
 652:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ( in) - 17));
 653:.\Include/arm_math.h ****     }
 654:.\Include/arm_math.h ****     else
 655:.\Include/arm_math.h ****     {
 656:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ(-in) - 17));
 657:.\Include/arm_math.h ****     }
 658:.\Include/arm_math.h **** 
 659:.\Include/arm_math.h ****     /* Convert input sample to 1.15 format */
 660:.\Include/arm_math.h ****     in = (in << signBits);
 661:.\Include/arm_math.h **** 
 662:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 663:.\Include/arm_math.h ****     index = (uint32_t)(in >>  8);
 664:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 665:.\Include/arm_math.h **** 
 666:.\Include/arm_math.h ****     /*      1.15 with exp 1  */
 667:.\Include/arm_math.h ****     out = pRecipTable[index];
 668:.\Include/arm_math.h **** 
 669:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 670:.\Include/arm_math.h ****     /* running approximation for two iterations */
 671:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 672:.\Include/arm_math.h ****     {
 673:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q31_t) in * out) >> 15);
 674:.\Include/arm_math.h ****       tempVal = 0x7FFFu - tempVal;
 675:.\Include/arm_math.h ****       /*      1.15 with exp 1 */
 676:.\Include/arm_math.h ****       out = (q15_t) (((q31_t) out * tempVal) >> 14);
 677:.\Include/arm_math.h ****       /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
 678:.\Include/arm_math.h ****     }
 679:.\Include/arm_math.h **** 
 680:.\Include/arm_math.h ****     /* write output */
 681:.\Include/arm_math.h ****     *dst = out;
 682:.\Include/arm_math.h **** 
 683:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 684:.\Include/arm_math.h ****     return (signBits + 1);
 685:.\Include/arm_math.h ****   }
 686:.\Include/arm_math.h **** 
 687:.\Include/arm_math.h **** 
 688:.\Include/arm_math.h ****   /*
 689:.\Include/arm_math.h ****    * @brief C custom defined intrinisic function for only M0 processors
 690:.\Include/arm_math.h ****    */
 691:.\Include/arm_math.h **** #if defined(ARM_MATH_CM0_FAMILY)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 17


 692:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t __SSAT(
 693:.\Include/arm_math.h ****   q31_t x,
 694:.\Include/arm_math.h ****   uint32_t y)
 695:.\Include/arm_math.h ****   {
 696:.\Include/arm_math.h ****     int32_t posMax, negMin;
 697:.\Include/arm_math.h ****     uint32_t i;
 698:.\Include/arm_math.h **** 
 699:.\Include/arm_math.h ****     posMax = 1;
 700:.\Include/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 701:.\Include/arm_math.h ****     {
 702:.\Include/arm_math.h ****       posMax = posMax * 2;
 703:.\Include/arm_math.h ****     }
 704:.\Include/arm_math.h **** 
 705:.\Include/arm_math.h ****     if (x > 0)
 706:.\Include/arm_math.h ****     {
 707:.\Include/arm_math.h ****       posMax = (posMax - 1);
 708:.\Include/arm_math.h **** 
 709:.\Include/arm_math.h ****       if (x > posMax)
 710:.\Include/arm_math.h ****       {
 711:.\Include/arm_math.h ****         x = posMax;
 712:.\Include/arm_math.h ****       }
 713:.\Include/arm_math.h ****     }
 714:.\Include/arm_math.h ****     else
 715:.\Include/arm_math.h ****     {
 716:.\Include/arm_math.h ****       negMin = -posMax;
 717:.\Include/arm_math.h **** 
 718:.\Include/arm_math.h ****       if (x < negMin)
 719:.\Include/arm_math.h ****       {
 720:.\Include/arm_math.h ****         x = negMin;
 721:.\Include/arm_math.h ****       }
 722:.\Include/arm_math.h ****     }
 723:.\Include/arm_math.h ****     return (x);
 724:.\Include/arm_math.h ****   }
 725:.\Include/arm_math.h **** #endif /* end of ARM_MATH_CM0_FAMILY */
 726:.\Include/arm_math.h **** 
 727:.\Include/arm_math.h **** 
 728:.\Include/arm_math.h ****   /*
 729:.\Include/arm_math.h ****    * @brief C custom defined intrinsic function for M3 and M0 processors
 730:.\Include/arm_math.h ****    */
 731:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 732:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 733:.\Include/arm_math.h **** 
 734:.\Include/arm_math.h ****   /*
 735:.\Include/arm_math.h ****    * @brief C custom defined QADD8 for M3 and M0 processors
 736:.\Include/arm_math.h ****    */
 737:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
 738:.\Include/arm_math.h ****   uint32_t x,
 739:.\Include/arm_math.h ****   uint32_t y)
 740:.\Include/arm_math.h ****   {
 741:.\Include/arm_math.h ****     q31_t r, s, t, u;
 742:.\Include/arm_math.h **** 
 743:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 744:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 745:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 746:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 747:.\Include/arm_math.h **** 
 748:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 18


 749:.\Include/arm_math.h ****   }
 750:.\Include/arm_math.h **** 
 751:.\Include/arm_math.h **** 
 752:.\Include/arm_math.h ****   /*
 753:.\Include/arm_math.h ****    * @brief C custom defined QSUB8 for M3 and M0 processors
 754:.\Include/arm_math.h ****    */
 755:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
 756:.\Include/arm_math.h ****   uint32_t x,
 757:.\Include/arm_math.h ****   uint32_t y)
 758:.\Include/arm_math.h ****   {
 759:.\Include/arm_math.h ****     q31_t r, s, t, u;
 760:.\Include/arm_math.h **** 
 761:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 762:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 763:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 764:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 765:.\Include/arm_math.h **** 
 766:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 767:.\Include/arm_math.h ****   }
 768:.\Include/arm_math.h **** 
 769:.\Include/arm_math.h **** 
 770:.\Include/arm_math.h ****   /*
 771:.\Include/arm_math.h ****    * @brief C custom defined QADD16 for M3 and M0 processors
 772:.\Include/arm_math.h ****    */
 773:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
 774:.\Include/arm_math.h ****   uint32_t x,
 775:.\Include/arm_math.h ****   uint32_t y)
 776:.\Include/arm_math.h ****   {
 777:.\Include/arm_math.h **** /*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass
 778:.\Include/arm_math.h ****     q31_t r = 0, s = 0;
 779:.\Include/arm_math.h **** 
 780:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 781:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 782:.\Include/arm_math.h **** 
 783:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 784:.\Include/arm_math.h ****   }
 785:.\Include/arm_math.h **** 
 786:.\Include/arm_math.h **** 
 787:.\Include/arm_math.h ****   /*
 788:.\Include/arm_math.h ****    * @brief C custom defined SHADD16 for M3 and M0 processors
 789:.\Include/arm_math.h ****    */
 790:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
 791:.\Include/arm_math.h ****   uint32_t x,
 792:.\Include/arm_math.h ****   uint32_t y)
 793:.\Include/arm_math.h ****   {
 794:.\Include/arm_math.h ****     q31_t r, s;
 795:.\Include/arm_math.h **** 
 796:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 797:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 798:.\Include/arm_math.h **** 
 799:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 800:.\Include/arm_math.h ****   }
 801:.\Include/arm_math.h **** 
 802:.\Include/arm_math.h **** 
 803:.\Include/arm_math.h ****   /*
 804:.\Include/arm_math.h ****    * @brief C custom defined QSUB16 for M3 and M0 processors
 805:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 19


 806:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
 807:.\Include/arm_math.h ****   uint32_t x,
 808:.\Include/arm_math.h ****   uint32_t y)
 809:.\Include/arm_math.h ****   {
 810:.\Include/arm_math.h ****     q31_t r, s;
 811:.\Include/arm_math.h **** 
 812:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 813:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 814:.\Include/arm_math.h **** 
 815:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 816:.\Include/arm_math.h ****   }
 817:.\Include/arm_math.h **** 
 818:.\Include/arm_math.h **** 
 819:.\Include/arm_math.h ****   /*
 820:.\Include/arm_math.h ****    * @brief C custom defined SHSUB16 for M3 and M0 processors
 821:.\Include/arm_math.h ****    */
 822:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
 823:.\Include/arm_math.h ****   uint32_t x,
 824:.\Include/arm_math.h ****   uint32_t y)
 825:.\Include/arm_math.h ****   {
 826:.\Include/arm_math.h ****     q31_t r, s;
 827:.\Include/arm_math.h **** 
 828:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 829:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 830:.\Include/arm_math.h **** 
 831:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 832:.\Include/arm_math.h ****   }
 833:.\Include/arm_math.h **** 
 834:.\Include/arm_math.h **** 
 835:.\Include/arm_math.h ****   /*
 836:.\Include/arm_math.h ****    * @brief C custom defined QASX for M3 and M0 processors
 837:.\Include/arm_math.h ****    */
 838:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
 839:.\Include/arm_math.h ****   uint32_t x,
 840:.\Include/arm_math.h ****   uint32_t y)
 841:.\Include/arm_math.h ****   {
 842:.\Include/arm_math.h ****     q31_t r, s;
 843:.\Include/arm_math.h **** 
 844:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 845:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 846:.\Include/arm_math.h **** 
 847:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 848:.\Include/arm_math.h ****   }
 849:.\Include/arm_math.h **** 
 850:.\Include/arm_math.h **** 
 851:.\Include/arm_math.h ****   /*
 852:.\Include/arm_math.h ****    * @brief C custom defined SHASX for M3 and M0 processors
 853:.\Include/arm_math.h ****    */
 854:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
 855:.\Include/arm_math.h ****   uint32_t x,
 856:.\Include/arm_math.h ****   uint32_t y)
 857:.\Include/arm_math.h ****   {
 858:.\Include/arm_math.h ****     q31_t r, s;
 859:.\Include/arm_math.h **** 
 860:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 861:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 862:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 20


 863:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 864:.\Include/arm_math.h ****   }
 865:.\Include/arm_math.h **** 
 866:.\Include/arm_math.h **** 
 867:.\Include/arm_math.h ****   /*
 868:.\Include/arm_math.h ****    * @brief C custom defined QSAX for M3 and M0 processors
 869:.\Include/arm_math.h ****    */
 870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
 871:.\Include/arm_math.h ****   uint32_t x,
 872:.\Include/arm_math.h ****   uint32_t y)
 873:.\Include/arm_math.h ****   {
 874:.\Include/arm_math.h ****     q31_t r, s;
 875:.\Include/arm_math.h **** 
 876:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 877:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 878:.\Include/arm_math.h **** 
 879:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 880:.\Include/arm_math.h ****   }
 881:.\Include/arm_math.h **** 
 882:.\Include/arm_math.h **** 
 883:.\Include/arm_math.h ****   /*
 884:.\Include/arm_math.h ****    * @brief C custom defined SHSAX for M3 and M0 processors
 885:.\Include/arm_math.h ****    */
 886:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
 887:.\Include/arm_math.h ****   uint32_t x,
 888:.\Include/arm_math.h ****   uint32_t y)
 889:.\Include/arm_math.h ****   {
 890:.\Include/arm_math.h ****     q31_t r, s;
 891:.\Include/arm_math.h **** 
 892:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 893:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 894:.\Include/arm_math.h **** 
 895:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 896:.\Include/arm_math.h ****   }
 897:.\Include/arm_math.h **** 
 898:.\Include/arm_math.h **** 
 899:.\Include/arm_math.h ****   /*
 900:.\Include/arm_math.h ****    * @brief C custom defined SMUSDX for M3 and M0 processors
 901:.\Include/arm_math.h ****    */
 902:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
 903:.\Include/arm_math.h ****   uint32_t x,
 904:.\Include/arm_math.h ****   uint32_t y)
 905:.\Include/arm_math.h ****   {
 906:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 907:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 908:.\Include/arm_math.h ****   }
 909:.\Include/arm_math.h **** 
 910:.\Include/arm_math.h ****   /*
 911:.\Include/arm_math.h ****    * @brief C custom defined SMUADX for M3 and M0 processors
 912:.\Include/arm_math.h ****    */
 913:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
 914:.\Include/arm_math.h ****   uint32_t x,
 915:.\Include/arm_math.h ****   uint32_t y)
 916:.\Include/arm_math.h ****   {
 917:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 918:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 919:.\Include/arm_math.h ****   }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 21


 920:.\Include/arm_math.h **** 
 921:.\Include/arm_math.h **** 
 922:.\Include/arm_math.h ****   /*
 923:.\Include/arm_math.h ****    * @brief C custom defined QADD for M3 and M0 processors
 924:.\Include/arm_math.h ****    */
 925:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
 926:.\Include/arm_math.h ****   int32_t x,
 927:.\Include/arm_math.h ****   int32_t y)
 928:.\Include/arm_math.h ****   {
 929:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
 930:.\Include/arm_math.h ****   }
 931:.\Include/arm_math.h **** 
 932:.\Include/arm_math.h **** 
 933:.\Include/arm_math.h ****   /*
 934:.\Include/arm_math.h ****    * @brief C custom defined QSUB for M3 and M0 processors
 935:.\Include/arm_math.h ****    */
 936:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
 937:.\Include/arm_math.h ****   int32_t x,
 938:.\Include/arm_math.h ****   int32_t y)
 939:.\Include/arm_math.h ****   {
 940:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
 941:.\Include/arm_math.h ****   }
 942:.\Include/arm_math.h **** 
 943:.\Include/arm_math.h **** 
 944:.\Include/arm_math.h ****   /*
 945:.\Include/arm_math.h ****    * @brief C custom defined SMLAD for M3 and M0 processors
 946:.\Include/arm_math.h ****    */
 947:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
 948:.\Include/arm_math.h ****   uint32_t x,
 949:.\Include/arm_math.h ****   uint32_t y,
 950:.\Include/arm_math.h ****   uint32_t sum)
 951:.\Include/arm_math.h ****   {
 952:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 953:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 954:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 955:.\Include/arm_math.h ****   }
 956:.\Include/arm_math.h **** 
 957:.\Include/arm_math.h **** 
 958:.\Include/arm_math.h ****   /*
 959:.\Include/arm_math.h ****    * @brief C custom defined SMLADX for M3 and M0 processors
 960:.\Include/arm_math.h ****    */
 961:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
 962:.\Include/arm_math.h ****   uint32_t x,
 963:.\Include/arm_math.h ****   uint32_t y,
 964:.\Include/arm_math.h ****   uint32_t sum)
 965:.\Include/arm_math.h ****   {
 966:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 967:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 968:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 969:.\Include/arm_math.h ****   }
 970:.\Include/arm_math.h **** 
 971:.\Include/arm_math.h **** 
 972:.\Include/arm_math.h ****   /*
 973:.\Include/arm_math.h ****    * @brief C custom defined SMLSDX for M3 and M0 processors
 974:.\Include/arm_math.h ****    */
 975:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
 976:.\Include/arm_math.h ****   uint32_t x,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 22


 977:.\Include/arm_math.h ****   uint32_t y,
 978:.\Include/arm_math.h ****   uint32_t sum)
 979:.\Include/arm_math.h ****   {
 980:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 981:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 982:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 983:.\Include/arm_math.h ****   }
 984:.\Include/arm_math.h **** 
 985:.\Include/arm_math.h **** 
 986:.\Include/arm_math.h ****   /*
 987:.\Include/arm_math.h ****    * @brief C custom defined SMLALD for M3 and M0 processors
 988:.\Include/arm_math.h ****    */
 989:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
 990:.\Include/arm_math.h ****   uint32_t x,
 991:.\Include/arm_math.h ****   uint32_t y,
 992:.\Include/arm_math.h ****   uint64_t sum)
 993:.\Include/arm_math.h ****   {
 994:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
 995:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 996:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 997:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 998:.\Include/arm_math.h ****   }
 999:.\Include/arm_math.h **** 
1000:.\Include/arm_math.h **** 
1001:.\Include/arm_math.h ****   /*
1002:.\Include/arm_math.h ****    * @brief C custom defined SMLALDX for M3 and M0 processors
1003:.\Include/arm_math.h ****    */
1004:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
1005:.\Include/arm_math.h ****   uint32_t x,
1006:.\Include/arm_math.h ****   uint32_t y,
1007:.\Include/arm_math.h ****   uint64_t sum)
1008:.\Include/arm_math.h ****   {
1009:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
1010:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
1011:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
1012:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
1013:.\Include/arm_math.h ****   }
1014:.\Include/arm_math.h **** 
1015:.\Include/arm_math.h **** 
1016:.\Include/arm_math.h ****   /*
1017:.\Include/arm_math.h ****    * @brief C custom defined SMUAD for M3 and M0 processors
1018:.\Include/arm_math.h ****    */
1019:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
1020:.\Include/arm_math.h ****   uint32_t x,
1021:.\Include/arm_math.h ****   uint32_t y)
1022:.\Include/arm_math.h ****   {
1023:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
1024:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1025:.\Include/arm_math.h ****   }
1026:.\Include/arm_math.h **** 
1027:.\Include/arm_math.h **** 
1028:.\Include/arm_math.h ****   /*
1029:.\Include/arm_math.h ****    * @brief C custom defined SMUSD for M3 and M0 processors
1030:.\Include/arm_math.h ****    */
1031:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
1032:.\Include/arm_math.h ****   uint32_t x,
1033:.\Include/arm_math.h ****   uint32_t y)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 23


1034:.\Include/arm_math.h ****   {
1035:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
1036:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1037:.\Include/arm_math.h ****   }
1038:.\Include/arm_math.h **** 
1039:.\Include/arm_math.h **** 
1040:.\Include/arm_math.h ****   /*
1041:.\Include/arm_math.h ****    * @brief C custom defined SXTB16 for M3 and M0 processors
1042:.\Include/arm_math.h ****    */
1043:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
1044:.\Include/arm_math.h ****   uint32_t x)
1045:.\Include/arm_math.h ****   {
1046:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
1047:.\Include/arm_math.h ****                        ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
1048:.\Include/arm_math.h ****   }
1049:.\Include/arm_math.h **** 
1050:.\Include/arm_math.h ****   /*
1051:.\Include/arm_math.h ****    * @brief C custom defined SMMLA for M3 and M0 processors
1052:.\Include/arm_math.h ****    */
1053:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
1054:.\Include/arm_math.h ****   int32_t x,
1055:.\Include/arm_math.h ****   int32_t y,
1056:.\Include/arm_math.h ****   int32_t sum)
1057:.\Include/arm_math.h ****   {
1058:.\Include/arm_math.h ****     return (sum + (int32_t) (((int64_t) x * y) >> 32));
1059:.\Include/arm_math.h ****   }
1060:.\Include/arm_math.h **** 
1061:.\Include/arm_math.h **** #if 0
1062:.\Include/arm_math.h ****   /*
1063:.\Include/arm_math.h ****    * @brief C custom defined PKHBT for unavailable DSP extension
1064:.\Include/arm_math.h ****    */
1065:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHBT(
1066:.\Include/arm_math.h ****   uint32_t x,
1067:.\Include/arm_math.h ****   uint32_t y,
1068:.\Include/arm_math.h ****   uint32_t leftshift)
1069:.\Include/arm_math.h ****   {
1070:.\Include/arm_math.h ****     return ( ((x             ) & 0x0000FFFFUL) |
1071:.\Include/arm_math.h ****              ((y << leftshift) & 0xFFFF0000UL)  );
1072:.\Include/arm_math.h ****   }
1073:.\Include/arm_math.h **** 
1074:.\Include/arm_math.h ****   /*
1075:.\Include/arm_math.h ****    * @brief C custom defined PKHTB for unavailable DSP extension
1076:.\Include/arm_math.h ****    */
1077:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHTB(
1078:.\Include/arm_math.h ****   uint32_t x,
1079:.\Include/arm_math.h ****   uint32_t y,
1080:.\Include/arm_math.h ****   uint32_t rightshift)
1081:.\Include/arm_math.h ****   {
1082:.\Include/arm_math.h ****     return ( ((x              ) & 0xFFFF0000UL) |
1083:.\Include/arm_math.h ****              ((y >> rightshift) & 0x0000FFFFUL)  );
1084:.\Include/arm_math.h ****   }
1085:.\Include/arm_math.h **** #endif
1086:.\Include/arm_math.h **** 
1087:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
1088:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
1089:.\Include/arm_math.h **** 
1090:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 24


1091:.\Include/arm_math.h ****   /**
1092:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 FIR filter.
1093:.\Include/arm_math.h ****    */
1094:.\Include/arm_math.h ****   typedef struct
1095:.\Include/arm_math.h ****   {
1096:.\Include/arm_math.h ****     uint16_t numTaps;        /**< number of filter coefficients in the filter. */
1097:.\Include/arm_math.h ****     q7_t *pState;            /**< points to the state variable array. The array is of length numTap
1098:.\Include/arm_math.h ****     q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*
1099:.\Include/arm_math.h ****   } arm_fir_instance_q7;
1100:.\Include/arm_math.h **** 
1101:.\Include/arm_math.h ****   /**
1102:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR filter.
1103:.\Include/arm_math.h ****    */
1104:.\Include/arm_math.h ****   typedef struct
1105:.\Include/arm_math.h ****   {
1106:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1107:.\Include/arm_math.h ****     q15_t *pState;            /**< points to the state variable array. The array is of length numTa
1108:.\Include/arm_math.h ****     q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1109:.\Include/arm_math.h ****   } arm_fir_instance_q15;
1110:.\Include/arm_math.h **** 
1111:.\Include/arm_math.h ****   /**
1112:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR filter.
1113:.\Include/arm_math.h ****    */
1114:.\Include/arm_math.h ****   typedef struct
1115:.\Include/arm_math.h ****   {
1116:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1117:.\Include/arm_math.h ****     q31_t *pState;            /**< points to the state variable array. The array is of length numTa
1118:.\Include/arm_math.h ****     q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1119:.\Include/arm_math.h ****   } arm_fir_instance_q31;
1120:.\Include/arm_math.h **** 
1121:.\Include/arm_math.h ****   /**
1122:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR filter.
1123:.\Include/arm_math.h ****    */
1124:.\Include/arm_math.h ****   typedef struct
1125:.\Include/arm_math.h ****   {
1126:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of filter coefficients in the filter. */
1127:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
1128:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
1129:.\Include/arm_math.h ****   } arm_fir_instance_f32;
1130:.\Include/arm_math.h **** 
1131:.\Include/arm_math.h **** 
1132:.\Include/arm_math.h ****   /**
1133:.\Include/arm_math.h ****    * @brief Processing function for the Q7 FIR filter.
1134:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
1135:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1136:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1137:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1138:.\Include/arm_math.h ****    */
1139:.\Include/arm_math.h ****   void arm_fir_q7(
1140:.\Include/arm_math.h ****   const arm_fir_instance_q7 * S,
1141:.\Include/arm_math.h ****   q7_t * pSrc,
1142:.\Include/arm_math.h ****   q7_t * pDst,
1143:.\Include/arm_math.h ****   uint32_t blockSize);
1144:.\Include/arm_math.h **** 
1145:.\Include/arm_math.h **** 
1146:.\Include/arm_math.h ****   /**
1147:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 FIR filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 25


1148:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 FIR structure.
1149:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1150:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1151:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1152:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed.
1153:.\Include/arm_math.h ****    */
1154:.\Include/arm_math.h ****   void arm_fir_init_q7(
1155:.\Include/arm_math.h ****   arm_fir_instance_q7 * S,
1156:.\Include/arm_math.h ****   uint16_t numTaps,
1157:.\Include/arm_math.h ****   q7_t * pCoeffs,
1158:.\Include/arm_math.h ****   q7_t * pState,
1159:.\Include/arm_math.h ****   uint32_t blockSize);
1160:.\Include/arm_math.h **** 
1161:.\Include/arm_math.h **** 
1162:.\Include/arm_math.h ****   /**
1163:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR filter.
1164:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR structure.
1165:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1166:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1167:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1168:.\Include/arm_math.h ****    */
1169:.\Include/arm_math.h ****   void arm_fir_q15(
1170:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1171:.\Include/arm_math.h ****   q15_t * pSrc,
1172:.\Include/arm_math.h ****   q15_t * pDst,
1173:.\Include/arm_math.h ****   uint32_t blockSize);
1174:.\Include/arm_math.h **** 
1175:.\Include/arm_math.h **** 
1176:.\Include/arm_math.h ****   /**
1177:.\Include/arm_math.h ****    * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
1178:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
1179:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1180:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1181:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1182:.\Include/arm_math.h ****    */
1183:.\Include/arm_math.h ****   void arm_fir_fast_q15(
1184:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1185:.\Include/arm_math.h ****   q15_t * pSrc,
1186:.\Include/arm_math.h ****   q15_t * pDst,
1187:.\Include/arm_math.h ****   uint32_t blockSize);
1188:.\Include/arm_math.h **** 
1189:.\Include/arm_math.h **** 
1190:.\Include/arm_math.h ****   /**
1191:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR filter.
1192:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
1193:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greate
1194:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1195:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1196:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1197:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARG
1198:.\Include/arm_math.h ****    * <code>numTaps</code> is not a supported value.
1199:.\Include/arm_math.h ****    */
1200:.\Include/arm_math.h ****   arm_status arm_fir_init_q15(
1201:.\Include/arm_math.h ****   arm_fir_instance_q15 * S,
1202:.\Include/arm_math.h ****   uint16_t numTaps,
1203:.\Include/arm_math.h ****   q15_t * pCoeffs,
1204:.\Include/arm_math.h ****   q15_t * pState,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 26


1205:.\Include/arm_math.h ****   uint32_t blockSize);
1206:.\Include/arm_math.h **** 
1207:.\Include/arm_math.h **** 
1208:.\Include/arm_math.h ****   /**
1209:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR filter.
1210:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR filter structure.
1211:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1212:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1213:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1214:.\Include/arm_math.h ****    */
1215:.\Include/arm_math.h ****   void arm_fir_q31(
1216:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1217:.\Include/arm_math.h ****   q31_t * pSrc,
1218:.\Include/arm_math.h ****   q31_t * pDst,
1219:.\Include/arm_math.h ****   uint32_t blockSize);
1220:.\Include/arm_math.h **** 
1221:.\Include/arm_math.h **** 
1222:.\Include/arm_math.h ****   /**
1223:.\Include/arm_math.h ****    * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
1224:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR structure.
1225:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1226:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1227:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1228:.\Include/arm_math.h ****    */
1229:.\Include/arm_math.h ****   void arm_fir_fast_q31(
1230:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1231:.\Include/arm_math.h ****   q31_t * pSrc,
1232:.\Include/arm_math.h ****   q31_t * pDst,
1233:.\Include/arm_math.h ****   uint32_t blockSize);
1234:.\Include/arm_math.h **** 
1235:.\Include/arm_math.h **** 
1236:.\Include/arm_math.h ****   /**
1237:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR filter.
1238:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR structure.
1239:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1240:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1241:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1242:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1243:.\Include/arm_math.h ****    */
1244:.\Include/arm_math.h ****   void arm_fir_init_q31(
1245:.\Include/arm_math.h ****   arm_fir_instance_q31 * S,
1246:.\Include/arm_math.h ****   uint16_t numTaps,
1247:.\Include/arm_math.h ****   q31_t * pCoeffs,
1248:.\Include/arm_math.h ****   q31_t * pState,
1249:.\Include/arm_math.h ****   uint32_t blockSize);
1250:.\Include/arm_math.h **** 
1251:.\Include/arm_math.h **** 
1252:.\Include/arm_math.h ****   /**
1253:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR filter.
1254:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR structure.
1255:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1256:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1257:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1258:.\Include/arm_math.h ****    */
1259:.\Include/arm_math.h ****   void arm_fir_f32(
1260:.\Include/arm_math.h ****   const arm_fir_instance_f32 * S,
1261:.\Include/arm_math.h ****   float32_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 27


1262:.\Include/arm_math.h ****   float32_t * pDst,
1263:.\Include/arm_math.h ****   uint32_t blockSize);
1264:.\Include/arm_math.h **** 
1265:.\Include/arm_math.h **** 
1266:.\Include/arm_math.h ****   /**
1267:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR filter.
1268:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
1269:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1270:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1271:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1272:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1273:.\Include/arm_math.h ****    */
1274:.\Include/arm_math.h ****   void arm_fir_init_f32(
1275:.\Include/arm_math.h ****   arm_fir_instance_f32 * S,
1276:.\Include/arm_math.h ****   uint16_t numTaps,
1277:.\Include/arm_math.h ****   float32_t * pCoeffs,
1278:.\Include/arm_math.h ****   float32_t * pState,
1279:.\Include/arm_math.h ****   uint32_t blockSize);
1280:.\Include/arm_math.h **** 
1281:.\Include/arm_math.h **** 
1282:.\Include/arm_math.h ****   /**
1283:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 Biquad cascade filter.
1284:.\Include/arm_math.h ****    */
1285:.\Include/arm_math.h ****   typedef struct
1286:.\Include/arm_math.h ****   {
1287:.\Include/arm_math.h ****     int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*num
1288:.\Include/arm_math.h ****     q15_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1289:.\Include/arm_math.h ****     q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1290:.\Include/arm_math.h ****     int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
1291:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q15;
1292:.\Include/arm_math.h **** 
1293:.\Include/arm_math.h ****   /**
1294:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 Biquad cascade filter.
1295:.\Include/arm_math.h ****    */
1296:.\Include/arm_math.h ****   typedef struct
1297:.\Include/arm_math.h ****   {
1298:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1299:.\Include/arm_math.h ****     q31_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1300:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1301:.\Include/arm_math.h ****     uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
1302:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q31;
1303:.\Include/arm_math.h **** 
1304:.\Include/arm_math.h ****   /**
1305:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Biquad cascade filter.
1306:.\Include/arm_math.h ****    */
1307:.\Include/arm_math.h ****   typedef struct
1308:.\Include/arm_math.h ****   {
1309:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1310:.\Include/arm_math.h ****     float32_t *pState;       /**< Points to the array of state coefficients.  The array is of lengt
1311:.\Include/arm_math.h ****     float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*nu
1312:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_f32;
1313:.\Include/arm_math.h **** 
1314:.\Include/arm_math.h **** 
1315:.\Include/arm_math.h ****   /**
1316:.\Include/arm_math.h ****    * @brief Processing function for the Q15 Biquad cascade filter.
1317:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1318:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 28


1319:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1320:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1321:.\Include/arm_math.h ****    */
1322:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q15(
1323:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1324:.\Include/arm_math.h ****   q15_t * pSrc,
1325:.\Include/arm_math.h ****   q15_t * pDst,
1326:.\Include/arm_math.h ****   uint32_t blockSize);
1327:.\Include/arm_math.h **** 
1328:.\Include/arm_math.h **** 
1329:.\Include/arm_math.h ****   /**
1330:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 Biquad cascade filter.
1331:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
1332:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1333:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1334:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1335:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1336:.\Include/arm_math.h ****    */
1337:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q15(
1338:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q15 * S,
1339:.\Include/arm_math.h ****   uint8_t numStages,
1340:.\Include/arm_math.h ****   q15_t * pCoeffs,
1341:.\Include/arm_math.h ****   q15_t * pState,
1342:.\Include/arm_math.h ****   int8_t postShift);
1343:.\Include/arm_math.h **** 
1344:.\Include/arm_math.h **** 
1345:.\Include/arm_math.h ****   /**
1346:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-
1347:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1348:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1349:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1350:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1351:.\Include/arm_math.h ****    */
1352:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q15(
1353:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1354:.\Include/arm_math.h ****   q15_t * pSrc,
1355:.\Include/arm_math.h ****   q15_t * pDst,
1356:.\Include/arm_math.h ****   uint32_t blockSize);
1357:.\Include/arm_math.h **** 
1358:.\Include/arm_math.h **** 
1359:.\Include/arm_math.h ****   /**
1360:.\Include/arm_math.h ****    * @brief Processing function for the Q31 Biquad cascade filter
1361:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1362:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1363:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1364:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1365:.\Include/arm_math.h ****    */
1366:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q31(
1367:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1368:.\Include/arm_math.h ****   q31_t * pSrc,
1369:.\Include/arm_math.h ****   q31_t * pDst,
1370:.\Include/arm_math.h ****   uint32_t blockSize);
1371:.\Include/arm_math.h **** 
1372:.\Include/arm_math.h **** 
1373:.\Include/arm_math.h ****   /**
1374:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-
1375:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 29


1376:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1377:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1378:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1379:.\Include/arm_math.h ****    */
1380:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q31(
1381:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1382:.\Include/arm_math.h ****   q31_t * pSrc,
1383:.\Include/arm_math.h ****   q31_t * pDst,
1384:.\Include/arm_math.h ****   uint32_t blockSize);
1385:.\Include/arm_math.h **** 
1386:.\Include/arm_math.h **** 
1387:.\Include/arm_math.h ****   /**
1388:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 Biquad cascade filter.
1389:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
1390:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1391:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1392:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1393:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1394:.\Include/arm_math.h ****    */
1395:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q31(
1396:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q31 * S,
1397:.\Include/arm_math.h ****   uint8_t numStages,
1398:.\Include/arm_math.h ****   q31_t * pCoeffs,
1399:.\Include/arm_math.h ****   q31_t * pState,
1400:.\Include/arm_math.h ****   int8_t postShift);
1401:.\Include/arm_math.h **** 
1402:.\Include/arm_math.h **** 
1403:.\Include/arm_math.h ****   /**
1404:.\Include/arm_math.h ****    * @brief Processing function for the floating-point Biquad cascade filter.
1405:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
1406:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1407:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1408:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1409:.\Include/arm_math.h ****    */
1410:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_f32(
1411:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_f32 * S,
1412:.\Include/arm_math.h ****   float32_t * pSrc,
1413:.\Include/arm_math.h ****   float32_t * pDst,
1414:.\Include/arm_math.h ****   uint32_t blockSize);
1415:.\Include/arm_math.h **** 
1416:.\Include/arm_math.h **** 
1417:.\Include/arm_math.h ****   /**
1418:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point Biquad cascade filter.
1419:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure
1420:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1421:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1422:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1423:.\Include/arm_math.h ****    */
1424:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_f32(
1425:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_f32 * S,
1426:.\Include/arm_math.h ****   uint8_t numStages,
1427:.\Include/arm_math.h ****   float32_t * pCoeffs,
1428:.\Include/arm_math.h ****   float32_t * pState);
1429:.\Include/arm_math.h **** 
1430:.\Include/arm_math.h **** 
1431:.\Include/arm_math.h ****   /**
1432:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 30


1433:.\Include/arm_math.h ****    */
1434:.\Include/arm_math.h ****   typedef struct
1435:.\Include/arm_math.h ****   {
1436:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1437:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1438:.\Include/arm_math.h ****     float32_t *pData;     /**< points to the data of the matrix. */
1439:.\Include/arm_math.h ****   } arm_matrix_instance_f32;
1440:.\Include/arm_math.h **** 
1441:.\Include/arm_math.h **** 
1442:.\Include/arm_math.h ****   /**
1443:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1444:.\Include/arm_math.h ****    */
1445:.\Include/arm_math.h ****   typedef struct
1446:.\Include/arm_math.h ****   {
1447:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1448:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1449:.\Include/arm_math.h ****     float64_t *pData;     /**< points to the data of the matrix. */
1450:.\Include/arm_math.h ****   } arm_matrix_instance_f64;
1451:.\Include/arm_math.h **** 
1452:.\Include/arm_math.h ****   /**
1453:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 matrix structure.
1454:.\Include/arm_math.h ****    */
1455:.\Include/arm_math.h ****   typedef struct
1456:.\Include/arm_math.h ****   {
1457:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1458:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1459:.\Include/arm_math.h ****     q15_t *pData;         /**< points to the data of the matrix. */
1460:.\Include/arm_math.h ****   } arm_matrix_instance_q15;
1461:.\Include/arm_math.h **** 
1462:.\Include/arm_math.h ****   /**
1463:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 matrix structure.
1464:.\Include/arm_math.h ****    */
1465:.\Include/arm_math.h ****   typedef struct
1466:.\Include/arm_math.h ****   {
1467:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1468:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1469:.\Include/arm_math.h ****     q31_t *pData;         /**< points to the data of the matrix. */
1470:.\Include/arm_math.h ****   } arm_matrix_instance_q31;
1471:.\Include/arm_math.h **** 
1472:.\Include/arm_math.h **** 
1473:.\Include/arm_math.h ****   /**
1474:.\Include/arm_math.h ****    * @brief Floating-point matrix addition.
1475:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1476:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1477:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1478:.\Include/arm_math.h ****    * @return     The function returns either
1479:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1480:.\Include/arm_math.h ****    */
1481:.\Include/arm_math.h ****   arm_status arm_mat_add_f32(
1482:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1483:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1484:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1485:.\Include/arm_math.h **** 
1486:.\Include/arm_math.h **** 
1487:.\Include/arm_math.h ****   /**
1488:.\Include/arm_math.h ****    * @brief Q15 matrix addition.
1489:.\Include/arm_math.h ****    * @param[in]   pSrcA  points to the first input matrix structure
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 31


1490:.\Include/arm_math.h ****    * @param[in]   pSrcB  points to the second input matrix structure
1491:.\Include/arm_math.h ****    * @param[out]  pDst   points to output matrix structure
1492:.\Include/arm_math.h ****    * @return     The function returns either
1493:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1494:.\Include/arm_math.h ****    */
1495:.\Include/arm_math.h ****   arm_status arm_mat_add_q15(
1496:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1497:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1498:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1499:.\Include/arm_math.h **** 
1500:.\Include/arm_math.h **** 
1501:.\Include/arm_math.h ****   /**
1502:.\Include/arm_math.h ****    * @brief Q31 matrix addition.
1503:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1504:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1505:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1506:.\Include/arm_math.h ****    * @return     The function returns either
1507:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1508:.\Include/arm_math.h ****    */
1509:.\Include/arm_math.h ****   arm_status arm_mat_add_q31(
1510:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1511:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1512:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1513:.\Include/arm_math.h **** 
1514:.\Include/arm_math.h **** 
1515:.\Include/arm_math.h ****   /**
1516:.\Include/arm_math.h ****    * @brief Floating-point, complex, matrix multiplication.
1517:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1518:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1519:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1520:.\Include/arm_math.h ****    * @return     The function returns either
1521:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1522:.\Include/arm_math.h ****    */
1523:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_f32(
1524:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1525:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1526:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1527:.\Include/arm_math.h **** 
1528:.\Include/arm_math.h **** 
1529:.\Include/arm_math.h ****   /**
1530:.\Include/arm_math.h ****    * @brief Q15, complex,  matrix multiplication.
1531:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1532:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1533:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1534:.\Include/arm_math.h ****    * @return     The function returns either
1535:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1536:.\Include/arm_math.h ****    */
1537:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q15(
1538:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1539:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1540:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1541:.\Include/arm_math.h ****   q15_t * pScratch);
1542:.\Include/arm_math.h **** 
1543:.\Include/arm_math.h **** 
1544:.\Include/arm_math.h ****   /**
1545:.\Include/arm_math.h ****    * @brief Q31, complex, matrix multiplication.
1546:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 32


1547:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1548:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1549:.\Include/arm_math.h ****    * @return     The function returns either
1550:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1551:.\Include/arm_math.h ****    */
1552:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q31(
1553:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1554:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1555:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1556:.\Include/arm_math.h **** 
1557:.\Include/arm_math.h **** 
1558:.\Include/arm_math.h ****   /**
1559:.\Include/arm_math.h ****    * @brief Floating-point matrix transpose.
1560:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1561:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1562:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1563:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1564:.\Include/arm_math.h ****    */
1565:.\Include/arm_math.h ****   arm_status arm_mat_trans_f32(
1566:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1567:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1568:.\Include/arm_math.h **** 
1569:.\Include/arm_math.h **** 
1570:.\Include/arm_math.h ****   /**
1571:.\Include/arm_math.h ****    * @brief Q15 matrix transpose.
1572:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1573:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1574:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1575:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1576:.\Include/arm_math.h ****    */
1577:.\Include/arm_math.h ****   arm_status arm_mat_trans_q15(
1578:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1579:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1580:.\Include/arm_math.h **** 
1581:.\Include/arm_math.h **** 
1582:.\Include/arm_math.h ****   /**
1583:.\Include/arm_math.h ****    * @brief Q31 matrix transpose.
1584:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1585:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1586:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1587:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1588:.\Include/arm_math.h ****    */
1589:.\Include/arm_math.h ****   arm_status arm_mat_trans_q31(
1590:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1591:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1592:.\Include/arm_math.h **** 
1593:.\Include/arm_math.h **** 
1594:.\Include/arm_math.h ****   /**
1595:.\Include/arm_math.h ****    * @brief Floating-point matrix multiplication
1596:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1597:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1598:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1599:.\Include/arm_math.h ****    * @return     The function returns either
1600:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1601:.\Include/arm_math.h ****    */
1602:.\Include/arm_math.h ****   arm_status arm_mat_mult_f32(
1603:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 33


1604:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1605:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1606:.\Include/arm_math.h **** 
1607:.\Include/arm_math.h **** 
1608:.\Include/arm_math.h ****   /**
1609:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication
1610:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1611:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1612:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1613:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1614:.\Include/arm_math.h ****    * @return     The function returns either
1615:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1616:.\Include/arm_math.h ****    */
1617:.\Include/arm_math.h ****   arm_status arm_mat_mult_q15(
1618:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1619:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1620:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1621:.\Include/arm_math.h ****   q15_t * pState);
1622:.\Include/arm_math.h **** 
1623:.\Include/arm_math.h **** 
1624:.\Include/arm_math.h ****   /**
1625:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1626:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1627:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1628:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1629:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1630:.\Include/arm_math.h ****    * @return     The function returns either
1631:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1632:.\Include/arm_math.h ****    */
1633:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q15(
1634:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1635:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1636:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1637:.\Include/arm_math.h ****   q15_t * pState);
1638:.\Include/arm_math.h **** 
1639:.\Include/arm_math.h **** 
1640:.\Include/arm_math.h ****   /**
1641:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication
1642:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1643:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1644:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1645:.\Include/arm_math.h ****    * @return     The function returns either
1646:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1647:.\Include/arm_math.h ****    */
1648:.\Include/arm_math.h ****   arm_status arm_mat_mult_q31(
1649:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1650:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1651:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1652:.\Include/arm_math.h **** 
1653:.\Include/arm_math.h **** 
1654:.\Include/arm_math.h ****   /**
1655:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1656:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1657:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1658:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1659:.\Include/arm_math.h ****    * @return     The function returns either
1660:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 34


1661:.\Include/arm_math.h ****    */
1662:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q31(
1663:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1664:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1665:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1666:.\Include/arm_math.h **** 
1667:.\Include/arm_math.h **** 
1668:.\Include/arm_math.h ****   /**
1669:.\Include/arm_math.h ****    * @brief Floating-point matrix subtraction
1670:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1671:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1672:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1673:.\Include/arm_math.h ****    * @return     The function returns either
1674:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1675:.\Include/arm_math.h ****    */
1676:.\Include/arm_math.h ****   arm_status arm_mat_sub_f32(
1677:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1678:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1679:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1680:.\Include/arm_math.h **** 
1681:.\Include/arm_math.h **** 
1682:.\Include/arm_math.h ****   /**
1683:.\Include/arm_math.h ****    * @brief Q15 matrix subtraction
1684:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1685:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1686:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1687:.\Include/arm_math.h ****    * @return     The function returns either
1688:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1689:.\Include/arm_math.h ****    */
1690:.\Include/arm_math.h ****   arm_status arm_mat_sub_q15(
1691:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1692:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1693:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1694:.\Include/arm_math.h **** 
1695:.\Include/arm_math.h **** 
1696:.\Include/arm_math.h ****   /**
1697:.\Include/arm_math.h ****    * @brief Q31 matrix subtraction
1698:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1699:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1700:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1701:.\Include/arm_math.h ****    * @return     The function returns either
1702:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1703:.\Include/arm_math.h ****    */
1704:.\Include/arm_math.h ****   arm_status arm_mat_sub_q31(
1705:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1706:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1707:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1708:.\Include/arm_math.h **** 
1709:.\Include/arm_math.h **** 
1710:.\Include/arm_math.h ****   /**
1711:.\Include/arm_math.h ****    * @brief Floating-point matrix scaling.
1712:.\Include/arm_math.h ****    * @param[in]  pSrc   points to the input matrix
1713:.\Include/arm_math.h ****    * @param[in]  scale  scale factor
1714:.\Include/arm_math.h ****    * @param[out] pDst   points to the output matrix
1715:.\Include/arm_math.h ****    * @return     The function returns either
1716:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1717:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 35


1718:.\Include/arm_math.h ****   arm_status arm_mat_scale_f32(
1719:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1720:.\Include/arm_math.h ****   float32_t scale,
1721:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1722:.\Include/arm_math.h **** 
1723:.\Include/arm_math.h **** 
1724:.\Include/arm_math.h ****   /**
1725:.\Include/arm_math.h ****    * @brief Q15 matrix scaling.
1726:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1727:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1728:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1729:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix
1730:.\Include/arm_math.h ****    * @return     The function returns either
1731:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1732:.\Include/arm_math.h ****    */
1733:.\Include/arm_math.h ****   arm_status arm_mat_scale_q15(
1734:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1735:.\Include/arm_math.h ****   q15_t scaleFract,
1736:.\Include/arm_math.h ****   int32_t shift,
1737:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1738:.\Include/arm_math.h **** 
1739:.\Include/arm_math.h **** 
1740:.\Include/arm_math.h ****   /**
1741:.\Include/arm_math.h ****    * @brief Q31 matrix scaling.
1742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1743:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1744:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1745:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix structure
1746:.\Include/arm_math.h ****    * @return     The function returns either
1747:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1748:.\Include/arm_math.h ****    */
1749:.\Include/arm_math.h ****   arm_status arm_mat_scale_q31(
1750:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1751:.\Include/arm_math.h ****   q31_t scaleFract,
1752:.\Include/arm_math.h ****   int32_t shift,
1753:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1754:.\Include/arm_math.h **** 
1755:.\Include/arm_math.h **** 
1756:.\Include/arm_math.h ****   /**
1757:.\Include/arm_math.h ****    * @brief  Q31 matrix initialization.
1758:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1759:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1760:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1761:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1762:.\Include/arm_math.h ****    */
1763:.\Include/arm_math.h ****   void arm_mat_init_q31(
1764:.\Include/arm_math.h ****   arm_matrix_instance_q31 * S,
1765:.\Include/arm_math.h ****   uint16_t nRows,
1766:.\Include/arm_math.h ****   uint16_t nColumns,
1767:.\Include/arm_math.h ****   q31_t * pData);
1768:.\Include/arm_math.h **** 
1769:.\Include/arm_math.h **** 
1770:.\Include/arm_math.h ****   /**
1771:.\Include/arm_math.h ****    * @brief  Q15 matrix initialization.
1772:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1773:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1774:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 36


1775:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1776:.\Include/arm_math.h ****    */
1777:.\Include/arm_math.h ****   void arm_mat_init_q15(
1778:.\Include/arm_math.h ****   arm_matrix_instance_q15 * S,
1779:.\Include/arm_math.h ****   uint16_t nRows,
1780:.\Include/arm_math.h ****   uint16_t nColumns,
1781:.\Include/arm_math.h ****   q15_t * pData);
1782:.\Include/arm_math.h **** 
1783:.\Include/arm_math.h **** 
1784:.\Include/arm_math.h ****   /**
1785:.\Include/arm_math.h ****    * @brief  Floating-point matrix initialization.
1786:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1787:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1788:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1789:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1790:.\Include/arm_math.h ****    */
1791:.\Include/arm_math.h ****   void arm_mat_init_f32(
1792:.\Include/arm_math.h ****   arm_matrix_instance_f32 * S,
1793:.\Include/arm_math.h ****   uint16_t nRows,
1794:.\Include/arm_math.h ****   uint16_t nColumns,
1795:.\Include/arm_math.h ****   float32_t * pData);
1796:.\Include/arm_math.h **** 
1797:.\Include/arm_math.h **** 
1798:.\Include/arm_math.h **** 
1799:.\Include/arm_math.h ****   /**
1800:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 PID Control.
1801:.\Include/arm_math.h ****    */
1802:.\Include/arm_math.h ****   typedef struct
1803:.\Include/arm_math.h ****   {
1804:.\Include/arm_math.h ****     q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
1805:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
1806:.\Include/arm_math.h ****     q15_t A1;
1807:.\Include/arm_math.h ****     q15_t A2;
1808:.\Include/arm_math.h **** #else
1809:.\Include/arm_math.h ****     q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
1810:.\Include/arm_math.h **** #endif
1811:.\Include/arm_math.h ****     q15_t state[3];     /**< The state array of length 3. */
1812:.\Include/arm_math.h ****     q15_t Kp;           /**< The proportional gain. */
1813:.\Include/arm_math.h ****     q15_t Ki;           /**< The integral gain. */
1814:.\Include/arm_math.h ****     q15_t Kd;           /**< The derivative gain. */
1815:.\Include/arm_math.h ****   } arm_pid_instance_q15;
1816:.\Include/arm_math.h **** 
1817:.\Include/arm_math.h ****   /**
1818:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 PID Control.
1819:.\Include/arm_math.h ****    */
1820:.\Include/arm_math.h ****   typedef struct
1821:.\Include/arm_math.h ****   {
1822:.\Include/arm_math.h ****     q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
1823:.\Include/arm_math.h ****     q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
1824:.\Include/arm_math.h ****     q31_t A2;            /**< The derived gain, A2 = Kd . */
1825:.\Include/arm_math.h ****     q31_t state[3];      /**< The state array of length 3. */
1826:.\Include/arm_math.h ****     q31_t Kp;            /**< The proportional gain. */
1827:.\Include/arm_math.h ****     q31_t Ki;            /**< The integral gain. */
1828:.\Include/arm_math.h ****     q31_t Kd;            /**< The derivative gain. */
1829:.\Include/arm_math.h ****   } arm_pid_instance_q31;
1830:.\Include/arm_math.h **** 
1831:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 37


1832:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point PID Control.
1833:.\Include/arm_math.h ****    */
1834:.\Include/arm_math.h ****   typedef struct
1835:.\Include/arm_math.h ****   {
1836:.\Include/arm_math.h ****     float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
1837:.\Include/arm_math.h ****     float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
1838:.\Include/arm_math.h ****     float32_t A2;          /**< The derived gain, A2 = Kd . */
1839:.\Include/arm_math.h ****     float32_t state[3];    /**< The state array of length 3. */
1840:.\Include/arm_math.h ****     float32_t Kp;          /**< The proportional gain. */
1841:.\Include/arm_math.h ****     float32_t Ki;          /**< The integral gain. */
1842:.\Include/arm_math.h ****     float32_t Kd;          /**< The derivative gain. */
1843:.\Include/arm_math.h ****   } arm_pid_instance_f32;
1844:.\Include/arm_math.h **** 
1845:.\Include/arm_math.h **** 
1846:.\Include/arm_math.h **** 
1847:.\Include/arm_math.h ****   /**
1848:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point PID Control.
1849:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the PID structure.
1850:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1851:.\Include/arm_math.h ****    */
1852:.\Include/arm_math.h ****   void arm_pid_init_f32(
1853:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
1854:.\Include/arm_math.h ****   int32_t resetStateFlag);
1855:.\Include/arm_math.h **** 
1856:.\Include/arm_math.h **** 
1857:.\Include/arm_math.h ****   /**
1858:.\Include/arm_math.h ****    * @brief  Reset function for the floating-point PID Control.
1859:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point PID Control structure
1860:.\Include/arm_math.h ****    */
1861:.\Include/arm_math.h ****   void arm_pid_reset_f32(
1862:.\Include/arm_math.h ****   arm_pid_instance_f32 * S);
1863:.\Include/arm_math.h **** 
1864:.\Include/arm_math.h **** 
1865:.\Include/arm_math.h ****   /**
1866:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 PID Control.
1867:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1868:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1869:.\Include/arm_math.h ****    */
1870:.\Include/arm_math.h ****   void arm_pid_init_q31(
1871:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
1872:.\Include/arm_math.h ****   int32_t resetStateFlag);
1873:.\Include/arm_math.h **** 
1874:.\Include/arm_math.h **** 
1875:.\Include/arm_math.h ****   /**
1876:.\Include/arm_math.h ****    * @brief  Reset function for the Q31 PID Control.
1877:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q31 PID Control structure
1878:.\Include/arm_math.h ****    */
1879:.\Include/arm_math.h **** 
1880:.\Include/arm_math.h ****   void arm_pid_reset_q31(
1881:.\Include/arm_math.h ****   arm_pid_instance_q31 * S);
1882:.\Include/arm_math.h **** 
1883:.\Include/arm_math.h **** 
1884:.\Include/arm_math.h ****   /**
1885:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 PID Control.
1886:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1887:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1888:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 38


1889:.\Include/arm_math.h ****   void arm_pid_init_q15(
1890:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
1891:.\Include/arm_math.h ****   int32_t resetStateFlag);
1892:.\Include/arm_math.h **** 
1893:.\Include/arm_math.h **** 
1894:.\Include/arm_math.h ****   /**
1895:.\Include/arm_math.h ****    * @brief  Reset function for the Q15 PID Control.
1896:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the q15 PID Control structure
1897:.\Include/arm_math.h ****    */
1898:.\Include/arm_math.h ****   void arm_pid_reset_q15(
1899:.\Include/arm_math.h ****   arm_pid_instance_q15 * S);
1900:.\Include/arm_math.h **** 
1901:.\Include/arm_math.h **** 
1902:.\Include/arm_math.h ****   /**
1903:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Linear Interpolate function.
1904:.\Include/arm_math.h ****    */
1905:.\Include/arm_math.h ****   typedef struct
1906:.\Include/arm_math.h ****   {
1907:.\Include/arm_math.h ****     uint32_t nValues;           /**< nValues */
1908:.\Include/arm_math.h ****     float32_t x1;               /**< x1 */
1909:.\Include/arm_math.h ****     float32_t xSpacing;         /**< xSpacing */
1910:.\Include/arm_math.h ****     float32_t *pYData;          /**< pointer to the table of Y values */
1911:.\Include/arm_math.h ****   } arm_linear_interp_instance_f32;
1912:.\Include/arm_math.h **** 
1913:.\Include/arm_math.h ****   /**
1914:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point bilinear interpolation function.
1915:.\Include/arm_math.h ****    */
1916:.\Include/arm_math.h ****   typedef struct
1917:.\Include/arm_math.h ****   {
1918:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1919:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1920:.\Include/arm_math.h ****     float32_t *pData;   /**< points to the data table. */
1921:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_f32;
1922:.\Include/arm_math.h **** 
1923:.\Include/arm_math.h ****    /**
1924:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 bilinear interpolation function.
1925:.\Include/arm_math.h ****    */
1926:.\Include/arm_math.h ****   typedef struct
1927:.\Include/arm_math.h ****   {
1928:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1929:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1930:.\Include/arm_math.h ****     q31_t *pData;       /**< points to the data table. */
1931:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q31;
1932:.\Include/arm_math.h **** 
1933:.\Include/arm_math.h ****    /**
1934:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1935:.\Include/arm_math.h ****    */
1936:.\Include/arm_math.h ****   typedef struct
1937:.\Include/arm_math.h ****   {
1938:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1939:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1940:.\Include/arm_math.h ****     q15_t *pData;       /**< points to the data table. */
1941:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q15;
1942:.\Include/arm_math.h **** 
1943:.\Include/arm_math.h ****    /**
1944:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1945:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 39


1946:.\Include/arm_math.h ****   typedef struct
1947:.\Include/arm_math.h ****   {
1948:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1949:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1950:.\Include/arm_math.h ****     q7_t *pData;        /**< points to the data table. */
1951:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q7;
1952:.\Include/arm_math.h **** 
1953:.\Include/arm_math.h **** 
1954:.\Include/arm_math.h ****   /**
1955:.\Include/arm_math.h ****    * @brief Q7 vector multiplication.
1956:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1957:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1958:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1959:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1960:.\Include/arm_math.h ****    */
1961:.\Include/arm_math.h ****   void arm_mult_q7(
1962:.\Include/arm_math.h ****   q7_t * pSrcA,
1963:.\Include/arm_math.h ****   q7_t * pSrcB,
1964:.\Include/arm_math.h ****   q7_t * pDst,
1965:.\Include/arm_math.h ****   uint32_t blockSize);
1966:.\Include/arm_math.h **** 
1967:.\Include/arm_math.h **** 
1968:.\Include/arm_math.h ****   /**
1969:.\Include/arm_math.h ****    * @brief Q15 vector multiplication.
1970:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1971:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1972:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1973:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1974:.\Include/arm_math.h ****    */
1975:.\Include/arm_math.h ****   void arm_mult_q15(
1976:.\Include/arm_math.h ****   q15_t * pSrcA,
1977:.\Include/arm_math.h ****   q15_t * pSrcB,
1978:.\Include/arm_math.h ****   q15_t * pDst,
1979:.\Include/arm_math.h ****   uint32_t blockSize);
1980:.\Include/arm_math.h **** 
1981:.\Include/arm_math.h **** 
1982:.\Include/arm_math.h ****   /**
1983:.\Include/arm_math.h ****    * @brief Q31 vector multiplication.
1984:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1985:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1986:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1987:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1988:.\Include/arm_math.h ****    */
1989:.\Include/arm_math.h ****   void arm_mult_q31(
1990:.\Include/arm_math.h ****   q31_t * pSrcA,
1991:.\Include/arm_math.h ****   q31_t * pSrcB,
1992:.\Include/arm_math.h ****   q31_t * pDst,
1993:.\Include/arm_math.h ****   uint32_t blockSize);
1994:.\Include/arm_math.h **** 
1995:.\Include/arm_math.h **** 
1996:.\Include/arm_math.h ****   /**
1997:.\Include/arm_math.h ****    * @brief Floating-point vector multiplication.
1998:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1999:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2000:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2001:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2002:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 40


2003:.\Include/arm_math.h ****   void arm_mult_f32(
2004:.\Include/arm_math.h ****   float32_t * pSrcA,
2005:.\Include/arm_math.h ****   float32_t * pSrcB,
2006:.\Include/arm_math.h ****   float32_t * pDst,
2007:.\Include/arm_math.h ****   uint32_t blockSize);
2008:.\Include/arm_math.h **** 
2009:.\Include/arm_math.h **** 
2010:.\Include/arm_math.h ****   /**
2011:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2012:.\Include/arm_math.h ****    */
2013:.\Include/arm_math.h ****   typedef struct
2014:.\Include/arm_math.h ****   {
2015:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2016:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2017:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2018:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
2019:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2020:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2021:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2022:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q15;
2023:.\Include/arm_math.h **** 
2024:.\Include/arm_math.h **** /* Deprecated */
2025:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q15(
2026:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q15 * S,
2027:.\Include/arm_math.h ****   uint16_t fftLen,
2028:.\Include/arm_math.h ****   uint8_t ifftFlag,
2029:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2030:.\Include/arm_math.h **** 
2031:.\Include/arm_math.h **** /* Deprecated */
2032:.\Include/arm_math.h ****   void arm_cfft_radix2_q15(
2033:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q15 * S,
2034:.\Include/arm_math.h ****   q15_t * pSrc);
2035:.\Include/arm_math.h **** 
2036:.\Include/arm_math.h **** 
2037:.\Include/arm_math.h ****   /**
2038:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2039:.\Include/arm_math.h ****    */
2040:.\Include/arm_math.h ****   typedef struct
2041:.\Include/arm_math.h ****   {
2042:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2043:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2044:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2045:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
2046:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2047:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2048:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2049:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q15;
2050:.\Include/arm_math.h **** 
2051:.\Include/arm_math.h **** /* Deprecated */
2052:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q15(
2053:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S,
2054:.\Include/arm_math.h ****   uint16_t fftLen,
2055:.\Include/arm_math.h ****   uint8_t ifftFlag,
2056:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2057:.\Include/arm_math.h **** 
2058:.\Include/arm_math.h **** /* Deprecated */
2059:.\Include/arm_math.h ****   void arm_cfft_radix4_q15(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 41


2060:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q15 * S,
2061:.\Include/arm_math.h ****   q15_t * pSrc);
2062:.\Include/arm_math.h **** 
2063:.\Include/arm_math.h ****   /**
2064:.\Include/arm_math.h ****    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
2065:.\Include/arm_math.h ****    */
2066:.\Include/arm_math.h ****   typedef struct
2067:.\Include/arm_math.h ****   {
2068:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2069:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2070:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2071:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
2072:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2073:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2074:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2075:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q31;
2076:.\Include/arm_math.h **** 
2077:.\Include/arm_math.h **** /* Deprecated */
2078:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q31(
2079:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q31 * S,
2080:.\Include/arm_math.h ****   uint16_t fftLen,
2081:.\Include/arm_math.h ****   uint8_t ifftFlag,
2082:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2083:.\Include/arm_math.h **** 
2084:.\Include/arm_math.h **** /* Deprecated */
2085:.\Include/arm_math.h ****   void arm_cfft_radix2_q31(
2086:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q31 * S,
2087:.\Include/arm_math.h ****   q31_t * pSrc);
2088:.\Include/arm_math.h **** 
2089:.\Include/arm_math.h ****   /**
2090:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 CFFT/CIFFT function.
2091:.\Include/arm_math.h ****    */
2092:.\Include/arm_math.h ****   typedef struct
2093:.\Include/arm_math.h ****   {
2094:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2095:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2096:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2097:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
2098:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2099:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2100:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2101:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q31;
2102:.\Include/arm_math.h **** 
2103:.\Include/arm_math.h **** /* Deprecated */
2104:.\Include/arm_math.h ****   void arm_cfft_radix4_q31(
2105:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q31 * S,
2106:.\Include/arm_math.h ****   q31_t * pSrc);
2107:.\Include/arm_math.h **** 
2108:.\Include/arm_math.h **** /* Deprecated */
2109:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q31(
2110:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S,
2111:.\Include/arm_math.h ****   uint16_t fftLen,
2112:.\Include/arm_math.h ****   uint8_t ifftFlag,
2113:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2114:.\Include/arm_math.h **** 
2115:.\Include/arm_math.h ****   /**
2116:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 42


2117:.\Include/arm_math.h ****    */
2118:.\Include/arm_math.h ****   typedef struct
2119:.\Include/arm_math.h ****   {
2120:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2121:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2122:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2123:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2124:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2125:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2126:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2127:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2128:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_f32;
2129:.\Include/arm_math.h **** 
2130:.\Include/arm_math.h **** /* Deprecated */
2131:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_f32(
2132:.\Include/arm_math.h ****   arm_cfft_radix2_instance_f32 * S,
2133:.\Include/arm_math.h ****   uint16_t fftLen,
2134:.\Include/arm_math.h ****   uint8_t ifftFlag,
2135:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2136:.\Include/arm_math.h **** 
2137:.\Include/arm_math.h **** /* Deprecated */
2138:.\Include/arm_math.h ****   void arm_cfft_radix2_f32(
2139:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_f32 * S,
2140:.\Include/arm_math.h ****   float32_t * pSrc);
2141:.\Include/arm_math.h **** 
2142:.\Include/arm_math.h ****   /**
2143:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2144:.\Include/arm_math.h ****    */
2145:.\Include/arm_math.h ****   typedef struct
2146:.\Include/arm_math.h ****   {
2147:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2148:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2149:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2150:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2151:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2152:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2153:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2154:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2155:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_f32;
2156:.\Include/arm_math.h **** 
2157:.\Include/arm_math.h **** /* Deprecated */
2158:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_f32(
2159:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S,
2160:.\Include/arm_math.h ****   uint16_t fftLen,
2161:.\Include/arm_math.h ****   uint8_t ifftFlag,
2162:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2163:.\Include/arm_math.h **** 
2164:.\Include/arm_math.h **** /* Deprecated */
2165:.\Include/arm_math.h ****   void arm_cfft_radix4_f32(
2166:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_f32 * S,
2167:.\Include/arm_math.h ****   float32_t * pSrc);
2168:.\Include/arm_math.h **** 
2169:.\Include/arm_math.h ****   /**
2170:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2171:.\Include/arm_math.h ****    */
2172:.\Include/arm_math.h ****   typedef struct
2173:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 43


2174:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2175:.\Include/arm_math.h ****     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
2176:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2177:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2178:.\Include/arm_math.h ****   } arm_cfft_instance_q15;
2179:.\Include/arm_math.h **** 
2180:.\Include/arm_math.h **** void arm_cfft_q15(
2181:.\Include/arm_math.h ****     const arm_cfft_instance_q15 * S,
2182:.\Include/arm_math.h ****     q15_t * p1,
2183:.\Include/arm_math.h ****     uint8_t ifftFlag,
2184:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2185:.\Include/arm_math.h **** 
2186:.\Include/arm_math.h ****   /**
2187:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2188:.\Include/arm_math.h ****    */
2189:.\Include/arm_math.h ****   typedef struct
2190:.\Include/arm_math.h ****   {
2191:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2192:.\Include/arm_math.h ****     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
2193:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2194:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2195:.\Include/arm_math.h ****   } arm_cfft_instance_q31;
2196:.\Include/arm_math.h **** 
2197:.\Include/arm_math.h **** void arm_cfft_q31(
2198:.\Include/arm_math.h ****     const arm_cfft_instance_q31 * S,
2199:.\Include/arm_math.h ****     q31_t * p1,
2200:.\Include/arm_math.h ****     uint8_t ifftFlag,
2201:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2202:.\Include/arm_math.h **** 
2203:.\Include/arm_math.h ****   /**
2204:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2205:.\Include/arm_math.h ****    */
2206:.\Include/arm_math.h ****   typedef struct
2207:.\Include/arm_math.h ****   {
2208:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2209:.\Include/arm_math.h ****     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
2210:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2211:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2212:.\Include/arm_math.h ****   } arm_cfft_instance_f32;
2213:.\Include/arm_math.h **** 
2214:.\Include/arm_math.h ****   void arm_cfft_f32(
2215:.\Include/arm_math.h ****   const arm_cfft_instance_f32 * S,
2216:.\Include/arm_math.h ****   float32_t * p1,
2217:.\Include/arm_math.h ****   uint8_t ifftFlag,
2218:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2219:.\Include/arm_math.h **** 
2220:.\Include/arm_math.h ****   /**
2221:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 RFFT/RIFFT function.
2222:.\Include/arm_math.h ****    */
2223:.\Include/arm_math.h ****   typedef struct
2224:.\Include/arm_math.h ****   {
2225:.\Include/arm_math.h ****     uint32_t fftLenReal;                      /**< length of the real FFT. */
2226:.\Include/arm_math.h ****     uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inver
2227:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disable
2228:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports diffe
2229:.\Include/arm_math.h ****     q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
2230:.\Include/arm_math.h ****     q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 44


2231:.\Include/arm_math.h ****     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
2232:.\Include/arm_math.h ****   } arm_rfft_instance_q15;
2233:.\Include/arm_math.h **** 
2234:.\Include/arm_math.h ****   arm_status arm_rfft_init_q15(
2235:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S,
2236:.\Include/arm_math.h ****   uint32_t fftLenReal,
2237:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2238:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2239:.\Include/arm_math.h **** 
2240:.\Include/arm_math.h ****   void arm_rfft_q15(
2241:.\Include/arm_math.h ****   const arm_rfft_instance_q15 * S,
2242:.\Include/arm_math.h ****   q15_t * pSrc,
2243:.\Include/arm_math.h ****   q15_t * pDst);
2244:.\Include/arm_math.h **** 
2245:.\Include/arm_math.h ****   /**
2246:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 RFFT/RIFFT function.
2247:.\Include/arm_math.h ****    */
2248:.\Include/arm_math.h ****   typedef struct
2249:.\Include/arm_math.h ****   {
2250:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2251:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2252:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2253:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports dif
2254:.\Include/arm_math.h ****     q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
2255:.\Include/arm_math.h ****     q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
2256:.\Include/arm_math.h ****     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
2257:.\Include/arm_math.h ****   } arm_rfft_instance_q31;
2258:.\Include/arm_math.h **** 
2259:.\Include/arm_math.h ****   arm_status arm_rfft_init_q31(
2260:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S,
2261:.\Include/arm_math.h ****   uint32_t fftLenReal,
2262:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2263:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2264:.\Include/arm_math.h **** 
2265:.\Include/arm_math.h ****   void arm_rfft_q31(
2266:.\Include/arm_math.h ****   const arm_rfft_instance_q31 * S,
2267:.\Include/arm_math.h ****   q31_t * pSrc,
2268:.\Include/arm_math.h ****   q31_t * pDst);
2269:.\Include/arm_math.h **** 
2270:.\Include/arm_math.h ****   /**
2271:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2272:.\Include/arm_math.h ****    */
2273:.\Include/arm_math.h ****   typedef struct
2274:.\Include/arm_math.h ****   {
2275:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2276:.\Include/arm_math.h ****     uint16_t fftLenBy2;                         /**< length of the complex FFT. */
2277:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2278:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2279:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports
2280:.\Include/arm_math.h ****     float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
2281:.\Include/arm_math.h ****     float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
2282:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
2283:.\Include/arm_math.h ****   } arm_rfft_instance_f32;
2284:.\Include/arm_math.h **** 
2285:.\Include/arm_math.h ****   arm_status arm_rfft_init_f32(
2286:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S,
2287:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 45


2288:.\Include/arm_math.h ****   uint32_t fftLenReal,
2289:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2290:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2291:.\Include/arm_math.h **** 
2292:.\Include/arm_math.h ****   void arm_rfft_f32(
2293:.\Include/arm_math.h ****   const arm_rfft_instance_f32 * S,
2294:.\Include/arm_math.h ****   float32_t * pSrc,
2295:.\Include/arm_math.h ****   float32_t * pDst);
2296:.\Include/arm_math.h **** 
2297:.\Include/arm_math.h ****   /**
2298:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2299:.\Include/arm_math.h ****    */
2300:.\Include/arm_math.h **** typedef struct
2301:.\Include/arm_math.h ****   {
2302:.\Include/arm_math.h ****     arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
2303:.\Include/arm_math.h ****     uint16_t fftLenRFFT;             /**< length of the real sequence */
2304:.\Include/arm_math.h ****     float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
2305:.\Include/arm_math.h ****   } arm_rfft_fast_instance_f32 ;
2306:.\Include/arm_math.h **** 
2307:.\Include/arm_math.h **** arm_status arm_rfft_fast_init_f32 (
2308:.\Include/arm_math.h ****    arm_rfft_fast_instance_f32 * S,
2309:.\Include/arm_math.h ****    uint16_t fftLen);
2310:.\Include/arm_math.h **** 
2311:.\Include/arm_math.h **** void arm_rfft_fast_f32(
2312:.\Include/arm_math.h ****   arm_rfft_fast_instance_f32 * S,
2313:.\Include/arm_math.h ****   float32_t * p, float32_t * pOut,
2314:.\Include/arm_math.h ****   uint8_t ifftFlag);
2315:.\Include/arm_math.h **** 
2316:.\Include/arm_math.h ****   /**
2317:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
2318:.\Include/arm_math.h ****    */
2319:.\Include/arm_math.h ****   typedef struct
2320:.\Include/arm_math.h ****   {
2321:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2322:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2323:.\Include/arm_math.h ****     float32_t normalize;                 /**< normalizing factor. */
2324:.\Include/arm_math.h ****     float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
2325:.\Include/arm_math.h ****     float32_t *pCosFactor;               /**< points to the cosFactor table. */
2326:.\Include/arm_math.h ****     arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
2327:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
2328:.\Include/arm_math.h ****   } arm_dct4_instance_f32;
2329:.\Include/arm_math.h **** 
2330:.\Include/arm_math.h **** 
2331:.\Include/arm_math.h ****   /**
2332:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point DCT4/IDCT4.
2333:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
2334:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
2335:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
2336:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2337:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2338:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2339:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2340:.\Include/arm_math.h ****    */
2341:.\Include/arm_math.h ****   arm_status arm_dct4_init_f32(
2342:.\Include/arm_math.h ****   arm_dct4_instance_f32 * S,
2343:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S_RFFT,
2344:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 46


2345:.\Include/arm_math.h ****   uint16_t N,
2346:.\Include/arm_math.h ****   uint16_t Nby2,
2347:.\Include/arm_math.h ****   float32_t normalize);
2348:.\Include/arm_math.h **** 
2349:.\Include/arm_math.h **** 
2350:.\Include/arm_math.h ****   /**
2351:.\Include/arm_math.h ****    * @brief Processing function for the floating-point DCT4/IDCT4.
2352:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure
2353:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2354:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2355:.\Include/arm_math.h ****    */
2356:.\Include/arm_math.h ****   void arm_dct4_f32(
2357:.\Include/arm_math.h ****   const arm_dct4_instance_f32 * S,
2358:.\Include/arm_math.h ****   float32_t * pState,
2359:.\Include/arm_math.h ****   float32_t * pInlineBuffer);
2360:.\Include/arm_math.h **** 
2361:.\Include/arm_math.h **** 
2362:.\Include/arm_math.h ****   /**
2363:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 DCT4/IDCT4 function.
2364:.\Include/arm_math.h ****    */
2365:.\Include/arm_math.h ****   typedef struct
2366:.\Include/arm_math.h ****   {
2367:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2368:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2369:.\Include/arm_math.h ****     q31_t normalize;                     /**< normalizing factor. */
2370:.\Include/arm_math.h ****     q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
2371:.\Include/arm_math.h ****     q31_t *pCosFactor;                   /**< points to the cosFactor table. */
2372:.\Include/arm_math.h ****     arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
2373:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
2374:.\Include/arm_math.h ****   } arm_dct4_instance_q31;
2375:.\Include/arm_math.h **** 
2376:.\Include/arm_math.h **** 
2377:.\Include/arm_math.h ****   /**
2378:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 DCT4/IDCT4.
2379:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
2380:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
2381:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
2382:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2383:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2384:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2385:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2386:.\Include/arm_math.h ****    */
2387:.\Include/arm_math.h ****   arm_status arm_dct4_init_q31(
2388:.\Include/arm_math.h ****   arm_dct4_instance_q31 * S,
2389:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S_RFFT,
2390:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S_CFFT,
2391:.\Include/arm_math.h ****   uint16_t N,
2392:.\Include/arm_math.h ****   uint16_t Nby2,
2393:.\Include/arm_math.h ****   q31_t normalize);
2394:.\Include/arm_math.h **** 
2395:.\Include/arm_math.h **** 
2396:.\Include/arm_math.h ****   /**
2397:.\Include/arm_math.h ****    * @brief Processing function for the Q31 DCT4/IDCT4.
2398:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q31 DCT4 structure.
2399:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2400:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2401:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 47


2402:.\Include/arm_math.h ****   void arm_dct4_q31(
2403:.\Include/arm_math.h ****   const arm_dct4_instance_q31 * S,
2404:.\Include/arm_math.h ****   q31_t * pState,
2405:.\Include/arm_math.h ****   q31_t * pInlineBuffer);
2406:.\Include/arm_math.h **** 
2407:.\Include/arm_math.h **** 
2408:.\Include/arm_math.h ****   /**
2409:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 DCT4/IDCT4 function.
2410:.\Include/arm_math.h ****    */
2411:.\Include/arm_math.h ****   typedef struct
2412:.\Include/arm_math.h ****   {
2413:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2414:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2415:.\Include/arm_math.h ****     q15_t normalize;                     /**< normalizing factor. */
2416:.\Include/arm_math.h ****     q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
2417:.\Include/arm_math.h ****     q15_t *pCosFactor;                   /**< points to the cosFactor table. */
2418:.\Include/arm_math.h ****     arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
2419:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
2420:.\Include/arm_math.h ****   } arm_dct4_instance_q15;
2421:.\Include/arm_math.h **** 
2422:.\Include/arm_math.h **** 
2423:.\Include/arm_math.h ****   /**
2424:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 DCT4/IDCT4.
2425:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
2426:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
2427:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
2428:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2429:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2430:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2431:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2432:.\Include/arm_math.h ****    */
2433:.\Include/arm_math.h ****   arm_status arm_dct4_init_q15(
2434:.\Include/arm_math.h ****   arm_dct4_instance_q15 * S,
2435:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S_RFFT,
2436:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S_CFFT,
2437:.\Include/arm_math.h ****   uint16_t N,
2438:.\Include/arm_math.h ****   uint16_t Nby2,
2439:.\Include/arm_math.h ****   q15_t normalize);
2440:.\Include/arm_math.h **** 
2441:.\Include/arm_math.h **** 
2442:.\Include/arm_math.h ****   /**
2443:.\Include/arm_math.h ****    * @brief Processing function for the Q15 DCT4/IDCT4.
2444:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q15 DCT4 structure.
2445:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2446:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2447:.\Include/arm_math.h ****    */
2448:.\Include/arm_math.h ****   void arm_dct4_q15(
2449:.\Include/arm_math.h ****   const arm_dct4_instance_q15 * S,
2450:.\Include/arm_math.h ****   q15_t * pState,
2451:.\Include/arm_math.h ****   q15_t * pInlineBuffer);
2452:.\Include/arm_math.h **** 
2453:.\Include/arm_math.h **** 
2454:.\Include/arm_math.h ****   /**
2455:.\Include/arm_math.h ****    * @brief Floating-point vector addition.
2456:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2457:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2458:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 48


2459:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2460:.\Include/arm_math.h ****    */
2461:.\Include/arm_math.h ****   void arm_add_f32(
2462:.\Include/arm_math.h ****   float32_t * pSrcA,
2463:.\Include/arm_math.h ****   float32_t * pSrcB,
2464:.\Include/arm_math.h ****   float32_t * pDst,
2465:.\Include/arm_math.h ****   uint32_t blockSize);
2466:.\Include/arm_math.h **** 
2467:.\Include/arm_math.h **** 
2468:.\Include/arm_math.h ****   /**
2469:.\Include/arm_math.h ****    * @brief Q7 vector addition.
2470:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2471:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2472:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2473:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2474:.\Include/arm_math.h ****    */
2475:.\Include/arm_math.h ****   void arm_add_q7(
2476:.\Include/arm_math.h ****   q7_t * pSrcA,
2477:.\Include/arm_math.h ****   q7_t * pSrcB,
2478:.\Include/arm_math.h ****   q7_t * pDst,
2479:.\Include/arm_math.h ****   uint32_t blockSize);
2480:.\Include/arm_math.h **** 
2481:.\Include/arm_math.h **** 
2482:.\Include/arm_math.h ****   /**
2483:.\Include/arm_math.h ****    * @brief Q15 vector addition.
2484:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2485:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2486:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2487:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2488:.\Include/arm_math.h ****    */
2489:.\Include/arm_math.h ****   void arm_add_q15(
2490:.\Include/arm_math.h ****   q15_t * pSrcA,
2491:.\Include/arm_math.h ****   q15_t * pSrcB,
2492:.\Include/arm_math.h ****   q15_t * pDst,
2493:.\Include/arm_math.h ****   uint32_t blockSize);
2494:.\Include/arm_math.h **** 
2495:.\Include/arm_math.h **** 
2496:.\Include/arm_math.h ****   /**
2497:.\Include/arm_math.h ****    * @brief Q31 vector addition.
2498:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2499:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2500:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2501:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2502:.\Include/arm_math.h ****    */
2503:.\Include/arm_math.h ****   void arm_add_q31(
2504:.\Include/arm_math.h ****   q31_t * pSrcA,
2505:.\Include/arm_math.h ****   q31_t * pSrcB,
2506:.\Include/arm_math.h ****   q31_t * pDst,
2507:.\Include/arm_math.h ****   uint32_t blockSize);
2508:.\Include/arm_math.h **** 
2509:.\Include/arm_math.h **** 
2510:.\Include/arm_math.h ****   /**
2511:.\Include/arm_math.h ****    * @brief Floating-point vector subtraction.
2512:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2513:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2514:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2515:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 49


2516:.\Include/arm_math.h ****    */
2517:.\Include/arm_math.h ****   void arm_sub_f32(
2518:.\Include/arm_math.h ****   float32_t * pSrcA,
2519:.\Include/arm_math.h ****   float32_t * pSrcB,
2520:.\Include/arm_math.h ****   float32_t * pDst,
2521:.\Include/arm_math.h ****   uint32_t blockSize);
2522:.\Include/arm_math.h **** 
2523:.\Include/arm_math.h **** 
2524:.\Include/arm_math.h ****   /**
2525:.\Include/arm_math.h ****    * @brief Q7 vector subtraction.
2526:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2527:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2528:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2529:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2530:.\Include/arm_math.h ****    */
2531:.\Include/arm_math.h ****   void arm_sub_q7(
2532:.\Include/arm_math.h ****   q7_t * pSrcA,
2533:.\Include/arm_math.h ****   q7_t * pSrcB,
2534:.\Include/arm_math.h ****   q7_t * pDst,
2535:.\Include/arm_math.h ****   uint32_t blockSize);
2536:.\Include/arm_math.h **** 
2537:.\Include/arm_math.h **** 
2538:.\Include/arm_math.h ****   /**
2539:.\Include/arm_math.h ****    * @brief Q15 vector subtraction.
2540:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2541:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2542:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2543:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2544:.\Include/arm_math.h ****    */
2545:.\Include/arm_math.h ****   void arm_sub_q15(
2546:.\Include/arm_math.h ****   q15_t * pSrcA,
2547:.\Include/arm_math.h ****   q15_t * pSrcB,
2548:.\Include/arm_math.h ****   q15_t * pDst,
2549:.\Include/arm_math.h ****   uint32_t blockSize);
2550:.\Include/arm_math.h **** 
2551:.\Include/arm_math.h **** 
2552:.\Include/arm_math.h ****   /**
2553:.\Include/arm_math.h ****    * @brief Q31 vector subtraction.
2554:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2555:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2556:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2557:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2558:.\Include/arm_math.h ****    */
2559:.\Include/arm_math.h ****   void arm_sub_q31(
2560:.\Include/arm_math.h ****   q31_t * pSrcA,
2561:.\Include/arm_math.h ****   q31_t * pSrcB,
2562:.\Include/arm_math.h ****   q31_t * pDst,
2563:.\Include/arm_math.h ****   uint32_t blockSize);
2564:.\Include/arm_math.h **** 
2565:.\Include/arm_math.h **** 
2566:.\Include/arm_math.h ****   /**
2567:.\Include/arm_math.h ****    * @brief Multiplies a floating-point vector by a scalar.
2568:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2569:.\Include/arm_math.h ****    * @param[in]  scale      scale factor to be applied
2570:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2571:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2572:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 50


2573:.\Include/arm_math.h ****   void arm_scale_f32(
2574:.\Include/arm_math.h ****   float32_t * pSrc,
2575:.\Include/arm_math.h ****   float32_t scale,
2576:.\Include/arm_math.h ****   float32_t * pDst,
2577:.\Include/arm_math.h ****   uint32_t blockSize);
2578:.\Include/arm_math.h **** 
2579:.\Include/arm_math.h **** 
2580:.\Include/arm_math.h ****   /**
2581:.\Include/arm_math.h ****    * @brief Multiplies a Q7 vector by a scalar.
2582:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2583:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2584:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2585:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2586:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2587:.\Include/arm_math.h ****    */
2588:.\Include/arm_math.h ****   void arm_scale_q7(
2589:.\Include/arm_math.h ****   q7_t * pSrc,
2590:.\Include/arm_math.h ****   q7_t scaleFract,
2591:.\Include/arm_math.h ****   int8_t shift,
2592:.\Include/arm_math.h ****   q7_t * pDst,
2593:.\Include/arm_math.h ****   uint32_t blockSize);
2594:.\Include/arm_math.h **** 
2595:.\Include/arm_math.h **** 
2596:.\Include/arm_math.h ****   /**
2597:.\Include/arm_math.h ****    * @brief Multiplies a Q15 vector by a scalar.
2598:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2599:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2600:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2601:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2602:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2603:.\Include/arm_math.h ****    */
2604:.\Include/arm_math.h ****   void arm_scale_q15(
2605:.\Include/arm_math.h ****   q15_t * pSrc,
2606:.\Include/arm_math.h ****   q15_t scaleFract,
2607:.\Include/arm_math.h ****   int8_t shift,
2608:.\Include/arm_math.h ****   q15_t * pDst,
2609:.\Include/arm_math.h ****   uint32_t blockSize);
2610:.\Include/arm_math.h **** 
2611:.\Include/arm_math.h **** 
2612:.\Include/arm_math.h ****   /**
2613:.\Include/arm_math.h ****    * @brief Multiplies a Q31 vector by a scalar.
2614:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2615:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2616:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2617:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2618:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2619:.\Include/arm_math.h ****    */
2620:.\Include/arm_math.h ****   void arm_scale_q31(
2621:.\Include/arm_math.h ****   q31_t * pSrc,
2622:.\Include/arm_math.h ****   q31_t scaleFract,
2623:.\Include/arm_math.h ****   int8_t shift,
2624:.\Include/arm_math.h ****   q31_t * pDst,
2625:.\Include/arm_math.h ****   uint32_t blockSize);
2626:.\Include/arm_math.h **** 
2627:.\Include/arm_math.h **** 
2628:.\Include/arm_math.h ****   /**
2629:.\Include/arm_math.h ****    * @brief Q7 vector absolute value.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 51


2630:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2631:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2632:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2633:.\Include/arm_math.h ****    */
2634:.\Include/arm_math.h ****   void arm_abs_q7(
2635:.\Include/arm_math.h ****   q7_t * pSrc,
2636:.\Include/arm_math.h ****   q7_t * pDst,
2637:.\Include/arm_math.h ****   uint32_t blockSize);
2638:.\Include/arm_math.h **** 
2639:.\Include/arm_math.h **** 
2640:.\Include/arm_math.h ****   /**
2641:.\Include/arm_math.h ****    * @brief Floating-point vector absolute value.
2642:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2643:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2644:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2645:.\Include/arm_math.h ****    */
2646:.\Include/arm_math.h ****   void arm_abs_f32(
2647:.\Include/arm_math.h ****   float32_t * pSrc,
2648:.\Include/arm_math.h ****   float32_t * pDst,
2649:.\Include/arm_math.h ****   uint32_t blockSize);
2650:.\Include/arm_math.h **** 
2651:.\Include/arm_math.h **** 
2652:.\Include/arm_math.h ****   /**
2653:.\Include/arm_math.h ****    * @brief Q15 vector absolute value.
2654:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2655:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2656:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2657:.\Include/arm_math.h ****    */
2658:.\Include/arm_math.h ****   void arm_abs_q15(
2659:.\Include/arm_math.h ****   q15_t * pSrc,
2660:.\Include/arm_math.h ****   q15_t * pDst,
2661:.\Include/arm_math.h ****   uint32_t blockSize);
2662:.\Include/arm_math.h **** 
2663:.\Include/arm_math.h **** 
2664:.\Include/arm_math.h ****   /**
2665:.\Include/arm_math.h ****    * @brief Q31 vector absolute value.
2666:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2667:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2668:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2669:.\Include/arm_math.h ****    */
2670:.\Include/arm_math.h ****   void arm_abs_q31(
2671:.\Include/arm_math.h ****   q31_t * pSrc,
2672:.\Include/arm_math.h ****   q31_t * pDst,
2673:.\Include/arm_math.h ****   uint32_t blockSize);
2674:.\Include/arm_math.h **** 
2675:.\Include/arm_math.h **** 
2676:.\Include/arm_math.h ****   /**
2677:.\Include/arm_math.h ****    * @brief Dot product of floating-point vectors.
2678:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2679:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2680:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2681:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2682:.\Include/arm_math.h ****    */
2683:.\Include/arm_math.h ****   void arm_dot_prod_f32(
2684:.\Include/arm_math.h ****   float32_t * pSrcA,
2685:.\Include/arm_math.h ****   float32_t * pSrcB,
2686:.\Include/arm_math.h ****   uint32_t blockSize,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 52


2687:.\Include/arm_math.h ****   float32_t * result);
2688:.\Include/arm_math.h **** 
2689:.\Include/arm_math.h **** 
2690:.\Include/arm_math.h ****   /**
2691:.\Include/arm_math.h ****    * @brief Dot product of Q7 vectors.
2692:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2693:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2694:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2695:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2696:.\Include/arm_math.h ****    */
2697:.\Include/arm_math.h ****   void arm_dot_prod_q7(
2698:.\Include/arm_math.h ****   q7_t * pSrcA,
2699:.\Include/arm_math.h ****   q7_t * pSrcB,
2700:.\Include/arm_math.h ****   uint32_t blockSize,
2701:.\Include/arm_math.h ****   q31_t * result);
2702:.\Include/arm_math.h **** 
2703:.\Include/arm_math.h **** 
2704:.\Include/arm_math.h ****   /**
2705:.\Include/arm_math.h ****    * @brief Dot product of Q15 vectors.
2706:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2707:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2708:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2709:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2710:.\Include/arm_math.h ****    */
2711:.\Include/arm_math.h ****   void arm_dot_prod_q15(
2712:.\Include/arm_math.h ****   q15_t * pSrcA,
2713:.\Include/arm_math.h ****   q15_t * pSrcB,
2714:.\Include/arm_math.h ****   uint32_t blockSize,
2715:.\Include/arm_math.h ****   q63_t * result);
2716:.\Include/arm_math.h **** 
2717:.\Include/arm_math.h **** 
2718:.\Include/arm_math.h ****   /**
2719:.\Include/arm_math.h ****    * @brief Dot product of Q31 vectors.
2720:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2721:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2722:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2723:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2724:.\Include/arm_math.h ****    */
2725:.\Include/arm_math.h ****   void arm_dot_prod_q31(
2726:.\Include/arm_math.h ****   q31_t * pSrcA,
2727:.\Include/arm_math.h ****   q31_t * pSrcB,
2728:.\Include/arm_math.h ****   uint32_t blockSize,
2729:.\Include/arm_math.h ****   q63_t * result);
2730:.\Include/arm_math.h **** 
2731:.\Include/arm_math.h **** 
2732:.\Include/arm_math.h ****   /**
2733:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q7 vector a specified number of bits.
2734:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2735:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2736:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2737:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2738:.\Include/arm_math.h ****    */
2739:.\Include/arm_math.h ****   void arm_shift_q7(
2740:.\Include/arm_math.h ****   q7_t * pSrc,
2741:.\Include/arm_math.h ****   int8_t shiftBits,
2742:.\Include/arm_math.h ****   q7_t * pDst,
2743:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 53


2744:.\Include/arm_math.h **** 
2745:.\Include/arm_math.h **** 
2746:.\Include/arm_math.h ****   /**
2747:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q15 vector a specified number of bits.
2748:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2749:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2750:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2751:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2752:.\Include/arm_math.h ****    */
2753:.\Include/arm_math.h ****   void arm_shift_q15(
2754:.\Include/arm_math.h ****   q15_t * pSrc,
2755:.\Include/arm_math.h ****   int8_t shiftBits,
2756:.\Include/arm_math.h ****   q15_t * pDst,
2757:.\Include/arm_math.h ****   uint32_t blockSize);
2758:.\Include/arm_math.h **** 
2759:.\Include/arm_math.h **** 
2760:.\Include/arm_math.h ****   /**
2761:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q31 vector a specified number of bits.
2762:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2763:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2764:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2765:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2766:.\Include/arm_math.h ****    */
2767:.\Include/arm_math.h ****   void arm_shift_q31(
2768:.\Include/arm_math.h ****   q31_t * pSrc,
2769:.\Include/arm_math.h ****   int8_t shiftBits,
2770:.\Include/arm_math.h ****   q31_t * pDst,
2771:.\Include/arm_math.h ****   uint32_t blockSize);
2772:.\Include/arm_math.h **** 
2773:.\Include/arm_math.h **** 
2774:.\Include/arm_math.h ****   /**
2775:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a floating-point vector.
2776:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2777:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2778:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2779:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2780:.\Include/arm_math.h ****    */
2781:.\Include/arm_math.h ****   void arm_offset_f32(
2782:.\Include/arm_math.h ****   float32_t * pSrc,
2783:.\Include/arm_math.h ****   float32_t offset,
2784:.\Include/arm_math.h ****   float32_t * pDst,
2785:.\Include/arm_math.h ****   uint32_t blockSize);
2786:.\Include/arm_math.h **** 
2787:.\Include/arm_math.h **** 
2788:.\Include/arm_math.h ****   /**
2789:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q7 vector.
2790:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2791:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2792:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2793:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2794:.\Include/arm_math.h ****    */
2795:.\Include/arm_math.h ****   void arm_offset_q7(
2796:.\Include/arm_math.h ****   q7_t * pSrc,
2797:.\Include/arm_math.h ****   q7_t offset,
2798:.\Include/arm_math.h ****   q7_t * pDst,
2799:.\Include/arm_math.h ****   uint32_t blockSize);
2800:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 54


2801:.\Include/arm_math.h **** 
2802:.\Include/arm_math.h ****   /**
2803:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q15 vector.
2804:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2805:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2806:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2807:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2808:.\Include/arm_math.h ****    */
2809:.\Include/arm_math.h ****   void arm_offset_q15(
2810:.\Include/arm_math.h ****   q15_t * pSrc,
2811:.\Include/arm_math.h ****   q15_t offset,
2812:.\Include/arm_math.h ****   q15_t * pDst,
2813:.\Include/arm_math.h ****   uint32_t blockSize);
2814:.\Include/arm_math.h **** 
2815:.\Include/arm_math.h **** 
2816:.\Include/arm_math.h ****   /**
2817:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q31 vector.
2818:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2819:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2820:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2821:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2822:.\Include/arm_math.h ****    */
2823:.\Include/arm_math.h ****   void arm_offset_q31(
2824:.\Include/arm_math.h ****   q31_t * pSrc,
2825:.\Include/arm_math.h ****   q31_t offset,
2826:.\Include/arm_math.h ****   q31_t * pDst,
2827:.\Include/arm_math.h ****   uint32_t blockSize);
2828:.\Include/arm_math.h **** 
2829:.\Include/arm_math.h **** 
2830:.\Include/arm_math.h ****   /**
2831:.\Include/arm_math.h ****    * @brief  Negates the elements of a floating-point vector.
2832:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2833:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2834:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2835:.\Include/arm_math.h ****    */
2836:.\Include/arm_math.h ****   void arm_negate_f32(
2837:.\Include/arm_math.h ****   float32_t * pSrc,
2838:.\Include/arm_math.h ****   float32_t * pDst,
2839:.\Include/arm_math.h ****   uint32_t blockSize);
2840:.\Include/arm_math.h **** 
2841:.\Include/arm_math.h **** 
2842:.\Include/arm_math.h ****   /**
2843:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q7 vector.
2844:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2845:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2846:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2847:.\Include/arm_math.h ****    */
2848:.\Include/arm_math.h ****   void arm_negate_q7(
2849:.\Include/arm_math.h ****   q7_t * pSrc,
2850:.\Include/arm_math.h ****   q7_t * pDst,
2851:.\Include/arm_math.h ****   uint32_t blockSize);
2852:.\Include/arm_math.h **** 
2853:.\Include/arm_math.h **** 
2854:.\Include/arm_math.h ****   /**
2855:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q15 vector.
2856:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2857:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 55


2858:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2859:.\Include/arm_math.h ****    */
2860:.\Include/arm_math.h ****   void arm_negate_q15(
2861:.\Include/arm_math.h ****   q15_t * pSrc,
2862:.\Include/arm_math.h ****   q15_t * pDst,
2863:.\Include/arm_math.h ****   uint32_t blockSize);
2864:.\Include/arm_math.h **** 
2865:.\Include/arm_math.h **** 
2866:.\Include/arm_math.h ****   /**
2867:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q31 vector.
2868:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2869:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2870:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2871:.\Include/arm_math.h ****    */
2872:.\Include/arm_math.h ****   void arm_negate_q31(
2873:.\Include/arm_math.h ****   q31_t * pSrc,
2874:.\Include/arm_math.h ****   q31_t * pDst,
2875:.\Include/arm_math.h ****   uint32_t blockSize);
2876:.\Include/arm_math.h **** 
2877:.\Include/arm_math.h **** 
2878:.\Include/arm_math.h ****   /**
2879:.\Include/arm_math.h ****    * @brief  Copies the elements of a floating-point vector.
2880:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2881:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2882:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2883:.\Include/arm_math.h ****    */
2884:.\Include/arm_math.h ****   void arm_copy_f32(
2885:.\Include/arm_math.h ****   float32_t * pSrc,
2886:.\Include/arm_math.h ****   float32_t * pDst,
2887:.\Include/arm_math.h ****   uint32_t blockSize);
2888:.\Include/arm_math.h **** 
2889:.\Include/arm_math.h **** 
2890:.\Include/arm_math.h ****   /**
2891:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q7 vector.
2892:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2893:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2894:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2895:.\Include/arm_math.h ****    */
2896:.\Include/arm_math.h ****   void arm_copy_q7(
2897:.\Include/arm_math.h ****   q7_t * pSrc,
2898:.\Include/arm_math.h ****   q7_t * pDst,
2899:.\Include/arm_math.h ****   uint32_t blockSize);
2900:.\Include/arm_math.h **** 
2901:.\Include/arm_math.h **** 
2902:.\Include/arm_math.h ****   /**
2903:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q15 vector.
2904:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2905:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2906:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2907:.\Include/arm_math.h ****    */
2908:.\Include/arm_math.h ****   void arm_copy_q15(
2909:.\Include/arm_math.h ****   q15_t * pSrc,
2910:.\Include/arm_math.h ****   q15_t * pDst,
2911:.\Include/arm_math.h ****   uint32_t blockSize);
2912:.\Include/arm_math.h **** 
2913:.\Include/arm_math.h **** 
2914:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 56


2915:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q31 vector.
2916:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2917:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2918:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2919:.\Include/arm_math.h ****    */
2920:.\Include/arm_math.h ****   void arm_copy_q31(
2921:.\Include/arm_math.h ****   q31_t * pSrc,
2922:.\Include/arm_math.h ****   q31_t * pDst,
2923:.\Include/arm_math.h ****   uint32_t blockSize);
2924:.\Include/arm_math.h **** 
2925:.\Include/arm_math.h **** 
2926:.\Include/arm_math.h ****   /**
2927:.\Include/arm_math.h ****    * @brief  Fills a constant value into a floating-point vector.
2928:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2929:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2930:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2931:.\Include/arm_math.h ****    */
2932:.\Include/arm_math.h ****   void arm_fill_f32(
2933:.\Include/arm_math.h ****   float32_t value,
2934:.\Include/arm_math.h ****   float32_t * pDst,
2935:.\Include/arm_math.h ****   uint32_t blockSize);
2936:.\Include/arm_math.h **** 
2937:.\Include/arm_math.h **** 
2938:.\Include/arm_math.h ****   /**
2939:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q7 vector.
2940:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2941:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2942:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2943:.\Include/arm_math.h ****    */
2944:.\Include/arm_math.h ****   void arm_fill_q7(
2945:.\Include/arm_math.h ****   q7_t value,
2946:.\Include/arm_math.h ****   q7_t * pDst,
2947:.\Include/arm_math.h ****   uint32_t blockSize);
2948:.\Include/arm_math.h **** 
2949:.\Include/arm_math.h **** 
2950:.\Include/arm_math.h ****   /**
2951:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q15 vector.
2952:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2953:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2954:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2955:.\Include/arm_math.h ****    */
2956:.\Include/arm_math.h ****   void arm_fill_q15(
2957:.\Include/arm_math.h ****   q15_t value,
2958:.\Include/arm_math.h ****   q15_t * pDst,
2959:.\Include/arm_math.h ****   uint32_t blockSize);
2960:.\Include/arm_math.h **** 
2961:.\Include/arm_math.h **** 
2962:.\Include/arm_math.h ****   /**
2963:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q31 vector.
2964:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2965:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2966:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2967:.\Include/arm_math.h ****    */
2968:.\Include/arm_math.h ****   void arm_fill_q31(
2969:.\Include/arm_math.h ****   q31_t value,
2970:.\Include/arm_math.h ****   q31_t * pDst,
2971:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 57


2972:.\Include/arm_math.h **** 
2973:.\Include/arm_math.h **** 
2974:.\Include/arm_math.h **** /**
2975:.\Include/arm_math.h ****  * @brief Convolution of floating-point sequences.
2976:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2977:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2978:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2979:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2980:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2981:.\Include/arm_math.h ****  */
2982:.\Include/arm_math.h ****   void arm_conv_f32(
2983:.\Include/arm_math.h ****   float32_t * pSrcA,
2984:.\Include/arm_math.h ****   uint32_t srcALen,
2985:.\Include/arm_math.h ****   float32_t * pSrcB,
2986:.\Include/arm_math.h ****   uint32_t srcBLen,
2987:.\Include/arm_math.h ****   float32_t * pDst);
2988:.\Include/arm_math.h **** 
2989:.\Include/arm_math.h **** 
2990:.\Include/arm_math.h ****   /**
2991:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences.
2992:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2993:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2994:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2995:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2996:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2997:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2998:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2999:.\Include/arm_math.h ****    */
3000:.\Include/arm_math.h ****   void arm_conv_opt_q15(
3001:.\Include/arm_math.h ****   q15_t * pSrcA,
3002:.\Include/arm_math.h ****   uint32_t srcALen,
3003:.\Include/arm_math.h ****   q15_t * pSrcB,
3004:.\Include/arm_math.h ****   uint32_t srcBLen,
3005:.\Include/arm_math.h ****   q15_t * pDst,
3006:.\Include/arm_math.h ****   q15_t * pScratch1,
3007:.\Include/arm_math.h ****   q15_t * pScratch2);
3008:.\Include/arm_math.h **** 
3009:.\Include/arm_math.h **** 
3010:.\Include/arm_math.h **** /**
3011:.\Include/arm_math.h ****  * @brief Convolution of Q15 sequences.
3012:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
3013:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
3014:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
3015:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
3016:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
3017:.\Include/arm_math.h ****  */
3018:.\Include/arm_math.h ****   void arm_conv_q15(
3019:.\Include/arm_math.h ****   q15_t * pSrcA,
3020:.\Include/arm_math.h ****   uint32_t srcALen,
3021:.\Include/arm_math.h ****   q15_t * pSrcB,
3022:.\Include/arm_math.h ****   uint32_t srcBLen,
3023:.\Include/arm_math.h ****   q15_t * pDst);
3024:.\Include/arm_math.h **** 
3025:.\Include/arm_math.h **** 
3026:.\Include/arm_math.h ****   /**
3027:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3028:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 58


3029:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3030:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3031:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3032:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3033:.\Include/arm_math.h ****    */
3034:.\Include/arm_math.h ****   void arm_conv_fast_q15(
3035:.\Include/arm_math.h ****           q15_t * pSrcA,
3036:.\Include/arm_math.h ****           uint32_t srcALen,
3037:.\Include/arm_math.h ****           q15_t * pSrcB,
3038:.\Include/arm_math.h ****           uint32_t srcBLen,
3039:.\Include/arm_math.h ****           q15_t * pDst);
3040:.\Include/arm_math.h **** 
3041:.\Include/arm_math.h **** 
3042:.\Include/arm_math.h ****   /**
3043:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3044:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3045:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3046:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3047:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3048:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3049:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
3050:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
3051:.\Include/arm_math.h ****    */
3052:.\Include/arm_math.h ****   void arm_conv_fast_opt_q15(
3053:.\Include/arm_math.h ****   q15_t * pSrcA,
3054:.\Include/arm_math.h ****   uint32_t srcALen,
3055:.\Include/arm_math.h ****   q15_t * pSrcB,
3056:.\Include/arm_math.h ****   uint32_t srcBLen,
3057:.\Include/arm_math.h ****   q15_t * pDst,
3058:.\Include/arm_math.h ****   q15_t * pScratch1,
3059:.\Include/arm_math.h ****   q15_t * pScratch2);
3060:.\Include/arm_math.h **** 
3061:.\Include/arm_math.h **** 
3062:.\Include/arm_math.h ****   /**
3063:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences.
3064:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3065:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3066:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3067:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3068:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3069:.\Include/arm_math.h ****    */
3070:.\Include/arm_math.h ****   void arm_conv_q31(
3071:.\Include/arm_math.h ****   q31_t * pSrcA,
3072:.\Include/arm_math.h ****   uint32_t srcALen,
3073:.\Include/arm_math.h ****   q31_t * pSrcB,
3074:.\Include/arm_math.h ****   uint32_t srcBLen,
3075:.\Include/arm_math.h ****   q31_t * pDst);
3076:.\Include/arm_math.h **** 
3077:.\Include/arm_math.h **** 
3078:.\Include/arm_math.h ****   /**
3079:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3080:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3081:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3082:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3083:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3084:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3085:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 59


3086:.\Include/arm_math.h ****   void arm_conv_fast_q31(
3087:.\Include/arm_math.h ****   q31_t * pSrcA,
3088:.\Include/arm_math.h ****   uint32_t srcALen,
3089:.\Include/arm_math.h ****   q31_t * pSrcB,
3090:.\Include/arm_math.h ****   uint32_t srcBLen,
3091:.\Include/arm_math.h ****   q31_t * pDst);
3092:.\Include/arm_math.h **** 
3093:.\Include/arm_math.h **** 
3094:.\Include/arm_math.h ****     /**
3095:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3096:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3097:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3098:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3099:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3100:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3101:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
3102:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
3103:.\Include/arm_math.h ****    */
3104:.\Include/arm_math.h ****   void arm_conv_opt_q7(
3105:.\Include/arm_math.h ****   q7_t * pSrcA,
3106:.\Include/arm_math.h ****   uint32_t srcALen,
3107:.\Include/arm_math.h ****   q7_t * pSrcB,
3108:.\Include/arm_math.h ****   uint32_t srcBLen,
3109:.\Include/arm_math.h ****   q7_t * pDst,
3110:.\Include/arm_math.h ****   q15_t * pScratch1,
3111:.\Include/arm_math.h ****   q15_t * pScratch2);
3112:.\Include/arm_math.h **** 
3113:.\Include/arm_math.h **** 
3114:.\Include/arm_math.h ****   /**
3115:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3116:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3117:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3118:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3119:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3120:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3121:.\Include/arm_math.h ****    */
3122:.\Include/arm_math.h ****   void arm_conv_q7(
3123:.\Include/arm_math.h ****   q7_t * pSrcA,
3124:.\Include/arm_math.h ****   uint32_t srcALen,
3125:.\Include/arm_math.h ****   q7_t * pSrcB,
3126:.\Include/arm_math.h ****   uint32_t srcBLen,
3127:.\Include/arm_math.h ****   q7_t * pDst);
3128:.\Include/arm_math.h **** 
3129:.\Include/arm_math.h **** 
3130:.\Include/arm_math.h ****   /**
3131:.\Include/arm_math.h ****    * @brief Partial convolution of floating-point sequences.
3132:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3133:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3134:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3135:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3136:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3137:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3138:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3139:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3140:.\Include/arm_math.h ****    */
3141:.\Include/arm_math.h ****   arm_status arm_conv_partial_f32(
3142:.\Include/arm_math.h ****   float32_t * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 60


3143:.\Include/arm_math.h ****   uint32_t srcALen,
3144:.\Include/arm_math.h ****   float32_t * pSrcB,
3145:.\Include/arm_math.h ****   uint32_t srcBLen,
3146:.\Include/arm_math.h ****   float32_t * pDst,
3147:.\Include/arm_math.h ****   uint32_t firstIndex,
3148:.\Include/arm_math.h ****   uint32_t numPoints);
3149:.\Include/arm_math.h **** 
3150:.\Include/arm_math.h **** 
3151:.\Include/arm_math.h ****   /**
3152:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3153:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3154:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3155:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3156:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3157:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3158:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3159:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3160:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3161:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3162:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3163:.\Include/arm_math.h ****    */
3164:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q15(
3165:.\Include/arm_math.h ****   q15_t * pSrcA,
3166:.\Include/arm_math.h ****   uint32_t srcALen,
3167:.\Include/arm_math.h ****   q15_t * pSrcB,
3168:.\Include/arm_math.h ****   uint32_t srcBLen,
3169:.\Include/arm_math.h ****   q15_t * pDst,
3170:.\Include/arm_math.h ****   uint32_t firstIndex,
3171:.\Include/arm_math.h ****   uint32_t numPoints,
3172:.\Include/arm_math.h ****   q15_t * pScratch1,
3173:.\Include/arm_math.h ****   q15_t * pScratch2);
3174:.\Include/arm_math.h **** 
3175:.\Include/arm_math.h **** 
3176:.\Include/arm_math.h ****   /**
3177:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3178:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3179:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3180:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3181:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3182:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3183:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3184:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3185:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3186:.\Include/arm_math.h ****    */
3187:.\Include/arm_math.h ****   arm_status arm_conv_partial_q15(
3188:.\Include/arm_math.h ****   q15_t * pSrcA,
3189:.\Include/arm_math.h ****   uint32_t srcALen,
3190:.\Include/arm_math.h ****   q15_t * pSrcB,
3191:.\Include/arm_math.h ****   uint32_t srcBLen,
3192:.\Include/arm_math.h ****   q15_t * pDst,
3193:.\Include/arm_math.h ****   uint32_t firstIndex,
3194:.\Include/arm_math.h ****   uint32_t numPoints);
3195:.\Include/arm_math.h **** 
3196:.\Include/arm_math.h **** 
3197:.\Include/arm_math.h ****   /**
3198:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3199:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 61


3200:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3201:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3202:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3203:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3204:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3205:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3206:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3207:.\Include/arm_math.h ****    */
3208:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q15(
3209:.\Include/arm_math.h ****   q15_t * pSrcA,
3210:.\Include/arm_math.h ****   uint32_t srcALen,
3211:.\Include/arm_math.h ****   q15_t * pSrcB,
3212:.\Include/arm_math.h ****   uint32_t srcBLen,
3213:.\Include/arm_math.h ****   q15_t * pDst,
3214:.\Include/arm_math.h ****   uint32_t firstIndex,
3215:.\Include/arm_math.h ****   uint32_t numPoints);
3216:.\Include/arm_math.h **** 
3217:.\Include/arm_math.h **** 
3218:.\Include/arm_math.h ****   /**
3219:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3220:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3221:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3222:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3223:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3224:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3225:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3226:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3227:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3228:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3229:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3230:.\Include/arm_math.h ****    */
3231:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_opt_q15(
3232:.\Include/arm_math.h ****   q15_t * pSrcA,
3233:.\Include/arm_math.h ****   uint32_t srcALen,
3234:.\Include/arm_math.h ****   q15_t * pSrcB,
3235:.\Include/arm_math.h ****   uint32_t srcBLen,
3236:.\Include/arm_math.h ****   q15_t * pDst,
3237:.\Include/arm_math.h ****   uint32_t firstIndex,
3238:.\Include/arm_math.h ****   uint32_t numPoints,
3239:.\Include/arm_math.h ****   q15_t * pScratch1,
3240:.\Include/arm_math.h ****   q15_t * pScratch2);
3241:.\Include/arm_math.h **** 
3242:.\Include/arm_math.h **** 
3243:.\Include/arm_math.h ****   /**
3244:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences.
3245:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3246:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3247:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3248:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3249:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3250:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3251:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3252:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3253:.\Include/arm_math.h ****    */
3254:.\Include/arm_math.h ****   arm_status arm_conv_partial_q31(
3255:.\Include/arm_math.h ****   q31_t * pSrcA,
3256:.\Include/arm_math.h ****   uint32_t srcALen,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 62


3257:.\Include/arm_math.h ****   q31_t * pSrcB,
3258:.\Include/arm_math.h ****   uint32_t srcBLen,
3259:.\Include/arm_math.h ****   q31_t * pDst,
3260:.\Include/arm_math.h ****   uint32_t firstIndex,
3261:.\Include/arm_math.h ****   uint32_t numPoints);
3262:.\Include/arm_math.h **** 
3263:.\Include/arm_math.h **** 
3264:.\Include/arm_math.h ****   /**
3265:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3266:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3267:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3268:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3269:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3270:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3271:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3272:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3273:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3274:.\Include/arm_math.h ****    */
3275:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q31(
3276:.\Include/arm_math.h ****   q31_t * pSrcA,
3277:.\Include/arm_math.h ****   uint32_t srcALen,
3278:.\Include/arm_math.h ****   q31_t * pSrcB,
3279:.\Include/arm_math.h ****   uint32_t srcBLen,
3280:.\Include/arm_math.h ****   q31_t * pDst,
3281:.\Include/arm_math.h ****   uint32_t firstIndex,
3282:.\Include/arm_math.h ****   uint32_t numPoints);
3283:.\Include/arm_math.h **** 
3284:.\Include/arm_math.h **** 
3285:.\Include/arm_math.h ****   /**
3286:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences
3287:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3288:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3289:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3290:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3291:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3292:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3293:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3294:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) 
3295:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)
3296:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3297:.\Include/arm_math.h ****    */
3298:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q7(
3299:.\Include/arm_math.h ****   q7_t * pSrcA,
3300:.\Include/arm_math.h ****   uint32_t srcALen,
3301:.\Include/arm_math.h ****   q7_t * pSrcB,
3302:.\Include/arm_math.h ****   uint32_t srcBLen,
3303:.\Include/arm_math.h ****   q7_t * pDst,
3304:.\Include/arm_math.h ****   uint32_t firstIndex,
3305:.\Include/arm_math.h ****   uint32_t numPoints,
3306:.\Include/arm_math.h ****   q15_t * pScratch1,
3307:.\Include/arm_math.h ****   q15_t * pScratch2);
3308:.\Include/arm_math.h **** 
3309:.\Include/arm_math.h **** 
3310:.\Include/arm_math.h **** /**
3311:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences.
3312:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3313:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 63


3314:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3315:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3316:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3317:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3318:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3319:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3320:.\Include/arm_math.h ****    */
3321:.\Include/arm_math.h ****   arm_status arm_conv_partial_q7(
3322:.\Include/arm_math.h ****   q7_t * pSrcA,
3323:.\Include/arm_math.h ****   uint32_t srcALen,
3324:.\Include/arm_math.h ****   q7_t * pSrcB,
3325:.\Include/arm_math.h ****   uint32_t srcBLen,
3326:.\Include/arm_math.h ****   q7_t * pDst,
3327:.\Include/arm_math.h ****   uint32_t firstIndex,
3328:.\Include/arm_math.h ****   uint32_t numPoints);
3329:.\Include/arm_math.h **** 
3330:.\Include/arm_math.h **** 
3331:.\Include/arm_math.h ****   /**
3332:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR decimator.
3333:.\Include/arm_math.h ****    */
3334:.\Include/arm_math.h ****   typedef struct
3335:.\Include/arm_math.h ****   {
3336:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3337:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3338:.\Include/arm_math.h ****     q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3339:.\Include/arm_math.h ****     q15_t *pState;              /**< points to the state variable array. The array is of length num
3340:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q15;
3341:.\Include/arm_math.h **** 
3342:.\Include/arm_math.h ****   /**
3343:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR decimator.
3344:.\Include/arm_math.h ****    */
3345:.\Include/arm_math.h ****   typedef struct
3346:.\Include/arm_math.h ****   {
3347:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3348:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3349:.\Include/arm_math.h ****     q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3350:.\Include/arm_math.h ****     q31_t *pState;              /**< points to the state variable array. The array is of length num
3351:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q31;
3352:.\Include/arm_math.h **** 
3353:.\Include/arm_math.h ****   /**
3354:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR decimator.
3355:.\Include/arm_math.h ****    */
3356:.\Include/arm_math.h ****   typedef struct
3357:.\Include/arm_math.h ****   {
3358:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3359:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3360:.\Include/arm_math.h ****     float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTap
3361:.\Include/arm_math.h ****     float32_t *pState;          /**< points to the state variable array. The array is of length num
3362:.\Include/arm_math.h ****   } arm_fir_decimate_instance_f32;
3363:.\Include/arm_math.h **** 
3364:.\Include/arm_math.h **** 
3365:.\Include/arm_math.h ****   /**
3366:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR decimator.
3367:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
3368:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3369:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3370:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 64


3371:.\Include/arm_math.h ****    */
3372:.\Include/arm_math.h ****   void arm_fir_decimate_f32(
3373:.\Include/arm_math.h ****   const arm_fir_decimate_instance_f32 * S,
3374:.\Include/arm_math.h ****   float32_t * pSrc,
3375:.\Include/arm_math.h ****   float32_t * pDst,
3376:.\Include/arm_math.h ****   uint32_t blockSize);
3377:.\Include/arm_math.h **** 
3378:.\Include/arm_math.h **** 
3379:.\Include/arm_math.h ****   /**
3380:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR decimator.
3381:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
3382:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3383:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3384:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3385:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3386:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3387:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3388:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3389:.\Include/arm_math.h ****    */
3390:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_f32(
3391:.\Include/arm_math.h ****   arm_fir_decimate_instance_f32 * S,
3392:.\Include/arm_math.h ****   uint16_t numTaps,
3393:.\Include/arm_math.h ****   uint8_t M,
3394:.\Include/arm_math.h ****   float32_t * pCoeffs,
3395:.\Include/arm_math.h ****   float32_t * pState,
3396:.\Include/arm_math.h ****   uint32_t blockSize);
3397:.\Include/arm_math.h **** 
3398:.\Include/arm_math.h **** 
3399:.\Include/arm_math.h ****   /**
3400:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator.
3401:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3402:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3403:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3404:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3405:.\Include/arm_math.h ****    */
3406:.\Include/arm_math.h ****   void arm_fir_decimate_q15(
3407:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3408:.\Include/arm_math.h ****   q15_t * pSrc,
3409:.\Include/arm_math.h ****   q15_t * pDst,
3410:.\Include/arm_math.h ****   uint32_t blockSize);
3411:.\Include/arm_math.h **** 
3412:.\Include/arm_math.h **** 
3413:.\Include/arm_math.h ****   /**
3414:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3415:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3416:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3417:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3418:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3419:.\Include/arm_math.h ****    */
3420:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q15(
3421:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3422:.\Include/arm_math.h ****   q15_t * pSrc,
3423:.\Include/arm_math.h ****   q15_t * pDst,
3424:.\Include/arm_math.h ****   uint32_t blockSize);
3425:.\Include/arm_math.h **** 
3426:.\Include/arm_math.h **** 
3427:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 65


3428:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR decimator.
3429:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
3430:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3431:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3432:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3433:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3434:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3435:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3436:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3437:.\Include/arm_math.h ****    */
3438:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q15(
3439:.\Include/arm_math.h ****   arm_fir_decimate_instance_q15 * S,
3440:.\Include/arm_math.h ****   uint16_t numTaps,
3441:.\Include/arm_math.h ****   uint8_t M,
3442:.\Include/arm_math.h ****   q15_t * pCoeffs,
3443:.\Include/arm_math.h ****   q15_t * pState,
3444:.\Include/arm_math.h ****   uint32_t blockSize);
3445:.\Include/arm_math.h **** 
3446:.\Include/arm_math.h **** 
3447:.\Include/arm_math.h ****   /**
3448:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator.
3449:.\Include/arm_math.h ****    * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
3450:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the block of input data.
3451:.\Include/arm_math.h ****    * @param[out] pDst  points to the block of output data
3452:.\Include/arm_math.h ****    * @param[in] blockSize number of input samples to process per call.
3453:.\Include/arm_math.h ****    */
3454:.\Include/arm_math.h ****   void arm_fir_decimate_q31(
3455:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q31 * S,
3456:.\Include/arm_math.h ****   q31_t * pSrc,
3457:.\Include/arm_math.h ****   q31_t * pDst,
3458:.\Include/arm_math.h ****   uint32_t blockSize);
3459:.\Include/arm_math.h **** 
3460:.\Include/arm_math.h ****   /**
3461:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3462:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
3463:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3464:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3465:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3466:.\Include/arm_math.h ****    */
3467:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q31(
3468:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3469:.\Include/arm_math.h ****   q31_t * pSrc,
3470:.\Include/arm_math.h ****   q31_t * pDst,
3471:.\Include/arm_math.h ****   uint32_t blockSize);
3472:.\Include/arm_math.h **** 
3473:.\Include/arm_math.h **** 
3474:.\Include/arm_math.h ****   /**
3475:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR decimator.
3476:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
3477:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3478:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3479:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3480:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3481:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3482:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3483:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3484:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 66


3485:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q31(
3486:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3487:.\Include/arm_math.h ****   uint16_t numTaps,
3488:.\Include/arm_math.h ****   uint8_t M,
3489:.\Include/arm_math.h ****   q31_t * pCoeffs,
3490:.\Include/arm_math.h ****   q31_t * pState,
3491:.\Include/arm_math.h ****   uint32_t blockSize);
3492:.\Include/arm_math.h **** 
3493:.\Include/arm_math.h **** 
3494:.\Include/arm_math.h ****   /**
3495:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR interpolator.
3496:.\Include/arm_math.h ****    */
3497:.\Include/arm_math.h ****   typedef struct
3498:.\Include/arm_math.h ****   {
3499:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3500:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3501:.\Include/arm_math.h ****     q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3502:.\Include/arm_math.h ****     q15_t *pState;                  /**< points to the state variable array. The array is of length
3503:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q15;
3504:.\Include/arm_math.h **** 
3505:.\Include/arm_math.h ****   /**
3506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR interpolator.
3507:.\Include/arm_math.h ****    */
3508:.\Include/arm_math.h ****   typedef struct
3509:.\Include/arm_math.h ****   {
3510:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3511:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3512:.\Include/arm_math.h ****     q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3513:.\Include/arm_math.h ****     q31_t *pState;                  /**< points to the state variable array. The array is of length
3514:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q31;
3515:.\Include/arm_math.h **** 
3516:.\Include/arm_math.h ****   /**
3517:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR interpolator.
3518:.\Include/arm_math.h ****    */
3519:.\Include/arm_math.h ****   typedef struct
3520:.\Include/arm_math.h ****   {
3521:.\Include/arm_math.h ****     uint8_t L;                     /**< upsample factor. */
3522:.\Include/arm_math.h ****     uint16_t phaseLength;          /**< length of each polyphase filter component. */
3523:.\Include/arm_math.h ****     float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*p
3524:.\Include/arm_math.h ****     float32_t *pState;             /**< points to the state variable array. The array is of length 
3525:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_f32;
3526:.\Include/arm_math.h **** 
3527:.\Include/arm_math.h **** 
3528:.\Include/arm_math.h ****   /**
3529:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR interpolator.
3530:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3531:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3532:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3533:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3534:.\Include/arm_math.h ****    */
3535:.\Include/arm_math.h ****   void arm_fir_interpolate_q15(
3536:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q15 * S,
3537:.\Include/arm_math.h ****   q15_t * pSrc,
3538:.\Include/arm_math.h ****   q15_t * pDst,
3539:.\Include/arm_math.h ****   uint32_t blockSize);
3540:.\Include/arm_math.h **** 
3541:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 67


3542:.\Include/arm_math.h ****   /**
3543:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR interpolator.
3544:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
3545:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3546:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3547:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3548:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3549:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3550:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3551:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3552:.\Include/arm_math.h ****    */
3553:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q15(
3554:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q15 * S,
3555:.\Include/arm_math.h ****   uint8_t L,
3556:.\Include/arm_math.h ****   uint16_t numTaps,
3557:.\Include/arm_math.h ****   q15_t * pCoeffs,
3558:.\Include/arm_math.h ****   q15_t * pState,
3559:.\Include/arm_math.h ****   uint32_t blockSize);
3560:.\Include/arm_math.h **** 
3561:.\Include/arm_math.h **** 
3562:.\Include/arm_math.h ****   /**
3563:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR interpolator.
3564:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3565:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3566:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3567:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3568:.\Include/arm_math.h ****    */
3569:.\Include/arm_math.h ****   void arm_fir_interpolate_q31(
3570:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q31 * S,
3571:.\Include/arm_math.h ****   q31_t * pSrc,
3572:.\Include/arm_math.h ****   q31_t * pDst,
3573:.\Include/arm_math.h ****   uint32_t blockSize);
3574:.\Include/arm_math.h **** 
3575:.\Include/arm_math.h **** 
3576:.\Include/arm_math.h ****   /**
3577:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR interpolator.
3578:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
3579:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3580:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3581:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3582:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3583:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3584:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3585:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3586:.\Include/arm_math.h ****    */
3587:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q31(
3588:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q31 * S,
3589:.\Include/arm_math.h ****   uint8_t L,
3590:.\Include/arm_math.h ****   uint16_t numTaps,
3591:.\Include/arm_math.h ****   q31_t * pCoeffs,
3592:.\Include/arm_math.h ****   q31_t * pState,
3593:.\Include/arm_math.h ****   uint32_t blockSize);
3594:.\Include/arm_math.h **** 
3595:.\Include/arm_math.h **** 
3596:.\Include/arm_math.h ****   /**
3597:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR interpolator.
3598:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 68


3599:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3600:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3601:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3602:.\Include/arm_math.h ****    */
3603:.\Include/arm_math.h ****   void arm_fir_interpolate_f32(
3604:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_f32 * S,
3605:.\Include/arm_math.h ****   float32_t * pSrc,
3606:.\Include/arm_math.h ****   float32_t * pDst,
3607:.\Include/arm_math.h ****   uint32_t blockSize);
3608:.\Include/arm_math.h **** 
3609:.\Include/arm_math.h **** 
3610:.\Include/arm_math.h ****   /**
3611:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR interpolator.
3612:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR interpolator structu
3613:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3614:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3615:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3616:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3617:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3618:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3619:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3620:.\Include/arm_math.h ****    */
3621:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_f32(
3622:.\Include/arm_math.h ****   arm_fir_interpolate_instance_f32 * S,
3623:.\Include/arm_math.h ****   uint8_t L,
3624:.\Include/arm_math.h ****   uint16_t numTaps,
3625:.\Include/arm_math.h ****   float32_t * pCoeffs,
3626:.\Include/arm_math.h ****   float32_t * pState,
3627:.\Include/arm_math.h ****   uint32_t blockSize);
3628:.\Include/arm_math.h **** 
3629:.\Include/arm_math.h **** 
3630:.\Include/arm_math.h ****   /**
3631:.\Include/arm_math.h ****    * @brief Instance structure for the high precision Q31 Biquad cascade filter.
3632:.\Include/arm_math.h ****    */
3633:.\Include/arm_math.h ****   typedef struct
3634:.\Include/arm_math.h ****   {
3635:.\Include/arm_math.h ****     uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*num
3636:.\Include/arm_math.h ****     q63_t *pState;           /**< points to the array of state coefficients.  The array is of lengt
3637:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*nu
3638:.\Include/arm_math.h ****     uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
3639:.\Include/arm_math.h ****   } arm_biquad_cas_df1_32x64_ins_q31;
3640:.\Include/arm_math.h **** 
3641:.\Include/arm_math.h **** 
3642:.\Include/arm_math.h ****   /**
3643:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter s
3644:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3645:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3646:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3647:.\Include/arm_math.h ****    */
3648:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_q31(
3649:.\Include/arm_math.h ****   const arm_biquad_cas_df1_32x64_ins_q31 * S,
3650:.\Include/arm_math.h ****   q31_t * pSrc,
3651:.\Include/arm_math.h ****   q31_t * pDst,
3652:.\Include/arm_math.h ****   uint32_t blockSize);
3653:.\Include/arm_math.h **** 
3654:.\Include/arm_math.h **** 
3655:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 69


3656:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filte
3657:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3658:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3659:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3660:.\Include/arm_math.h ****    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficie
3661:.\Include/arm_math.h ****    */
3662:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_init_q31(
3663:.\Include/arm_math.h ****   arm_biquad_cas_df1_32x64_ins_q31 * S,
3664:.\Include/arm_math.h ****   uint8_t numStages,
3665:.\Include/arm_math.h ****   q31_t * pCoeffs,
3666:.\Include/arm_math.h ****   q63_t * pState,
3667:.\Include/arm_math.h ****   uint8_t postShift);
3668:.\Include/arm_math.h **** 
3669:.\Include/arm_math.h **** 
3670:.\Include/arm_math.h ****   /**
3671:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3672:.\Include/arm_math.h ****    */
3673:.\Include/arm_math.h ****   typedef struct
3674:.\Include/arm_math.h ****   {
3675:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3676:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3677:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3678:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f32;
3679:.\Include/arm_math.h **** 
3680:.\Include/arm_math.h ****   /**
3681:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3682:.\Include/arm_math.h ****    */
3683:.\Include/arm_math.h ****   typedef struct
3684:.\Include/arm_math.h ****   {
3685:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3686:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3687:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3688:.\Include/arm_math.h ****   } arm_biquad_cascade_stereo_df2T_instance_f32;
3689:.\Include/arm_math.h **** 
3690:.\Include/arm_math.h ****   /**
3691:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3692:.\Include/arm_math.h ****    */
3693:.\Include/arm_math.h ****   typedef struct
3694:.\Include/arm_math.h ****   {
3695:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3696:.\Include/arm_math.h ****     float64_t *pState;         /**< points to the array of state coefficients.  The array is of len
3697:.\Include/arm_math.h ****     float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3698:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f64;
3699:.\Include/arm_math.h **** 
3700:.\Include/arm_math.h **** 
3701:.\Include/arm_math.h ****   /**
3702:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3703:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3704:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3705:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3706:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3707:.\Include/arm_math.h ****    */
3708:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f32(
3709:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f32 * S,
3710:.\Include/arm_math.h ****   float32_t * pSrc,
3711:.\Include/arm_math.h ****   float32_t * pDst,
3712:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 70


3713:.\Include/arm_math.h **** 
3714:.\Include/arm_math.h **** 
3715:.\Include/arm_math.h ****   /**
3716:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3717:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3718:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3719:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3720:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3721:.\Include/arm_math.h ****    */
3722:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_f32(
3723:.\Include/arm_math.h ****   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3724:.\Include/arm_math.h ****   float32_t * pSrc,
3725:.\Include/arm_math.h ****   float32_t * pDst,
3726:.\Include/arm_math.h ****   uint32_t blockSize);
3727:.\Include/arm_math.h **** 
3728:.\Include/arm_math.h **** 
3729:.\Include/arm_math.h ****   /**
3730:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3731:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3732:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3733:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3734:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3735:.\Include/arm_math.h ****    */
3736:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f64(
3737:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f64 * S,
3738:.\Include/arm_math.h ****   float64_t * pSrc,
3739:.\Include/arm_math.h ****   float64_t * pDst,
3740:.\Include/arm_math.h ****   uint32_t blockSize);
3741:.\Include/arm_math.h **** 
3742:.\Include/arm_math.h **** 
3743:.\Include/arm_math.h ****   /**
3744:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3745:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3746:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3747:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3748:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3749:.\Include/arm_math.h ****    */
3750:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f32(
3751:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f32 * S,
3752:.\Include/arm_math.h ****   uint8_t numStages,
3753:.\Include/arm_math.h ****   float32_t * pCoeffs,
3754:.\Include/arm_math.h ****   float32_t * pState);
3755:.\Include/arm_math.h **** 
3756:.\Include/arm_math.h **** 
3757:.\Include/arm_math.h ****   /**
3758:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3759:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3760:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3761:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3762:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3763:.\Include/arm_math.h ****    */
3764:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_init_f32(
3765:.\Include/arm_math.h ****   arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3766:.\Include/arm_math.h ****   uint8_t numStages,
3767:.\Include/arm_math.h ****   float32_t * pCoeffs,
3768:.\Include/arm_math.h ****   float32_t * pState);
3769:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 71


3770:.\Include/arm_math.h **** 
3771:.\Include/arm_math.h ****   /**
3772:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3773:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3774:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3775:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3776:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3777:.\Include/arm_math.h ****    */
3778:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f64(
3779:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f64 * S,
3780:.\Include/arm_math.h ****   uint8_t numStages,
3781:.\Include/arm_math.h ****   float64_t * pCoeffs,
3782:.\Include/arm_math.h ****   float64_t * pState);
3783:.\Include/arm_math.h **** 
3784:.\Include/arm_math.h **** 
3785:.\Include/arm_math.h ****   /**
3786:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR lattice filter.
3787:.\Include/arm_math.h ****    */
3788:.\Include/arm_math.h ****   typedef struct
3789:.\Include/arm_math.h ****   {
3790:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3791:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3792:.\Include/arm_math.h ****     q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3793:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q15;
3794:.\Include/arm_math.h **** 
3795:.\Include/arm_math.h ****   /**
3796:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR lattice filter.
3797:.\Include/arm_math.h ****    */
3798:.\Include/arm_math.h ****   typedef struct
3799:.\Include/arm_math.h ****   {
3800:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3801:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3802:.\Include/arm_math.h ****     q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3803:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q31;
3804:.\Include/arm_math.h **** 
3805:.\Include/arm_math.h ****   /**
3806:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR lattice filter.
3807:.\Include/arm_math.h ****    */
3808:.\Include/arm_math.h ****   typedef struct
3809:.\Include/arm_math.h ****   {
3810:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3811:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3812:.\Include/arm_math.h ****     float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of leng
3813:.\Include/arm_math.h ****   } arm_fir_lattice_instance_f32;
3814:.\Include/arm_math.h **** 
3815:.\Include/arm_math.h **** 
3816:.\Include/arm_math.h ****   /**
3817:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 FIR lattice filter.
3818:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 FIR lattice structure.
3819:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3820:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3821:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages.
3822:.\Include/arm_math.h ****    */
3823:.\Include/arm_math.h ****   void arm_fir_lattice_init_q15(
3824:.\Include/arm_math.h ****   arm_fir_lattice_instance_q15 * S,
3825:.\Include/arm_math.h ****   uint16_t numStages,
3826:.\Include/arm_math.h ****   q15_t * pCoeffs,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 72


3827:.\Include/arm_math.h ****   q15_t * pState);
3828:.\Include/arm_math.h **** 
3829:.\Include/arm_math.h **** 
3830:.\Include/arm_math.h ****   /**
3831:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR lattice filter.
3832:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
3833:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3834:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3835:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3836:.\Include/arm_math.h ****    */
3837:.\Include/arm_math.h ****   void arm_fir_lattice_q15(
3838:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q15 * S,
3839:.\Include/arm_math.h ****   q15_t * pSrc,
3840:.\Include/arm_math.h ****   q15_t * pDst,
3841:.\Include/arm_math.h ****   uint32_t blockSize);
3842:.\Include/arm_math.h **** 
3843:.\Include/arm_math.h **** 
3844:.\Include/arm_math.h ****   /**
3845:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 FIR lattice filter.
3846:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 FIR lattice structure.
3847:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3848:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3849:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.   The array is of length numStages.
3850:.\Include/arm_math.h ****    */
3851:.\Include/arm_math.h ****   void arm_fir_lattice_init_q31(
3852:.\Include/arm_math.h ****   arm_fir_lattice_instance_q31 * S,
3853:.\Include/arm_math.h ****   uint16_t numStages,
3854:.\Include/arm_math.h ****   q31_t * pCoeffs,
3855:.\Include/arm_math.h ****   q31_t * pState);
3856:.\Include/arm_math.h **** 
3857:.\Include/arm_math.h **** 
3858:.\Include/arm_math.h ****   /**
3859:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR lattice filter.
3860:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
3861:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3862:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3863:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3864:.\Include/arm_math.h ****    */
3865:.\Include/arm_math.h ****   void arm_fir_lattice_q31(
3866:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q31 * S,
3867:.\Include/arm_math.h ****   q31_t * pSrc,
3868:.\Include/arm_math.h ****   q31_t * pDst,
3869:.\Include/arm_math.h ****   uint32_t blockSize);
3870:.\Include/arm_math.h **** 
3871:.\Include/arm_math.h **** 
3872:.\Include/arm_math.h **** /**
3873:.\Include/arm_math.h ****  * @brief Initialization function for the floating-point FIR lattice filter.
3874:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the floating-point FIR lattice structure.
3875:.\Include/arm_math.h ****  * @param[in] numStages  number of filter stages.
3876:.\Include/arm_math.h ****  * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3877:.\Include/arm_math.h ****  * @param[in] pState     points to the state buffer.  The array is of length numStages.
3878:.\Include/arm_math.h ****  */
3879:.\Include/arm_math.h ****   void arm_fir_lattice_init_f32(
3880:.\Include/arm_math.h ****   arm_fir_lattice_instance_f32 * S,
3881:.\Include/arm_math.h ****   uint16_t numStages,
3882:.\Include/arm_math.h ****   float32_t * pCoeffs,
3883:.\Include/arm_math.h ****   float32_t * pState);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 73


3884:.\Include/arm_math.h **** 
3885:.\Include/arm_math.h **** 
3886:.\Include/arm_math.h ****   /**
3887:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR lattice filter.
3888:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
3889:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3890:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3891:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3892:.\Include/arm_math.h ****    */
3893:.\Include/arm_math.h ****   void arm_fir_lattice_f32(
3894:.\Include/arm_math.h ****   const arm_fir_lattice_instance_f32 * S,
3895:.\Include/arm_math.h ****   float32_t * pSrc,
3896:.\Include/arm_math.h ****   float32_t * pDst,
3897:.\Include/arm_math.h ****   uint32_t blockSize);
3898:.\Include/arm_math.h **** 
3899:.\Include/arm_math.h **** 
3900:.\Include/arm_math.h ****   /**
3901:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 IIR lattice filter.
3902:.\Include/arm_math.h ****    */
3903:.\Include/arm_math.h ****   typedef struct
3904:.\Include/arm_math.h ****   {
3905:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3906:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3907:.\Include/arm_math.h ****     q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3908:.\Include/arm_math.h ****     q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3909:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q15;
3910:.\Include/arm_math.h **** 
3911:.\Include/arm_math.h ****   /**
3912:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 IIR lattice filter.
3913:.\Include/arm_math.h ****    */
3914:.\Include/arm_math.h ****   typedef struct
3915:.\Include/arm_math.h ****   {
3916:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3917:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3918:.\Include/arm_math.h ****     q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3919:.\Include/arm_math.h ****     q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3920:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q31;
3921:.\Include/arm_math.h **** 
3922:.\Include/arm_math.h ****   /**
3923:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point IIR lattice filter.
3924:.\Include/arm_math.h ****    */
3925:.\Include/arm_math.h ****   typedef struct
3926:.\Include/arm_math.h ****   {
3927:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3928:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3929:.\Include/arm_math.h ****     float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array
3930:.\Include/arm_math.h ****     float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is 
3931:.\Include/arm_math.h ****   } arm_iir_lattice_instance_f32;
3932:.\Include/arm_math.h **** 
3933:.\Include/arm_math.h **** 
3934:.\Include/arm_math.h ****   /**
3935:.\Include/arm_math.h ****    * @brief Processing function for the floating-point IIR lattice filter.
3936:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
3937:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3938:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3939:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3940:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 74


3941:.\Include/arm_math.h ****   void arm_iir_lattice_f32(
3942:.\Include/arm_math.h ****   const arm_iir_lattice_instance_f32 * S,
3943:.\Include/arm_math.h ****   float32_t * pSrc,
3944:.\Include/arm_math.h ****   float32_t * pDst,
3945:.\Include/arm_math.h ****   uint32_t blockSize);
3946:.\Include/arm_math.h **** 
3947:.\Include/arm_math.h **** 
3948:.\Include/arm_math.h ****   /**
3949:.\Include/arm_math.h ****    * @brief Initialization function for the floating-point IIR lattice filter.
3950:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point IIR lattice structure.
3951:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3952:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3953:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3954:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-
3955:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3956:.\Include/arm_math.h ****    */
3957:.\Include/arm_math.h ****   void arm_iir_lattice_init_f32(
3958:.\Include/arm_math.h ****   arm_iir_lattice_instance_f32 * S,
3959:.\Include/arm_math.h ****   uint16_t numStages,
3960:.\Include/arm_math.h ****   float32_t * pkCoeffs,
3961:.\Include/arm_math.h ****   float32_t * pvCoeffs,
3962:.\Include/arm_math.h ****   float32_t * pState,
3963:.\Include/arm_math.h ****   uint32_t blockSize);
3964:.\Include/arm_math.h **** 
3965:.\Include/arm_math.h **** 
3966:.\Include/arm_math.h ****   /**
3967:.\Include/arm_math.h ****    * @brief Processing function for the Q31 IIR lattice filter.
3968:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
3969:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3970:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3971:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3972:.\Include/arm_math.h ****    */
3973:.\Include/arm_math.h ****   void arm_iir_lattice_q31(
3974:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q31 * S,
3975:.\Include/arm_math.h ****   q31_t * pSrc,
3976:.\Include/arm_math.h ****   q31_t * pDst,
3977:.\Include/arm_math.h ****   uint32_t blockSize);
3978:.\Include/arm_math.h **** 
3979:.\Include/arm_math.h **** 
3980:.\Include/arm_math.h ****   /**
3981:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 IIR lattice filter.
3982:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 IIR lattice structure.
3983:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3984:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3985:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3986:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
3987:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3988:.\Include/arm_math.h ****    */
3989:.\Include/arm_math.h ****   void arm_iir_lattice_init_q31(
3990:.\Include/arm_math.h ****   arm_iir_lattice_instance_q31 * S,
3991:.\Include/arm_math.h ****   uint16_t numStages,
3992:.\Include/arm_math.h ****   q31_t * pkCoeffs,
3993:.\Include/arm_math.h ****   q31_t * pvCoeffs,
3994:.\Include/arm_math.h ****   q31_t * pState,
3995:.\Include/arm_math.h ****   uint32_t blockSize);
3996:.\Include/arm_math.h **** 
3997:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 75


3998:.\Include/arm_math.h ****   /**
3999:.\Include/arm_math.h ****    * @brief Processing function for the Q15 IIR lattice filter.
4000:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
4001:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4002:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
4003:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4004:.\Include/arm_math.h ****    */
4005:.\Include/arm_math.h ****   void arm_iir_lattice_q15(
4006:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q15 * S,
4007:.\Include/arm_math.h ****   q15_t * pSrc,
4008:.\Include/arm_math.h ****   q15_t * pDst,
4009:.\Include/arm_math.h ****   uint32_t blockSize);
4010:.\Include/arm_math.h **** 
4011:.\Include/arm_math.h **** 
4012:.\Include/arm_math.h **** /**
4013:.\Include/arm_math.h ****  * @brief Initialization function for the Q15 IIR lattice filter.
4014:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
4015:.\Include/arm_math.h ****  * @param[in] numStages  number of stages in the filter.
4016:.\Include/arm_math.h ****  * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages
4017:.\Include/arm_math.h ****  * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
4018:.\Include/arm_math.h ****  * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
4019:.\Include/arm_math.h ****  * @param[in] blockSize  number of samples to process per call.
4020:.\Include/arm_math.h ****  */
4021:.\Include/arm_math.h ****   void arm_iir_lattice_init_q15(
4022:.\Include/arm_math.h ****   arm_iir_lattice_instance_q15 * S,
4023:.\Include/arm_math.h ****   uint16_t numStages,
4024:.\Include/arm_math.h ****   q15_t * pkCoeffs,
4025:.\Include/arm_math.h ****   q15_t * pvCoeffs,
4026:.\Include/arm_math.h ****   q15_t * pState,
4027:.\Include/arm_math.h ****   uint32_t blockSize);
4028:.\Include/arm_math.h **** 
4029:.\Include/arm_math.h **** 
4030:.\Include/arm_math.h ****   /**
4031:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point LMS filter.
4032:.\Include/arm_math.h ****    */
4033:.\Include/arm_math.h ****   typedef struct
4034:.\Include/arm_math.h ****   {
4035:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4036:.\Include/arm_math.h ****     float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+bl
4037:.\Include/arm_math.h ****     float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
4038:.\Include/arm_math.h ****     float32_t mu;        /**< step size that controls filter coefficient updates. */
4039:.\Include/arm_math.h ****   } arm_lms_instance_f32;
4040:.\Include/arm_math.h **** 
4041:.\Include/arm_math.h **** 
4042:.\Include/arm_math.h ****   /**
4043:.\Include/arm_math.h ****    * @brief Processing function for floating-point LMS filter.
4044:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point LMS filter structure.
4045:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4046:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4047:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4048:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4049:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4050:.\Include/arm_math.h ****    */
4051:.\Include/arm_math.h ****   void arm_lms_f32(
4052:.\Include/arm_math.h ****   const arm_lms_instance_f32 * S,
4053:.\Include/arm_math.h ****   float32_t * pSrc,
4054:.\Include/arm_math.h ****   float32_t * pRef,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 76


4055:.\Include/arm_math.h ****   float32_t * pOut,
4056:.\Include/arm_math.h ****   float32_t * pErr,
4057:.\Include/arm_math.h ****   uint32_t blockSize);
4058:.\Include/arm_math.h **** 
4059:.\Include/arm_math.h **** 
4060:.\Include/arm_math.h ****   /**
4061:.\Include/arm_math.h ****    * @brief Initialization function for floating-point LMS filter.
4062:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4063:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4064:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4065:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4066:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4067:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4068:.\Include/arm_math.h ****    */
4069:.\Include/arm_math.h ****   void arm_lms_init_f32(
4070:.\Include/arm_math.h ****   arm_lms_instance_f32 * S,
4071:.\Include/arm_math.h ****   uint16_t numTaps,
4072:.\Include/arm_math.h ****   float32_t * pCoeffs,
4073:.\Include/arm_math.h ****   float32_t * pState,
4074:.\Include/arm_math.h ****   float32_t mu,
4075:.\Include/arm_math.h ****   uint32_t blockSize);
4076:.\Include/arm_math.h **** 
4077:.\Include/arm_math.h **** 
4078:.\Include/arm_math.h ****   /**
4079:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 LMS filter.
4080:.\Include/arm_math.h ****    */
4081:.\Include/arm_math.h ****   typedef struct
4082:.\Include/arm_math.h ****   {
4083:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4084:.\Include/arm_math.h ****     q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4085:.\Include/arm_math.h ****     q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4086:.\Include/arm_math.h ****     q15_t mu;            /**< step size that controls filter coefficient updates. */
4087:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4088:.\Include/arm_math.h ****   } arm_lms_instance_q15;
4089:.\Include/arm_math.h **** 
4090:.\Include/arm_math.h **** 
4091:.\Include/arm_math.h ****   /**
4092:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 LMS filter.
4093:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 LMS filter structure.
4094:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4095:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4096:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.
4097:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4098:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4099:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4100:.\Include/arm_math.h ****    */
4101:.\Include/arm_math.h ****   void arm_lms_init_q15(
4102:.\Include/arm_math.h ****   arm_lms_instance_q15 * S,
4103:.\Include/arm_math.h ****   uint16_t numTaps,
4104:.\Include/arm_math.h ****   q15_t * pCoeffs,
4105:.\Include/arm_math.h ****   q15_t * pState,
4106:.\Include/arm_math.h ****   q15_t mu,
4107:.\Include/arm_math.h ****   uint32_t blockSize,
4108:.\Include/arm_math.h ****   uint32_t postShift);
4109:.\Include/arm_math.h **** 
4110:.\Include/arm_math.h **** 
4111:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 77


4112:.\Include/arm_math.h ****    * @brief Processing function for Q15 LMS filter.
4113:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4114:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4115:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4116:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4117:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4118:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4119:.\Include/arm_math.h ****    */
4120:.\Include/arm_math.h ****   void arm_lms_q15(
4121:.\Include/arm_math.h ****   const arm_lms_instance_q15 * S,
4122:.\Include/arm_math.h ****   q15_t * pSrc,
4123:.\Include/arm_math.h ****   q15_t * pRef,
4124:.\Include/arm_math.h ****   q15_t * pOut,
4125:.\Include/arm_math.h ****   q15_t * pErr,
4126:.\Include/arm_math.h ****   uint32_t blockSize);
4127:.\Include/arm_math.h **** 
4128:.\Include/arm_math.h **** 
4129:.\Include/arm_math.h ****   /**
4130:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 LMS filter.
4131:.\Include/arm_math.h ****    */
4132:.\Include/arm_math.h ****   typedef struct
4133:.\Include/arm_math.h ****   {
4134:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4135:.\Include/arm_math.h ****     q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4136:.\Include/arm_math.h ****     q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4137:.\Include/arm_math.h ****     q31_t mu;            /**< step size that controls filter coefficient updates. */
4138:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4139:.\Include/arm_math.h ****   } arm_lms_instance_q31;
4140:.\Include/arm_math.h **** 
4141:.\Include/arm_math.h **** 
4142:.\Include/arm_math.h ****   /**
4143:.\Include/arm_math.h ****    * @brief Processing function for Q31 LMS filter.
4144:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4145:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4146:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4147:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4148:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4149:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4150:.\Include/arm_math.h ****    */
4151:.\Include/arm_math.h ****   void arm_lms_q31(
4152:.\Include/arm_math.h ****   const arm_lms_instance_q31 * S,
4153:.\Include/arm_math.h ****   q31_t * pSrc,
4154:.\Include/arm_math.h ****   q31_t * pRef,
4155:.\Include/arm_math.h ****   q31_t * pOut,
4156:.\Include/arm_math.h ****   q31_t * pErr,
4157:.\Include/arm_math.h ****   uint32_t blockSize);
4158:.\Include/arm_math.h **** 
4159:.\Include/arm_math.h **** 
4160:.\Include/arm_math.h ****   /**
4161:.\Include/arm_math.h ****    * @brief Initialization function for Q31 LMS filter.
4162:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 LMS filter structure.
4163:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4164:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4165:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4166:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4167:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4168:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 78


4169:.\Include/arm_math.h ****    */
4170:.\Include/arm_math.h ****   void arm_lms_init_q31(
4171:.\Include/arm_math.h ****   arm_lms_instance_q31 * S,
4172:.\Include/arm_math.h ****   uint16_t numTaps,
4173:.\Include/arm_math.h ****   q31_t * pCoeffs,
4174:.\Include/arm_math.h ****   q31_t * pState,
4175:.\Include/arm_math.h ****   q31_t mu,
4176:.\Include/arm_math.h ****   uint32_t blockSize,
4177:.\Include/arm_math.h ****   uint32_t postShift);
4178:.\Include/arm_math.h **** 
4179:.\Include/arm_math.h **** 
4180:.\Include/arm_math.h ****   /**
4181:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point normalized LMS filter.
4182:.\Include/arm_math.h ****    */
4183:.\Include/arm_math.h ****   typedef struct
4184:.\Include/arm_math.h ****   {
4185:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4186:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
4187:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
4188:.\Include/arm_math.h ****     float32_t mu;         /**< step size that control filter coefficient updates. */
4189:.\Include/arm_math.h ****     float32_t energy;     /**< saves previous frame energy. */
4190:.\Include/arm_math.h ****     float32_t x0;         /**< saves previous input sample. */
4191:.\Include/arm_math.h ****   } arm_lms_norm_instance_f32;
4192:.\Include/arm_math.h **** 
4193:.\Include/arm_math.h **** 
4194:.\Include/arm_math.h ****   /**
4195:.\Include/arm_math.h ****    * @brief Processing function for floating-point normalized LMS filter.
4196:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point normalized LMS filter struc
4197:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4198:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4199:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4200:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4201:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4202:.\Include/arm_math.h ****    */
4203:.\Include/arm_math.h ****   void arm_lms_norm_f32(
4204:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4205:.\Include/arm_math.h ****   float32_t * pSrc,
4206:.\Include/arm_math.h ****   float32_t * pRef,
4207:.\Include/arm_math.h ****   float32_t * pOut,
4208:.\Include/arm_math.h ****   float32_t * pErr,
4209:.\Include/arm_math.h ****   uint32_t blockSize);
4210:.\Include/arm_math.h **** 
4211:.\Include/arm_math.h **** 
4212:.\Include/arm_math.h ****   /**
4213:.\Include/arm_math.h ****    * @brief Initialization function for floating-point normalized LMS filter.
4214:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4215:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4216:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4217:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4218:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4219:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4220:.\Include/arm_math.h ****    */
4221:.\Include/arm_math.h ****   void arm_lms_norm_init_f32(
4222:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4223:.\Include/arm_math.h ****   uint16_t numTaps,
4224:.\Include/arm_math.h ****   float32_t * pCoeffs,
4225:.\Include/arm_math.h ****   float32_t * pState,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 79


4226:.\Include/arm_math.h ****   float32_t mu,
4227:.\Include/arm_math.h ****   uint32_t blockSize);
4228:.\Include/arm_math.h **** 
4229:.\Include/arm_math.h **** 
4230:.\Include/arm_math.h ****   /**
4231:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 normalized LMS filter.
4232:.\Include/arm_math.h ****    */
4233:.\Include/arm_math.h ****   typedef struct
4234:.\Include/arm_math.h ****   {
4235:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4236:.\Include/arm_math.h ****     q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4237:.\Include/arm_math.h ****     q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4238:.\Include/arm_math.h ****     q31_t mu;             /**< step size that controls filter coefficient updates. */
4239:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4240:.\Include/arm_math.h ****     q31_t *recipTable;    /**< points to the reciprocal initial value table. */
4241:.\Include/arm_math.h ****     q31_t energy;         /**< saves previous frame energy. */
4242:.\Include/arm_math.h ****     q31_t x0;             /**< saves previous input sample. */
4243:.\Include/arm_math.h ****   } arm_lms_norm_instance_q31;
4244:.\Include/arm_math.h **** 
4245:.\Include/arm_math.h **** 
4246:.\Include/arm_math.h ****   /**
4247:.\Include/arm_math.h ****    * @brief Processing function for Q31 normalized LMS filter.
4248:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
4249:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4250:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4251:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4252:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4253:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4254:.\Include/arm_math.h ****    */
4255:.\Include/arm_math.h ****   void arm_lms_norm_q31(
4256:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4257:.\Include/arm_math.h ****   q31_t * pSrc,
4258:.\Include/arm_math.h ****   q31_t * pRef,
4259:.\Include/arm_math.h ****   q31_t * pOut,
4260:.\Include/arm_math.h ****   q31_t * pErr,
4261:.\Include/arm_math.h ****   uint32_t blockSize);
4262:.\Include/arm_math.h **** 
4263:.\Include/arm_math.h **** 
4264:.\Include/arm_math.h ****   /**
4265:.\Include/arm_math.h ****    * @brief Initialization function for Q31 normalized LMS filter.
4266:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
4267:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4268:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4269:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4270:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4271:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4272:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4273:.\Include/arm_math.h ****    */
4274:.\Include/arm_math.h ****   void arm_lms_norm_init_q31(
4275:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4276:.\Include/arm_math.h ****   uint16_t numTaps,
4277:.\Include/arm_math.h ****   q31_t * pCoeffs,
4278:.\Include/arm_math.h ****   q31_t * pState,
4279:.\Include/arm_math.h ****   q31_t mu,
4280:.\Include/arm_math.h ****   uint32_t blockSize,
4281:.\Include/arm_math.h ****   uint8_t postShift);
4282:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 80


4283:.\Include/arm_math.h **** 
4284:.\Include/arm_math.h ****   /**
4285:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 normalized LMS filter.
4286:.\Include/arm_math.h ****    */
4287:.\Include/arm_math.h ****   typedef struct
4288:.\Include/arm_math.h ****   {
4289:.\Include/arm_math.h ****     uint16_t numTaps;     /**< Number of coefficients in the filter. */
4290:.\Include/arm_math.h ****     q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4291:.\Include/arm_math.h ****     q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4292:.\Include/arm_math.h ****     q15_t mu;             /**< step size that controls filter coefficient updates. */
4293:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4294:.\Include/arm_math.h ****     q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
4295:.\Include/arm_math.h ****     q15_t energy;         /**< saves previous frame energy. */
4296:.\Include/arm_math.h ****     q15_t x0;             /**< saves previous input sample. */
4297:.\Include/arm_math.h ****   } arm_lms_norm_instance_q15;
4298:.\Include/arm_math.h **** 
4299:.\Include/arm_math.h **** 
4300:.\Include/arm_math.h ****   /**
4301:.\Include/arm_math.h ****    * @brief Processing function for Q15 normalized LMS filter.
4302:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
4303:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4304:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4305:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4306:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4307:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4308:.\Include/arm_math.h ****    */
4309:.\Include/arm_math.h ****   void arm_lms_norm_q15(
4310:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4311:.\Include/arm_math.h ****   q15_t * pSrc,
4312:.\Include/arm_math.h ****   q15_t * pRef,
4313:.\Include/arm_math.h ****   q15_t * pOut,
4314:.\Include/arm_math.h ****   q15_t * pErr,
4315:.\Include/arm_math.h ****   uint32_t blockSize);
4316:.\Include/arm_math.h **** 
4317:.\Include/arm_math.h **** 
4318:.\Include/arm_math.h ****   /**
4319:.\Include/arm_math.h ****    * @brief Initialization function for Q15 normalized LMS filter.
4320:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
4321:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4322:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4323:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4324:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4325:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4326:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4327:.\Include/arm_math.h ****    */
4328:.\Include/arm_math.h ****   void arm_lms_norm_init_q15(
4329:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4330:.\Include/arm_math.h ****   uint16_t numTaps,
4331:.\Include/arm_math.h ****   q15_t * pCoeffs,
4332:.\Include/arm_math.h ****   q15_t * pState,
4333:.\Include/arm_math.h ****   q15_t mu,
4334:.\Include/arm_math.h ****   uint32_t blockSize,
4335:.\Include/arm_math.h ****   uint8_t postShift);
4336:.\Include/arm_math.h **** 
4337:.\Include/arm_math.h **** 
4338:.\Include/arm_math.h ****   /**
4339:.\Include/arm_math.h ****    * @brief Correlation of floating-point sequences.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 81


4340:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4341:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4342:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4343:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4344:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4345:.\Include/arm_math.h ****    */
4346:.\Include/arm_math.h ****   void arm_correlate_f32(
4347:.\Include/arm_math.h ****   float32_t * pSrcA,
4348:.\Include/arm_math.h ****   uint32_t srcALen,
4349:.\Include/arm_math.h ****   float32_t * pSrcB,
4350:.\Include/arm_math.h ****   uint32_t srcBLen,
4351:.\Include/arm_math.h ****   float32_t * pDst);
4352:.\Include/arm_math.h **** 
4353:.\Include/arm_math.h **** 
4354:.\Include/arm_math.h ****    /**
4355:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences
4356:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4357:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4358:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4359:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4360:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4361:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4362:.\Include/arm_math.h ****    */
4363:.\Include/arm_math.h ****   void arm_correlate_opt_q15(
4364:.\Include/arm_math.h ****   q15_t * pSrcA,
4365:.\Include/arm_math.h ****   uint32_t srcALen,
4366:.\Include/arm_math.h ****   q15_t * pSrcB,
4367:.\Include/arm_math.h ****   uint32_t srcBLen,
4368:.\Include/arm_math.h ****   q15_t * pDst,
4369:.\Include/arm_math.h ****   q15_t * pScratch);
4370:.\Include/arm_math.h **** 
4371:.\Include/arm_math.h **** 
4372:.\Include/arm_math.h ****   /**
4373:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences.
4374:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4375:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4376:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4377:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4378:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4379:.\Include/arm_math.h ****    */
4380:.\Include/arm_math.h **** 
4381:.\Include/arm_math.h ****   void arm_correlate_q15(
4382:.\Include/arm_math.h ****   q15_t * pSrcA,
4383:.\Include/arm_math.h ****   uint32_t srcALen,
4384:.\Include/arm_math.h ****   q15_t * pSrcB,
4385:.\Include/arm_math.h ****   uint32_t srcBLen,
4386:.\Include/arm_math.h ****   q15_t * pDst);
4387:.\Include/arm_math.h **** 
4388:.\Include/arm_math.h **** 
4389:.\Include/arm_math.h ****   /**
4390:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4391:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4392:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4393:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4394:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4395:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4396:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 82


4397:.\Include/arm_math.h **** 
4398:.\Include/arm_math.h ****   void arm_correlate_fast_q15(
4399:.\Include/arm_math.h ****   q15_t * pSrcA,
4400:.\Include/arm_math.h ****   uint32_t srcALen,
4401:.\Include/arm_math.h ****   q15_t * pSrcB,
4402:.\Include/arm_math.h ****   uint32_t srcBLen,
4403:.\Include/arm_math.h ****   q15_t * pDst);
4404:.\Include/arm_math.h **** 
4405:.\Include/arm_math.h **** 
4406:.\Include/arm_math.h ****   /**
4407:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4408:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4409:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4410:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4411:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4412:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4413:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4414:.\Include/arm_math.h ****    */
4415:.\Include/arm_math.h ****   void arm_correlate_fast_opt_q15(
4416:.\Include/arm_math.h ****   q15_t * pSrcA,
4417:.\Include/arm_math.h ****   uint32_t srcALen,
4418:.\Include/arm_math.h ****   q15_t * pSrcB,
4419:.\Include/arm_math.h ****   uint32_t srcBLen,
4420:.\Include/arm_math.h ****   q15_t * pDst,
4421:.\Include/arm_math.h ****   q15_t * pScratch);
4422:.\Include/arm_math.h **** 
4423:.\Include/arm_math.h **** 
4424:.\Include/arm_math.h ****   /**
4425:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences.
4426:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4427:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4428:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4429:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4430:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4431:.\Include/arm_math.h ****    */
4432:.\Include/arm_math.h ****   void arm_correlate_q31(
4433:.\Include/arm_math.h ****   q31_t * pSrcA,
4434:.\Include/arm_math.h ****   uint32_t srcALen,
4435:.\Include/arm_math.h ****   q31_t * pSrcB,
4436:.\Include/arm_math.h ****   uint32_t srcBLen,
4437:.\Include/arm_math.h ****   q31_t * pDst);
4438:.\Include/arm_math.h **** 
4439:.\Include/arm_math.h **** 
4440:.\Include/arm_math.h ****   /**
4441:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
4442:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4443:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4444:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4445:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4446:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4447:.\Include/arm_math.h ****    */
4448:.\Include/arm_math.h ****   void arm_correlate_fast_q31(
4449:.\Include/arm_math.h ****   q31_t * pSrcA,
4450:.\Include/arm_math.h ****   uint32_t srcALen,
4451:.\Include/arm_math.h ****   q31_t * pSrcB,
4452:.\Include/arm_math.h ****   uint32_t srcBLen,
4453:.\Include/arm_math.h ****   q31_t * pDst);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 83


4454:.\Include/arm_math.h **** 
4455:.\Include/arm_math.h **** 
4456:.\Include/arm_math.h ****  /**
4457:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4458:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
4459:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
4460:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
4461:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
4462:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 
4463:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
4464:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
4465:.\Include/arm_math.h ****    */
4466:.\Include/arm_math.h ****   void arm_correlate_opt_q7(
4467:.\Include/arm_math.h ****   q7_t * pSrcA,
4468:.\Include/arm_math.h ****   uint32_t srcALen,
4469:.\Include/arm_math.h ****   q7_t * pSrcB,
4470:.\Include/arm_math.h ****   uint32_t srcBLen,
4471:.\Include/arm_math.h ****   q7_t * pDst,
4472:.\Include/arm_math.h ****   q15_t * pScratch1,
4473:.\Include/arm_math.h ****   q15_t * pScratch2);
4474:.\Include/arm_math.h **** 
4475:.\Include/arm_math.h **** 
4476:.\Include/arm_math.h ****   /**
4477:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4478:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4479:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4480:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4481:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4482:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4483:.\Include/arm_math.h ****    */
4484:.\Include/arm_math.h ****   void arm_correlate_q7(
4485:.\Include/arm_math.h ****   q7_t * pSrcA,
4486:.\Include/arm_math.h ****   uint32_t srcALen,
4487:.\Include/arm_math.h ****   q7_t * pSrcB,
4488:.\Include/arm_math.h ****   uint32_t srcBLen,
4489:.\Include/arm_math.h ****   q7_t * pDst);
4490:.\Include/arm_math.h **** 
4491:.\Include/arm_math.h **** 
4492:.\Include/arm_math.h ****   /**
4493:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point sparse FIR filter.
4494:.\Include/arm_math.h ****    */
4495:.\Include/arm_math.h ****   typedef struct
4496:.\Include/arm_math.h ****   {
4497:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4498:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4499:.\Include/arm_math.h ****     float32_t *pState;            /**< points to the state buffer array. The array is of length max
4500:.\Include/arm_math.h ****     float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numT
4501:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4502:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4503:.\Include/arm_math.h ****   } arm_fir_sparse_instance_f32;
4504:.\Include/arm_math.h **** 
4505:.\Include/arm_math.h ****   /**
4506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 sparse FIR filter.
4507:.\Include/arm_math.h ****    */
4508:.\Include/arm_math.h ****   typedef struct
4509:.\Include/arm_math.h ****   {
4510:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 84


4511:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4512:.\Include/arm_math.h ****     q31_t *pState;                /**< points to the state buffer array. The array is of length max
4513:.\Include/arm_math.h ****     q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4514:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4515:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4516:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q31;
4517:.\Include/arm_math.h **** 
4518:.\Include/arm_math.h ****   /**
4519:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 sparse FIR filter.
4520:.\Include/arm_math.h ****    */
4521:.\Include/arm_math.h ****   typedef struct
4522:.\Include/arm_math.h ****   {
4523:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4524:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4525:.\Include/arm_math.h ****     q15_t *pState;                /**< points to the state buffer array. The array is of length max
4526:.\Include/arm_math.h ****     q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4527:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4528:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4529:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q15;
4530:.\Include/arm_math.h **** 
4531:.\Include/arm_math.h ****   /**
4532:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 sparse FIR filter.
4533:.\Include/arm_math.h ****    */
4534:.\Include/arm_math.h ****   typedef struct
4535:.\Include/arm_math.h ****   {
4536:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4537:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4538:.\Include/arm_math.h ****     q7_t *pState;                 /**< points to the state buffer array. The array is of length max
4539:.\Include/arm_math.h ****     q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numT
4540:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4541:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4542:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q7;
4543:.\Include/arm_math.h **** 
4544:.\Include/arm_math.h **** 
4545:.\Include/arm_math.h ****   /**
4546:.\Include/arm_math.h ****    * @brief Processing function for the floating-point sparse FIR filter.
4547:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
4548:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4549:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4550:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4551:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4552:.\Include/arm_math.h ****    */
4553:.\Include/arm_math.h ****   void arm_fir_sparse_f32(
4554:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4555:.\Include/arm_math.h ****   float32_t * pSrc,
4556:.\Include/arm_math.h ****   float32_t * pDst,
4557:.\Include/arm_math.h ****   float32_t * pScratchIn,
4558:.\Include/arm_math.h ****   uint32_t blockSize);
4559:.\Include/arm_math.h **** 
4560:.\Include/arm_math.h **** 
4561:.\Include/arm_math.h ****   /**
4562:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point sparse FIR filter.
4563:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
4564:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4565:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4566:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4567:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 85


4568:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4569:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4570:.\Include/arm_math.h ****    */
4571:.\Include/arm_math.h ****   void arm_fir_sparse_init_f32(
4572:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4573:.\Include/arm_math.h ****   uint16_t numTaps,
4574:.\Include/arm_math.h ****   float32_t * pCoeffs,
4575:.\Include/arm_math.h ****   float32_t * pState,
4576:.\Include/arm_math.h ****   int32_t * pTapDelay,
4577:.\Include/arm_math.h ****   uint16_t maxDelay,
4578:.\Include/arm_math.h ****   uint32_t blockSize);
4579:.\Include/arm_math.h **** 
4580:.\Include/arm_math.h **** 
4581:.\Include/arm_math.h ****   /**
4582:.\Include/arm_math.h ****    * @brief Processing function for the Q31 sparse FIR filter.
4583:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
4584:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4585:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4586:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4587:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4588:.\Include/arm_math.h ****    */
4589:.\Include/arm_math.h ****   void arm_fir_sparse_q31(
4590:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4591:.\Include/arm_math.h ****   q31_t * pSrc,
4592:.\Include/arm_math.h ****   q31_t * pDst,
4593:.\Include/arm_math.h ****   q31_t * pScratchIn,
4594:.\Include/arm_math.h ****   uint32_t blockSize);
4595:.\Include/arm_math.h **** 
4596:.\Include/arm_math.h **** 
4597:.\Include/arm_math.h ****   /**
4598:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 sparse FIR filter.
4599:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
4600:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4601:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4602:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4603:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4604:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4605:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4606:.\Include/arm_math.h ****    */
4607:.\Include/arm_math.h ****   void arm_fir_sparse_init_q31(
4608:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4609:.\Include/arm_math.h ****   uint16_t numTaps,
4610:.\Include/arm_math.h ****   q31_t * pCoeffs,
4611:.\Include/arm_math.h ****   q31_t * pState,
4612:.\Include/arm_math.h ****   int32_t * pTapDelay,
4613:.\Include/arm_math.h ****   uint16_t maxDelay,
4614:.\Include/arm_math.h ****   uint32_t blockSize);
4615:.\Include/arm_math.h **** 
4616:.\Include/arm_math.h **** 
4617:.\Include/arm_math.h ****   /**
4618:.\Include/arm_math.h ****    * @brief Processing function for the Q15 sparse FIR filter.
4619:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
4620:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4621:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4622:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4623:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4624:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 86


4625:.\Include/arm_math.h ****    */
4626:.\Include/arm_math.h ****   void arm_fir_sparse_q15(
4627:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4628:.\Include/arm_math.h ****   q15_t * pSrc,
4629:.\Include/arm_math.h ****   q15_t * pDst,
4630:.\Include/arm_math.h ****   q15_t * pScratchIn,
4631:.\Include/arm_math.h ****   q31_t * pScratchOut,
4632:.\Include/arm_math.h ****   uint32_t blockSize);
4633:.\Include/arm_math.h **** 
4634:.\Include/arm_math.h **** 
4635:.\Include/arm_math.h ****   /**
4636:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 sparse FIR filter.
4637:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
4638:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4639:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4640:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4641:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4642:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4643:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4644:.\Include/arm_math.h ****    */
4645:.\Include/arm_math.h ****   void arm_fir_sparse_init_q15(
4646:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4647:.\Include/arm_math.h ****   uint16_t numTaps,
4648:.\Include/arm_math.h ****   q15_t * pCoeffs,
4649:.\Include/arm_math.h ****   q15_t * pState,
4650:.\Include/arm_math.h ****   int32_t * pTapDelay,
4651:.\Include/arm_math.h ****   uint16_t maxDelay,
4652:.\Include/arm_math.h ****   uint32_t blockSize);
4653:.\Include/arm_math.h **** 
4654:.\Include/arm_math.h **** 
4655:.\Include/arm_math.h ****   /**
4656:.\Include/arm_math.h ****    * @brief Processing function for the Q7 sparse FIR filter.
4657:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
4658:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4659:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4660:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4661:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4662:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4663:.\Include/arm_math.h ****    */
4664:.\Include/arm_math.h ****   void arm_fir_sparse_q7(
4665:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4666:.\Include/arm_math.h ****   q7_t * pSrc,
4667:.\Include/arm_math.h ****   q7_t * pDst,
4668:.\Include/arm_math.h ****   q7_t * pScratchIn,
4669:.\Include/arm_math.h ****   q31_t * pScratchOut,
4670:.\Include/arm_math.h ****   uint32_t blockSize);
4671:.\Include/arm_math.h **** 
4672:.\Include/arm_math.h **** 
4673:.\Include/arm_math.h ****   /**
4674:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 sparse FIR filter.
4675:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
4676:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4677:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4678:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4679:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4680:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4681:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 87


4682:.\Include/arm_math.h ****    */
4683:.\Include/arm_math.h ****   void arm_fir_sparse_init_q7(
4684:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4685:.\Include/arm_math.h ****   uint16_t numTaps,
4686:.\Include/arm_math.h ****   q7_t * pCoeffs,
4687:.\Include/arm_math.h ****   q7_t * pState,
4688:.\Include/arm_math.h ****   int32_t * pTapDelay,
4689:.\Include/arm_math.h ****   uint16_t maxDelay,
4690:.\Include/arm_math.h ****   uint32_t blockSize);
4691:.\Include/arm_math.h **** 
4692:.\Include/arm_math.h **** 
4693:.\Include/arm_math.h ****   /**
4694:.\Include/arm_math.h ****    * @brief  Floating-point sin_cos function.
4695:.\Include/arm_math.h ****    * @param[in]  theta   input value in degrees
4696:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4697:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cos output.
4698:.\Include/arm_math.h ****    */
4699:.\Include/arm_math.h ****   void arm_sin_cos_f32(
4700:.\Include/arm_math.h ****   float32_t theta,
4701:.\Include/arm_math.h ****   float32_t * pSinVal,
4702:.\Include/arm_math.h ****   float32_t * pCosVal);
4703:.\Include/arm_math.h **** 
4704:.\Include/arm_math.h **** 
4705:.\Include/arm_math.h ****   /**
4706:.\Include/arm_math.h ****    * @brief  Q31 sin_cos function.
4707:.\Include/arm_math.h ****    * @param[in]  theta    scaled input value in degrees
4708:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4709:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cosine output.
4710:.\Include/arm_math.h ****    */
4711:.\Include/arm_math.h ****   void arm_sin_cos_q31(
4712:.\Include/arm_math.h ****   q31_t theta,
4713:.\Include/arm_math.h ****   q31_t * pSinVal,
4714:.\Include/arm_math.h ****   q31_t * pCosVal);
4715:.\Include/arm_math.h **** 
4716:.\Include/arm_math.h **** 
4717:.\Include/arm_math.h ****   /**
4718:.\Include/arm_math.h ****    * @brief  Floating-point complex conjugate.
4719:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4720:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4721:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4722:.\Include/arm_math.h ****    */
4723:.\Include/arm_math.h ****   void arm_cmplx_conj_f32(
4724:.\Include/arm_math.h ****   float32_t * pSrc,
4725:.\Include/arm_math.h ****   float32_t * pDst,
4726:.\Include/arm_math.h ****   uint32_t numSamples);
4727:.\Include/arm_math.h **** 
4728:.\Include/arm_math.h ****   /**
4729:.\Include/arm_math.h ****    * @brief  Q31 complex conjugate.
4730:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4731:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4732:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4733:.\Include/arm_math.h ****    */
4734:.\Include/arm_math.h ****   void arm_cmplx_conj_q31(
4735:.\Include/arm_math.h ****   q31_t * pSrc,
4736:.\Include/arm_math.h ****   q31_t * pDst,
4737:.\Include/arm_math.h ****   uint32_t numSamples);
4738:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 88


4739:.\Include/arm_math.h **** 
4740:.\Include/arm_math.h ****   /**
4741:.\Include/arm_math.h ****    * @brief  Q15 complex conjugate.
4742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4743:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4744:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4745:.\Include/arm_math.h ****    */
4746:.\Include/arm_math.h ****   void arm_cmplx_conj_q15(
4747:.\Include/arm_math.h ****   q15_t * pSrc,
4748:.\Include/arm_math.h ****   q15_t * pDst,
4749:.\Include/arm_math.h ****   uint32_t numSamples);
4750:.\Include/arm_math.h **** 
4751:.\Include/arm_math.h **** 
4752:.\Include/arm_math.h ****   /**
4753:.\Include/arm_math.h ****    * @brief  Floating-point complex magnitude squared
4754:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4755:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4756:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4757:.\Include/arm_math.h ****    */
4758:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_f32(
4759:.\Include/arm_math.h ****   float32_t * pSrc,
4760:.\Include/arm_math.h ****   float32_t * pDst,
4761:.\Include/arm_math.h ****   uint32_t numSamples);
4762:.\Include/arm_math.h **** 
4763:.\Include/arm_math.h **** 
4764:.\Include/arm_math.h ****   /**
4765:.\Include/arm_math.h ****    * @brief  Q31 complex magnitude squared
4766:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4767:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4768:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4769:.\Include/arm_math.h ****    */
4770:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q31(
4771:.\Include/arm_math.h ****   q31_t * pSrc,
4772:.\Include/arm_math.h ****   q31_t * pDst,
4773:.\Include/arm_math.h ****   uint32_t numSamples);
4774:.\Include/arm_math.h **** 
4775:.\Include/arm_math.h **** 
4776:.\Include/arm_math.h ****   /**
4777:.\Include/arm_math.h ****    * @brief  Q15 complex magnitude squared
4778:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4779:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4780:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4781:.\Include/arm_math.h ****    */
4782:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q15(
4783:.\Include/arm_math.h ****   q15_t * pSrc,
4784:.\Include/arm_math.h ****   q15_t * pDst,
4785:.\Include/arm_math.h ****   uint32_t numSamples);
4786:.\Include/arm_math.h **** 
4787:.\Include/arm_math.h **** 
4788:.\Include/arm_math.h ****  /**
4789:.\Include/arm_math.h ****    * @ingroup groupController
4790:.\Include/arm_math.h ****    */
4791:.\Include/arm_math.h **** 
4792:.\Include/arm_math.h ****   /**
4793:.\Include/arm_math.h ****    * @defgroup PID PID Motor Control
4794:.\Include/arm_math.h ****    *
4795:.\Include/arm_math.h ****    * A Proportional Integral Derivative (PID) controller is a generic feedback control
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 89


4796:.\Include/arm_math.h ****    * loop mechanism widely used in industrial control systems.
4797:.\Include/arm_math.h ****    * A PID controller is the most commonly used type of feedback controller.
4798:.\Include/arm_math.h ****    *
4799:.\Include/arm_math.h ****    * This set of functions implements (PID) controllers
4800:.\Include/arm_math.h ****    * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
4801:.\Include/arm_math.h ****    * of data and each call to the function returns a single processed value.
4802:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
4803:.\Include/arm_math.h ****    * is the input sample value. The functions return the output value.
4804:.\Include/arm_math.h ****    *
4805:.\Include/arm_math.h ****    * \par Algorithm:
4806:.\Include/arm_math.h ****    * <pre>
4807:.\Include/arm_math.h ****    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
4808:.\Include/arm_math.h ****    *    A0 = Kp + Ki + Kd
4809:.\Include/arm_math.h ****    *    A1 = (-Kp ) - (2 * Kd )
4810:.\Include/arm_math.h ****    *    A2 = Kd  </pre>
4811:.\Include/arm_math.h ****    *
4812:.\Include/arm_math.h ****    * \par
4813:.\Include/arm_math.h ****    * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative const
4814:.\Include/arm_math.h ****    *
4815:.\Include/arm_math.h ****    * \par
4816:.\Include/arm_math.h ****    * \image html PID.gif "Proportional Integral Derivative Controller"
4817:.\Include/arm_math.h ****    *
4818:.\Include/arm_math.h ****    * \par
4819:.\Include/arm_math.h ****    * The PID controller calculates an "error" value as the difference between
4820:.\Include/arm_math.h ****    * the measured output and the reference input.
4821:.\Include/arm_math.h ****    * The controller attempts to minimize the error by adjusting the process control inputs.
4822:.\Include/arm_math.h ****    * The proportional value determines the reaction to the current error,
4823:.\Include/arm_math.h ****    * the integral value determines the reaction based on the sum of recent errors,
4824:.\Include/arm_math.h ****    * and the derivative value determines the reaction based on the rate at which the error has been
4825:.\Include/arm_math.h ****    *
4826:.\Include/arm_math.h ****    * \par Instance Structure
4827:.\Include/arm_math.h ****    * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instan
4828:.\Include/arm_math.h ****    * A separate instance structure must be defined for each PID Controller.
4829:.\Include/arm_math.h ****    * There are separate instance structure declarations for each of the 3 supported data types.
4830:.\Include/arm_math.h ****    *
4831:.\Include/arm_math.h ****    * \par Reset Functions
4832:.\Include/arm_math.h ****    * There is also an associated reset function for each data type which clears the state array.
4833:.\Include/arm_math.h ****    *
4834:.\Include/arm_math.h ****    * \par Initialization Functions
4835:.\Include/arm_math.h ****    * There is also an associated initialization function for each data type.
4836:.\Include/arm_math.h ****    * The initialization function performs the following operations:
4837:.\Include/arm_math.h ****    * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
4838:.\Include/arm_math.h ****    * - Zeros out the values in the state buffer.
4839:.\Include/arm_math.h ****    *
4840:.\Include/arm_math.h ****    * \par
4841:.\Include/arm_math.h ****    * Instance structure cannot be placed into a const data section and it is recommended to use the
4842:.\Include/arm_math.h ****    *
4843:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
4844:.\Include/arm_math.h ****    * Care must be taken when using the fixed-point versions of the PID Controller functions.
4845:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used in each function m
4846:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4847:.\Include/arm_math.h ****    */
4848:.\Include/arm_math.h **** 
4849:.\Include/arm_math.h ****   /**
4850:.\Include/arm_math.h ****    * @addtogroup PID
4851:.\Include/arm_math.h ****    * @{
4852:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 90


4853:.\Include/arm_math.h **** 
4854:.\Include/arm_math.h ****   /**
4855:.\Include/arm_math.h ****    * @brief  Process function for the floating-point PID Control.
4856:.\Include/arm_math.h ****    * @param[in,out] S   is an instance of the floating-point PID Control structure
4857:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4858:.\Include/arm_math.h ****    * @return out processed output sample.
4859:.\Include/arm_math.h ****    */
4860:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_pid_f32(
4861:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
4862:.\Include/arm_math.h ****   float32_t in)
4863:.\Include/arm_math.h ****   {
4864:.\Include/arm_math.h ****     float32_t out;
4865:.\Include/arm_math.h **** 
4866:.\Include/arm_math.h ****     /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
4867:.\Include/arm_math.h ****     out = (S->A0 * in) +
4868:.\Include/arm_math.h ****       (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
4869:.\Include/arm_math.h **** 
4870:.\Include/arm_math.h ****     /* Update state */
4871:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4872:.\Include/arm_math.h ****     S->state[0] = in;
4873:.\Include/arm_math.h ****     S->state[2] = out;
4874:.\Include/arm_math.h **** 
4875:.\Include/arm_math.h ****     /* return to application */
4876:.\Include/arm_math.h ****     return (out);
4877:.\Include/arm_math.h **** 
4878:.\Include/arm_math.h ****   }
4879:.\Include/arm_math.h **** 
4880:.\Include/arm_math.h ****   /**
4881:.\Include/arm_math.h ****    * @brief  Process function for the Q31 PID Control.
4882:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the Q31 PID Control structure
4883:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4884:.\Include/arm_math.h ****    * @return out processed output sample.
4885:.\Include/arm_math.h ****    *
4886:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4887:.\Include/arm_math.h ****    * \par
4888:.\Include/arm_math.h ****    * The function is implemented using an internal 64-bit accumulator.
4889:.\Include/arm_math.h ****    * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplicat
4890:.\Include/arm_math.h ****    * Thus, if the accumulator result overflows it wraps around rather than clip.
4891:.\Include/arm_math.h ****    * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there
4892:.\Include/arm_math.h ****    * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format
4893:.\Include/arm_math.h ****    */
4894:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_pid_q31(
4895:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
4896:.\Include/arm_math.h ****   q31_t in)
4897:.\Include/arm_math.h ****   {
4898:.\Include/arm_math.h ****     q63_t acc;
4899:.\Include/arm_math.h ****     q31_t out;
4900:.\Include/arm_math.h **** 
4901:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4902:.\Include/arm_math.h ****     acc = (q63_t) S->A0 * in;
4903:.\Include/arm_math.h **** 
4904:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] */
4905:.\Include/arm_math.h ****     acc += (q63_t) S->A1 * S->state[0];
4906:.\Include/arm_math.h **** 
4907:.\Include/arm_math.h ****     /* acc += A2 * x[n-2]  */
4908:.\Include/arm_math.h ****     acc += (q63_t) S->A2 * S->state[1];
4909:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 91


4910:.\Include/arm_math.h ****     /* convert output to 1.31 format to add y[n-1] */
4911:.\Include/arm_math.h ****     out = (q31_t) (acc >> 31u);
4912:.\Include/arm_math.h **** 
4913:.\Include/arm_math.h ****     /* out += y[n-1] */
4914:.\Include/arm_math.h ****     out += S->state[2];
4915:.\Include/arm_math.h **** 
4916:.\Include/arm_math.h ****     /* Update state */
4917:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4918:.\Include/arm_math.h ****     S->state[0] = in;
4919:.\Include/arm_math.h ****     S->state[2] = out;
4920:.\Include/arm_math.h **** 
4921:.\Include/arm_math.h ****     /* return to application */
4922:.\Include/arm_math.h ****     return (out);
4923:.\Include/arm_math.h ****   }
4924:.\Include/arm_math.h **** 
4925:.\Include/arm_math.h **** 
4926:.\Include/arm_math.h ****   /**
4927:.\Include/arm_math.h ****    * @brief  Process function for the Q15 PID Control.
4928:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q15 PID Control structure
4929:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4930:.\Include/arm_math.h ****    * @return out processed output sample.
4931:.\Include/arm_math.h ****    *
4932:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4933:.\Include/arm_math.h ****    * \par
4934:.\Include/arm_math.h ****    * The function is implemented using a 64-bit internal accumulator.
4935:.\Include/arm_math.h ****    * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30
4936:.\Include/arm_math.h ****    * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
4937:.\Include/arm_math.h ****    * There is no risk of internal overflow with this approach and the full precision of intermediat
4938:.\Include/arm_math.h ****    * After all additions have been performed, the accumulator is truncated to 34.15 format by disca
4939:.\Include/arm_math.h ****    * Lastly, the accumulator is saturated to yield a result in 1.15 format.
4940:.\Include/arm_math.h ****    */
4941:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_pid_q15(
4942:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
4943:.\Include/arm_math.h ****   q15_t in)
4944:.\Include/arm_math.h ****   {
4945:.\Include/arm_math.h ****     q63_t acc;
4946:.\Include/arm_math.h ****     q15_t out;
4947:.\Include/arm_math.h **** 
4948:.\Include/arm_math.h **** #if defined (ARM_MATH_DSP)
4949:.\Include/arm_math.h ****     __SIMD32_TYPE *vstate;
4950:.\Include/arm_math.h **** 
4951:.\Include/arm_math.h ****     /* Implementation of PID controller */
4952:.\Include/arm_math.h **** 
4953:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4954:.\Include/arm_math.h ****     acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
4955:.\Include/arm_math.h **** 
4956:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4957:.\Include/arm_math.h ****     vstate = __SIMD32_CONST(S->state);
4958:.\Include/arm_math.h ****     acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
4959:.\Include/arm_math.h **** #else
4960:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4961:.\Include/arm_math.h ****     acc = ((q31_t) S->A0) * in;
4962:.\Include/arm_math.h **** 
4963:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4964:.\Include/arm_math.h ****     acc += (q31_t) S->A1 * S->state[0];
4965:.\Include/arm_math.h ****     acc += (q31_t) S->A2 * S->state[1];
4966:.\Include/arm_math.h **** #endif
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 92


4967:.\Include/arm_math.h **** 
4968:.\Include/arm_math.h ****     /* acc += y[n-1] */
4969:.\Include/arm_math.h ****     acc += (q31_t) S->state[2] << 15;
4970:.\Include/arm_math.h **** 
4971:.\Include/arm_math.h ****     /* saturate the output */
4972:.\Include/arm_math.h ****     out = (q15_t) (__SSAT((acc >> 15), 16));
4973:.\Include/arm_math.h **** 
4974:.\Include/arm_math.h ****     /* Update state */
4975:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4976:.\Include/arm_math.h ****     S->state[0] = in;
4977:.\Include/arm_math.h ****     S->state[2] = out;
4978:.\Include/arm_math.h **** 
4979:.\Include/arm_math.h ****     /* return to application */
4980:.\Include/arm_math.h ****     return (out);
4981:.\Include/arm_math.h ****   }
4982:.\Include/arm_math.h **** 
4983:.\Include/arm_math.h ****   /**
4984:.\Include/arm_math.h ****    * @} end of PID group
4985:.\Include/arm_math.h ****    */
4986:.\Include/arm_math.h **** 
4987:.\Include/arm_math.h **** 
4988:.\Include/arm_math.h ****   /**
4989:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
4990:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4991:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4992:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4993:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4994:.\Include/arm_math.h ****    */
4995:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f32(
4996:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * src,
4997:.\Include/arm_math.h ****   arm_matrix_instance_f32 * dst);
4998:.\Include/arm_math.h **** 
4999:.\Include/arm_math.h **** 
5000:.\Include/arm_math.h ****   /**
5001:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
5002:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
5003:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
5004:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
5005:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
5006:.\Include/arm_math.h ****    */
5007:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f64(
5008:.\Include/arm_math.h ****   const arm_matrix_instance_f64 * src,
5009:.\Include/arm_math.h ****   arm_matrix_instance_f64 * dst);
5010:.\Include/arm_math.h **** 
5011:.\Include/arm_math.h **** 
5012:.\Include/arm_math.h **** 
5013:.\Include/arm_math.h ****   /**
5014:.\Include/arm_math.h ****    * @ingroup groupController
5015:.\Include/arm_math.h ****    */
5016:.\Include/arm_math.h **** 
5017:.\Include/arm_math.h ****   /**
5018:.\Include/arm_math.h ****    * @defgroup clarke Vector Clarke Transform
5019:.\Include/arm_math.h ****    * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time i
5020:.\Include/arm_math.h ****    * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calcula
5021:.\Include/arm_math.h ****    * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
5022:.\Include/arm_math.h ****    * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
5023:.\Include/arm_math.h ****    * \image html clarke.gif Stator current space vector and its components in (a,b).
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 93


5024:.\Include/arm_math.h ****    * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code
5025:.\Include/arm_math.h ****    * can be calculated using only <code>Ia</code> and <code>Ib</code>.
5026:.\Include/arm_math.h ****    *
5027:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5028:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5029:.\Include/arm_math.h ****    * \par Algorithm
5030:.\Include/arm_math.h ****    * \image html clarkeFormula.gif
5031:.\Include/arm_math.h ****    * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
5032:.\Include/arm_math.h ****    * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
5033:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5034:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5035:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5036:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5037:.\Include/arm_math.h ****    */
5038:.\Include/arm_math.h **** 
5039:.\Include/arm_math.h ****   /**
5040:.\Include/arm_math.h ****    * @addtogroup clarke
5041:.\Include/arm_math.h ****    * @{
5042:.\Include/arm_math.h ****    */
5043:.\Include/arm_math.h **** 
5044:.\Include/arm_math.h ****   /**
5045:.\Include/arm_math.h ****    *
5046:.\Include/arm_math.h ****    * @brief  Floating-point Clarke transform
5047:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5048:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5049:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5050:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5051:.\Include/arm_math.h ****    */
5052:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_f32(
5053:.\Include/arm_math.h ****   float32_t Ia,
5054:.\Include/arm_math.h ****   float32_t Ib,
5055:.\Include/arm_math.h ****   float32_t * pIalpha,
5056:.\Include/arm_math.h ****   float32_t * pIbeta)
5057:.\Include/arm_math.h ****   {
5058:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Ia */
5059:.\Include/arm_math.h ****     *pIalpha = Ia;
5060:.\Include/arm_math.h **** 
5061:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
5062:.\Include/arm_math.h ****     *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
5063:.\Include/arm_math.h ****   }
5064:.\Include/arm_math.h **** 
5065:.\Include/arm_math.h **** 
5066:.\Include/arm_math.h ****   /**
5067:.\Include/arm_math.h ****    * @brief  Clarke transform for Q31 version
5068:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5069:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5070:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5071:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5072:.\Include/arm_math.h ****    *
5073:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5074:.\Include/arm_math.h ****    * \par
5075:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5076:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5077:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5078:.\Include/arm_math.h ****    */
5079:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_q31(
5080:.\Include/arm_math.h ****   q31_t Ia,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 94


5081:.\Include/arm_math.h ****   q31_t Ib,
5082:.\Include/arm_math.h ****   q31_t * pIalpha,
5083:.\Include/arm_math.h ****   q31_t * pIbeta)
5084:.\Include/arm_math.h ****   {
5085:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5086:.\Include/arm_math.h **** 
5087:.\Include/arm_math.h ****     /* Calculating pIalpha from Ia by equation pIalpha = Ia */
5088:.\Include/arm_math.h ****     *pIalpha = Ia;
5089:.\Include/arm_math.h **** 
5090:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
5091:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
5092:.\Include/arm_math.h **** 
5093:.\Include/arm_math.h ****     /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
5094:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
5095:.\Include/arm_math.h **** 
5096:.\Include/arm_math.h ****     /* pIbeta is calculated by adding the intermediate products */
5097:.\Include/arm_math.h ****     *pIbeta = __QADD(product1, product2);
5098:.\Include/arm_math.h ****   }
5099:.\Include/arm_math.h **** 
5100:.\Include/arm_math.h ****   /**
5101:.\Include/arm_math.h ****    * @} end of clarke group
5102:.\Include/arm_math.h ****    */
5103:.\Include/arm_math.h **** 
5104:.\Include/arm_math.h ****   /**
5105:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q31 vector.
5106:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5107:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5108:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5109:.\Include/arm_math.h ****    */
5110:.\Include/arm_math.h ****   void arm_q7_to_q31(
5111:.\Include/arm_math.h ****   q7_t * pSrc,
5112:.\Include/arm_math.h ****   q31_t * pDst,
5113:.\Include/arm_math.h ****   uint32_t blockSize);
5114:.\Include/arm_math.h **** 
5115:.\Include/arm_math.h **** 
5116:.\Include/arm_math.h **** 
5117:.\Include/arm_math.h ****   /**
5118:.\Include/arm_math.h ****    * @ingroup groupController
5119:.\Include/arm_math.h ****    */
5120:.\Include/arm_math.h **** 
5121:.\Include/arm_math.h ****   /**
5122:.\Include/arm_math.h ****    * @defgroup inv_clarke Vector Inverse Clarke Transform
5123:.\Include/arm_math.h ****    * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous 
5124:.\Include/arm_math.h ****    *
5125:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5126:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5127:.\Include/arm_math.h ****    * \par Algorithm
5128:.\Include/arm_math.h ****    * \image html clarkeInvFormula.gif
5129:.\Include/arm_math.h ****    * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
5130:.\Include/arm_math.h ****    * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
5131:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5132:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5133:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5134:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5135:.\Include/arm_math.h ****    */
5136:.\Include/arm_math.h **** 
5137:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 95


5138:.\Include/arm_math.h ****    * @addtogroup inv_clarke
5139:.\Include/arm_math.h ****    * @{
5140:.\Include/arm_math.h ****    */
5141:.\Include/arm_math.h **** 
5142:.\Include/arm_math.h ****    /**
5143:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Clarke transform
5144:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5145:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5146:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5147:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5148:.\Include/arm_math.h ****    */
5149:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_f32(
5150:.\Include/arm_math.h ****   float32_t Ialpha,
5151:.\Include/arm_math.h ****   float32_t Ibeta,
5152:.\Include/arm_math.h ****   float32_t * pIa,
5153:.\Include/arm_math.h ****   float32_t * pIb)
5154:.\Include/arm_math.h ****   {
5155:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5156:.\Include/arm_math.h ****     *pIa = Ialpha;
5157:.\Include/arm_math.h **** 
5158:.\Include/arm_math.h ****     /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibet
5159:.\Include/arm_math.h ****     *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
5160:.\Include/arm_math.h ****   }
5161:.\Include/arm_math.h **** 
5162:.\Include/arm_math.h **** 
5163:.\Include/arm_math.h ****   /**
5164:.\Include/arm_math.h ****    * @brief  Inverse Clarke transform for Q31 version
5165:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5166:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5167:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5168:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5169:.\Include/arm_math.h ****    *
5170:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5171:.\Include/arm_math.h ****    * \par
5172:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5173:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5174:.\Include/arm_math.h ****    * There is saturation on the subtraction, hence there is no risk of overflow.
5175:.\Include/arm_math.h ****    */
5176:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_q31(
5177:.\Include/arm_math.h ****   q31_t Ialpha,
5178:.\Include/arm_math.h ****   q31_t Ibeta,
5179:.\Include/arm_math.h ****   q31_t * pIa,
5180:.\Include/arm_math.h ****   q31_t * pIb)
5181:.\Include/arm_math.h ****   {
5182:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5183:.\Include/arm_math.h **** 
5184:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5185:.\Include/arm_math.h ****     *pIa = Ialpha;
5186:.\Include/arm_math.h **** 
5187:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
5188:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
5189:.\Include/arm_math.h **** 
5190:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
5191:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
5192:.\Include/arm_math.h **** 
5193:.\Include/arm_math.h ****     /* pIb is calculated by subtracting the products */
5194:.\Include/arm_math.h ****     *pIb = __QSUB(product2, product1);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 96


5195:.\Include/arm_math.h ****   }
5196:.\Include/arm_math.h **** 
5197:.\Include/arm_math.h ****   /**
5198:.\Include/arm_math.h ****    * @} end of inv_clarke group
5199:.\Include/arm_math.h ****    */
5200:.\Include/arm_math.h **** 
5201:.\Include/arm_math.h ****   /**
5202:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q15 vector.
5203:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5204:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5205:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5206:.\Include/arm_math.h ****    */
5207:.\Include/arm_math.h ****   void arm_q7_to_q15(
5208:.\Include/arm_math.h ****   q7_t * pSrc,
5209:.\Include/arm_math.h ****   q15_t * pDst,
5210:.\Include/arm_math.h ****   uint32_t blockSize);
5211:.\Include/arm_math.h **** 
5212:.\Include/arm_math.h **** 
5213:.\Include/arm_math.h **** 
5214:.\Include/arm_math.h ****   /**
5215:.\Include/arm_math.h ****    * @ingroup groupController
5216:.\Include/arm_math.h ****    */
5217:.\Include/arm_math.h **** 
5218:.\Include/arm_math.h ****   /**
5219:.\Include/arm_math.h ****    * @defgroup park Vector Park Transform
5220:.\Include/arm_math.h ****    *
5221:.\Include/arm_math.h ****    * Forward Park transform converts the input two-coordinate vector to flux and torque components.
5222:.\Include/arm_math.h ****    * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and th
5223:.\Include/arm_math.h ****    * from the stationary to the moving reference frame and control the spatial relationship between
5224:.\Include/arm_math.h ****    * the stator vector current and rotor flux vector.
5225:.\Include/arm_math.h ****    * If we consider the d axis aligned with the rotor flux, the diagram below shows the
5226:.\Include/arm_math.h ****    * current vector and the relationship from the two reference frames:
5227:.\Include/arm_math.h ****    * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q ro
5228:.\Include/arm_math.h ****    *
5229:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5230:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5231:.\Include/arm_math.h ****    * \par Algorithm
5232:.\Include/arm_math.h ****    * \image html parkFormula.gif
5233:.\Include/arm_math.h ****    * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
5234:.\Include/arm_math.h ****    * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and 
5235:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5236:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5237:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5238:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5239:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5240:.\Include/arm_math.h ****    */
5241:.\Include/arm_math.h **** 
5242:.\Include/arm_math.h ****   /**
5243:.\Include/arm_math.h ****    * @addtogroup park
5244:.\Include/arm_math.h ****    * @{
5245:.\Include/arm_math.h ****    */
5246:.\Include/arm_math.h **** 
5247:.\Include/arm_math.h ****   /**
5248:.\Include/arm_math.h ****    * @brief Floating-point Park transform
5249:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5250:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5251:.\Include/arm_math.h ****    * @param[out] pId     points to output   rotor reference frame d
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 97


5252:.\Include/arm_math.h ****    * @param[out] pIq     points to output   rotor reference frame q
5253:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5254:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5255:.\Include/arm_math.h ****    *
5256:.\Include/arm_math.h ****    * The function implements the forward Park transform.
5257:.\Include/arm_math.h ****    *
5258:.\Include/arm_math.h ****    */
5259:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_f32(
5260:.\Include/arm_math.h ****   float32_t Ialpha,
5261:.\Include/arm_math.h ****   float32_t Ibeta,
5262:.\Include/arm_math.h ****   float32_t * pId,
5263:.\Include/arm_math.h ****   float32_t * pIq,
5264:.\Include/arm_math.h ****   float32_t sinVal,
5265:.\Include/arm_math.h ****   float32_t cosVal)
5266:.\Include/arm_math.h ****   {
5267:.\Include/arm_math.h ****     /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
5268:.\Include/arm_math.h ****     *pId = Ialpha * cosVal + Ibeta * sinVal;
5269:.\Include/arm_math.h **** 
5270:.\Include/arm_math.h ****     /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
5271:.\Include/arm_math.h ****     *pIq = -Ialpha * sinVal + Ibeta * cosVal;
5272:.\Include/arm_math.h ****   }
5273:.\Include/arm_math.h **** 
5274:.\Include/arm_math.h **** 
5275:.\Include/arm_math.h ****   /**
5276:.\Include/arm_math.h ****    * @brief  Park transform for Q31 version
5277:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5278:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5279:.\Include/arm_math.h ****    * @param[out] pId     points to output rotor reference frame d
5280:.\Include/arm_math.h ****    * @param[out] pIq     points to output rotor reference frame q
5281:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5282:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5283:.\Include/arm_math.h ****    *
5284:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5285:.\Include/arm_math.h ****    * \par
5286:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5287:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5288:.\Include/arm_math.h ****    * There is saturation on the addition and subtraction, hence there is no risk of overflow.
5289:.\Include/arm_math.h ****    */
5290:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_q31(
5291:.\Include/arm_math.h ****   q31_t Ialpha,
5292:.\Include/arm_math.h ****   q31_t Ibeta,
5293:.\Include/arm_math.h ****   q31_t * pId,
5294:.\Include/arm_math.h ****   q31_t * pIq,
5295:.\Include/arm_math.h ****   q31_t sinVal,
5296:.\Include/arm_math.h ****   q31_t cosVal)
5297:.\Include/arm_math.h ****   {
5298:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5299:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5300:.\Include/arm_math.h **** 
5301:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * cosVal) */
5302:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
5303:.\Include/arm_math.h **** 
5304:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * sinVal) */
5305:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
5306:.\Include/arm_math.h **** 
5307:.\Include/arm_math.h **** 
5308:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * sinVal) */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 98


5309:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
5310:.\Include/arm_math.h **** 
5311:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * cosVal) */
5312:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
5313:.\Include/arm_math.h **** 
5314:.\Include/arm_math.h ****     /* Calculate pId by adding the two intermediate products 1 and 2 */
5315:.\Include/arm_math.h ****     *pId = __QADD(product1, product2);
5316:.\Include/arm_math.h **** 
5317:.\Include/arm_math.h ****     /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
5318:.\Include/arm_math.h ****     *pIq = __QSUB(product4, product3);
5319:.\Include/arm_math.h ****   }
5320:.\Include/arm_math.h **** 
5321:.\Include/arm_math.h ****   /**
5322:.\Include/arm_math.h ****    * @} end of park group
5323:.\Include/arm_math.h ****    */
5324:.\Include/arm_math.h **** 
5325:.\Include/arm_math.h ****   /**
5326:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to floating-point vector.
5327:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5328:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5329:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5330:.\Include/arm_math.h ****    */
5331:.\Include/arm_math.h ****   void arm_q7_to_float(
5332:.\Include/arm_math.h ****   q7_t * pSrc,
5333:.\Include/arm_math.h ****   float32_t * pDst,
5334:.\Include/arm_math.h ****   uint32_t blockSize);
5335:.\Include/arm_math.h **** 
5336:.\Include/arm_math.h **** 
5337:.\Include/arm_math.h ****   /**
5338:.\Include/arm_math.h ****    * @ingroup groupController
5339:.\Include/arm_math.h ****    */
5340:.\Include/arm_math.h **** 
5341:.\Include/arm_math.h ****   /**
5342:.\Include/arm_math.h ****    * @defgroup inv_park Vector Inverse Park transform
5343:.\Include/arm_math.h ****    * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
5344:.\Include/arm_math.h ****    *
5345:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5346:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5347:.\Include/arm_math.h ****    * \par Algorithm
5348:.\Include/arm_math.h ****    * \image html parkInvFormula.gif
5349:.\Include/arm_math.h ****    * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
5350:.\Include/arm_math.h ****    * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <c
5351:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5352:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5353:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5354:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5355:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5356:.\Include/arm_math.h ****    */
5357:.\Include/arm_math.h **** 
5358:.\Include/arm_math.h ****   /**
5359:.\Include/arm_math.h ****    * @addtogroup inv_park
5360:.\Include/arm_math.h ****    * @{
5361:.\Include/arm_math.h ****    */
5362:.\Include/arm_math.h **** 
5363:.\Include/arm_math.h ****    /**
5364:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Park transform
5365:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 99


5366:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5367:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5368:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5369:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5370:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5371:.\Include/arm_math.h ****    */
5372:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_f32(
5373:.\Include/arm_math.h ****   float32_t Id,
5374:.\Include/arm_math.h ****   float32_t Iq,
5375:.\Include/arm_math.h ****   float32_t * pIalpha,
5376:.\Include/arm_math.h ****   float32_t * pIbeta,
5377:.\Include/arm_math.h ****   float32_t sinVal,
5378:.\Include/arm_math.h ****   float32_t cosVal)
5379:.\Include/arm_math.h ****   {
5380:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
5381:.\Include/arm_math.h ****     *pIalpha = Id * cosVal - Iq * sinVal;
5382:.\Include/arm_math.h **** 
5383:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
5384:.\Include/arm_math.h ****     *pIbeta = Id * sinVal + Iq * cosVal;
5385:.\Include/arm_math.h ****   }
5386:.\Include/arm_math.h **** 
5387:.\Include/arm_math.h **** 
5388:.\Include/arm_math.h ****   /**
5389:.\Include/arm_math.h ****    * @brief  Inverse Park transform for   Q31 version
5390:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5391:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5392:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5393:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5394:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5395:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5396:.\Include/arm_math.h ****    *
5397:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5398:.\Include/arm_math.h ****    * \par
5399:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5400:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5401:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5402:.\Include/arm_math.h ****    */
5403:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_q31(
5404:.\Include/arm_math.h ****   q31_t Id,
5405:.\Include/arm_math.h ****   q31_t Iq,
5406:.\Include/arm_math.h ****   q31_t * pIalpha,
5407:.\Include/arm_math.h ****   q31_t * pIbeta,
5408:.\Include/arm_math.h ****   q31_t sinVal,
5409:.\Include/arm_math.h ****   q31_t cosVal)
5410:.\Include/arm_math.h ****   {
5411:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5412:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5413:.\Include/arm_math.h **** 
5414:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * cosVal) */
5415:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
5416:.\Include/arm_math.h **** 
5417:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * sinVal) */
5418:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
5419:.\Include/arm_math.h **** 
5420:.\Include/arm_math.h **** 
5421:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * sinVal) */
5422:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 100


5423:.\Include/arm_math.h **** 
5424:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * cosVal) */
5425:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
5426:.\Include/arm_math.h **** 
5427:.\Include/arm_math.h ****     /* Calculate pIalpha by using the two intermediate products 1 and 2 */
5428:.\Include/arm_math.h ****     *pIalpha = __QSUB(product1, product2);
5429:.\Include/arm_math.h **** 
5430:.\Include/arm_math.h ****     /* Calculate pIbeta by using the two intermediate products 3 and 4 */
5431:.\Include/arm_math.h ****     *pIbeta = __QADD(product4, product3);
5432:.\Include/arm_math.h ****   }
5433:.\Include/arm_math.h **** 
5434:.\Include/arm_math.h ****   /**
5435:.\Include/arm_math.h ****    * @} end of Inverse park group
5436:.\Include/arm_math.h ****    */
5437:.\Include/arm_math.h **** 
5438:.\Include/arm_math.h **** 
5439:.\Include/arm_math.h ****   /**
5440:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q31 vector to floating-point vector.
5441:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5442:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5443:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5444:.\Include/arm_math.h ****    */
5445:.\Include/arm_math.h ****   void arm_q31_to_float(
5446:.\Include/arm_math.h ****   q31_t * pSrc,
5447:.\Include/arm_math.h ****   float32_t * pDst,
5448:.\Include/arm_math.h ****   uint32_t blockSize);
5449:.\Include/arm_math.h **** 
5450:.\Include/arm_math.h ****   /**
5451:.\Include/arm_math.h ****    * @ingroup groupInterpolation
5452:.\Include/arm_math.h ****    */
5453:.\Include/arm_math.h **** 
5454:.\Include/arm_math.h ****   /**
5455:.\Include/arm_math.h ****    * @defgroup LinearInterpolate Linear Interpolation
5456:.\Include/arm_math.h ****    *
5457:.\Include/arm_math.h ****    * Linear interpolation is a method of curve fitting using linear polynomials.
5458:.\Include/arm_math.h ****    * Linear interpolation works by effectively drawing a straight line between two neighboring samp
5459:.\Include/arm_math.h ****    *
5460:.\Include/arm_math.h ****    * \par
5461:.\Include/arm_math.h ****    * \image html LinearInterp.gif "Linear interpolation"
5462:.\Include/arm_math.h ****    *
5463:.\Include/arm_math.h ****    * \par
5464:.\Include/arm_math.h ****    * A  Linear Interpolate function calculates an output value(y), for the input(x)
5465:.\Include/arm_math.h ****    * using linear interpolation of the input values x0, x1( nearest input values) and the output va
5466:.\Include/arm_math.h ****    *
5467:.\Include/arm_math.h ****    * \par Algorithm:
5468:.\Include/arm_math.h ****    * <pre>
5469:.\Include/arm_math.h ****    *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
5470:.\Include/arm_math.h ****    *       where x0, x1 are nearest values of input x
5471:.\Include/arm_math.h ****    *             y0, y1 are nearest values to output y
5472:.\Include/arm_math.h ****    * </pre>
5473:.\Include/arm_math.h ****    *
5474:.\Include/arm_math.h ****    * \par
5475:.\Include/arm_math.h ****    * This set of functions implements Linear interpolation process
5476:.\Include/arm_math.h ****    * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
5477:.\Include/arm_math.h ****    * sample of data and each call to the function returns a single processed value.
5478:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the Linear Interpolate function data structure.
5479:.\Include/arm_math.h ****    * <code>x</code> is the input sample value. The functions returns the output value.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 101


5480:.\Include/arm_math.h ****    *
5481:.\Include/arm_math.h ****    * \par
5482:.\Include/arm_math.h ****    * if x is outside of the table boundary, Linear interpolation returns first value of the table
5483:.\Include/arm_math.h ****    * if x is below input range and returns last value of table if x is above range.
5484:.\Include/arm_math.h ****    */
5485:.\Include/arm_math.h **** 
5486:.\Include/arm_math.h ****   /**
5487:.\Include/arm_math.h ****    * @addtogroup LinearInterpolate
5488:.\Include/arm_math.h ****    * @{
5489:.\Include/arm_math.h ****    */
5490:.\Include/arm_math.h **** 
5491:.\Include/arm_math.h ****   /**
5492:.\Include/arm_math.h ****    * @brief  Process function for the floating-point Linear Interpolation Function.
5493:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
5494:.\Include/arm_math.h ****    * @param[in]     x  input sample to process
5495:.\Include/arm_math.h ****    * @return y processed output sample.
5496:.\Include/arm_math.h ****    *
5497:.\Include/arm_math.h ****    */
5498:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_linear_interp_f32(
5499:.\Include/arm_math.h ****   arm_linear_interp_instance_f32 * S,
5500:.\Include/arm_math.h ****   float32_t x)
5501:.\Include/arm_math.h ****   {
5502:.\Include/arm_math.h ****     float32_t y;
5503:.\Include/arm_math.h ****     float32_t x0, x1;                            /* Nearest input values */
5504:.\Include/arm_math.h ****     float32_t y0, y1;                            /* Nearest output values */
5505:.\Include/arm_math.h ****     float32_t xSpacing = S->xSpacing;            /* spacing between input values */
5506:.\Include/arm_math.h ****     int32_t i;                                   /* Index variable */
5507:.\Include/arm_math.h ****     float32_t *pYData = S->pYData;               /* pointer to output table */
5508:.\Include/arm_math.h **** 
5509:.\Include/arm_math.h ****     /* Calculation of index */
5510:.\Include/arm_math.h ****     i = (int32_t) ((x - S->x1) / xSpacing);
5511:.\Include/arm_math.h **** 
5512:.\Include/arm_math.h ****     if (i < 0)
5513:.\Include/arm_math.h ****     {
5514:.\Include/arm_math.h ****       /* Iniatilize output for below specified range as least output value of table */
5515:.\Include/arm_math.h ****       y = pYData[0];
5516:.\Include/arm_math.h ****     }
5517:.\Include/arm_math.h ****     else if ((uint32_t)i >= S->nValues)
5518:.\Include/arm_math.h ****     {
5519:.\Include/arm_math.h ****       /* Iniatilize output for above specified range as last output value of table */
5520:.\Include/arm_math.h ****       y = pYData[S->nValues - 1];
5521:.\Include/arm_math.h ****     }
5522:.\Include/arm_math.h ****     else
5523:.\Include/arm_math.h ****     {
5524:.\Include/arm_math.h ****       /* Calculation of nearest input values */
5525:.\Include/arm_math.h ****       x0 = S->x1 +  i      * xSpacing;
5526:.\Include/arm_math.h ****       x1 = S->x1 + (i + 1) * xSpacing;
5527:.\Include/arm_math.h **** 
5528:.\Include/arm_math.h ****       /* Read of nearest output values */
5529:.\Include/arm_math.h ****       y0 = pYData[i];
5530:.\Include/arm_math.h ****       y1 = pYData[i + 1];
5531:.\Include/arm_math.h **** 
5532:.\Include/arm_math.h ****       /* Calculation of output */
5533:.\Include/arm_math.h ****       y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
5534:.\Include/arm_math.h **** 
5535:.\Include/arm_math.h ****     }
5536:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 102


5537:.\Include/arm_math.h ****     /* returns output value */
5538:.\Include/arm_math.h ****     return (y);
5539:.\Include/arm_math.h ****   }
5540:.\Include/arm_math.h **** 
5541:.\Include/arm_math.h **** 
5542:.\Include/arm_math.h ****    /**
5543:.\Include/arm_math.h ****    *
5544:.\Include/arm_math.h ****    * @brief  Process function for the Q31 Linear Interpolation Function.
5545:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q31 Linear Interpolation table
5546:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5547:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5548:.\Include/arm_math.h ****    * @return y processed output sample.
5549:.\Include/arm_math.h ****    *
5550:.\Include/arm_math.h ****    * \par
5551:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5552:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5553:.\Include/arm_math.h ****    *
5554:.\Include/arm_math.h ****    */
5555:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_linear_interp_q31(
5556:.\Include/arm_math.h ****   q31_t * pYData,
5557:.\Include/arm_math.h ****   q31_t x,
5558:.\Include/arm_math.h ****   uint32_t nValues)
5559:.\Include/arm_math.h ****   {
5560:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5561:.\Include/arm_math.h ****     q31_t y0, y1;                                /* Nearest output values */
5562:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5563:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5564:.\Include/arm_math.h **** 
5565:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5566:.\Include/arm_math.h ****     /* 12 bits for the table index */
5567:.\Include/arm_math.h ****     /* Index value calculation */
5568:.\Include/arm_math.h ****     index = ((x & (q31_t)0xFFF00000) >> 20);
5569:.\Include/arm_math.h **** 
5570:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5571:.\Include/arm_math.h ****     {
5572:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5573:.\Include/arm_math.h ****     }
5574:.\Include/arm_math.h ****     else if (index < 0)
5575:.\Include/arm_math.h ****     {
5576:.\Include/arm_math.h ****       return (pYData[0]);
5577:.\Include/arm_math.h ****     }
5578:.\Include/arm_math.h ****     else
5579:.\Include/arm_math.h ****     {
5580:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5581:.\Include/arm_math.h ****       /* shift left by 11 to keep fract in 1.31 format */
5582:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF) << 11;
5583:.\Include/arm_math.h **** 
5584:.\Include/arm_math.h ****       /* Read two nearest output values from the index in 1.31(q31) format */
5585:.\Include/arm_math.h ****       y0 = pYData[index];
5586:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5587:.\Include/arm_math.h **** 
5588:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 2.30 format */
5589:.\Include/arm_math.h ****       y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
5590:.\Include/arm_math.h **** 
5591:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
5592:.\Include/arm_math.h ****       y += ((q31_t) (((q63_t) y1 * fract) >> 32));
5593:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 103


5594:.\Include/arm_math.h ****       /* Convert y to 1.31 format */
5595:.\Include/arm_math.h ****       return (y << 1u);
5596:.\Include/arm_math.h ****     }
5597:.\Include/arm_math.h ****   }
5598:.\Include/arm_math.h **** 
5599:.\Include/arm_math.h **** 
5600:.\Include/arm_math.h ****   /**
5601:.\Include/arm_math.h ****    *
5602:.\Include/arm_math.h ****    * @brief  Process function for the Q15 Linear Interpolation Function.
5603:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q15 Linear Interpolation table
5604:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5605:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5606:.\Include/arm_math.h ****    * @return y processed output sample.
5607:.\Include/arm_math.h ****    *
5608:.\Include/arm_math.h ****    * \par
5609:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5610:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5611:.\Include/arm_math.h ****    *
5612:.\Include/arm_math.h ****    */
5613:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_linear_interp_q15(
5614:.\Include/arm_math.h ****   q15_t * pYData,
5615:.\Include/arm_math.h ****   q31_t x,
5616:.\Include/arm_math.h ****   uint32_t nValues)
5617:.\Include/arm_math.h ****   {
5618:.\Include/arm_math.h ****     q63_t y;                                     /* output */
5619:.\Include/arm_math.h ****     q15_t y0, y1;                                /* Nearest output values */
5620:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5621:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5622:.\Include/arm_math.h **** 
5623:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5624:.\Include/arm_math.h ****     /* 12 bits for the table index */
5625:.\Include/arm_math.h ****     /* Index value calculation */
5626:.\Include/arm_math.h ****     index = ((x & (int32_t)0xFFF00000) >> 20);
5627:.\Include/arm_math.h **** 
5628:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5629:.\Include/arm_math.h ****     {
5630:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5631:.\Include/arm_math.h ****     }
5632:.\Include/arm_math.h ****     else if (index < 0)
5633:.\Include/arm_math.h ****     {
5634:.\Include/arm_math.h ****       return (pYData[0]);
5635:.\Include/arm_math.h ****     }
5636:.\Include/arm_math.h ****     else
5637:.\Include/arm_math.h ****     {
5638:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5639:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5640:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5641:.\Include/arm_math.h **** 
5642:.\Include/arm_math.h ****       /* Read two nearest output values from the index */
5643:.\Include/arm_math.h ****       y0 = pYData[index];
5644:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5645:.\Include/arm_math.h **** 
5646:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 13.35 format */
5647:.\Include/arm_math.h ****       y = ((q63_t) y0 * (0xFFFFF - fract));
5648:.\Include/arm_math.h **** 
5649:.\Include/arm_math.h ****       /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
5650:.\Include/arm_math.h ****       y += ((q63_t) y1 * (fract));
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 104


5651:.\Include/arm_math.h **** 
5652:.\Include/arm_math.h ****       /* convert y to 1.15 format */
5653:.\Include/arm_math.h ****       return (q15_t) (y >> 20);
5654:.\Include/arm_math.h ****     }
5655:.\Include/arm_math.h ****   }
5656:.\Include/arm_math.h **** 
5657:.\Include/arm_math.h **** 
5658:.\Include/arm_math.h ****   /**
5659:.\Include/arm_math.h ****    *
5660:.\Include/arm_math.h ****    * @brief  Process function for the Q7 Linear Interpolation Function.
5661:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q7 Linear Interpolation table
5662:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5663:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5664:.\Include/arm_math.h ****    * @return y processed output sample.
5665:.\Include/arm_math.h ****    *
5666:.\Include/arm_math.h ****    * \par
5667:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5668:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5669:.\Include/arm_math.h ****    */
5670:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t arm_linear_interp_q7(
5671:.\Include/arm_math.h ****   q7_t * pYData,
5672:.\Include/arm_math.h ****   q31_t x,
5673:.\Include/arm_math.h ****   uint32_t nValues)
5674:.\Include/arm_math.h ****   {
5675:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5676:.\Include/arm_math.h ****     q7_t y0, y1;                                 /* Nearest output values */
5677:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5678:.\Include/arm_math.h ****     uint32_t index;                              /* Index to read nearest output values */
5679:.\Include/arm_math.h **** 
5680:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5681:.\Include/arm_math.h ****     /* 12 bits for the table index */
5682:.\Include/arm_math.h ****     /* Index value calculation */
5683:.\Include/arm_math.h ****     if (x < 0)
5684:.\Include/arm_math.h ****     {
5685:.\Include/arm_math.h ****       return (pYData[0]);
5686:.\Include/arm_math.h ****     }
5687:.\Include/arm_math.h ****     index = (x >> 20) & 0xfff;
5688:.\Include/arm_math.h **** 
5689:.\Include/arm_math.h ****     if (index >= (nValues - 1))
5690:.\Include/arm_math.h ****     {
5691:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5692:.\Include/arm_math.h ****     }
5693:.\Include/arm_math.h ****     else
5694:.\Include/arm_math.h ****     {
5695:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5696:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5697:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5698:.\Include/arm_math.h **** 
5699:.\Include/arm_math.h ****       /* Read two nearest output values from the index and are in 1.7(q7) format */
5700:.\Include/arm_math.h ****       y0 = pYData[index];
5701:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5702:.\Include/arm_math.h **** 
5703:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
5704:.\Include/arm_math.h ****       y = ((y0 * (0xFFFFF - fract)));
5705:.\Include/arm_math.h **** 
5706:.\Include/arm_math.h ****       /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
5707:.\Include/arm_math.h ****       y += (y1 * fract);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 105


5708:.\Include/arm_math.h **** 
5709:.\Include/arm_math.h ****       /* convert y to 1.7(q7) format */
5710:.\Include/arm_math.h ****       return (q7_t) (y >> 20);
5711:.\Include/arm_math.h ****      }
5712:.\Include/arm_math.h ****   }
5713:.\Include/arm_math.h **** 
5714:.\Include/arm_math.h ****   /**
5715:.\Include/arm_math.h ****    * @} end of LinearInterpolate group
5716:.\Include/arm_math.h ****    */
5717:.\Include/arm_math.h **** 
5718:.\Include/arm_math.h ****   /**
5719:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for floating-point data.
5720:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5721:.\Include/arm_math.h ****    * @return  sin(x).
5722:.\Include/arm_math.h ****    */
5723:.\Include/arm_math.h ****   float32_t arm_sin_f32(
5724:.\Include/arm_math.h ****   float32_t x);
5725:.\Include/arm_math.h **** 
5726:.\Include/arm_math.h **** 
5727:.\Include/arm_math.h ****   /**
5728:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q31 data.
5729:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5730:.\Include/arm_math.h ****    * @return  sin(x).
5731:.\Include/arm_math.h ****    */
5732:.\Include/arm_math.h ****   q31_t arm_sin_q31(
5733:.\Include/arm_math.h ****   q31_t x);
5734:.\Include/arm_math.h **** 
5735:.\Include/arm_math.h **** 
5736:.\Include/arm_math.h ****   /**
5737:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q15 data.
5738:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5739:.\Include/arm_math.h ****    * @return  sin(x).
5740:.\Include/arm_math.h ****    */
5741:.\Include/arm_math.h ****   q15_t arm_sin_q15(
5742:.\Include/arm_math.h ****   q15_t x);
5743:.\Include/arm_math.h **** 
5744:.\Include/arm_math.h **** 
5745:.\Include/arm_math.h ****   /**
5746:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
5747:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5748:.\Include/arm_math.h ****    * @return  cos(x).
5749:.\Include/arm_math.h ****    */
5750:.\Include/arm_math.h ****   float32_t arm_cos_f32(
5751:.\Include/arm_math.h ****   float32_t x);
5752:.\Include/arm_math.h **** 
5753:.\Include/arm_math.h **** 
5754:.\Include/arm_math.h ****   /**
5755:.\Include/arm_math.h ****    * @brief Fast approximation to the trigonometric cosine function for Q31 data.
5756:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5757:.\Include/arm_math.h ****    * @return  cos(x).
5758:.\Include/arm_math.h ****    */
5759:.\Include/arm_math.h ****   q31_t arm_cos_q31(
5760:.\Include/arm_math.h ****   q31_t x);
5761:.\Include/arm_math.h **** 
5762:.\Include/arm_math.h **** 
5763:.\Include/arm_math.h ****   /**
5764:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 106


5765:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5766:.\Include/arm_math.h ****    * @return  cos(x).
5767:.\Include/arm_math.h ****    */
5768:.\Include/arm_math.h ****   q15_t arm_cos_q15(
5769:.\Include/arm_math.h ****   q15_t x);
5770:.\Include/arm_math.h **** 
5771:.\Include/arm_math.h **** 
5772:.\Include/arm_math.h ****   /**
5773:.\Include/arm_math.h ****    * @ingroup groupFastMath
5774:.\Include/arm_math.h ****    */
5775:.\Include/arm_math.h **** 
5776:.\Include/arm_math.h **** 
5777:.\Include/arm_math.h ****   /**
5778:.\Include/arm_math.h ****    * @defgroup SQRT Square Root
5779:.\Include/arm_math.h ****    *
5780:.\Include/arm_math.h ****    * Computes the square root of a number.
5781:.\Include/arm_math.h ****    * There are separate functions for Q15, Q31, and floating-point data types.
5782:.\Include/arm_math.h ****    * The square root function is computed using the Newton-Raphson algorithm.
5783:.\Include/arm_math.h ****    * This is an iterative algorithm of the form:
5784:.\Include/arm_math.h ****    * <pre>
5785:.\Include/arm_math.h ****    *      x1 = x0 - f(x0)/f'(x0)
5786:.\Include/arm_math.h ****    * </pre>
5787:.\Include/arm_math.h ****    * where <code>x1</code> is the current estimate,
5788:.\Include/arm_math.h ****    * <code>x0</code> is the previous estimate, and
5789:.\Include/arm_math.h ****    * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
5790:.\Include/arm_math.h ****    * For the square root function, the algorithm reduces to:
5791:.\Include/arm_math.h ****    * <pre>
5792:.\Include/arm_math.h ****    *     x0 = in/2                         [initial guess]
5793:.\Include/arm_math.h ****    *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
5794:.\Include/arm_math.h ****    * </pre>
5795:.\Include/arm_math.h ****    */
5796:.\Include/arm_math.h **** 
5797:.\Include/arm_math.h **** 
5798:.\Include/arm_math.h ****   /**
5799:.\Include/arm_math.h ****    * @addtogroup SQRT
5800:.\Include/arm_math.h ****    * @{
5801:.\Include/arm_math.h ****    */
5802:.\Include/arm_math.h **** 
5803:.\Include/arm_math.h ****   /**
5804:.\Include/arm_math.h ****    * @brief  Floating-point square root function.
5805:.\Include/arm_math.h ****    * @param[in]  in    input value.
5806:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5807:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5808:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5809:.\Include/arm_math.h ****    */
5810:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
5811:.\Include/arm_math.h ****   float32_t in,
5812:.\Include/arm_math.h ****   float32_t * pOut)
5813:.\Include/arm_math.h ****   {
5814:.\Include/arm_math.h ****     if (in >= 0.0f)
  81              		.loc 2 5814 0
  82 004e 7869     		ldr	r0, [r7, #20]
  83 0050 0021     		mov	r1, #0
  84 0052 FFF7FEFF 		bl	__aeabi_fcmpge
  85 0056 031E     		sub	r3, r0, #0
  86 0058 07D0     		beq	.L8
5815:.\Include/arm_math.h ****     {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 107


5816:.\Include/arm_math.h **** 
5817:.\Include/arm_math.h **** #if   (__FPU_USED == 1) && defined ( __CC_ARM   )
5818:.\Include/arm_math.h ****       *pOut = __sqrtf(in);
5819:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
5820:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5821:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined(__GNUC__)
5822:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5823:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
5824:.\Include/arm_math.h ****       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
5825:.\Include/arm_math.h **** #else
5826:.\Include/arm_math.h ****       *pOut = sqrtf(in);
  87              		.loc 2 5826 0
  88 005a 7B69     		ldr	r3, [r7, #20]
  89 005c 181C     		add	r0, r3, #0
  90 005e FFF7FEFF 		bl	sqrtf
  91 0062 021C     		add	r2, r0, #0
  92 0064 3B69     		ldr	r3, [r7, #16]
  93 0066 1A60     		str	r2, [r3]
  94 0068 02E0     		b	.L9
  95              	.L8:
5827:.\Include/arm_math.h **** #endif
5828:.\Include/arm_math.h **** 
5829:.\Include/arm_math.h ****       return (ARM_MATH_SUCCESS);
5830:.\Include/arm_math.h ****     }
5831:.\Include/arm_math.h ****     else
5832:.\Include/arm_math.h ****     {
5833:.\Include/arm_math.h ****       *pOut = 0.0f;
  96              		.loc 2 5833 0
  97 006a 3B69     		ldr	r3, [r7, #16]
  98 006c 0022     		mov	r2, #0
  99 006e 1A60     		str	r2, [r3]
 100              	.L9:
 101              	.LBE5:
 102              	.LBE4:
 142:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 143:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     /* Decrement the loop counter */
 144:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****     numSamples--;
 103              		.loc 1 144 0
 104 0070 7B68     		ldr	r3, [r7, #4]
 105 0072 013B     		sub	r3, r3, #1
 106 0074 7B60     		str	r3, [r7, #4]
 107              	.L2:
 135:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   {
 108              		.loc 1 135 0
 109 0076 7B68     		ldr	r3, [r7, #4]
 110 0078 002B     		cmp	r3, #0
 111 007a C8D1     		bne	.L6
 145:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c ****   }
 146:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 147:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** #endif /* #if defined (ARM_MATH_DSP) */
 148:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** 
 149:Source\ComplexMathFunctions/arm_cmplx_mag_f32.c **** }
 112              		.loc 1 149 0
 113 007c BD46     		mov	sp, r7
 114 007e 09B0     		add	sp, sp, #36
 115              		@ sp needed
 116 0080 90BD     		pop	{r4, r7, pc}
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 108


 117              		.cfi_endproc
 118              	.LFE82:
 119              		.size	arm_cmplx_mag_f32, .-arm_cmplx_mag_f32
 120 0082 C046     		.text
 121              	.Letext0:
 122              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 123              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 124              		.section	.debug_info,"",%progbits
 125              	.Ldebug_info0:
 126 0000 94010000 		.4byte	0x194
 127 0004 0400     		.2byte	0x4
 128 0006 00000000 		.4byte	.Ldebug_abbrev0
 129 000a 04       		.byte	0x4
 130 000b 01       		.uleb128 0x1
 131 000c 77010000 		.4byte	.LASF31
 132 0010 01       		.byte	0x1
 133 0011 92000000 		.4byte	.LASF32
 134 0015 2E000000 		.4byte	.LASF33
 135 0019 00000000 		.4byte	.Ldebug_ranges0+0
 136 001d 00000000 		.4byte	0
 137 0021 00000000 		.4byte	.Ldebug_line0
 138 0025 02       		.uleb128 0x2
 139 0026 01       		.byte	0x1
 140 0027 06       		.byte	0x6
 141 0028 78020000 		.4byte	.LASF0
 142 002c 02       		.uleb128 0x2
 143 002d 01       		.byte	0x1
 144 002e 08       		.byte	0x8
 145 002f C7000000 		.4byte	.LASF1
 146 0033 02       		.uleb128 0x2
 147 0034 02       		.byte	0x2
 148 0035 05       		.byte	0x5
 149 0036 50020000 		.4byte	.LASF2
 150 003a 02       		.uleb128 0x2
 151 003b 02       		.byte	0x2
 152 003c 07       		.byte	0x7
 153 003d FD000000 		.4byte	.LASF3
 154 0041 02       		.uleb128 0x2
 155 0042 04       		.byte	0x4
 156 0043 05       		.byte	0x5
 157 0044 63020000 		.4byte	.LASF4
 158 0048 03       		.uleb128 0x3
 159 0049 29010000 		.4byte	.LASF9
 160 004d 03       		.byte	0x3
 161 004e 41       		.byte	0x41
 162 004f 53000000 		.4byte	0x53
 163 0053 02       		.uleb128 0x2
 164 0054 04       		.byte	0x4
 165 0055 07       		.byte	0x7
 166 0056 EB000000 		.4byte	.LASF5
 167 005a 02       		.uleb128 0x2
 168 005b 08       		.byte	0x8
 169 005c 05       		.byte	0x5
 170 005d 22020000 		.4byte	.LASF6
 171 0061 02       		.uleb128 0x2
 172 0062 08       		.byte	0x8
 173 0063 07       		.byte	0x7
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 109


 174 0064 60010000 		.4byte	.LASF7
 175 0068 04       		.uleb128 0x4
 176 0069 04       		.byte	0x4
 177 006a 05       		.byte	0x5
 178 006b 696E7400 		.ascii	"int\000"
 179 006f 02       		.uleb128 0x2
 180 0070 04       		.byte	0x4
 181 0071 07       		.byte	0x7
 182 0072 4C010000 		.4byte	.LASF8
 183 0076 03       		.uleb128 0x3
 184 0077 5A020000 		.4byte	.LASF10
 185 007b 04       		.byte	0x4
 186 007c 2D       		.byte	0x2d
 187 007d 48000000 		.4byte	0x48
 188 0081 02       		.uleb128 0x2
 189 0082 04       		.byte	0x4
 190 0083 07       		.byte	0x7
 191 0084 19020000 		.4byte	.LASF11
 192 0088 02       		.uleb128 0x2
 193 0089 01       		.byte	0x1
 194 008a 08       		.byte	0x8
 195 008b 30020000 		.4byte	.LASF12
 196 008f 02       		.uleb128 0x2
 197 0090 08       		.byte	0x8
 198 0091 04       		.byte	0x4
 199 0092 15010000 		.4byte	.LASF13
 200 0096 02       		.uleb128 0x2
 201 0097 04       		.byte	0x4
 202 0098 04       		.byte	0x4
 203 0099 16000000 		.4byte	.LASF14
 204 009d 02       		.uleb128 0x2
 205 009e 08       		.byte	0x8
 206 009f 04       		.byte	0x4
 207 00a0 6C020000 		.4byte	.LASF15
 208 00a4 05       		.uleb128 0x5
 209 00a5 01       		.byte	0x1
 210 00a6 02       		.byte	0x2
 211 00a7 8401     		.2byte	0x184
 212 00a9 D8000000 		.4byte	0xd8
 213 00ad 06       		.uleb128 0x6
 214 00ae 3F020000 		.4byte	.LASF16
 215 00b2 00       		.sleb128 0
 216 00b3 06       		.uleb128 0x6
 217 00b4 34010000 		.4byte	.LASF17
 218 00b8 7F       		.sleb128 -1
 219 00b9 06       		.uleb128 0x6
 220 00ba 00000000 		.4byte	.LASF18
 221 00be 7E       		.sleb128 -2
 222 00bf 06       		.uleb128 0x6
 223 00c0 7B000000 		.4byte	.LASF19
 224 00c4 7D       		.sleb128 -3
 225 00c5 06       		.uleb128 0x6
 226 00c6 09020000 		.4byte	.LASF20
 227 00ca 7C       		.sleb128 -4
 228 00cb 06       		.uleb128 0x6
 229 00cc 9F020000 		.4byte	.LASF21
 230 00d0 7B       		.sleb128 -5
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 110


 231 00d1 06       		.uleb128 0x6
 232 00d2 D5000000 		.4byte	.LASF22
 233 00d6 7A       		.sleb128 -6
 234 00d7 00       		.byte	0
 235 00d8 07       		.uleb128 0x7
 236 00d9 94020000 		.4byte	.LASF23
 237 00dd 02       		.byte	0x2
 238 00de 8C01     		.2byte	0x18c
 239 00e0 A4000000 		.4byte	0xa4
 240 00e4 07       		.uleb128 0x7
 241 00e5 35020000 		.4byte	.LASF24
 242 00e9 02       		.byte	0x2
 243 00ea A501     		.2byte	0x1a5
 244 00ec 96000000 		.4byte	0x96
 245 00f0 08       		.uleb128 0x8
 246 00f1 04       		.byte	0x4
 247 00f2 E4000000 		.4byte	0xe4
 248 00f6 09       		.uleb128 0x9
 249 00f7 1C010000 		.4byte	.LASF34
 250 00fb 02       		.byte	0x2
 251 00fc B216     		.2byte	0x16b2
 252 00fe D8000000 		.4byte	0xd8
 253 0102 03       		.byte	0x3
 254 0103 1F010000 		.4byte	0x11f
 255 0107 0A       		.uleb128 0xa
 256 0108 696E00   		.ascii	"in\000"
 257 010b 02       		.byte	0x2
 258 010c B316     		.2byte	0x16b3
 259 010e E4000000 		.4byte	0xe4
 260 0112 0B       		.uleb128 0xb
 261 0113 C2000000 		.4byte	.LASF25
 262 0117 02       		.byte	0x2
 263 0118 B416     		.2byte	0x16b4
 264 011a F0000000 		.4byte	0xf0
 265 011e 00       		.byte	0
 266 011f 0C       		.uleb128 0xc
 267 0120 1C000000 		.4byte	.LASF35
 268 0124 01       		.byte	0x1
 269 0125 48       		.byte	0x48
 270 0126 00000000 		.4byte	.LFB82
 271 012a 82000000 		.4byte	.LFE82-.LFB82
 272 012e 01       		.uleb128 0x1
 273 012f 9C       		.byte	0x9c
 274 0130 0D       		.uleb128 0xd
 275 0131 84020000 		.4byte	.LASF26
 276 0135 01       		.byte	0x1
 277 0136 49       		.byte	0x49
 278 0137 F0000000 		.4byte	0xf0
 279 013b 02       		.uleb128 0x2
 280 013c 91       		.byte	0x91
 281 013d 5C       		.sleb128 -36
 282 013e 0D       		.uleb128 0xd
 283 013f 10010000 		.4byte	.LASF27
 284 0143 01       		.byte	0x1
 285 0144 4A       		.byte	0x4a
 286 0145 F0000000 		.4byte	0xf0
 287 0149 02       		.uleb128 0x2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 111


 288 014a 91       		.byte	0x91
 289 014b 58       		.sleb128 -40
 290 014c 0D       		.uleb128 0xd
 291 014d 89020000 		.4byte	.LASF28
 292 0151 01       		.byte	0x1
 293 0152 4B       		.byte	0x4b
 294 0153 76000000 		.4byte	0x76
 295 0157 02       		.uleb128 0x2
 296 0158 91       		.byte	0x91
 297 0159 54       		.sleb128 -44
 298 015a 0E       		.uleb128 0xe
 299 015b 74000000 		.4byte	.LASF29
 300 015f 01       		.byte	0x1
 301 0160 4D       		.byte	0x4d
 302 0161 E4000000 		.4byte	0xe4
 303 0165 02       		.uleb128 0x2
 304 0166 91       		.byte	0x91
 305 0167 6C       		.sleb128 -20
 306 0168 0E       		.uleb128 0xe
 307 0169 59010000 		.4byte	.LASF30
 308 016d 01       		.byte	0x1
 309 016e 4D       		.byte	0x4d
 310 016f E4000000 		.4byte	0xe4
 311 0173 02       		.uleb128 0x2
 312 0174 91       		.byte	0x91
 313 0175 68       		.sleb128 -24
 314 0176 0F       		.uleb128 0xf
 315 0177 F6000000 		.4byte	0xf6
 316 017b 4E000000 		.4byte	.LBB4
 317 017f 22000000 		.4byte	.LBE4-.LBB4
 318 0183 01       		.byte	0x1
 319 0184 8D       		.byte	0x8d
 320 0185 10       		.uleb128 0x10
 321 0186 12010000 		.4byte	0x112
 322 018a 02       		.uleb128 0x2
 323 018b 91       		.byte	0x91
 324 018c 60       		.sleb128 -32
 325 018d 10       		.uleb128 0x10
 326 018e 07010000 		.4byte	0x107
 327 0192 02       		.uleb128 0x2
 328 0193 91       		.byte	0x91
 329 0194 64       		.sleb128 -28
 330 0195 00       		.byte	0
 331 0196 00       		.byte	0
 332 0197 00       		.byte	0
 333              		.section	.debug_abbrev,"",%progbits
 334              	.Ldebug_abbrev0:
 335 0000 01       		.uleb128 0x1
 336 0001 11       		.uleb128 0x11
 337 0002 01       		.byte	0x1
 338 0003 25       		.uleb128 0x25
 339 0004 0E       		.uleb128 0xe
 340 0005 13       		.uleb128 0x13
 341 0006 0B       		.uleb128 0xb
 342 0007 03       		.uleb128 0x3
 343 0008 0E       		.uleb128 0xe
 344 0009 1B       		.uleb128 0x1b
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 112


 345 000a 0E       		.uleb128 0xe
 346 000b 55       		.uleb128 0x55
 347 000c 17       		.uleb128 0x17
 348 000d 11       		.uleb128 0x11
 349 000e 01       		.uleb128 0x1
 350 000f 10       		.uleb128 0x10
 351 0010 17       		.uleb128 0x17
 352 0011 00       		.byte	0
 353 0012 00       		.byte	0
 354 0013 02       		.uleb128 0x2
 355 0014 24       		.uleb128 0x24
 356 0015 00       		.byte	0
 357 0016 0B       		.uleb128 0xb
 358 0017 0B       		.uleb128 0xb
 359 0018 3E       		.uleb128 0x3e
 360 0019 0B       		.uleb128 0xb
 361 001a 03       		.uleb128 0x3
 362 001b 0E       		.uleb128 0xe
 363 001c 00       		.byte	0
 364 001d 00       		.byte	0
 365 001e 03       		.uleb128 0x3
 366 001f 16       		.uleb128 0x16
 367 0020 00       		.byte	0
 368 0021 03       		.uleb128 0x3
 369 0022 0E       		.uleb128 0xe
 370 0023 3A       		.uleb128 0x3a
 371 0024 0B       		.uleb128 0xb
 372 0025 3B       		.uleb128 0x3b
 373 0026 0B       		.uleb128 0xb
 374 0027 49       		.uleb128 0x49
 375 0028 13       		.uleb128 0x13
 376 0029 00       		.byte	0
 377 002a 00       		.byte	0
 378 002b 04       		.uleb128 0x4
 379 002c 24       		.uleb128 0x24
 380 002d 00       		.byte	0
 381 002e 0B       		.uleb128 0xb
 382 002f 0B       		.uleb128 0xb
 383 0030 3E       		.uleb128 0x3e
 384 0031 0B       		.uleb128 0xb
 385 0032 03       		.uleb128 0x3
 386 0033 08       		.uleb128 0x8
 387 0034 00       		.byte	0
 388 0035 00       		.byte	0
 389 0036 05       		.uleb128 0x5
 390 0037 04       		.uleb128 0x4
 391 0038 01       		.byte	0x1
 392 0039 0B       		.uleb128 0xb
 393 003a 0B       		.uleb128 0xb
 394 003b 3A       		.uleb128 0x3a
 395 003c 0B       		.uleb128 0xb
 396 003d 3B       		.uleb128 0x3b
 397 003e 05       		.uleb128 0x5
 398 003f 01       		.uleb128 0x1
 399 0040 13       		.uleb128 0x13
 400 0041 00       		.byte	0
 401 0042 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 113


 402 0043 06       		.uleb128 0x6
 403 0044 28       		.uleb128 0x28
 404 0045 00       		.byte	0
 405 0046 03       		.uleb128 0x3
 406 0047 0E       		.uleb128 0xe
 407 0048 1C       		.uleb128 0x1c
 408 0049 0D       		.uleb128 0xd
 409 004a 00       		.byte	0
 410 004b 00       		.byte	0
 411 004c 07       		.uleb128 0x7
 412 004d 16       		.uleb128 0x16
 413 004e 00       		.byte	0
 414 004f 03       		.uleb128 0x3
 415 0050 0E       		.uleb128 0xe
 416 0051 3A       		.uleb128 0x3a
 417 0052 0B       		.uleb128 0xb
 418 0053 3B       		.uleb128 0x3b
 419 0054 05       		.uleb128 0x5
 420 0055 49       		.uleb128 0x49
 421 0056 13       		.uleb128 0x13
 422 0057 00       		.byte	0
 423 0058 00       		.byte	0
 424 0059 08       		.uleb128 0x8
 425 005a 0F       		.uleb128 0xf
 426 005b 00       		.byte	0
 427 005c 0B       		.uleb128 0xb
 428 005d 0B       		.uleb128 0xb
 429 005e 49       		.uleb128 0x49
 430 005f 13       		.uleb128 0x13
 431 0060 00       		.byte	0
 432 0061 00       		.byte	0
 433 0062 09       		.uleb128 0x9
 434 0063 2E       		.uleb128 0x2e
 435 0064 01       		.byte	0x1
 436 0065 03       		.uleb128 0x3
 437 0066 0E       		.uleb128 0xe
 438 0067 3A       		.uleb128 0x3a
 439 0068 0B       		.uleb128 0xb
 440 0069 3B       		.uleb128 0x3b
 441 006a 05       		.uleb128 0x5
 442 006b 27       		.uleb128 0x27
 443 006c 19       		.uleb128 0x19
 444 006d 49       		.uleb128 0x49
 445 006e 13       		.uleb128 0x13
 446 006f 20       		.uleb128 0x20
 447 0070 0B       		.uleb128 0xb
 448 0071 01       		.uleb128 0x1
 449 0072 13       		.uleb128 0x13
 450 0073 00       		.byte	0
 451 0074 00       		.byte	0
 452 0075 0A       		.uleb128 0xa
 453 0076 05       		.uleb128 0x5
 454 0077 00       		.byte	0
 455 0078 03       		.uleb128 0x3
 456 0079 08       		.uleb128 0x8
 457 007a 3A       		.uleb128 0x3a
 458 007b 0B       		.uleb128 0xb
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 114


 459 007c 3B       		.uleb128 0x3b
 460 007d 05       		.uleb128 0x5
 461 007e 49       		.uleb128 0x49
 462 007f 13       		.uleb128 0x13
 463 0080 00       		.byte	0
 464 0081 00       		.byte	0
 465 0082 0B       		.uleb128 0xb
 466 0083 05       		.uleb128 0x5
 467 0084 00       		.byte	0
 468 0085 03       		.uleb128 0x3
 469 0086 0E       		.uleb128 0xe
 470 0087 3A       		.uleb128 0x3a
 471 0088 0B       		.uleb128 0xb
 472 0089 3B       		.uleb128 0x3b
 473 008a 05       		.uleb128 0x5
 474 008b 49       		.uleb128 0x49
 475 008c 13       		.uleb128 0x13
 476 008d 00       		.byte	0
 477 008e 00       		.byte	0
 478 008f 0C       		.uleb128 0xc
 479 0090 2E       		.uleb128 0x2e
 480 0091 01       		.byte	0x1
 481 0092 3F       		.uleb128 0x3f
 482 0093 19       		.uleb128 0x19
 483 0094 03       		.uleb128 0x3
 484 0095 0E       		.uleb128 0xe
 485 0096 3A       		.uleb128 0x3a
 486 0097 0B       		.uleb128 0xb
 487 0098 3B       		.uleb128 0x3b
 488 0099 0B       		.uleb128 0xb
 489 009a 27       		.uleb128 0x27
 490 009b 19       		.uleb128 0x19
 491 009c 11       		.uleb128 0x11
 492 009d 01       		.uleb128 0x1
 493 009e 12       		.uleb128 0x12
 494 009f 06       		.uleb128 0x6
 495 00a0 40       		.uleb128 0x40
 496 00a1 18       		.uleb128 0x18
 497 00a2 9642     		.uleb128 0x2116
 498 00a4 19       		.uleb128 0x19
 499 00a5 00       		.byte	0
 500 00a6 00       		.byte	0
 501 00a7 0D       		.uleb128 0xd
 502 00a8 05       		.uleb128 0x5
 503 00a9 00       		.byte	0
 504 00aa 03       		.uleb128 0x3
 505 00ab 0E       		.uleb128 0xe
 506 00ac 3A       		.uleb128 0x3a
 507 00ad 0B       		.uleb128 0xb
 508 00ae 3B       		.uleb128 0x3b
 509 00af 0B       		.uleb128 0xb
 510 00b0 49       		.uleb128 0x49
 511 00b1 13       		.uleb128 0x13
 512 00b2 02       		.uleb128 0x2
 513 00b3 18       		.uleb128 0x18
 514 00b4 00       		.byte	0
 515 00b5 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 115


 516 00b6 0E       		.uleb128 0xe
 517 00b7 34       		.uleb128 0x34
 518 00b8 00       		.byte	0
 519 00b9 03       		.uleb128 0x3
 520 00ba 0E       		.uleb128 0xe
 521 00bb 3A       		.uleb128 0x3a
 522 00bc 0B       		.uleb128 0xb
 523 00bd 3B       		.uleb128 0x3b
 524 00be 0B       		.uleb128 0xb
 525 00bf 49       		.uleb128 0x49
 526 00c0 13       		.uleb128 0x13
 527 00c1 02       		.uleb128 0x2
 528 00c2 18       		.uleb128 0x18
 529 00c3 00       		.byte	0
 530 00c4 00       		.byte	0
 531 00c5 0F       		.uleb128 0xf
 532 00c6 1D       		.uleb128 0x1d
 533 00c7 01       		.byte	0x1
 534 00c8 31       		.uleb128 0x31
 535 00c9 13       		.uleb128 0x13
 536 00ca 11       		.uleb128 0x11
 537 00cb 01       		.uleb128 0x1
 538 00cc 12       		.uleb128 0x12
 539 00cd 06       		.uleb128 0x6
 540 00ce 58       		.uleb128 0x58
 541 00cf 0B       		.uleb128 0xb
 542 00d0 59       		.uleb128 0x59
 543 00d1 0B       		.uleb128 0xb
 544 00d2 00       		.byte	0
 545 00d3 00       		.byte	0
 546 00d4 10       		.uleb128 0x10
 547 00d5 05       		.uleb128 0x5
 548 00d6 00       		.byte	0
 549 00d7 31       		.uleb128 0x31
 550 00d8 13       		.uleb128 0x13
 551 00d9 02       		.uleb128 0x2
 552 00da 18       		.uleb128 0x18
 553 00db 00       		.byte	0
 554 00dc 00       		.byte	0
 555 00dd 00       		.byte	0
 556              		.section	.debug_aranges,"",%progbits
 557 0000 1C000000 		.4byte	0x1c
 558 0004 0200     		.2byte	0x2
 559 0006 00000000 		.4byte	.Ldebug_info0
 560 000a 04       		.byte	0x4
 561 000b 00       		.byte	0
 562 000c 0000     		.2byte	0
 563 000e 0000     		.2byte	0
 564 0010 00000000 		.4byte	.LFB82
 565 0014 82000000 		.4byte	.LFE82-.LFB82
 566 0018 00000000 		.4byte	0
 567 001c 00000000 		.4byte	0
 568              		.section	.debug_ranges,"",%progbits
 569              	.Ldebug_ranges0:
 570 0000 00000000 		.4byte	.LFB82
 571 0004 82000000 		.4byte	.LFE82
 572 0008 00000000 		.4byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 116


 573 000c 00000000 		.4byte	0
 574              		.section	.debug_line,"",%progbits
 575              	.Ldebug_line0:
 576 0000 89010000 		.section	.debug_str,"MS",%progbits,1
 576      02005601 
 576      00000201 
 576      FB0E0D00 
 576      01010101 
 577              	.LASF18:
 578 0000 41524D5F 		.ascii	"ARM_MATH_LENGTH_ERROR\000"
 578      4D415448 
 578      5F4C454E 
 578      4754485F 
 578      4552524F 
 579              	.LASF14:
 580 0016 666C6F61 		.ascii	"float\000"
 580      7400
 581              	.LASF35:
 582 001c 61726D5F 		.ascii	"arm_cmplx_mag_f32\000"
 582      636D706C 
 582      785F6D61 
 582      675F6633 
 582      3200
 583              	.LASF33:
 584 002e 433A5C55 		.ascii	"C:\\Users\\fneves\\Documents\\PSoC Creator\\wp_1\\e"
 584      73657273 
 584      5C666E65 
 584      7665735C 
 584      446F6375 
 585 005b 6E67696E 		.ascii	"ngine_speed_sensor.cydsn\000"
 585      655F7370 
 585      6565645F 
 585      73656E73 
 585      6F722E63 
 586              	.LASF29:
 587 0074 7265616C 		.ascii	"realIn\000"
 587      496E00
 588              	.LASF19:
 589 007b 41524D5F 		.ascii	"ARM_MATH_SIZE_MISMATCH\000"
 589      4D415448 
 589      5F53495A 
 589      455F4D49 
 589      534D4154 
 590              	.LASF32:
 591 0092 536F7572 		.ascii	"Source\\ComplexMathFunctions\\arm_cmplx_mag_f32.c\000"
 591      63655C43 
 591      6F6D706C 
 591      65784D61 
 591      74684675 
 592              	.LASF25:
 593 00c2 704F7574 		.ascii	"pOut\000"
 593      00
 594              	.LASF1:
 595 00c7 756E7369 		.ascii	"unsigned char\000"
 595      676E6564 
 595      20636861 
 595      7200
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 117


 596              	.LASF22:
 597 00d5 41524D5F 		.ascii	"ARM_MATH_TEST_FAILURE\000"
 597      4D415448 
 597      5F544553 
 597      545F4641 
 597      494C5552 
 598              	.LASF5:
 599 00eb 6C6F6E67 		.ascii	"long unsigned int\000"
 599      20756E73 
 599      69676E65 
 599      6420696E 
 599      7400
 600              	.LASF3:
 601 00fd 73686F72 		.ascii	"short unsigned int\000"
 601      7420756E 
 601      7369676E 
 601      65642069 
 601      6E7400
 602              	.LASF27:
 603 0110 70447374 		.ascii	"pDst\000"
 603      00
 604              	.LASF13:
 605 0115 646F7562 		.ascii	"double\000"
 605      6C6500
 606              	.LASF34:
 607 011c 61726D5F 		.ascii	"arm_sqrt_f32\000"
 607      73717274 
 607      5F663332 
 607      00
 608              	.LASF9:
 609 0129 5F5F7569 		.ascii	"__uint32_t\000"
 609      6E743332 
 609      5F7400
 610              	.LASF17:
 611 0134 41524D5F 		.ascii	"ARM_MATH_ARGUMENT_ERROR\000"
 611      4D415448 
 611      5F415247 
 611      554D454E 
 611      545F4552 
 612              	.LASF8:
 613 014c 756E7369 		.ascii	"unsigned int\000"
 613      676E6564 
 613      20696E74 
 613      00
 614              	.LASF30:
 615 0159 696D6167 		.ascii	"imagIn\000"
 615      496E00
 616              	.LASF7:
 617 0160 6C6F6E67 		.ascii	"long long unsigned int\000"
 617      206C6F6E 
 617      6720756E 
 617      7369676E 
 617      65642069 
 618              	.LASF31:
 619 0177 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 619      4320342E 
 619      392E3320 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 118


 619      32303135 
 619      30333033 
 620 01aa 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0plus -mthumb -"
 620      20726576 
 620      6973696F 
 620      6E203232 
 620      31323230 
 621 01dd 67202D4F 		.ascii	"g -O0 -ffunction-sections -ffat-lto-objects\000"
 621      30202D66 
 621      66756E63 
 621      74696F6E 
 621      2D736563 
 622              	.LASF20:
 623 0209 41524D5F 		.ascii	"ARM_MATH_NANINF\000"
 623      4D415448 
 623      5F4E414E 
 623      494E4600 
 624              	.LASF11:
 625 0219 73697A65 		.ascii	"sizetype\000"
 625      74797065 
 625      00
 626              	.LASF6:
 627 0222 6C6F6E67 		.ascii	"long long int\000"
 627      206C6F6E 
 627      6720696E 
 627      7400
 628              	.LASF12:
 629 0230 63686172 		.ascii	"char\000"
 629      00
 630              	.LASF24:
 631 0235 666C6F61 		.ascii	"float32_t\000"
 631      7433325F 
 631      7400
 632              	.LASF16:
 633 023f 41524D5F 		.ascii	"ARM_MATH_SUCCESS\000"
 633      4D415448 
 633      5F535543 
 633      43455353 
 633      00
 634              	.LASF2:
 635 0250 73686F72 		.ascii	"short int\000"
 635      7420696E 
 635      7400
 636              	.LASF10:
 637 025a 75696E74 		.ascii	"uint32_t\000"
 637      33325F74 
 637      00
 638              	.LASF4:
 639 0263 6C6F6E67 		.ascii	"long int\000"
 639      20696E74 
 639      00
 640              	.LASF15:
 641 026c 6C6F6E67 		.ascii	"long double\000"
 641      20646F75 
 641      626C6500 
 642              	.LASF0:
 643 0278 7369676E 		.ascii	"signed char\000"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccdU4XJU.s 			page 119


 643      65642063 
 643      68617200 
 644              	.LASF26:
 645 0284 70537263 		.ascii	"pSrc\000"
 645      00
 646              	.LASF28:
 647 0289 6E756D53 		.ascii	"numSamples\000"
 647      616D706C 
 647      657300
 648              	.LASF23:
 649 0294 61726D5F 		.ascii	"arm_status\000"
 649      73746174 
 649      757300
 650              	.LASF21:
 651 029f 41524D5F 		.ascii	"ARM_MATH_SINGULAR\000"
 651      4D415448 
 651      5F53494E 
 651      47554C41 
 651      5200
 652              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
