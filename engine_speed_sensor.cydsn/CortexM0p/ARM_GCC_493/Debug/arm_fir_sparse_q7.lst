ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 1


   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"arm_fir_sparse_q7.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.arm_fir_sparse_q7,"ax",%progbits
  18              		.align	2
  19              		.global	arm_fir_sparse_q7
  20              		.code	16
  21              		.thumb_func
  22              		.type	arm_fir_sparse_q7, %function
  23              	arm_fir_sparse_q7:
  24              	.LFB82:
  25              		.file 1 "Source\\FilteringFunctions\\arm_fir_sparse_q7.c"
   1:Source\FilteringFunctions/arm_fir_sparse_q7.c **** /* ----------------------------------------------------------------------
   2:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Project:      CMSIS DSP Library
   3:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Title:        arm_fir_sparse_q7.c
   4:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Description:  Q7 sparse FIR filter processing function
   5:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  *
   6:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * $Date:        27. January 2017
   7:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * $Revision:    V.1.5.1
   8:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  *
   9:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Target Processor: Cortex-M cores
  10:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * -------------------------------------------------------------------- */
  11:Source\FilteringFunctions/arm_fir_sparse_q7.c **** /*
  12:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  *
  14:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * SPDX-License-Identifier: Apache-2.0
  15:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  *
  16:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * not use this file except in compliance with the License.
  18:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * You may obtain a copy of the License at
  19:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  *
  20:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  *
  22:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Unless required by applicable law or agreed to in writing, software
  23:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * See the License for the specific language governing permissions and
  26:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * limitations under the License.
  27:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  */
  28:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  29:Source\FilteringFunctions/arm_fir_sparse_q7.c **** #include "arm_math.h"
  30:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  31:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  32:Source\FilteringFunctions/arm_fir_sparse_q7.c **** /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 2


  33:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @ingroup groupFilters
  34:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  */
  35:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  36:Source\FilteringFunctions/arm_fir_sparse_q7.c **** /**
  37:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @addtogroup FIR_Sparse
  38:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @{
  39:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  */
  40:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  41:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  42:Source\FilteringFunctions/arm_fir_sparse_q7.c **** /**
  43:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @brief Processing function for the Q7 sparse FIR filter.
  44:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @param[in]  *S           points to an instance of the Q7 sparse FIR structure.
  45:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @param[in]  *pSrc        points to the block of input data.
  46:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @param[out] *pDst        points to the block of output data
  47:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
  48:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
  49:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @param[in]  blockSize    number of input samples to process per call.
  50:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * @return none.
  51:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  *
  52:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * <b>Scaling and Overflow Behavior:</b>
  53:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * \par
  54:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * The function is implemented using a 32-bit internal accumulator.
  55:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Both coefficients and state variables are represented in 1.7 format and multiplications yield a 
  56:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * The 2.14 intermediate results are accumulated in a 32-bit accumulator in 18.14 format.
  57:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * There is no risk of internal overflow with this approach and the full precision of intermediate 
  58:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * The accumulator is then converted to 18.7 format by discarding the low 7 bits.
  59:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  * Finally, the result is truncated to 1.7 format.
  60:Source\FilteringFunctions/arm_fir_sparse_q7.c ****  */
  61:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  62:Source\FilteringFunctions/arm_fir_sparse_q7.c **** void arm_fir_sparse_q7(
  63:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   arm_fir_sparse_instance_q7 * S,
  64:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t * pSrc,
  65:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t * pDst,
  66:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t * pScratchIn,
  67:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q31_t * pScratchOut,
  68:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   uint32_t blockSize)
  69:Source\FilteringFunctions/arm_fir_sparse_q7.c **** {
  26              		.loc 1 69 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 7, -8
  31              		.cfi_offset 14, -4
  32 0002 C6B0     		sub	sp, sp, #280
  33              		.cfi_def_cfa_offset 288
  34 0004 00AF     		add	r7, sp, #0
  35              		.cfi_def_cfa_register 7
  36 0006 F860     		str	r0, [r7, #12]
  37 0008 B960     		str	r1, [r7, #8]
  38 000a 7A60     		str	r2, [r7, #4]
  39 000c 3B60     		str	r3, [r7]
  70:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  71:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t *pState = S->pState;                      /* State pointer */
  40              		.loc 1 71 0
  41 000e FB68     		ldr	r3, [r7, #12]
  42 0010 5B68     		ldr	r3, [r3, #4]
  43 0012 F422     		mov	r2, #244
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 3


  44 0014 BA18     		add	r2, r7, r2
  45 0016 1360     		str	r3, [r2]
  72:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t *pCoeffs = S->pCoeffs;                    /* Coefficient pointer */
  46              		.loc 1 72 0
  47 0018 FB68     		ldr	r3, [r7, #12]
  48 001a 9B68     		ldr	r3, [r3, #8]
  49 001c 8A22     		mov	r2, #138
  50 001e 5200     		lsl	r2, r2, #1
  51 0020 BA18     		add	r2, r7, r2
  52 0022 1360     		str	r3, [r2]
  73:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t *px;                                      /* Scratch buffer pointer */
  74:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t *py = pState;                             /* Temporary pointers for state buffer */
  53              		.loc 1 74 0
  54 0024 F423     		mov	r3, #244
  55 0026 FB18     		add	r3, r7, r3
  56 0028 1B68     		ldr	r3, [r3]
  57 002a F022     		mov	r2, #240
  58 002c BA18     		add	r2, r7, r2
  59 002e 1360     		str	r3, [r2]
  75:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t *pb = pScratchIn;                         /* Temporary pointers for scratch buffer */
  60              		.loc 1 75 0
  61 0030 3B68     		ldr	r3, [r7]
  62 0032 EC22     		mov	r2, #236
  63 0034 BA18     		add	r2, r7, r2
  64 0036 1360     		str	r3, [r2]
  76:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t *pOut = pDst;                             /* Destination pointer */
  65              		.loc 1 76 0
  66 0038 7B68     		ldr	r3, [r7, #4]
  67 003a 8622     		mov	r2, #134
  68 003c 5200     		lsl	r2, r2, #1
  69 003e BA18     		add	r2, r7, r2
  70 0040 1360     		str	r3, [r2]
  77:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the n
  71              		.loc 1 77 0
  72 0042 FB68     		ldr	r3, [r7, #12]
  73 0044 1B69     		ldr	r3, [r3, #16]
  74 0046 8422     		mov	r2, #132
  75 0048 5200     		lsl	r2, r2, #1
  76 004a BA18     		add	r2, r7, r2
  77 004c 1360     		str	r3, [r2]
  78:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
  78              		.loc 1 78 0
  79 004e FB68     		ldr	r3, [r7, #12]
  80 0050 9B89     		ldrh	r3, [r3, #12]
  81 0052 1A1C     		mov	r2, r3
  82 0054 9223     		mov	r3, #146
  83 0056 5B00     		lsl	r3, r3, #1
  84 0058 FB18     		add	r3, r7, r3
  85 005a 1B68     		ldr	r3, [r3]
  86 005c D318     		add	r3, r2, r3
  87 005e E822     		mov	r2, #232
  88 0060 BA18     		add	r2, r7, r2
  89 0062 1360     		str	r3, [r2]
  79:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   uint16_t numTaps = S->numTaps;                 /* Filter order */
  90              		.loc 1 79 0
  91 0064 E623     		mov	r3, #230
  92 0066 FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 4


  93 0068 FA68     		ldr	r2, [r7, #12]
  94 006a 1288     		ldrh	r2, [r2]
  95 006c 1A80     		strh	r2, [r3]
  80:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   int32_t readIndex;                             /* Read index of the state buffer */
  81:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   uint32_t tapCnt, blkCnt;                       /* loop counters */
  82:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t coeff = *pCoeffs++;                       /* Read the coefficient value */
  96              		.loc 1 82 0
  97 006e 8A23     		mov	r3, #138
  98 0070 5B00     		lsl	r3, r3, #1
  99 0072 FB18     		add	r3, r7, r3
 100 0074 1B68     		ldr	r3, [r3]
 101 0076 5A1C     		add	r2, r3, #1
 102 0078 8A21     		mov	r1, #138
 103 007a 4900     		lsl	r1, r1, #1
 104 007c 7918     		add	r1, r7, r1
 105 007e 0A60     		str	r2, [r1]
 106 0080 FF22     		mov	r2, #255
 107 0082 BA18     		add	r2, r7, r2
 108 0084 1B78     		ldrb	r3, [r3]
 109 0086 1370     		strb	r3, [r2]
  83:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q31_t *pScr2 = pScratchOut;                    /* Working pointer for scratch buffer of output va
 110              		.loc 1 83 0
 111 0088 9023     		mov	r3, #144
 112 008a 5B00     		lsl	r3, r3, #1
 113 008c FB18     		add	r3, r7, r3
 114 008e 1B68     		ldr	r3, [r3]
 115 0090 F822     		mov	r2, #248
 116 0092 BA18     		add	r2, r7, r2
 117 0094 1360     		str	r3, [r2]
  84:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q31_t in;
  85:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  86:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  87:Source\FilteringFunctions/arm_fir_sparse_q7.c **** #if defined (ARM_MATH_DSP)
  88:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  89:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
  90:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  91:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   q7_t in1, in2, in3, in4;
  92:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  93:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* BlockSize of Input samples are copied into the state buffer */
  94:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* StateIndex points to the starting position to write in the state buffer */
  95:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,
  96:Source\FilteringFunctions/arm_fir_sparse_q7.c ****                        blockSize);
  97:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
  98:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the number of taps. */
  99:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   tapCnt = numTaps;
 100:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 101:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 102:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 103:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 104:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Wraparound of readIndex */
 105:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   if (readIndex < 0)
 106:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 107:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     readIndex += (int32_t) delaySize;
 108:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 109:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 110:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Working pointer for state buffer is updated */
 111:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   py = pState;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 5


 112:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 113:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* blockSize samples are read from the state buffer */
 114:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
 115:Source\FilteringFunctions/arm_fir_sparse_q7.c ****                       (int32_t) blockSize, 1, blockSize);
 116:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 117:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Working pointer for the scratch buffer of state values */
 118:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   px = pb;
 119:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 120:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Working pointer for scratch buffer of output values */
 121:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   pScratchOut = pScr2;
 122:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 123:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the blockSize. Unroll by a factor of 4.
 124:Source\FilteringFunctions/arm_fir_sparse_q7.c ****    * Compute 4 multiplications at a time. */
 125:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   blkCnt = blockSize >> 2;
 126:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 127:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (blkCnt > 0u)
 128:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 129:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Perform multiplication and store in the scratch buffer */
 130:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 131:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 132:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 133:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 134:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 135:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the loop counter */
 136:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt--;
 137:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 138:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 139:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* If the blockSize is not a multiple of 4,
 140:Source\FilteringFunctions/arm_fir_sparse_q7.c ****    * compute the remaining samples */
 141:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   blkCnt = blockSize % 0x4u;
 142:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 143:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (blkCnt > 0u)
 144:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 145:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Perform multiplication and store in the scratch buffer */
 146:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 147:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 148:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the loop counter */
 149:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt--;
 150:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 151:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 152:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Load the coefficient value and
 153:Source\FilteringFunctions/arm_fir_sparse_q7.c ****    * increment the coefficient buffer for the next set of state values */
 154:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   coeff = *pCoeffs++;
 155:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 156:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 157:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 158:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 159:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Wraparound of readIndex */
 160:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   if (readIndex < 0)
 161:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 162:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     readIndex += (int32_t) delaySize;
 163:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 164:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 165:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the number of taps. */
 166:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   tapCnt = (uint32_t) numTaps - 2u;
 167:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 168:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (tapCnt > 0u)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 6


 169:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 170:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Working pointer for state buffer is updated */
 171:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     py = pState;
 172:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 173:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* blockSize samples are read from the state buffer */
 174:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
 175:Source\FilteringFunctions/arm_fir_sparse_q7.c ****                         (int32_t) blockSize, 1, blockSize);
 176:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 177:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Working pointer for the scratch buffer of state values */
 178:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     px = pb;
 179:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 180:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Working pointer for scratch buffer of output values */
 181:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     pScratchOut = pScr2;
 182:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 183:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Loop over the blockSize. Unroll by a factor of 4.
 184:Source\FilteringFunctions/arm_fir_sparse_q7.c ****      * Compute 4 MACS at a time. */
 185:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt = blockSize >> 2;
 186:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 187:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     while (blkCnt > 0u)
 188:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     {
 189:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       /* Perform Multiply-Accumulate */
 190:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       in = *pScratchOut + ((q31_t) * px++ * coeff);
 191:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       *pScratchOut++ = in;
 192:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       in = *pScratchOut + ((q31_t) * px++ * coeff);
 193:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       *pScratchOut++ = in;
 194:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       in = *pScratchOut + ((q31_t) * px++ * coeff);
 195:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       *pScratchOut++ = in;
 196:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       in = *pScratchOut + ((q31_t) * px++ * coeff);
 197:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       *pScratchOut++ = in;
 198:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 199:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       /* Decrement the loop counter */
 200:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       blkCnt--;
 201:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     }
 202:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 203:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* If the blockSize is not a multiple of 4,
 204:Source\FilteringFunctions/arm_fir_sparse_q7.c ****      * compute the remaining samples */
 205:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt = blockSize % 0x4u;
 206:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 207:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     while (blkCnt > 0u)
 208:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     {
 209:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       /* Perform Multiply-Accumulate */
 210:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       in = *pScratchOut + ((q31_t) * px++ * coeff);
 211:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       *pScratchOut++ = in;
 212:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 213:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       /* Decrement the loop counter */
 214:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       blkCnt--;
 215:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     }
 216:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 217:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Load the coefficient value and
 218:Source\FilteringFunctions/arm_fir_sparse_q7.c ****      * increment the coefficient buffer for the next set of state values */
 219:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     coeff = *pCoeffs++;
 220:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 221:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 222:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     readIndex = ((int32_t) S->stateIndex -
 223:Source\FilteringFunctions/arm_fir_sparse_q7.c ****                  (int32_t) blockSize) - *pTapDelay++;
 224:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 225:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Wraparound of readIndex */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 7


 226:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     if (readIndex < 0)
 227:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     {
 228:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       readIndex += (int32_t) delaySize;
 229:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     }
 230:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 231:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the tap loop counter */
 232:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     tapCnt--;
 233:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 234:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 235:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Compute last tap without the final read of pTapDelay */
 236:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 237:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Working pointer for state buffer is updated */
 238:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	py = pState;
 239:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 240:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* blockSize samples are read from the state buffer */
 241:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
 242:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 											(int32_t) blockSize, 1, blockSize);
 243:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 244:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Working pointer for the scratch buffer of state values */
 245:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	px = pb;
 246:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 247:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Working pointer for scratch buffer of output values */
 248:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	pScratchOut = pScr2;
 249:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 250:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Loop over the blockSize. Unroll by a factor of 4.
 251:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	 * Compute 4 MACS at a time. */
 252:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	blkCnt = blockSize >> 2;
 253:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 254:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	while (blkCnt > 0u)
 255:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	{
 256:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		/* Perform Multiply-Accumulate */
 257:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		in = *pScratchOut + ((q31_t) * px++ * coeff);
 258:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		*pScratchOut++ = in;
 259:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		in = *pScratchOut + ((q31_t) * px++ * coeff);
 260:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		*pScratchOut++ = in;
 261:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		in = *pScratchOut + ((q31_t) * px++ * coeff);
 262:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		*pScratchOut++ = in;
 263:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		in = *pScratchOut + ((q31_t) * px++ * coeff);
 264:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		*pScratchOut++ = in;
 265:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 266:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		/* Decrement the loop counter */
 267:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		blkCnt--;
 268:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	}
 269:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 270:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* If the blockSize is not a multiple of 4,
 271:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	 * compute the remaining samples */
 272:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	blkCnt = blockSize % 0x4u;
 273:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 274:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	while (blkCnt > 0u)
 275:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	{
 276:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		/* Perform Multiply-Accumulate */
 277:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		in = *pScratchOut + ((q31_t) * px++ * coeff);
 278:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		*pScratchOut++ = in;
 279:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 280:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		/* Decrement the loop counter */
 281:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		blkCnt--;
 282:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	}
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 8


 283:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 284:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* All the output values are in pScratchOut buffer.
 285:Source\FilteringFunctions/arm_fir_sparse_q7.c ****      Convert them into 1.15 format, saturate and store in the destination buffer. */
 286:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the blockSize. */
 287:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   blkCnt = blockSize >> 2;
 288:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 289:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (blkCnt > 0u)
 290:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 291:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     in1 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
 292:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     in2 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
 293:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     in3 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
 294:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     in4 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
 295:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 296:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *__SIMD32(pOut)++ = __PACKq7(in1, in2, in3, in4);
 297:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 298:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the blockSize loop counter */
 299:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt--;
 300:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 301:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 302:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* If the blockSize is not a multiple of 4,
 303:Source\FilteringFunctions/arm_fir_sparse_q7.c ****      remaining samples are processed in the below loop */
 304:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   blkCnt = blockSize % 0x4u;
 305:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 306:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (blkCnt > 0u)
 307:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 308:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pOut++ = (q7_t) __SSAT(*pScr2++ >> 7, 8);
 309:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 310:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the blockSize loop counter */
 311:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt--;
 312:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 313:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 314:Source\FilteringFunctions/arm_fir_sparse_q7.c **** #else
 315:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 316:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Run the below code for Cortex-M0 */
 317:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 318:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* BlockSize of Input samples are copied into the state buffer */
 319:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* StateIndex points to the starting position to write in the state buffer */
 320:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,
 118              		.loc 1 320 0
 119 0096 E823     		mov	r3, #232
 120 0098 FB18     		add	r3, r7, r3
 121 009a 1A68     		ldr	r2, [r3]
 122 009c FB68     		ldr	r3, [r7, #12]
 123 009e 0233     		add	r3, r3, #2
 124 00a0 F021     		mov	r1, #240
 125 00a2 7918     		add	r1, r7, r1
 126 00a4 0968     		ldr	r1, [r1]
 127 00a6 DC20     		mov	r0, #220
 128 00a8 3818     		add	r0, r7, r0
 129 00aa 0160     		str	r1, [r0]
 130 00ac D821     		mov	r1, #216
 131 00ae 7918     		add	r1, r7, r1
 132 00b0 0A60     		str	r2, [r1]
 133 00b2 D422     		mov	r2, #212
 134 00b4 BA18     		add	r2, r7, r2
 135 00b6 1360     		str	r3, [r2]
 136 00b8 0123     		mov	r3, #1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 9


 137 00ba D022     		mov	r2, #208
 138 00bc BA18     		add	r2, r7, r2
 139 00be 1360     		str	r3, [r2]
 140 00c0 BB68     		ldr	r3, [r7, #8]
 141 00c2 CC22     		mov	r2, #204
 142 00c4 BA18     		add	r2, r7, r2
 143 00c6 1360     		str	r3, [r2]
 144 00c8 0123     		mov	r3, #1
 145 00ca C822     		mov	r2, #200
 146 00cc BA18     		add	r2, r7, r2
 147 00ce 1360     		str	r3, [r2]
 148 00d0 9223     		mov	r3, #146
 149 00d2 5B00     		lsl	r3, r3, #1
 150 00d4 FB18     		add	r3, r7, r3
 151 00d6 1B68     		ldr	r3, [r3]
 152 00d8 C422     		mov	r2, #196
 153 00da BA18     		add	r2, r7, r2
 154 00dc 1360     		str	r3, [r2]
 155              	.LBB12:
 156              	.LBB13:
 157              		.file 2 ".\\Include/arm_math.h"
   1:.\Include/arm_math.h **** /* ----------------------------------------------------------------------
   2:.\Include/arm_math.h ****  * Project:      CMSIS DSP Library
   3:.\Include/arm_math.h ****  * Title:        arm_math.h
   4:.\Include/arm_math.h ****  * Description:  Public header file for CMSIS DSP Library
   5:.\Include/arm_math.h ****  *
   6:.\Include/arm_math.h ****  * $Date:        27. January 2017
   7:.\Include/arm_math.h ****  * $Revision:    V.1.5.1
   8:.\Include/arm_math.h ****  *
   9:.\Include/arm_math.h ****  * Target Processor: Cortex-M cores
  10:.\Include/arm_math.h ****  * -------------------------------------------------------------------- */
  11:.\Include/arm_math.h **** /*
  12:.\Include/arm_math.h ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:.\Include/arm_math.h ****  *
  14:.\Include/arm_math.h ****  * SPDX-License-Identifier: Apache-2.0
  15:.\Include/arm_math.h ****  *
  16:.\Include/arm_math.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:.\Include/arm_math.h ****  * not use this file except in compliance with the License.
  18:.\Include/arm_math.h ****  * You may obtain a copy of the License at
  19:.\Include/arm_math.h ****  *
  20:.\Include/arm_math.h ****  * www.apache.org/licenses/LICENSE-2.0
  21:.\Include/arm_math.h ****  *
  22:.\Include/arm_math.h ****  * Unless required by applicable law or agreed to in writing, software
  23:.\Include/arm_math.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:.\Include/arm_math.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:.\Include/arm_math.h ****  * See the License for the specific language governing permissions and
  26:.\Include/arm_math.h ****  * limitations under the License.
  27:.\Include/arm_math.h ****  */
  28:.\Include/arm_math.h **** 
  29:.\Include/arm_math.h **** /**
  30:.\Include/arm_math.h ****    \mainpage CMSIS DSP Software Library
  31:.\Include/arm_math.h ****    *
  32:.\Include/arm_math.h ****    * Introduction
  33:.\Include/arm_math.h ****    * ------------
  34:.\Include/arm_math.h ****    *
  35:.\Include/arm_math.h ****    * This user manual describes the CMSIS DSP software library,
  36:.\Include/arm_math.h ****    * a suite of common signal processing functions for use on Cortex-M processor based devices.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 10


  37:.\Include/arm_math.h ****    *
  38:.\Include/arm_math.h ****    * The library is divided into a number of functions each covering a specific category:
  39:.\Include/arm_math.h ****    * - Basic math functions
  40:.\Include/arm_math.h ****    * - Fast math functions
  41:.\Include/arm_math.h ****    * - Complex math functions
  42:.\Include/arm_math.h ****    * - Filters
  43:.\Include/arm_math.h ****    * - Matrix functions
  44:.\Include/arm_math.h ****    * - Transforms
  45:.\Include/arm_math.h ****    * - Motor control functions
  46:.\Include/arm_math.h ****    * - Statistical functions
  47:.\Include/arm_math.h ****    * - Support functions
  48:.\Include/arm_math.h ****    * - Interpolation functions
  49:.\Include/arm_math.h ****    *
  50:.\Include/arm_math.h ****    * The library has separate functions for operating on 8-bit integers, 16-bit integers,
  51:.\Include/arm_math.h ****    * 32-bit integer and 32-bit floating-point values.
  52:.\Include/arm_math.h ****    *
  53:.\Include/arm_math.h ****    * Using the Library
  54:.\Include/arm_math.h ****    * ------------
  55:.\Include/arm_math.h ****    *
  56:.\Include/arm_math.h ****    * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> fold
  57:.\Include/arm_math.h ****    * - arm_cortexM7lfdp_math.lib (Cortex-M7, Little endian, Double Precision Floating Point Unit)
  58:.\Include/arm_math.h ****    * - arm_cortexM7bfdp_math.lib (Cortex-M7, Big endian, Double Precision Floating Point Unit)
  59:.\Include/arm_math.h ****    * - arm_cortexM7lfsp_math.lib (Cortex-M7, Little endian, Single Precision Floating Point Unit)
  60:.\Include/arm_math.h ****    * - arm_cortexM7bfsp_math.lib (Cortex-M7, Big endian and Single Precision Floating Point Unit on
  61:.\Include/arm_math.h ****    * - arm_cortexM7l_math.lib (Cortex-M7, Little endian)
  62:.\Include/arm_math.h ****    * - arm_cortexM7b_math.lib (Cortex-M7, Big endian)
  63:.\Include/arm_math.h ****    * - arm_cortexM4lf_math.lib (Cortex-M4, Little endian, Floating Point Unit)
  64:.\Include/arm_math.h ****    * - arm_cortexM4bf_math.lib (Cortex-M4, Big endian, Floating Point Unit)
  65:.\Include/arm_math.h ****    * - arm_cortexM4l_math.lib (Cortex-M4, Little endian)
  66:.\Include/arm_math.h ****    * - arm_cortexM4b_math.lib (Cortex-M4, Big endian)
  67:.\Include/arm_math.h ****    * - arm_cortexM3l_math.lib (Cortex-M3, Little endian)
  68:.\Include/arm_math.h ****    * - arm_cortexM3b_math.lib (Cortex-M3, Big endian)
  69:.\Include/arm_math.h ****    * - arm_cortexM0l_math.lib (Cortex-M0 / Cortex-M0+, Little endian)
  70:.\Include/arm_math.h ****    * - arm_cortexM0b_math.lib (Cortex-M0 / Cortex-M0+, Big endian)
  71:.\Include/arm_math.h ****    * - arm_ARMv8MBLl_math.lib (ARMv8M Baseline, Little endian)
  72:.\Include/arm_math.h ****    * - arm_ARMv8MMLl_math.lib (ARMv8M Mainline, Little endian)
  73:.\Include/arm_math.h ****    * - arm_ARMv8MMLlfsp_math.lib (ARMv8M Mainline, Little endian, Single Precision Floating Point U
  74:.\Include/arm_math.h ****    * - arm_ARMv8MMLld_math.lib (ARMv8M Mainline, Little endian, DSP instructions)
  75:.\Include/arm_math.h ****    * - arm_ARMv8MMLldfsp_math.lib (ARMv8M Mainline, Little endian, DSP instructions, Single Precisi
  76:.\Include/arm_math.h ****    *
  77:.\Include/arm_math.h ****    * The library functions are declared in the public file <code>arm_math.h</code> which is placed 
  78:.\Include/arm_math.h ****    * Simply include this file and link the appropriate library in the application and begin calling
  79:.\Include/arm_math.h ****    * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endi
  80:.\Include/arm_math.h ****    * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
  81:.\Include/arm_math.h ****    * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
  82:.\Include/arm_math.h ****    * For ARMv8M cores define pre processor MACRO ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
  83:.\Include/arm_math.h ****    * Set Pre processor MACRO __DSP_PRESENT if ARMv8M Mainline core supports DSP instructions.
  84:.\Include/arm_math.h ****    * 
  85:.\Include/arm_math.h ****    *
  86:.\Include/arm_math.h ****    * Examples
  87:.\Include/arm_math.h ****    * --------
  88:.\Include/arm_math.h ****    *
  89:.\Include/arm_math.h ****    * The library ships with a number of examples which demonstrate how to use the library functions
  90:.\Include/arm_math.h ****    *
  91:.\Include/arm_math.h ****    * Toolchain Support
  92:.\Include/arm_math.h ****    * ------------
  93:.\Include/arm_math.h ****    *
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 11


  94:.\Include/arm_math.h ****    * The library has been developed and tested with MDK-ARM version 5.14.0.0
  95:.\Include/arm_math.h ****    * The library is being tested in GCC and IAR toolchains and updates on this activity will be mad
  96:.\Include/arm_math.h ****    *
  97:.\Include/arm_math.h ****    * Building the Library
  98:.\Include/arm_math.h ****    * ------------
  99:.\Include/arm_math.h ****    *
 100:.\Include/arm_math.h ****    * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in t
 101:.\Include/arm_math.h ****    * - arm_cortexM_math.uvprojx
 102:.\Include/arm_math.h ****    *
 103:.\Include/arm_math.h ****    *
 104:.\Include/arm_math.h ****    * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecti
 105:.\Include/arm_math.h ****    *
 106:.\Include/arm_math.h ****    * Pre-processor Macros
 107:.\Include/arm_math.h ****    * ------------
 108:.\Include/arm_math.h ****    *
 109:.\Include/arm_math.h ****    * Each library project have differant pre-processor macros.
 110:.\Include/arm_math.h ****    *
 111:.\Include/arm_math.h ****    * - UNALIGNED_SUPPORT_DISABLE:
 112:.\Include/arm_math.h ****    *
 113:.\Include/arm_math.h ****    * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory acces
 114:.\Include/arm_math.h ****    *
 115:.\Include/arm_math.h ****    * - ARM_MATH_BIG_ENDIAN:
 116:.\Include/arm_math.h ****    *
 117:.\Include/arm_math.h ****    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default libra
 118:.\Include/arm_math.h ****    *
 119:.\Include/arm_math.h ****    * - ARM_MATH_MATRIX_CHECK:
 120:.\Include/arm_math.h ****    *
 121:.\Include/arm_math.h ****    * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
 122:.\Include/arm_math.h ****    *
 123:.\Include/arm_math.h ****    * - ARM_MATH_ROUNDING:
 124:.\Include/arm_math.h ****    *
 125:.\Include/arm_math.h ****    * Define macro ARM_MATH_ROUNDING for rounding on support functions
 126:.\Include/arm_math.h ****    *
 127:.\Include/arm_math.h ****    * - ARM_MATH_CMx:
 128:.\Include/arm_math.h ****    *
 129:.\Include/arm_math.h ****    * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for build
 130:.\Include/arm_math.h ****    * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building libra
 131:.\Include/arm_math.h ****    * ARM_MATH_CM7 for building the library on cortex-M7.
 132:.\Include/arm_math.h ****    *
 133:.\Include/arm_math.h ****    * - ARM_MATH_ARMV8MxL:
 134:.\Include/arm_math.h ****    *
 135:.\Include/arm_math.h ****    * Define macro ARM_MATH_ARMV8MBL for building the library on ARMv8M Baseline target, ARM_MATH_AR
 136:.\Include/arm_math.h ****    * on ARMv8M Mainline target.
 137:.\Include/arm_math.h ****    *
 138:.\Include/arm_math.h ****    * - __FPU_PRESENT:
 139:.\Include/arm_math.h ****    *
 140:.\Include/arm_math.h ****    * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro f
 141:.\Include/arm_math.h ****    *
 142:.\Include/arm_math.h ****    * - __DSP_PRESENT:
 143:.\Include/arm_math.h ****    *
 144:.\Include/arm_math.h ****    * Initialize macro __DSP_PRESENT = 1 when ARMv8M Mainline core supports DSP instructions.
 145:.\Include/arm_math.h ****    *
 146:.\Include/arm_math.h ****    * <hr>
 147:.\Include/arm_math.h ****    * CMSIS-DSP in ARM::CMSIS Pack
 148:.\Include/arm_math.h ****    * -----------------------------
 149:.\Include/arm_math.h ****    *
 150:.\Include/arm_math.h ****    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directorie
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 12


 151:.\Include/arm_math.h ****    * |File/Folder                   |Content                                                       
 152:.\Include/arm_math.h ****    * |------------------------------|--------------------------------------------------------------
 153:.\Include/arm_math.h ****    * |\b CMSIS\\Documentation\\DSP  | This documentation                                           
 154:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                     
 155:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library funct
 156:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                      
 157:.\Include/arm_math.h ****    *
 158:.\Include/arm_math.h ****    * <hr>
 159:.\Include/arm_math.h ****    * Revision History of CMSIS-DSP
 160:.\Include/arm_math.h ****    * ------------
 161:.\Include/arm_math.h ****    * Please refer to \ref ChangeLog_pg.
 162:.\Include/arm_math.h ****    *
 163:.\Include/arm_math.h ****    * Copyright Notice
 164:.\Include/arm_math.h ****    * ------------
 165:.\Include/arm_math.h ****    *
 166:.\Include/arm_math.h ****    * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
 167:.\Include/arm_math.h ****    */
 168:.\Include/arm_math.h **** 
 169:.\Include/arm_math.h **** 
 170:.\Include/arm_math.h **** /**
 171:.\Include/arm_math.h ****  * @defgroup groupMath Basic Math Functions
 172:.\Include/arm_math.h ****  */
 173:.\Include/arm_math.h **** 
 174:.\Include/arm_math.h **** /**
 175:.\Include/arm_math.h ****  * @defgroup groupFastMath Fast Math Functions
 176:.\Include/arm_math.h ****  * This set of functions provides a fast approximation to sine, cosine, and square root.
 177:.\Include/arm_math.h ****  * As compared to most of the other functions in the CMSIS math library, the fast math functions
 178:.\Include/arm_math.h ****  * operate on individual values and not arrays.
 179:.\Include/arm_math.h ****  * There are separate functions for Q15, Q31, and floating-point data.
 180:.\Include/arm_math.h ****  *
 181:.\Include/arm_math.h ****  */
 182:.\Include/arm_math.h **** 
 183:.\Include/arm_math.h **** /**
 184:.\Include/arm_math.h ****  * @defgroup groupCmplxMath Complex Math Functions
 185:.\Include/arm_math.h ****  * This set of functions operates on complex data vectors.
 186:.\Include/arm_math.h ****  * The data in the complex arrays is stored in an interleaved fashion
 187:.\Include/arm_math.h ****  * (real, imag, real, imag, ...).
 188:.\Include/arm_math.h ****  * In the API functions, the number of samples in a complex array refers
 189:.\Include/arm_math.h ****  * to the number of complex values; the array contains twice this number of
 190:.\Include/arm_math.h ****  * real values.
 191:.\Include/arm_math.h ****  */
 192:.\Include/arm_math.h **** 
 193:.\Include/arm_math.h **** /**
 194:.\Include/arm_math.h ****  * @defgroup groupFilters Filtering Functions
 195:.\Include/arm_math.h ****  */
 196:.\Include/arm_math.h **** 
 197:.\Include/arm_math.h **** /**
 198:.\Include/arm_math.h ****  * @defgroup groupMatrix Matrix Functions
 199:.\Include/arm_math.h ****  *
 200:.\Include/arm_math.h ****  * This set of functions provides basic matrix math operations.
 201:.\Include/arm_math.h ****  * The functions operate on matrix data structures.  For example,
 202:.\Include/arm_math.h ****  * the type
 203:.\Include/arm_math.h ****  * definition for the floating-point matrix structure is shown
 204:.\Include/arm_math.h ****  * below:
 205:.\Include/arm_math.h ****  * <pre>
 206:.\Include/arm_math.h ****  *     typedef struct
 207:.\Include/arm_math.h ****  *     {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 13


 208:.\Include/arm_math.h ****  *       uint16_t numRows;     // number of rows of the matrix.
 209:.\Include/arm_math.h ****  *       uint16_t numCols;     // number of columns of the matrix.
 210:.\Include/arm_math.h ****  *       float32_t *pData;     // points to the data of the matrix.
 211:.\Include/arm_math.h ****  *     } arm_matrix_instance_f32;
 212:.\Include/arm_math.h ****  * </pre>
 213:.\Include/arm_math.h ****  * There are similar definitions for Q15 and Q31 data types.
 214:.\Include/arm_math.h ****  *
 215:.\Include/arm_math.h ****  * The structure specifies the size of the matrix and then points to
 216:.\Include/arm_math.h ****  * an array of data.  The array is of size <code>numRows X numCols</code>
 217:.\Include/arm_math.h ****  * and the values are arranged in row order.  That is, the
 218:.\Include/arm_math.h ****  * matrix element (i, j) is stored at:
 219:.\Include/arm_math.h ****  * <pre>
 220:.\Include/arm_math.h ****  *     pData[i*numCols + j]
 221:.\Include/arm_math.h ****  * </pre>
 222:.\Include/arm_math.h ****  *
 223:.\Include/arm_math.h ****  * \par Init Functions
 224:.\Include/arm_math.h ****  * There is an associated initialization function for each type of matrix
 225:.\Include/arm_math.h ****  * data structure.
 226:.\Include/arm_math.h ****  * The initialization function sets the values of the internal structure fields.
 227:.\Include/arm_math.h ****  * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
 228:.\Include/arm_math.h ****  * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
 229:.\Include/arm_math.h ****  *
 230:.\Include/arm_math.h ****  * \par
 231:.\Include/arm_math.h ****  * Use of the initialization function is optional. However, if initialization function is used
 232:.\Include/arm_math.h ****  * then the instance structure cannot be placed into a const data section.
 233:.\Include/arm_math.h ****  * To place the instance structure in a const data
 234:.\Include/arm_math.h ****  * section, manually initialize the data structure.  For example:
 235:.\Include/arm_math.h ****  * <pre>
 236:.\Include/arm_math.h ****  * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
 237:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
 238:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
 239:.\Include/arm_math.h ****  * </pre>
 240:.\Include/arm_math.h ****  * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
 241:.\Include/arm_math.h ****  * specifies the number of columns, and <code>pData</code> points to the
 242:.\Include/arm_math.h ****  * data array.
 243:.\Include/arm_math.h ****  *
 244:.\Include/arm_math.h ****  * \par Size Checking
 245:.\Include/arm_math.h ****  * By default all of the matrix functions perform size checking on the input and
 246:.\Include/arm_math.h ****  * output matrices.  For example, the matrix addition function verifies that the
 247:.\Include/arm_math.h ****  * two input matrices and the output matrix all have the same number of rows and
 248:.\Include/arm_math.h ****  * columns.  If the size check fails the functions return:
 249:.\Include/arm_math.h ****  * <pre>
 250:.\Include/arm_math.h ****  *     ARM_MATH_SIZE_MISMATCH
 251:.\Include/arm_math.h ****  * </pre>
 252:.\Include/arm_math.h ****  * Otherwise the functions return
 253:.\Include/arm_math.h ****  * <pre>
 254:.\Include/arm_math.h ****  *     ARM_MATH_SUCCESS
 255:.\Include/arm_math.h ****  * </pre>
 256:.\Include/arm_math.h ****  * There is some overhead associated with this matrix size checking.
 257:.\Include/arm_math.h ****  * The matrix size checking is enabled via the \#define
 258:.\Include/arm_math.h ****  * <pre>
 259:.\Include/arm_math.h ****  *     ARM_MATH_MATRIX_CHECK
 260:.\Include/arm_math.h ****  * </pre>
 261:.\Include/arm_math.h ****  * within the library project settings.  By default this macro is defined
 262:.\Include/arm_math.h ****  * and size checking is enabled.  By changing the project settings and
 263:.\Include/arm_math.h ****  * undefining this macro size checking is eliminated and the functions
 264:.\Include/arm_math.h ****  * run a bit faster.  With size checking disabled the functions always
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 14


 265:.\Include/arm_math.h ****  * return <code>ARM_MATH_SUCCESS</code>.
 266:.\Include/arm_math.h ****  */
 267:.\Include/arm_math.h **** 
 268:.\Include/arm_math.h **** /**
 269:.\Include/arm_math.h ****  * @defgroup groupTransforms Transform Functions
 270:.\Include/arm_math.h ****  */
 271:.\Include/arm_math.h **** 
 272:.\Include/arm_math.h **** /**
 273:.\Include/arm_math.h ****  * @defgroup groupController Controller Functions
 274:.\Include/arm_math.h ****  */
 275:.\Include/arm_math.h **** 
 276:.\Include/arm_math.h **** /**
 277:.\Include/arm_math.h ****  * @defgroup groupStats Statistics Functions
 278:.\Include/arm_math.h ****  */
 279:.\Include/arm_math.h **** /**
 280:.\Include/arm_math.h ****  * @defgroup groupSupport Support Functions
 281:.\Include/arm_math.h ****  */
 282:.\Include/arm_math.h **** 
 283:.\Include/arm_math.h **** /**
 284:.\Include/arm_math.h ****  * @defgroup groupInterpolation Interpolation Functions
 285:.\Include/arm_math.h ****  * These functions perform 1- and 2-dimensional interpolation of data.
 286:.\Include/arm_math.h ****  * Linear interpolation is used for 1-dimensional data and
 287:.\Include/arm_math.h ****  * bilinear interpolation is used for 2-dimensional data.
 288:.\Include/arm_math.h ****  */
 289:.\Include/arm_math.h **** 
 290:.\Include/arm_math.h **** /**
 291:.\Include/arm_math.h ****  * @defgroup groupExamples Examples
 292:.\Include/arm_math.h ****  */
 293:.\Include/arm_math.h **** #ifndef _ARM_MATH_H
 294:.\Include/arm_math.h **** #define _ARM_MATH_H
 295:.\Include/arm_math.h **** 
 296:.\Include/arm_math.h **** /* ignore some GCC warnings */
 297:.\Include/arm_math.h **** #if defined ( __GNUC__ )
 298:.\Include/arm_math.h **** #pragma GCC diagnostic push
 299:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
 300:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wconversion"
 301:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
 302:.\Include/arm_math.h **** #endif
 303:.\Include/arm_math.h **** 
 304:.\Include/arm_math.h **** #define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
 305:.\Include/arm_math.h **** 
 306:.\Include/arm_math.h **** #if defined(ARM_MATH_CM7)
 307:.\Include/arm_math.h ****   #include "core_cm7.h"
 308:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 309:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM4)
 310:.\Include/arm_math.h ****   #include "core_cm4.h"
 311:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 312:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM3)
 313:.\Include/arm_math.h ****   #include "core_cm3.h"
 314:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0)
 315:.\Include/arm_math.h ****   #include "core_cm0.h"
 316:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 317:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0PLUS)
 318:.\Include/arm_math.h ****   #include "core_cm0plus.h"
 319:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 320:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MBL)
 321:.\Include/arm_math.h ****   #include "core_armv8mbl.h"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 15


 322:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 323:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MML)
 324:.\Include/arm_math.h ****   #include "core_armv8mml.h"
 325:.\Include/arm_math.h ****   #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
 326:.\Include/arm_math.h ****     #define ARM_MATH_DSP
 327:.\Include/arm_math.h ****   #endif
 328:.\Include/arm_math.h **** #else
 329:.\Include/arm_math.h ****   #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_
 330:.\Include/arm_math.h **** #endif
 331:.\Include/arm_math.h **** 
 332:.\Include/arm_math.h **** #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 333:.\Include/arm_math.h **** #include "string.h"
 334:.\Include/arm_math.h **** #include "math.h"
 335:.\Include/arm_math.h **** #ifdef   __cplusplus
 336:.\Include/arm_math.h **** extern "C"
 337:.\Include/arm_math.h **** {
 338:.\Include/arm_math.h **** #endif
 339:.\Include/arm_math.h **** 
 340:.\Include/arm_math.h **** 
 341:.\Include/arm_math.h ****   /**
 342:.\Include/arm_math.h ****    * @brief Macros required for reciprocal calculation in Normalized LMS
 343:.\Include/arm_math.h ****    */
 344:.\Include/arm_math.h **** 
 345:.\Include/arm_math.h **** #define DELTA_Q31          (0x100)
 346:.\Include/arm_math.h **** #define DELTA_Q15          0x5
 347:.\Include/arm_math.h **** #define INDEX_MASK         0x0000003F
 348:.\Include/arm_math.h **** #ifndef PI
 349:.\Include/arm_math.h ****   #define PI               3.14159265358979f
 350:.\Include/arm_math.h **** #endif
 351:.\Include/arm_math.h **** 
 352:.\Include/arm_math.h ****   /**
 353:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Fast math approximations
 354:.\Include/arm_math.h ****    */
 355:.\Include/arm_math.h **** 
 356:.\Include/arm_math.h **** #define FAST_MATH_TABLE_SIZE  512
 357:.\Include/arm_math.h **** #define FAST_MATH_Q31_SHIFT   (32 - 10)
 358:.\Include/arm_math.h **** #define FAST_MATH_Q15_SHIFT   (16 - 10)
 359:.\Include/arm_math.h **** #define CONTROLLER_Q31_SHIFT  (32 - 9)
 360:.\Include/arm_math.h **** #define TABLE_SPACING_Q31     0x400000
 361:.\Include/arm_math.h **** #define TABLE_SPACING_Q15     0x80
 362:.\Include/arm_math.h **** 
 363:.\Include/arm_math.h ****   /**
 364:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Controller functions
 365:.\Include/arm_math.h ****    */
 366:.\Include/arm_math.h ****   /* 1.31(q31) Fixed value of 2/360 */
 367:.\Include/arm_math.h ****   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 368:.\Include/arm_math.h **** #define INPUT_SPACING         0xB60B61
 369:.\Include/arm_math.h **** 
 370:.\Include/arm_math.h ****   /**
 371:.\Include/arm_math.h ****    * @brief Macro for Unaligned Support
 372:.\Include/arm_math.h ****    */
 373:.\Include/arm_math.h **** #ifndef UNALIGNED_SUPPORT_DISABLE
 374:.\Include/arm_math.h ****     #define ALIGN4
 375:.\Include/arm_math.h **** #else
 376:.\Include/arm_math.h ****   #if defined  (__GNUC__)
 377:.\Include/arm_math.h ****     #define ALIGN4 __attribute__((aligned(4)))
 378:.\Include/arm_math.h ****   #else
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 16


 379:.\Include/arm_math.h ****     #define ALIGN4 __align(4)
 380:.\Include/arm_math.h ****   #endif
 381:.\Include/arm_math.h **** #endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 382:.\Include/arm_math.h **** 
 383:.\Include/arm_math.h ****   /**
 384:.\Include/arm_math.h ****    * @brief Error status returned by some functions in the library.
 385:.\Include/arm_math.h ****    */
 386:.\Include/arm_math.h **** 
 387:.\Include/arm_math.h ****   typedef enum
 388:.\Include/arm_math.h ****   {
 389:.\Include/arm_math.h ****     ARM_MATH_SUCCESS = 0,                /**< No error */
 390:.\Include/arm_math.h ****     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
 391:.\Include/arm_math.h ****     ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
 392:.\Include/arm_math.h ****     ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation
 393:.\Include/arm_math.h ****     ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
 394:.\Include/arm_math.h ****     ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is 
 395:.\Include/arm_math.h ****     ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
 396:.\Include/arm_math.h ****   } arm_status;
 397:.\Include/arm_math.h **** 
 398:.\Include/arm_math.h ****   /**
 399:.\Include/arm_math.h ****    * @brief 8-bit fractional data type in 1.7 format.
 400:.\Include/arm_math.h ****    */
 401:.\Include/arm_math.h ****   typedef int8_t q7_t;
 402:.\Include/arm_math.h **** 
 403:.\Include/arm_math.h ****   /**
 404:.\Include/arm_math.h ****    * @brief 16-bit fractional data type in 1.15 format.
 405:.\Include/arm_math.h ****    */
 406:.\Include/arm_math.h ****   typedef int16_t q15_t;
 407:.\Include/arm_math.h **** 
 408:.\Include/arm_math.h ****   /**
 409:.\Include/arm_math.h ****    * @brief 32-bit fractional data type in 1.31 format.
 410:.\Include/arm_math.h ****    */
 411:.\Include/arm_math.h ****   typedef int32_t q31_t;
 412:.\Include/arm_math.h **** 
 413:.\Include/arm_math.h ****   /**
 414:.\Include/arm_math.h ****    * @brief 64-bit fractional data type in 1.63 format.
 415:.\Include/arm_math.h ****    */
 416:.\Include/arm_math.h ****   typedef int64_t q63_t;
 417:.\Include/arm_math.h **** 
 418:.\Include/arm_math.h ****   /**
 419:.\Include/arm_math.h ****    * @brief 32-bit floating-point type definition.
 420:.\Include/arm_math.h ****    */
 421:.\Include/arm_math.h ****   typedef float float32_t;
 422:.\Include/arm_math.h **** 
 423:.\Include/arm_math.h ****   /**
 424:.\Include/arm_math.h ****    * @brief 64-bit floating-point type definition.
 425:.\Include/arm_math.h ****    */
 426:.\Include/arm_math.h ****   typedef double float64_t;
 427:.\Include/arm_math.h **** 
 428:.\Include/arm_math.h ****   /**
 429:.\Include/arm_math.h ****    * @brief definition to read/write two 16 bit values.
 430:.\Include/arm_math.h ****    */
 431:.\Include/arm_math.h **** #if   defined ( __CC_ARM )
 432:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 433:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 434:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 435:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 17


 436:.\Include/arm_math.h **** #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 437:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 438:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 439:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 440:.\Include/arm_math.h **** 
 441:.\Include/arm_math.h **** #elif defined ( __GNUC__ )
 442:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 443:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 444:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 445:.\Include/arm_math.h **** 
 446:.\Include/arm_math.h **** #elif defined ( __ICCARM__ )
 447:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 448:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 449:.\Include/arm_math.h ****   #define CMSIS_INLINE
 450:.\Include/arm_math.h **** 
 451:.\Include/arm_math.h **** #elif defined ( __TI_ARM__ )
 452:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 453:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 454:.\Include/arm_math.h ****   #define CMSIS_INLINE
 455:.\Include/arm_math.h **** 
 456:.\Include/arm_math.h **** #elif defined ( __CSMC__ )
 457:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 458:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 459:.\Include/arm_math.h ****   #define CMSIS_INLINE
 460:.\Include/arm_math.h **** 
 461:.\Include/arm_math.h **** #elif defined ( __TASKING__ )
 462:.\Include/arm_math.h ****   #define __SIMD32_TYPE __unaligned int32_t
 463:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 464:.\Include/arm_math.h ****   #define CMSIS_INLINE
 465:.\Include/arm_math.h **** 
 466:.\Include/arm_math.h **** #else
 467:.\Include/arm_math.h ****   #error Unknown compiler
 468:.\Include/arm_math.h **** #endif
 469:.\Include/arm_math.h **** 
 470:.\Include/arm_math.h **** #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
 471:.\Include/arm_math.h **** #define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
 472:.\Include/arm_math.h **** #define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
 473:.\Include/arm_math.h **** #define __SIMD64(addr)        (*(int64_t **) & (addr))
 474:.\Include/arm_math.h **** 
 475:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 476:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 477:.\Include/arm_math.h ****   /**
 478:.\Include/arm_math.h ****    * @brief definition to pack two 16 bit values.
 479:.\Include/arm_math.h ****    */
 480:.\Include/arm_math.h **** #define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
 481:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
 482:.\Include/arm_math.h **** #define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
 483:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
 484:.\Include/arm_math.h **** 
 485:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 486:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
 487:.\Include/arm_math.h **** 
 488:.\Include/arm_math.h ****    /**
 489:.\Include/arm_math.h ****    * @brief definition to pack four 8 bit values.
 490:.\Include/arm_math.h ****    */
 491:.\Include/arm_math.h **** #ifndef ARM_MATH_BIG_ENDIAN
 492:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 18


 493:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
 494:.\Include/arm_math.h ****                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
 495:.\Include/arm_math.h ****                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
 496:.\Include/arm_math.h ****                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 497:.\Include/arm_math.h **** #else
 498:.\Include/arm_math.h **** 
 499:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
 500:.\Include/arm_math.h ****                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
 501:.\Include/arm_math.h ****                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
 502:.\Include/arm_math.h ****                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 503:.\Include/arm_math.h **** 
 504:.\Include/arm_math.h **** #endif
 505:.\Include/arm_math.h **** 
 506:.\Include/arm_math.h **** 
 507:.\Include/arm_math.h ****   /**
 508:.\Include/arm_math.h ****    * @brief Clips Q63 to Q31 values.
 509:.\Include/arm_math.h ****    */
 510:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
 511:.\Include/arm_math.h ****   q63_t x)
 512:.\Include/arm_math.h ****   {
 513:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 514:.\Include/arm_math.h ****       ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
 515:.\Include/arm_math.h ****   }
 516:.\Include/arm_math.h **** 
 517:.\Include/arm_math.h ****   /**
 518:.\Include/arm_math.h ****    * @brief Clips Q63 to Q15 values.
 519:.\Include/arm_math.h ****    */
 520:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
 521:.\Include/arm_math.h ****   q63_t x)
 522:.\Include/arm_math.h ****   {
 523:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 524:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
 525:.\Include/arm_math.h ****   }
 526:.\Include/arm_math.h **** 
 527:.\Include/arm_math.h ****   /**
 528:.\Include/arm_math.h ****    * @brief Clips Q31 to Q7 values.
 529:.\Include/arm_math.h ****    */
 530:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
 531:.\Include/arm_math.h ****   q31_t x)
 532:.\Include/arm_math.h ****   {
 533:.\Include/arm_math.h ****     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
 534:.\Include/arm_math.h ****       ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
 535:.\Include/arm_math.h ****   }
 536:.\Include/arm_math.h **** 
 537:.\Include/arm_math.h ****   /**
 538:.\Include/arm_math.h ****    * @brief Clips Q31 to Q15 values.
 539:.\Include/arm_math.h ****    */
 540:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
 541:.\Include/arm_math.h ****   q31_t x)
 542:.\Include/arm_math.h ****   {
 543:.\Include/arm_math.h ****     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
 544:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
 545:.\Include/arm_math.h ****   }
 546:.\Include/arm_math.h **** 
 547:.\Include/arm_math.h ****   /**
 548:.\Include/arm_math.h ****    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
 549:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 19


 550:.\Include/arm_math.h **** 
 551:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
 552:.\Include/arm_math.h ****   q63_t x,
 553:.\Include/arm_math.h ****   q31_t y)
 554:.\Include/arm_math.h ****   {
 555:.\Include/arm_math.h ****     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
 556:.\Include/arm_math.h ****             (((q63_t) (x >> 32) * y)));
 557:.\Include/arm_math.h ****   }
 558:.\Include/arm_math.h **** 
 559:.\Include/arm_math.h **** /*
 560:.\Include/arm_math.h ****   #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
 561:.\Include/arm_math.h ****   #define __CLZ __clz
 562:.\Include/arm_math.h ****   #endif
 563:.\Include/arm_math.h ****  */
 564:.\Include/arm_math.h **** /* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
 565:.\Include/arm_math.h **** #if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
 566:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 567:.\Include/arm_math.h ****   q31_t data);
 568:.\Include/arm_math.h **** 
 569:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 570:.\Include/arm_math.h ****   q31_t data)
 571:.\Include/arm_math.h ****   {
 572:.\Include/arm_math.h ****     uint32_t count = 0;
 573:.\Include/arm_math.h ****     uint32_t mask = 0x80000000;
 574:.\Include/arm_math.h **** 
 575:.\Include/arm_math.h ****     while ((data & mask) == 0)
 576:.\Include/arm_math.h ****     {
 577:.\Include/arm_math.h ****       count += 1u;
 578:.\Include/arm_math.h ****       mask = mask >> 1u;
 579:.\Include/arm_math.h ****     }
 580:.\Include/arm_math.h **** 
 581:.\Include/arm_math.h ****     return (count);
 582:.\Include/arm_math.h ****   }
 583:.\Include/arm_math.h **** #endif
 584:.\Include/arm_math.h **** 
 585:.\Include/arm_math.h ****   /**
 586:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
 587:.\Include/arm_math.h ****    */
 588:.\Include/arm_math.h **** 
 589:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
 590:.\Include/arm_math.h ****   q31_t in,
 591:.\Include/arm_math.h ****   q31_t * dst,
 592:.\Include/arm_math.h ****   q31_t * pRecipTable)
 593:.\Include/arm_math.h ****   {
 594:.\Include/arm_math.h ****     q31_t out;
 595:.\Include/arm_math.h ****     uint32_t tempVal;
 596:.\Include/arm_math.h ****     uint32_t index, i;
 597:.\Include/arm_math.h ****     uint32_t signBits;
 598:.\Include/arm_math.h **** 
 599:.\Include/arm_math.h ****     if (in > 0)
 600:.\Include/arm_math.h ****     {
 601:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ( in) - 1));
 602:.\Include/arm_math.h ****     }
 603:.\Include/arm_math.h ****     else
 604:.\Include/arm_math.h ****     {
 605:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ(-in) - 1));
 606:.\Include/arm_math.h ****     }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 20


 607:.\Include/arm_math.h **** 
 608:.\Include/arm_math.h ****     /* Convert input sample to 1.31 format */
 609:.\Include/arm_math.h ****     in = (in << signBits);
 610:.\Include/arm_math.h **** 
 611:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 612:.\Include/arm_math.h ****     index = (uint32_t)(in >> 24);
 613:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 614:.\Include/arm_math.h **** 
 615:.\Include/arm_math.h ****     /* 1.31 with exp 1 */
 616:.\Include/arm_math.h ****     out = pRecipTable[index];
 617:.\Include/arm_math.h **** 
 618:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 619:.\Include/arm_math.h ****     /* running approximation for two iterations */
 620:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 621:.\Include/arm_math.h ****     {
 622:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q63_t) in * out) >> 31);
 623:.\Include/arm_math.h ****       tempVal = 0x7FFFFFFFu - tempVal;
 624:.\Include/arm_math.h ****       /*      1.31 with exp 1 */
 625:.\Include/arm_math.h ****       /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
 626:.\Include/arm_math.h ****       out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
 627:.\Include/arm_math.h ****     }
 628:.\Include/arm_math.h **** 
 629:.\Include/arm_math.h ****     /* write output */
 630:.\Include/arm_math.h ****     *dst = out;
 631:.\Include/arm_math.h **** 
 632:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 633:.\Include/arm_math.h ****     return (signBits + 1u);
 634:.\Include/arm_math.h ****   }
 635:.\Include/arm_math.h **** 
 636:.\Include/arm_math.h **** 
 637:.\Include/arm_math.h ****   /**
 638:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
 639:.\Include/arm_math.h ****    */
 640:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
 641:.\Include/arm_math.h ****   q15_t in,
 642:.\Include/arm_math.h ****   q15_t * dst,
 643:.\Include/arm_math.h ****   q15_t * pRecipTable)
 644:.\Include/arm_math.h ****   {
 645:.\Include/arm_math.h ****     q15_t out = 0;
 646:.\Include/arm_math.h ****     uint32_t tempVal = 0;
 647:.\Include/arm_math.h ****     uint32_t index = 0, i = 0;
 648:.\Include/arm_math.h ****     uint32_t signBits = 0;
 649:.\Include/arm_math.h **** 
 650:.\Include/arm_math.h ****     if (in > 0)
 651:.\Include/arm_math.h ****     {
 652:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ( in) - 17));
 653:.\Include/arm_math.h ****     }
 654:.\Include/arm_math.h ****     else
 655:.\Include/arm_math.h ****     {
 656:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ(-in) - 17));
 657:.\Include/arm_math.h ****     }
 658:.\Include/arm_math.h **** 
 659:.\Include/arm_math.h ****     /* Convert input sample to 1.15 format */
 660:.\Include/arm_math.h ****     in = (in << signBits);
 661:.\Include/arm_math.h **** 
 662:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 663:.\Include/arm_math.h ****     index = (uint32_t)(in >>  8);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 21


 664:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 665:.\Include/arm_math.h **** 
 666:.\Include/arm_math.h ****     /*      1.15 with exp 1  */
 667:.\Include/arm_math.h ****     out = pRecipTable[index];
 668:.\Include/arm_math.h **** 
 669:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 670:.\Include/arm_math.h ****     /* running approximation for two iterations */
 671:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 672:.\Include/arm_math.h ****     {
 673:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q31_t) in * out) >> 15);
 674:.\Include/arm_math.h ****       tempVal = 0x7FFFu - tempVal;
 675:.\Include/arm_math.h ****       /*      1.15 with exp 1 */
 676:.\Include/arm_math.h ****       out = (q15_t) (((q31_t) out * tempVal) >> 14);
 677:.\Include/arm_math.h ****       /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
 678:.\Include/arm_math.h ****     }
 679:.\Include/arm_math.h **** 
 680:.\Include/arm_math.h ****     /* write output */
 681:.\Include/arm_math.h ****     *dst = out;
 682:.\Include/arm_math.h **** 
 683:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 684:.\Include/arm_math.h ****     return (signBits + 1);
 685:.\Include/arm_math.h ****   }
 686:.\Include/arm_math.h **** 
 687:.\Include/arm_math.h **** 
 688:.\Include/arm_math.h ****   /*
 689:.\Include/arm_math.h ****    * @brief C custom defined intrinisic function for only M0 processors
 690:.\Include/arm_math.h ****    */
 691:.\Include/arm_math.h **** #if defined(ARM_MATH_CM0_FAMILY)
 692:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t __SSAT(
 693:.\Include/arm_math.h ****   q31_t x,
 694:.\Include/arm_math.h ****   uint32_t y)
 695:.\Include/arm_math.h ****   {
 696:.\Include/arm_math.h ****     int32_t posMax, negMin;
 697:.\Include/arm_math.h ****     uint32_t i;
 698:.\Include/arm_math.h **** 
 699:.\Include/arm_math.h ****     posMax = 1;
 700:.\Include/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 701:.\Include/arm_math.h ****     {
 702:.\Include/arm_math.h ****       posMax = posMax * 2;
 703:.\Include/arm_math.h ****     }
 704:.\Include/arm_math.h **** 
 705:.\Include/arm_math.h ****     if (x > 0)
 706:.\Include/arm_math.h ****     {
 707:.\Include/arm_math.h ****       posMax = (posMax - 1);
 708:.\Include/arm_math.h **** 
 709:.\Include/arm_math.h ****       if (x > posMax)
 710:.\Include/arm_math.h ****       {
 711:.\Include/arm_math.h ****         x = posMax;
 712:.\Include/arm_math.h ****       }
 713:.\Include/arm_math.h ****     }
 714:.\Include/arm_math.h ****     else
 715:.\Include/arm_math.h ****     {
 716:.\Include/arm_math.h ****       negMin = -posMax;
 717:.\Include/arm_math.h **** 
 718:.\Include/arm_math.h ****       if (x < negMin)
 719:.\Include/arm_math.h ****       {
 720:.\Include/arm_math.h ****         x = negMin;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 22


 721:.\Include/arm_math.h ****       }
 722:.\Include/arm_math.h ****     }
 723:.\Include/arm_math.h ****     return (x);
 724:.\Include/arm_math.h ****   }
 725:.\Include/arm_math.h **** #endif /* end of ARM_MATH_CM0_FAMILY */
 726:.\Include/arm_math.h **** 
 727:.\Include/arm_math.h **** 
 728:.\Include/arm_math.h ****   /*
 729:.\Include/arm_math.h ****    * @brief C custom defined intrinsic function for M3 and M0 processors
 730:.\Include/arm_math.h ****    */
 731:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 732:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 733:.\Include/arm_math.h **** 
 734:.\Include/arm_math.h ****   /*
 735:.\Include/arm_math.h ****    * @brief C custom defined QADD8 for M3 and M0 processors
 736:.\Include/arm_math.h ****    */
 737:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
 738:.\Include/arm_math.h ****   uint32_t x,
 739:.\Include/arm_math.h ****   uint32_t y)
 740:.\Include/arm_math.h ****   {
 741:.\Include/arm_math.h ****     q31_t r, s, t, u;
 742:.\Include/arm_math.h **** 
 743:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 744:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 745:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 746:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 747:.\Include/arm_math.h **** 
 748:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 749:.\Include/arm_math.h ****   }
 750:.\Include/arm_math.h **** 
 751:.\Include/arm_math.h **** 
 752:.\Include/arm_math.h ****   /*
 753:.\Include/arm_math.h ****    * @brief C custom defined QSUB8 for M3 and M0 processors
 754:.\Include/arm_math.h ****    */
 755:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
 756:.\Include/arm_math.h ****   uint32_t x,
 757:.\Include/arm_math.h ****   uint32_t y)
 758:.\Include/arm_math.h ****   {
 759:.\Include/arm_math.h ****     q31_t r, s, t, u;
 760:.\Include/arm_math.h **** 
 761:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 762:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 763:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 764:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 765:.\Include/arm_math.h **** 
 766:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 767:.\Include/arm_math.h ****   }
 768:.\Include/arm_math.h **** 
 769:.\Include/arm_math.h **** 
 770:.\Include/arm_math.h ****   /*
 771:.\Include/arm_math.h ****    * @brief C custom defined QADD16 for M3 and M0 processors
 772:.\Include/arm_math.h ****    */
 773:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
 774:.\Include/arm_math.h ****   uint32_t x,
 775:.\Include/arm_math.h ****   uint32_t y)
 776:.\Include/arm_math.h ****   {
 777:.\Include/arm_math.h **** /*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 23


 778:.\Include/arm_math.h ****     q31_t r = 0, s = 0;
 779:.\Include/arm_math.h **** 
 780:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 781:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 782:.\Include/arm_math.h **** 
 783:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 784:.\Include/arm_math.h ****   }
 785:.\Include/arm_math.h **** 
 786:.\Include/arm_math.h **** 
 787:.\Include/arm_math.h ****   /*
 788:.\Include/arm_math.h ****    * @brief C custom defined SHADD16 for M3 and M0 processors
 789:.\Include/arm_math.h ****    */
 790:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
 791:.\Include/arm_math.h ****   uint32_t x,
 792:.\Include/arm_math.h ****   uint32_t y)
 793:.\Include/arm_math.h ****   {
 794:.\Include/arm_math.h ****     q31_t r, s;
 795:.\Include/arm_math.h **** 
 796:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 797:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 798:.\Include/arm_math.h **** 
 799:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 800:.\Include/arm_math.h ****   }
 801:.\Include/arm_math.h **** 
 802:.\Include/arm_math.h **** 
 803:.\Include/arm_math.h ****   /*
 804:.\Include/arm_math.h ****    * @brief C custom defined QSUB16 for M3 and M0 processors
 805:.\Include/arm_math.h ****    */
 806:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
 807:.\Include/arm_math.h ****   uint32_t x,
 808:.\Include/arm_math.h ****   uint32_t y)
 809:.\Include/arm_math.h ****   {
 810:.\Include/arm_math.h ****     q31_t r, s;
 811:.\Include/arm_math.h **** 
 812:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 813:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 814:.\Include/arm_math.h **** 
 815:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 816:.\Include/arm_math.h ****   }
 817:.\Include/arm_math.h **** 
 818:.\Include/arm_math.h **** 
 819:.\Include/arm_math.h ****   /*
 820:.\Include/arm_math.h ****    * @brief C custom defined SHSUB16 for M3 and M0 processors
 821:.\Include/arm_math.h ****    */
 822:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
 823:.\Include/arm_math.h ****   uint32_t x,
 824:.\Include/arm_math.h ****   uint32_t y)
 825:.\Include/arm_math.h ****   {
 826:.\Include/arm_math.h ****     q31_t r, s;
 827:.\Include/arm_math.h **** 
 828:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 829:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 830:.\Include/arm_math.h **** 
 831:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 832:.\Include/arm_math.h ****   }
 833:.\Include/arm_math.h **** 
 834:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 24


 835:.\Include/arm_math.h ****   /*
 836:.\Include/arm_math.h ****    * @brief C custom defined QASX for M3 and M0 processors
 837:.\Include/arm_math.h ****    */
 838:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
 839:.\Include/arm_math.h ****   uint32_t x,
 840:.\Include/arm_math.h ****   uint32_t y)
 841:.\Include/arm_math.h ****   {
 842:.\Include/arm_math.h ****     q31_t r, s;
 843:.\Include/arm_math.h **** 
 844:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 845:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 846:.\Include/arm_math.h **** 
 847:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 848:.\Include/arm_math.h ****   }
 849:.\Include/arm_math.h **** 
 850:.\Include/arm_math.h **** 
 851:.\Include/arm_math.h ****   /*
 852:.\Include/arm_math.h ****    * @brief C custom defined SHASX for M3 and M0 processors
 853:.\Include/arm_math.h ****    */
 854:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
 855:.\Include/arm_math.h ****   uint32_t x,
 856:.\Include/arm_math.h ****   uint32_t y)
 857:.\Include/arm_math.h ****   {
 858:.\Include/arm_math.h ****     q31_t r, s;
 859:.\Include/arm_math.h **** 
 860:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 861:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 862:.\Include/arm_math.h **** 
 863:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 864:.\Include/arm_math.h ****   }
 865:.\Include/arm_math.h **** 
 866:.\Include/arm_math.h **** 
 867:.\Include/arm_math.h ****   /*
 868:.\Include/arm_math.h ****    * @brief C custom defined QSAX for M3 and M0 processors
 869:.\Include/arm_math.h ****    */
 870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
 871:.\Include/arm_math.h ****   uint32_t x,
 872:.\Include/arm_math.h ****   uint32_t y)
 873:.\Include/arm_math.h ****   {
 874:.\Include/arm_math.h ****     q31_t r, s;
 875:.\Include/arm_math.h **** 
 876:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 877:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 878:.\Include/arm_math.h **** 
 879:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 880:.\Include/arm_math.h ****   }
 881:.\Include/arm_math.h **** 
 882:.\Include/arm_math.h **** 
 883:.\Include/arm_math.h ****   /*
 884:.\Include/arm_math.h ****    * @brief C custom defined SHSAX for M3 and M0 processors
 885:.\Include/arm_math.h ****    */
 886:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
 887:.\Include/arm_math.h ****   uint32_t x,
 888:.\Include/arm_math.h ****   uint32_t y)
 889:.\Include/arm_math.h ****   {
 890:.\Include/arm_math.h ****     q31_t r, s;
 891:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 25


 892:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 893:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 894:.\Include/arm_math.h **** 
 895:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 896:.\Include/arm_math.h ****   }
 897:.\Include/arm_math.h **** 
 898:.\Include/arm_math.h **** 
 899:.\Include/arm_math.h ****   /*
 900:.\Include/arm_math.h ****    * @brief C custom defined SMUSDX for M3 and M0 processors
 901:.\Include/arm_math.h ****    */
 902:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
 903:.\Include/arm_math.h ****   uint32_t x,
 904:.\Include/arm_math.h ****   uint32_t y)
 905:.\Include/arm_math.h ****   {
 906:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 907:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 908:.\Include/arm_math.h ****   }
 909:.\Include/arm_math.h **** 
 910:.\Include/arm_math.h ****   /*
 911:.\Include/arm_math.h ****    * @brief C custom defined SMUADX for M3 and M0 processors
 912:.\Include/arm_math.h ****    */
 913:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
 914:.\Include/arm_math.h ****   uint32_t x,
 915:.\Include/arm_math.h ****   uint32_t y)
 916:.\Include/arm_math.h ****   {
 917:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 918:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 919:.\Include/arm_math.h ****   }
 920:.\Include/arm_math.h **** 
 921:.\Include/arm_math.h **** 
 922:.\Include/arm_math.h ****   /*
 923:.\Include/arm_math.h ****    * @brief C custom defined QADD for M3 and M0 processors
 924:.\Include/arm_math.h ****    */
 925:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
 926:.\Include/arm_math.h ****   int32_t x,
 927:.\Include/arm_math.h ****   int32_t y)
 928:.\Include/arm_math.h ****   {
 929:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
 930:.\Include/arm_math.h ****   }
 931:.\Include/arm_math.h **** 
 932:.\Include/arm_math.h **** 
 933:.\Include/arm_math.h ****   /*
 934:.\Include/arm_math.h ****    * @brief C custom defined QSUB for M3 and M0 processors
 935:.\Include/arm_math.h ****    */
 936:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
 937:.\Include/arm_math.h ****   int32_t x,
 938:.\Include/arm_math.h ****   int32_t y)
 939:.\Include/arm_math.h ****   {
 940:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
 941:.\Include/arm_math.h ****   }
 942:.\Include/arm_math.h **** 
 943:.\Include/arm_math.h **** 
 944:.\Include/arm_math.h ****   /*
 945:.\Include/arm_math.h ****    * @brief C custom defined SMLAD for M3 and M0 processors
 946:.\Include/arm_math.h ****    */
 947:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
 948:.\Include/arm_math.h ****   uint32_t x,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 26


 949:.\Include/arm_math.h ****   uint32_t y,
 950:.\Include/arm_math.h ****   uint32_t sum)
 951:.\Include/arm_math.h ****   {
 952:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 953:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 954:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 955:.\Include/arm_math.h ****   }
 956:.\Include/arm_math.h **** 
 957:.\Include/arm_math.h **** 
 958:.\Include/arm_math.h ****   /*
 959:.\Include/arm_math.h ****    * @brief C custom defined SMLADX for M3 and M0 processors
 960:.\Include/arm_math.h ****    */
 961:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
 962:.\Include/arm_math.h ****   uint32_t x,
 963:.\Include/arm_math.h ****   uint32_t y,
 964:.\Include/arm_math.h ****   uint32_t sum)
 965:.\Include/arm_math.h ****   {
 966:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 967:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 968:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 969:.\Include/arm_math.h ****   }
 970:.\Include/arm_math.h **** 
 971:.\Include/arm_math.h **** 
 972:.\Include/arm_math.h ****   /*
 973:.\Include/arm_math.h ****    * @brief C custom defined SMLSDX for M3 and M0 processors
 974:.\Include/arm_math.h ****    */
 975:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
 976:.\Include/arm_math.h ****   uint32_t x,
 977:.\Include/arm_math.h ****   uint32_t y,
 978:.\Include/arm_math.h ****   uint32_t sum)
 979:.\Include/arm_math.h ****   {
 980:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 981:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 982:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 983:.\Include/arm_math.h ****   }
 984:.\Include/arm_math.h **** 
 985:.\Include/arm_math.h **** 
 986:.\Include/arm_math.h ****   /*
 987:.\Include/arm_math.h ****    * @brief C custom defined SMLALD for M3 and M0 processors
 988:.\Include/arm_math.h ****    */
 989:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
 990:.\Include/arm_math.h ****   uint32_t x,
 991:.\Include/arm_math.h ****   uint32_t y,
 992:.\Include/arm_math.h ****   uint64_t sum)
 993:.\Include/arm_math.h ****   {
 994:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
 995:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 996:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 997:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 998:.\Include/arm_math.h ****   }
 999:.\Include/arm_math.h **** 
1000:.\Include/arm_math.h **** 
1001:.\Include/arm_math.h ****   /*
1002:.\Include/arm_math.h ****    * @brief C custom defined SMLALDX for M3 and M0 processors
1003:.\Include/arm_math.h ****    */
1004:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
1005:.\Include/arm_math.h ****   uint32_t x,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 27


1006:.\Include/arm_math.h ****   uint32_t y,
1007:.\Include/arm_math.h ****   uint64_t sum)
1008:.\Include/arm_math.h ****   {
1009:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
1010:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
1011:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
1012:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
1013:.\Include/arm_math.h ****   }
1014:.\Include/arm_math.h **** 
1015:.\Include/arm_math.h **** 
1016:.\Include/arm_math.h ****   /*
1017:.\Include/arm_math.h ****    * @brief C custom defined SMUAD for M3 and M0 processors
1018:.\Include/arm_math.h ****    */
1019:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
1020:.\Include/arm_math.h ****   uint32_t x,
1021:.\Include/arm_math.h ****   uint32_t y)
1022:.\Include/arm_math.h ****   {
1023:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
1024:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1025:.\Include/arm_math.h ****   }
1026:.\Include/arm_math.h **** 
1027:.\Include/arm_math.h **** 
1028:.\Include/arm_math.h ****   /*
1029:.\Include/arm_math.h ****    * @brief C custom defined SMUSD for M3 and M0 processors
1030:.\Include/arm_math.h ****    */
1031:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
1032:.\Include/arm_math.h ****   uint32_t x,
1033:.\Include/arm_math.h ****   uint32_t y)
1034:.\Include/arm_math.h ****   {
1035:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
1036:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1037:.\Include/arm_math.h ****   }
1038:.\Include/arm_math.h **** 
1039:.\Include/arm_math.h **** 
1040:.\Include/arm_math.h ****   /*
1041:.\Include/arm_math.h ****    * @brief C custom defined SXTB16 for M3 and M0 processors
1042:.\Include/arm_math.h ****    */
1043:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
1044:.\Include/arm_math.h ****   uint32_t x)
1045:.\Include/arm_math.h ****   {
1046:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
1047:.\Include/arm_math.h ****                        ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
1048:.\Include/arm_math.h ****   }
1049:.\Include/arm_math.h **** 
1050:.\Include/arm_math.h ****   /*
1051:.\Include/arm_math.h ****    * @brief C custom defined SMMLA for M3 and M0 processors
1052:.\Include/arm_math.h ****    */
1053:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
1054:.\Include/arm_math.h ****   int32_t x,
1055:.\Include/arm_math.h ****   int32_t y,
1056:.\Include/arm_math.h ****   int32_t sum)
1057:.\Include/arm_math.h ****   {
1058:.\Include/arm_math.h ****     return (sum + (int32_t) (((int64_t) x * y) >> 32));
1059:.\Include/arm_math.h ****   }
1060:.\Include/arm_math.h **** 
1061:.\Include/arm_math.h **** #if 0
1062:.\Include/arm_math.h ****   /*
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 28


1063:.\Include/arm_math.h ****    * @brief C custom defined PKHBT for unavailable DSP extension
1064:.\Include/arm_math.h ****    */
1065:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHBT(
1066:.\Include/arm_math.h ****   uint32_t x,
1067:.\Include/arm_math.h ****   uint32_t y,
1068:.\Include/arm_math.h ****   uint32_t leftshift)
1069:.\Include/arm_math.h ****   {
1070:.\Include/arm_math.h ****     return ( ((x             ) & 0x0000FFFFUL) |
1071:.\Include/arm_math.h ****              ((y << leftshift) & 0xFFFF0000UL)  );
1072:.\Include/arm_math.h ****   }
1073:.\Include/arm_math.h **** 
1074:.\Include/arm_math.h ****   /*
1075:.\Include/arm_math.h ****    * @brief C custom defined PKHTB for unavailable DSP extension
1076:.\Include/arm_math.h ****    */
1077:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHTB(
1078:.\Include/arm_math.h ****   uint32_t x,
1079:.\Include/arm_math.h ****   uint32_t y,
1080:.\Include/arm_math.h ****   uint32_t rightshift)
1081:.\Include/arm_math.h ****   {
1082:.\Include/arm_math.h ****     return ( ((x              ) & 0xFFFF0000UL) |
1083:.\Include/arm_math.h ****              ((y >> rightshift) & 0x0000FFFFUL)  );
1084:.\Include/arm_math.h ****   }
1085:.\Include/arm_math.h **** #endif
1086:.\Include/arm_math.h **** 
1087:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
1088:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
1089:.\Include/arm_math.h **** 
1090:.\Include/arm_math.h **** 
1091:.\Include/arm_math.h ****   /**
1092:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 FIR filter.
1093:.\Include/arm_math.h ****    */
1094:.\Include/arm_math.h ****   typedef struct
1095:.\Include/arm_math.h ****   {
1096:.\Include/arm_math.h ****     uint16_t numTaps;        /**< number of filter coefficients in the filter. */
1097:.\Include/arm_math.h ****     q7_t *pState;            /**< points to the state variable array. The array is of length numTap
1098:.\Include/arm_math.h ****     q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*
1099:.\Include/arm_math.h ****   } arm_fir_instance_q7;
1100:.\Include/arm_math.h **** 
1101:.\Include/arm_math.h ****   /**
1102:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR filter.
1103:.\Include/arm_math.h ****    */
1104:.\Include/arm_math.h ****   typedef struct
1105:.\Include/arm_math.h ****   {
1106:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1107:.\Include/arm_math.h ****     q15_t *pState;            /**< points to the state variable array. The array is of length numTa
1108:.\Include/arm_math.h ****     q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1109:.\Include/arm_math.h ****   } arm_fir_instance_q15;
1110:.\Include/arm_math.h **** 
1111:.\Include/arm_math.h ****   /**
1112:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR filter.
1113:.\Include/arm_math.h ****    */
1114:.\Include/arm_math.h ****   typedef struct
1115:.\Include/arm_math.h ****   {
1116:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1117:.\Include/arm_math.h ****     q31_t *pState;            /**< points to the state variable array. The array is of length numTa
1118:.\Include/arm_math.h ****     q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1119:.\Include/arm_math.h ****   } arm_fir_instance_q31;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 29


1120:.\Include/arm_math.h **** 
1121:.\Include/arm_math.h ****   /**
1122:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR filter.
1123:.\Include/arm_math.h ****    */
1124:.\Include/arm_math.h ****   typedef struct
1125:.\Include/arm_math.h ****   {
1126:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of filter coefficients in the filter. */
1127:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
1128:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
1129:.\Include/arm_math.h ****   } arm_fir_instance_f32;
1130:.\Include/arm_math.h **** 
1131:.\Include/arm_math.h **** 
1132:.\Include/arm_math.h ****   /**
1133:.\Include/arm_math.h ****    * @brief Processing function for the Q7 FIR filter.
1134:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
1135:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1136:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1137:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1138:.\Include/arm_math.h ****    */
1139:.\Include/arm_math.h ****   void arm_fir_q7(
1140:.\Include/arm_math.h ****   const arm_fir_instance_q7 * S,
1141:.\Include/arm_math.h ****   q7_t * pSrc,
1142:.\Include/arm_math.h ****   q7_t * pDst,
1143:.\Include/arm_math.h ****   uint32_t blockSize);
1144:.\Include/arm_math.h **** 
1145:.\Include/arm_math.h **** 
1146:.\Include/arm_math.h ****   /**
1147:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 FIR filter.
1148:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 FIR structure.
1149:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1150:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1151:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1152:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed.
1153:.\Include/arm_math.h ****    */
1154:.\Include/arm_math.h ****   void arm_fir_init_q7(
1155:.\Include/arm_math.h ****   arm_fir_instance_q7 * S,
1156:.\Include/arm_math.h ****   uint16_t numTaps,
1157:.\Include/arm_math.h ****   q7_t * pCoeffs,
1158:.\Include/arm_math.h ****   q7_t * pState,
1159:.\Include/arm_math.h ****   uint32_t blockSize);
1160:.\Include/arm_math.h **** 
1161:.\Include/arm_math.h **** 
1162:.\Include/arm_math.h ****   /**
1163:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR filter.
1164:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR structure.
1165:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1166:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1167:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1168:.\Include/arm_math.h ****    */
1169:.\Include/arm_math.h ****   void arm_fir_q15(
1170:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1171:.\Include/arm_math.h ****   q15_t * pSrc,
1172:.\Include/arm_math.h ****   q15_t * pDst,
1173:.\Include/arm_math.h ****   uint32_t blockSize);
1174:.\Include/arm_math.h **** 
1175:.\Include/arm_math.h **** 
1176:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 30


1177:.\Include/arm_math.h ****    * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
1178:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
1179:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1180:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1181:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1182:.\Include/arm_math.h ****    */
1183:.\Include/arm_math.h ****   void arm_fir_fast_q15(
1184:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1185:.\Include/arm_math.h ****   q15_t * pSrc,
1186:.\Include/arm_math.h ****   q15_t * pDst,
1187:.\Include/arm_math.h ****   uint32_t blockSize);
1188:.\Include/arm_math.h **** 
1189:.\Include/arm_math.h **** 
1190:.\Include/arm_math.h ****   /**
1191:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR filter.
1192:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
1193:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greate
1194:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1195:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1196:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1197:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARG
1198:.\Include/arm_math.h ****    * <code>numTaps</code> is not a supported value.
1199:.\Include/arm_math.h ****    */
1200:.\Include/arm_math.h ****   arm_status arm_fir_init_q15(
1201:.\Include/arm_math.h ****   arm_fir_instance_q15 * S,
1202:.\Include/arm_math.h ****   uint16_t numTaps,
1203:.\Include/arm_math.h ****   q15_t * pCoeffs,
1204:.\Include/arm_math.h ****   q15_t * pState,
1205:.\Include/arm_math.h ****   uint32_t blockSize);
1206:.\Include/arm_math.h **** 
1207:.\Include/arm_math.h **** 
1208:.\Include/arm_math.h ****   /**
1209:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR filter.
1210:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR filter structure.
1211:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1212:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1213:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1214:.\Include/arm_math.h ****    */
1215:.\Include/arm_math.h ****   void arm_fir_q31(
1216:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1217:.\Include/arm_math.h ****   q31_t * pSrc,
1218:.\Include/arm_math.h ****   q31_t * pDst,
1219:.\Include/arm_math.h ****   uint32_t blockSize);
1220:.\Include/arm_math.h **** 
1221:.\Include/arm_math.h **** 
1222:.\Include/arm_math.h ****   /**
1223:.\Include/arm_math.h ****    * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
1224:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR structure.
1225:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1226:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1227:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1228:.\Include/arm_math.h ****    */
1229:.\Include/arm_math.h ****   void arm_fir_fast_q31(
1230:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1231:.\Include/arm_math.h ****   q31_t * pSrc,
1232:.\Include/arm_math.h ****   q31_t * pDst,
1233:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 31


1234:.\Include/arm_math.h **** 
1235:.\Include/arm_math.h **** 
1236:.\Include/arm_math.h ****   /**
1237:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR filter.
1238:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR structure.
1239:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1240:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1241:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1242:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1243:.\Include/arm_math.h ****    */
1244:.\Include/arm_math.h ****   void arm_fir_init_q31(
1245:.\Include/arm_math.h ****   arm_fir_instance_q31 * S,
1246:.\Include/arm_math.h ****   uint16_t numTaps,
1247:.\Include/arm_math.h ****   q31_t * pCoeffs,
1248:.\Include/arm_math.h ****   q31_t * pState,
1249:.\Include/arm_math.h ****   uint32_t blockSize);
1250:.\Include/arm_math.h **** 
1251:.\Include/arm_math.h **** 
1252:.\Include/arm_math.h ****   /**
1253:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR filter.
1254:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR structure.
1255:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1256:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1257:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1258:.\Include/arm_math.h ****    */
1259:.\Include/arm_math.h ****   void arm_fir_f32(
1260:.\Include/arm_math.h ****   const arm_fir_instance_f32 * S,
1261:.\Include/arm_math.h ****   float32_t * pSrc,
1262:.\Include/arm_math.h ****   float32_t * pDst,
1263:.\Include/arm_math.h ****   uint32_t blockSize);
1264:.\Include/arm_math.h **** 
1265:.\Include/arm_math.h **** 
1266:.\Include/arm_math.h ****   /**
1267:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR filter.
1268:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
1269:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1270:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1271:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1272:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1273:.\Include/arm_math.h ****    */
1274:.\Include/arm_math.h ****   void arm_fir_init_f32(
1275:.\Include/arm_math.h ****   arm_fir_instance_f32 * S,
1276:.\Include/arm_math.h ****   uint16_t numTaps,
1277:.\Include/arm_math.h ****   float32_t * pCoeffs,
1278:.\Include/arm_math.h ****   float32_t * pState,
1279:.\Include/arm_math.h ****   uint32_t blockSize);
1280:.\Include/arm_math.h **** 
1281:.\Include/arm_math.h **** 
1282:.\Include/arm_math.h ****   /**
1283:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 Biquad cascade filter.
1284:.\Include/arm_math.h ****    */
1285:.\Include/arm_math.h ****   typedef struct
1286:.\Include/arm_math.h ****   {
1287:.\Include/arm_math.h ****     int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*num
1288:.\Include/arm_math.h ****     q15_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1289:.\Include/arm_math.h ****     q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1290:.\Include/arm_math.h ****     int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 32


1291:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q15;
1292:.\Include/arm_math.h **** 
1293:.\Include/arm_math.h ****   /**
1294:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 Biquad cascade filter.
1295:.\Include/arm_math.h ****    */
1296:.\Include/arm_math.h ****   typedef struct
1297:.\Include/arm_math.h ****   {
1298:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1299:.\Include/arm_math.h ****     q31_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1300:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1301:.\Include/arm_math.h ****     uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
1302:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q31;
1303:.\Include/arm_math.h **** 
1304:.\Include/arm_math.h ****   /**
1305:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Biquad cascade filter.
1306:.\Include/arm_math.h ****    */
1307:.\Include/arm_math.h ****   typedef struct
1308:.\Include/arm_math.h ****   {
1309:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1310:.\Include/arm_math.h ****     float32_t *pState;       /**< Points to the array of state coefficients.  The array is of lengt
1311:.\Include/arm_math.h ****     float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*nu
1312:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_f32;
1313:.\Include/arm_math.h **** 
1314:.\Include/arm_math.h **** 
1315:.\Include/arm_math.h ****   /**
1316:.\Include/arm_math.h ****    * @brief Processing function for the Q15 Biquad cascade filter.
1317:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1318:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1319:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1320:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1321:.\Include/arm_math.h ****    */
1322:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q15(
1323:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1324:.\Include/arm_math.h ****   q15_t * pSrc,
1325:.\Include/arm_math.h ****   q15_t * pDst,
1326:.\Include/arm_math.h ****   uint32_t blockSize);
1327:.\Include/arm_math.h **** 
1328:.\Include/arm_math.h **** 
1329:.\Include/arm_math.h ****   /**
1330:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 Biquad cascade filter.
1331:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
1332:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1333:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1334:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1335:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1336:.\Include/arm_math.h ****    */
1337:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q15(
1338:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q15 * S,
1339:.\Include/arm_math.h ****   uint8_t numStages,
1340:.\Include/arm_math.h ****   q15_t * pCoeffs,
1341:.\Include/arm_math.h ****   q15_t * pState,
1342:.\Include/arm_math.h ****   int8_t postShift);
1343:.\Include/arm_math.h **** 
1344:.\Include/arm_math.h **** 
1345:.\Include/arm_math.h ****   /**
1346:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-
1347:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 33


1348:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1349:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1350:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1351:.\Include/arm_math.h ****    */
1352:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q15(
1353:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1354:.\Include/arm_math.h ****   q15_t * pSrc,
1355:.\Include/arm_math.h ****   q15_t * pDst,
1356:.\Include/arm_math.h ****   uint32_t blockSize);
1357:.\Include/arm_math.h **** 
1358:.\Include/arm_math.h **** 
1359:.\Include/arm_math.h ****   /**
1360:.\Include/arm_math.h ****    * @brief Processing function for the Q31 Biquad cascade filter
1361:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1362:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1363:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1364:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1365:.\Include/arm_math.h ****    */
1366:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q31(
1367:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1368:.\Include/arm_math.h ****   q31_t * pSrc,
1369:.\Include/arm_math.h ****   q31_t * pDst,
1370:.\Include/arm_math.h ****   uint32_t blockSize);
1371:.\Include/arm_math.h **** 
1372:.\Include/arm_math.h **** 
1373:.\Include/arm_math.h ****   /**
1374:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-
1375:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1376:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1377:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1378:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1379:.\Include/arm_math.h ****    */
1380:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q31(
1381:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1382:.\Include/arm_math.h ****   q31_t * pSrc,
1383:.\Include/arm_math.h ****   q31_t * pDst,
1384:.\Include/arm_math.h ****   uint32_t blockSize);
1385:.\Include/arm_math.h **** 
1386:.\Include/arm_math.h **** 
1387:.\Include/arm_math.h ****   /**
1388:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 Biquad cascade filter.
1389:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
1390:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1391:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1392:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1393:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1394:.\Include/arm_math.h ****    */
1395:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q31(
1396:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q31 * S,
1397:.\Include/arm_math.h ****   uint8_t numStages,
1398:.\Include/arm_math.h ****   q31_t * pCoeffs,
1399:.\Include/arm_math.h ****   q31_t * pState,
1400:.\Include/arm_math.h ****   int8_t postShift);
1401:.\Include/arm_math.h **** 
1402:.\Include/arm_math.h **** 
1403:.\Include/arm_math.h ****   /**
1404:.\Include/arm_math.h ****    * @brief Processing function for the floating-point Biquad cascade filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 34


1405:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
1406:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1407:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1408:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1409:.\Include/arm_math.h ****    */
1410:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_f32(
1411:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_f32 * S,
1412:.\Include/arm_math.h ****   float32_t * pSrc,
1413:.\Include/arm_math.h ****   float32_t * pDst,
1414:.\Include/arm_math.h ****   uint32_t blockSize);
1415:.\Include/arm_math.h **** 
1416:.\Include/arm_math.h **** 
1417:.\Include/arm_math.h ****   /**
1418:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point Biquad cascade filter.
1419:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure
1420:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1421:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1422:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1423:.\Include/arm_math.h ****    */
1424:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_f32(
1425:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_f32 * S,
1426:.\Include/arm_math.h ****   uint8_t numStages,
1427:.\Include/arm_math.h ****   float32_t * pCoeffs,
1428:.\Include/arm_math.h ****   float32_t * pState);
1429:.\Include/arm_math.h **** 
1430:.\Include/arm_math.h **** 
1431:.\Include/arm_math.h ****   /**
1432:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1433:.\Include/arm_math.h ****    */
1434:.\Include/arm_math.h ****   typedef struct
1435:.\Include/arm_math.h ****   {
1436:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1437:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1438:.\Include/arm_math.h ****     float32_t *pData;     /**< points to the data of the matrix. */
1439:.\Include/arm_math.h ****   } arm_matrix_instance_f32;
1440:.\Include/arm_math.h **** 
1441:.\Include/arm_math.h **** 
1442:.\Include/arm_math.h ****   /**
1443:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1444:.\Include/arm_math.h ****    */
1445:.\Include/arm_math.h ****   typedef struct
1446:.\Include/arm_math.h ****   {
1447:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1448:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1449:.\Include/arm_math.h ****     float64_t *pData;     /**< points to the data of the matrix. */
1450:.\Include/arm_math.h ****   } arm_matrix_instance_f64;
1451:.\Include/arm_math.h **** 
1452:.\Include/arm_math.h ****   /**
1453:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 matrix structure.
1454:.\Include/arm_math.h ****    */
1455:.\Include/arm_math.h ****   typedef struct
1456:.\Include/arm_math.h ****   {
1457:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1458:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1459:.\Include/arm_math.h ****     q15_t *pData;         /**< points to the data of the matrix. */
1460:.\Include/arm_math.h ****   } arm_matrix_instance_q15;
1461:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 35


1462:.\Include/arm_math.h ****   /**
1463:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 matrix structure.
1464:.\Include/arm_math.h ****    */
1465:.\Include/arm_math.h ****   typedef struct
1466:.\Include/arm_math.h ****   {
1467:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1468:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1469:.\Include/arm_math.h ****     q31_t *pData;         /**< points to the data of the matrix. */
1470:.\Include/arm_math.h ****   } arm_matrix_instance_q31;
1471:.\Include/arm_math.h **** 
1472:.\Include/arm_math.h **** 
1473:.\Include/arm_math.h ****   /**
1474:.\Include/arm_math.h ****    * @brief Floating-point matrix addition.
1475:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1476:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1477:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1478:.\Include/arm_math.h ****    * @return     The function returns either
1479:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1480:.\Include/arm_math.h ****    */
1481:.\Include/arm_math.h ****   arm_status arm_mat_add_f32(
1482:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1483:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1484:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1485:.\Include/arm_math.h **** 
1486:.\Include/arm_math.h **** 
1487:.\Include/arm_math.h ****   /**
1488:.\Include/arm_math.h ****    * @brief Q15 matrix addition.
1489:.\Include/arm_math.h ****    * @param[in]   pSrcA  points to the first input matrix structure
1490:.\Include/arm_math.h ****    * @param[in]   pSrcB  points to the second input matrix structure
1491:.\Include/arm_math.h ****    * @param[out]  pDst   points to output matrix structure
1492:.\Include/arm_math.h ****    * @return     The function returns either
1493:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1494:.\Include/arm_math.h ****    */
1495:.\Include/arm_math.h ****   arm_status arm_mat_add_q15(
1496:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1497:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1498:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1499:.\Include/arm_math.h **** 
1500:.\Include/arm_math.h **** 
1501:.\Include/arm_math.h ****   /**
1502:.\Include/arm_math.h ****    * @brief Q31 matrix addition.
1503:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1504:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1505:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1506:.\Include/arm_math.h ****    * @return     The function returns either
1507:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1508:.\Include/arm_math.h ****    */
1509:.\Include/arm_math.h ****   arm_status arm_mat_add_q31(
1510:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1511:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1512:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1513:.\Include/arm_math.h **** 
1514:.\Include/arm_math.h **** 
1515:.\Include/arm_math.h ****   /**
1516:.\Include/arm_math.h ****    * @brief Floating-point, complex, matrix multiplication.
1517:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1518:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 36


1519:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1520:.\Include/arm_math.h ****    * @return     The function returns either
1521:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1522:.\Include/arm_math.h ****    */
1523:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_f32(
1524:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1525:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1526:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1527:.\Include/arm_math.h **** 
1528:.\Include/arm_math.h **** 
1529:.\Include/arm_math.h ****   /**
1530:.\Include/arm_math.h ****    * @brief Q15, complex,  matrix multiplication.
1531:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1532:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1533:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1534:.\Include/arm_math.h ****    * @return     The function returns either
1535:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1536:.\Include/arm_math.h ****    */
1537:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q15(
1538:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1539:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1540:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1541:.\Include/arm_math.h ****   q15_t * pScratch);
1542:.\Include/arm_math.h **** 
1543:.\Include/arm_math.h **** 
1544:.\Include/arm_math.h ****   /**
1545:.\Include/arm_math.h ****    * @brief Q31, complex, matrix multiplication.
1546:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1547:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1548:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1549:.\Include/arm_math.h ****    * @return     The function returns either
1550:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1551:.\Include/arm_math.h ****    */
1552:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q31(
1553:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1554:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1555:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1556:.\Include/arm_math.h **** 
1557:.\Include/arm_math.h **** 
1558:.\Include/arm_math.h ****   /**
1559:.\Include/arm_math.h ****    * @brief Floating-point matrix transpose.
1560:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1561:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1562:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1563:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1564:.\Include/arm_math.h ****    */
1565:.\Include/arm_math.h ****   arm_status arm_mat_trans_f32(
1566:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1567:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1568:.\Include/arm_math.h **** 
1569:.\Include/arm_math.h **** 
1570:.\Include/arm_math.h ****   /**
1571:.\Include/arm_math.h ****    * @brief Q15 matrix transpose.
1572:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1573:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1574:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1575:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 37


1576:.\Include/arm_math.h ****    */
1577:.\Include/arm_math.h ****   arm_status arm_mat_trans_q15(
1578:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1579:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1580:.\Include/arm_math.h **** 
1581:.\Include/arm_math.h **** 
1582:.\Include/arm_math.h ****   /**
1583:.\Include/arm_math.h ****    * @brief Q31 matrix transpose.
1584:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1585:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1586:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1587:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1588:.\Include/arm_math.h ****    */
1589:.\Include/arm_math.h ****   arm_status arm_mat_trans_q31(
1590:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1591:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1592:.\Include/arm_math.h **** 
1593:.\Include/arm_math.h **** 
1594:.\Include/arm_math.h ****   /**
1595:.\Include/arm_math.h ****    * @brief Floating-point matrix multiplication
1596:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1597:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1598:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1599:.\Include/arm_math.h ****    * @return     The function returns either
1600:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1601:.\Include/arm_math.h ****    */
1602:.\Include/arm_math.h ****   arm_status arm_mat_mult_f32(
1603:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1604:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1605:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1606:.\Include/arm_math.h **** 
1607:.\Include/arm_math.h **** 
1608:.\Include/arm_math.h ****   /**
1609:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication
1610:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1611:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1612:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1613:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1614:.\Include/arm_math.h ****    * @return     The function returns either
1615:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1616:.\Include/arm_math.h ****    */
1617:.\Include/arm_math.h ****   arm_status arm_mat_mult_q15(
1618:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1619:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1620:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1621:.\Include/arm_math.h ****   q15_t * pState);
1622:.\Include/arm_math.h **** 
1623:.\Include/arm_math.h **** 
1624:.\Include/arm_math.h ****   /**
1625:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1626:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1627:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1628:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1629:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1630:.\Include/arm_math.h ****    * @return     The function returns either
1631:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1632:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 38


1633:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q15(
1634:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1635:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1636:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1637:.\Include/arm_math.h ****   q15_t * pState);
1638:.\Include/arm_math.h **** 
1639:.\Include/arm_math.h **** 
1640:.\Include/arm_math.h ****   /**
1641:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication
1642:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1643:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1644:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1645:.\Include/arm_math.h ****    * @return     The function returns either
1646:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1647:.\Include/arm_math.h ****    */
1648:.\Include/arm_math.h ****   arm_status arm_mat_mult_q31(
1649:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1650:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1651:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1652:.\Include/arm_math.h **** 
1653:.\Include/arm_math.h **** 
1654:.\Include/arm_math.h ****   /**
1655:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1656:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1657:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1658:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1659:.\Include/arm_math.h ****    * @return     The function returns either
1660:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1661:.\Include/arm_math.h ****    */
1662:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q31(
1663:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1664:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1665:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1666:.\Include/arm_math.h **** 
1667:.\Include/arm_math.h **** 
1668:.\Include/arm_math.h ****   /**
1669:.\Include/arm_math.h ****    * @brief Floating-point matrix subtraction
1670:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1671:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1672:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1673:.\Include/arm_math.h ****    * @return     The function returns either
1674:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1675:.\Include/arm_math.h ****    */
1676:.\Include/arm_math.h ****   arm_status arm_mat_sub_f32(
1677:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1678:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1679:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1680:.\Include/arm_math.h **** 
1681:.\Include/arm_math.h **** 
1682:.\Include/arm_math.h ****   /**
1683:.\Include/arm_math.h ****    * @brief Q15 matrix subtraction
1684:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1685:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1686:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1687:.\Include/arm_math.h ****    * @return     The function returns either
1688:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1689:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 39


1690:.\Include/arm_math.h ****   arm_status arm_mat_sub_q15(
1691:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1692:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1693:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1694:.\Include/arm_math.h **** 
1695:.\Include/arm_math.h **** 
1696:.\Include/arm_math.h ****   /**
1697:.\Include/arm_math.h ****    * @brief Q31 matrix subtraction
1698:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1699:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1700:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1701:.\Include/arm_math.h ****    * @return     The function returns either
1702:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1703:.\Include/arm_math.h ****    */
1704:.\Include/arm_math.h ****   arm_status arm_mat_sub_q31(
1705:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1706:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1707:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1708:.\Include/arm_math.h **** 
1709:.\Include/arm_math.h **** 
1710:.\Include/arm_math.h ****   /**
1711:.\Include/arm_math.h ****    * @brief Floating-point matrix scaling.
1712:.\Include/arm_math.h ****    * @param[in]  pSrc   points to the input matrix
1713:.\Include/arm_math.h ****    * @param[in]  scale  scale factor
1714:.\Include/arm_math.h ****    * @param[out] pDst   points to the output matrix
1715:.\Include/arm_math.h ****    * @return     The function returns either
1716:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1717:.\Include/arm_math.h ****    */
1718:.\Include/arm_math.h ****   arm_status arm_mat_scale_f32(
1719:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1720:.\Include/arm_math.h ****   float32_t scale,
1721:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1722:.\Include/arm_math.h **** 
1723:.\Include/arm_math.h **** 
1724:.\Include/arm_math.h ****   /**
1725:.\Include/arm_math.h ****    * @brief Q15 matrix scaling.
1726:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1727:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1728:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1729:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix
1730:.\Include/arm_math.h ****    * @return     The function returns either
1731:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1732:.\Include/arm_math.h ****    */
1733:.\Include/arm_math.h ****   arm_status arm_mat_scale_q15(
1734:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1735:.\Include/arm_math.h ****   q15_t scaleFract,
1736:.\Include/arm_math.h ****   int32_t shift,
1737:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1738:.\Include/arm_math.h **** 
1739:.\Include/arm_math.h **** 
1740:.\Include/arm_math.h ****   /**
1741:.\Include/arm_math.h ****    * @brief Q31 matrix scaling.
1742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1743:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1744:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1745:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix structure
1746:.\Include/arm_math.h ****    * @return     The function returns either
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 40


1747:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1748:.\Include/arm_math.h ****    */
1749:.\Include/arm_math.h ****   arm_status arm_mat_scale_q31(
1750:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1751:.\Include/arm_math.h ****   q31_t scaleFract,
1752:.\Include/arm_math.h ****   int32_t shift,
1753:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1754:.\Include/arm_math.h **** 
1755:.\Include/arm_math.h **** 
1756:.\Include/arm_math.h ****   /**
1757:.\Include/arm_math.h ****    * @brief  Q31 matrix initialization.
1758:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1759:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1760:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1761:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1762:.\Include/arm_math.h ****    */
1763:.\Include/arm_math.h ****   void arm_mat_init_q31(
1764:.\Include/arm_math.h ****   arm_matrix_instance_q31 * S,
1765:.\Include/arm_math.h ****   uint16_t nRows,
1766:.\Include/arm_math.h ****   uint16_t nColumns,
1767:.\Include/arm_math.h ****   q31_t * pData);
1768:.\Include/arm_math.h **** 
1769:.\Include/arm_math.h **** 
1770:.\Include/arm_math.h ****   /**
1771:.\Include/arm_math.h ****    * @brief  Q15 matrix initialization.
1772:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1773:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1774:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1775:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1776:.\Include/arm_math.h ****    */
1777:.\Include/arm_math.h ****   void arm_mat_init_q15(
1778:.\Include/arm_math.h ****   arm_matrix_instance_q15 * S,
1779:.\Include/arm_math.h ****   uint16_t nRows,
1780:.\Include/arm_math.h ****   uint16_t nColumns,
1781:.\Include/arm_math.h ****   q15_t * pData);
1782:.\Include/arm_math.h **** 
1783:.\Include/arm_math.h **** 
1784:.\Include/arm_math.h ****   /**
1785:.\Include/arm_math.h ****    * @brief  Floating-point matrix initialization.
1786:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1787:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1788:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1789:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1790:.\Include/arm_math.h ****    */
1791:.\Include/arm_math.h ****   void arm_mat_init_f32(
1792:.\Include/arm_math.h ****   arm_matrix_instance_f32 * S,
1793:.\Include/arm_math.h ****   uint16_t nRows,
1794:.\Include/arm_math.h ****   uint16_t nColumns,
1795:.\Include/arm_math.h ****   float32_t * pData);
1796:.\Include/arm_math.h **** 
1797:.\Include/arm_math.h **** 
1798:.\Include/arm_math.h **** 
1799:.\Include/arm_math.h ****   /**
1800:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 PID Control.
1801:.\Include/arm_math.h ****    */
1802:.\Include/arm_math.h ****   typedef struct
1803:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 41


1804:.\Include/arm_math.h ****     q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
1805:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
1806:.\Include/arm_math.h ****     q15_t A1;
1807:.\Include/arm_math.h ****     q15_t A2;
1808:.\Include/arm_math.h **** #else
1809:.\Include/arm_math.h ****     q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
1810:.\Include/arm_math.h **** #endif
1811:.\Include/arm_math.h ****     q15_t state[3];     /**< The state array of length 3. */
1812:.\Include/arm_math.h ****     q15_t Kp;           /**< The proportional gain. */
1813:.\Include/arm_math.h ****     q15_t Ki;           /**< The integral gain. */
1814:.\Include/arm_math.h ****     q15_t Kd;           /**< The derivative gain. */
1815:.\Include/arm_math.h ****   } arm_pid_instance_q15;
1816:.\Include/arm_math.h **** 
1817:.\Include/arm_math.h ****   /**
1818:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 PID Control.
1819:.\Include/arm_math.h ****    */
1820:.\Include/arm_math.h ****   typedef struct
1821:.\Include/arm_math.h ****   {
1822:.\Include/arm_math.h ****     q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
1823:.\Include/arm_math.h ****     q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
1824:.\Include/arm_math.h ****     q31_t A2;            /**< The derived gain, A2 = Kd . */
1825:.\Include/arm_math.h ****     q31_t state[3];      /**< The state array of length 3. */
1826:.\Include/arm_math.h ****     q31_t Kp;            /**< The proportional gain. */
1827:.\Include/arm_math.h ****     q31_t Ki;            /**< The integral gain. */
1828:.\Include/arm_math.h ****     q31_t Kd;            /**< The derivative gain. */
1829:.\Include/arm_math.h ****   } arm_pid_instance_q31;
1830:.\Include/arm_math.h **** 
1831:.\Include/arm_math.h ****   /**
1832:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point PID Control.
1833:.\Include/arm_math.h ****    */
1834:.\Include/arm_math.h ****   typedef struct
1835:.\Include/arm_math.h ****   {
1836:.\Include/arm_math.h ****     float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
1837:.\Include/arm_math.h ****     float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
1838:.\Include/arm_math.h ****     float32_t A2;          /**< The derived gain, A2 = Kd . */
1839:.\Include/arm_math.h ****     float32_t state[3];    /**< The state array of length 3. */
1840:.\Include/arm_math.h ****     float32_t Kp;          /**< The proportional gain. */
1841:.\Include/arm_math.h ****     float32_t Ki;          /**< The integral gain. */
1842:.\Include/arm_math.h ****     float32_t Kd;          /**< The derivative gain. */
1843:.\Include/arm_math.h ****   } arm_pid_instance_f32;
1844:.\Include/arm_math.h **** 
1845:.\Include/arm_math.h **** 
1846:.\Include/arm_math.h **** 
1847:.\Include/arm_math.h ****   /**
1848:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point PID Control.
1849:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the PID structure.
1850:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1851:.\Include/arm_math.h ****    */
1852:.\Include/arm_math.h ****   void arm_pid_init_f32(
1853:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
1854:.\Include/arm_math.h ****   int32_t resetStateFlag);
1855:.\Include/arm_math.h **** 
1856:.\Include/arm_math.h **** 
1857:.\Include/arm_math.h ****   /**
1858:.\Include/arm_math.h ****    * @brief  Reset function for the floating-point PID Control.
1859:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point PID Control structure
1860:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 42


1861:.\Include/arm_math.h ****   void arm_pid_reset_f32(
1862:.\Include/arm_math.h ****   arm_pid_instance_f32 * S);
1863:.\Include/arm_math.h **** 
1864:.\Include/arm_math.h **** 
1865:.\Include/arm_math.h ****   /**
1866:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 PID Control.
1867:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1868:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1869:.\Include/arm_math.h ****    */
1870:.\Include/arm_math.h ****   void arm_pid_init_q31(
1871:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
1872:.\Include/arm_math.h ****   int32_t resetStateFlag);
1873:.\Include/arm_math.h **** 
1874:.\Include/arm_math.h **** 
1875:.\Include/arm_math.h ****   /**
1876:.\Include/arm_math.h ****    * @brief  Reset function for the Q31 PID Control.
1877:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q31 PID Control structure
1878:.\Include/arm_math.h ****    */
1879:.\Include/arm_math.h **** 
1880:.\Include/arm_math.h ****   void arm_pid_reset_q31(
1881:.\Include/arm_math.h ****   arm_pid_instance_q31 * S);
1882:.\Include/arm_math.h **** 
1883:.\Include/arm_math.h **** 
1884:.\Include/arm_math.h ****   /**
1885:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 PID Control.
1886:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1887:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1888:.\Include/arm_math.h ****    */
1889:.\Include/arm_math.h ****   void arm_pid_init_q15(
1890:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
1891:.\Include/arm_math.h ****   int32_t resetStateFlag);
1892:.\Include/arm_math.h **** 
1893:.\Include/arm_math.h **** 
1894:.\Include/arm_math.h ****   /**
1895:.\Include/arm_math.h ****    * @brief  Reset function for the Q15 PID Control.
1896:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the q15 PID Control structure
1897:.\Include/arm_math.h ****    */
1898:.\Include/arm_math.h ****   void arm_pid_reset_q15(
1899:.\Include/arm_math.h ****   arm_pid_instance_q15 * S);
1900:.\Include/arm_math.h **** 
1901:.\Include/arm_math.h **** 
1902:.\Include/arm_math.h ****   /**
1903:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Linear Interpolate function.
1904:.\Include/arm_math.h ****    */
1905:.\Include/arm_math.h ****   typedef struct
1906:.\Include/arm_math.h ****   {
1907:.\Include/arm_math.h ****     uint32_t nValues;           /**< nValues */
1908:.\Include/arm_math.h ****     float32_t x1;               /**< x1 */
1909:.\Include/arm_math.h ****     float32_t xSpacing;         /**< xSpacing */
1910:.\Include/arm_math.h ****     float32_t *pYData;          /**< pointer to the table of Y values */
1911:.\Include/arm_math.h ****   } arm_linear_interp_instance_f32;
1912:.\Include/arm_math.h **** 
1913:.\Include/arm_math.h ****   /**
1914:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point bilinear interpolation function.
1915:.\Include/arm_math.h ****    */
1916:.\Include/arm_math.h ****   typedef struct
1917:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 43


1918:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1919:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1920:.\Include/arm_math.h ****     float32_t *pData;   /**< points to the data table. */
1921:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_f32;
1922:.\Include/arm_math.h **** 
1923:.\Include/arm_math.h ****    /**
1924:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 bilinear interpolation function.
1925:.\Include/arm_math.h ****    */
1926:.\Include/arm_math.h ****   typedef struct
1927:.\Include/arm_math.h ****   {
1928:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1929:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1930:.\Include/arm_math.h ****     q31_t *pData;       /**< points to the data table. */
1931:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q31;
1932:.\Include/arm_math.h **** 
1933:.\Include/arm_math.h ****    /**
1934:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1935:.\Include/arm_math.h ****    */
1936:.\Include/arm_math.h ****   typedef struct
1937:.\Include/arm_math.h ****   {
1938:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1939:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1940:.\Include/arm_math.h ****     q15_t *pData;       /**< points to the data table. */
1941:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q15;
1942:.\Include/arm_math.h **** 
1943:.\Include/arm_math.h ****    /**
1944:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1945:.\Include/arm_math.h ****    */
1946:.\Include/arm_math.h ****   typedef struct
1947:.\Include/arm_math.h ****   {
1948:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1949:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1950:.\Include/arm_math.h ****     q7_t *pData;        /**< points to the data table. */
1951:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q7;
1952:.\Include/arm_math.h **** 
1953:.\Include/arm_math.h **** 
1954:.\Include/arm_math.h ****   /**
1955:.\Include/arm_math.h ****    * @brief Q7 vector multiplication.
1956:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1957:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1958:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1959:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1960:.\Include/arm_math.h ****    */
1961:.\Include/arm_math.h ****   void arm_mult_q7(
1962:.\Include/arm_math.h ****   q7_t * pSrcA,
1963:.\Include/arm_math.h ****   q7_t * pSrcB,
1964:.\Include/arm_math.h ****   q7_t * pDst,
1965:.\Include/arm_math.h ****   uint32_t blockSize);
1966:.\Include/arm_math.h **** 
1967:.\Include/arm_math.h **** 
1968:.\Include/arm_math.h ****   /**
1969:.\Include/arm_math.h ****    * @brief Q15 vector multiplication.
1970:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1971:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1972:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1973:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1974:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 44


1975:.\Include/arm_math.h ****   void arm_mult_q15(
1976:.\Include/arm_math.h ****   q15_t * pSrcA,
1977:.\Include/arm_math.h ****   q15_t * pSrcB,
1978:.\Include/arm_math.h ****   q15_t * pDst,
1979:.\Include/arm_math.h ****   uint32_t blockSize);
1980:.\Include/arm_math.h **** 
1981:.\Include/arm_math.h **** 
1982:.\Include/arm_math.h ****   /**
1983:.\Include/arm_math.h ****    * @brief Q31 vector multiplication.
1984:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1985:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1986:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1987:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1988:.\Include/arm_math.h ****    */
1989:.\Include/arm_math.h ****   void arm_mult_q31(
1990:.\Include/arm_math.h ****   q31_t * pSrcA,
1991:.\Include/arm_math.h ****   q31_t * pSrcB,
1992:.\Include/arm_math.h ****   q31_t * pDst,
1993:.\Include/arm_math.h ****   uint32_t blockSize);
1994:.\Include/arm_math.h **** 
1995:.\Include/arm_math.h **** 
1996:.\Include/arm_math.h ****   /**
1997:.\Include/arm_math.h ****    * @brief Floating-point vector multiplication.
1998:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1999:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2000:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2001:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2002:.\Include/arm_math.h ****    */
2003:.\Include/arm_math.h ****   void arm_mult_f32(
2004:.\Include/arm_math.h ****   float32_t * pSrcA,
2005:.\Include/arm_math.h ****   float32_t * pSrcB,
2006:.\Include/arm_math.h ****   float32_t * pDst,
2007:.\Include/arm_math.h ****   uint32_t blockSize);
2008:.\Include/arm_math.h **** 
2009:.\Include/arm_math.h **** 
2010:.\Include/arm_math.h ****   /**
2011:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2012:.\Include/arm_math.h ****    */
2013:.\Include/arm_math.h ****   typedef struct
2014:.\Include/arm_math.h ****   {
2015:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2016:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2017:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2018:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
2019:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2020:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2021:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2022:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q15;
2023:.\Include/arm_math.h **** 
2024:.\Include/arm_math.h **** /* Deprecated */
2025:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q15(
2026:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q15 * S,
2027:.\Include/arm_math.h ****   uint16_t fftLen,
2028:.\Include/arm_math.h ****   uint8_t ifftFlag,
2029:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2030:.\Include/arm_math.h **** 
2031:.\Include/arm_math.h **** /* Deprecated */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 45


2032:.\Include/arm_math.h ****   void arm_cfft_radix2_q15(
2033:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q15 * S,
2034:.\Include/arm_math.h ****   q15_t * pSrc);
2035:.\Include/arm_math.h **** 
2036:.\Include/arm_math.h **** 
2037:.\Include/arm_math.h ****   /**
2038:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2039:.\Include/arm_math.h ****    */
2040:.\Include/arm_math.h ****   typedef struct
2041:.\Include/arm_math.h ****   {
2042:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2043:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2044:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2045:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
2046:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2047:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2048:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2049:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q15;
2050:.\Include/arm_math.h **** 
2051:.\Include/arm_math.h **** /* Deprecated */
2052:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q15(
2053:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S,
2054:.\Include/arm_math.h ****   uint16_t fftLen,
2055:.\Include/arm_math.h ****   uint8_t ifftFlag,
2056:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2057:.\Include/arm_math.h **** 
2058:.\Include/arm_math.h **** /* Deprecated */
2059:.\Include/arm_math.h ****   void arm_cfft_radix4_q15(
2060:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q15 * S,
2061:.\Include/arm_math.h ****   q15_t * pSrc);
2062:.\Include/arm_math.h **** 
2063:.\Include/arm_math.h ****   /**
2064:.\Include/arm_math.h ****    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
2065:.\Include/arm_math.h ****    */
2066:.\Include/arm_math.h ****   typedef struct
2067:.\Include/arm_math.h ****   {
2068:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2069:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2070:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2071:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
2072:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2073:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2074:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2075:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q31;
2076:.\Include/arm_math.h **** 
2077:.\Include/arm_math.h **** /* Deprecated */
2078:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q31(
2079:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q31 * S,
2080:.\Include/arm_math.h ****   uint16_t fftLen,
2081:.\Include/arm_math.h ****   uint8_t ifftFlag,
2082:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2083:.\Include/arm_math.h **** 
2084:.\Include/arm_math.h **** /* Deprecated */
2085:.\Include/arm_math.h ****   void arm_cfft_radix2_q31(
2086:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q31 * S,
2087:.\Include/arm_math.h ****   q31_t * pSrc);
2088:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 46


2089:.\Include/arm_math.h ****   /**
2090:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 CFFT/CIFFT function.
2091:.\Include/arm_math.h ****    */
2092:.\Include/arm_math.h ****   typedef struct
2093:.\Include/arm_math.h ****   {
2094:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2095:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2096:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2097:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
2098:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2099:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2100:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2101:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q31;
2102:.\Include/arm_math.h **** 
2103:.\Include/arm_math.h **** /* Deprecated */
2104:.\Include/arm_math.h ****   void arm_cfft_radix4_q31(
2105:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q31 * S,
2106:.\Include/arm_math.h ****   q31_t * pSrc);
2107:.\Include/arm_math.h **** 
2108:.\Include/arm_math.h **** /* Deprecated */
2109:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q31(
2110:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S,
2111:.\Include/arm_math.h ****   uint16_t fftLen,
2112:.\Include/arm_math.h ****   uint8_t ifftFlag,
2113:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2114:.\Include/arm_math.h **** 
2115:.\Include/arm_math.h ****   /**
2116:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2117:.\Include/arm_math.h ****    */
2118:.\Include/arm_math.h ****   typedef struct
2119:.\Include/arm_math.h ****   {
2120:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2121:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2122:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2123:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2124:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2125:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2126:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2127:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2128:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_f32;
2129:.\Include/arm_math.h **** 
2130:.\Include/arm_math.h **** /* Deprecated */
2131:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_f32(
2132:.\Include/arm_math.h ****   arm_cfft_radix2_instance_f32 * S,
2133:.\Include/arm_math.h ****   uint16_t fftLen,
2134:.\Include/arm_math.h ****   uint8_t ifftFlag,
2135:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2136:.\Include/arm_math.h **** 
2137:.\Include/arm_math.h **** /* Deprecated */
2138:.\Include/arm_math.h ****   void arm_cfft_radix2_f32(
2139:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_f32 * S,
2140:.\Include/arm_math.h ****   float32_t * pSrc);
2141:.\Include/arm_math.h **** 
2142:.\Include/arm_math.h ****   /**
2143:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2144:.\Include/arm_math.h ****    */
2145:.\Include/arm_math.h ****   typedef struct
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 47


2146:.\Include/arm_math.h ****   {
2147:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2148:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2149:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2150:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2151:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2152:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2153:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2154:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2155:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_f32;
2156:.\Include/arm_math.h **** 
2157:.\Include/arm_math.h **** /* Deprecated */
2158:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_f32(
2159:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S,
2160:.\Include/arm_math.h ****   uint16_t fftLen,
2161:.\Include/arm_math.h ****   uint8_t ifftFlag,
2162:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2163:.\Include/arm_math.h **** 
2164:.\Include/arm_math.h **** /* Deprecated */
2165:.\Include/arm_math.h ****   void arm_cfft_radix4_f32(
2166:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_f32 * S,
2167:.\Include/arm_math.h ****   float32_t * pSrc);
2168:.\Include/arm_math.h **** 
2169:.\Include/arm_math.h ****   /**
2170:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2171:.\Include/arm_math.h ****    */
2172:.\Include/arm_math.h ****   typedef struct
2173:.\Include/arm_math.h ****   {
2174:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2175:.\Include/arm_math.h ****     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
2176:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2177:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2178:.\Include/arm_math.h ****   } arm_cfft_instance_q15;
2179:.\Include/arm_math.h **** 
2180:.\Include/arm_math.h **** void arm_cfft_q15(
2181:.\Include/arm_math.h ****     const arm_cfft_instance_q15 * S,
2182:.\Include/arm_math.h ****     q15_t * p1,
2183:.\Include/arm_math.h ****     uint8_t ifftFlag,
2184:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2185:.\Include/arm_math.h **** 
2186:.\Include/arm_math.h ****   /**
2187:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2188:.\Include/arm_math.h ****    */
2189:.\Include/arm_math.h ****   typedef struct
2190:.\Include/arm_math.h ****   {
2191:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2192:.\Include/arm_math.h ****     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
2193:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2194:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2195:.\Include/arm_math.h ****   } arm_cfft_instance_q31;
2196:.\Include/arm_math.h **** 
2197:.\Include/arm_math.h **** void arm_cfft_q31(
2198:.\Include/arm_math.h ****     const arm_cfft_instance_q31 * S,
2199:.\Include/arm_math.h ****     q31_t * p1,
2200:.\Include/arm_math.h ****     uint8_t ifftFlag,
2201:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2202:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 48


2203:.\Include/arm_math.h ****   /**
2204:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2205:.\Include/arm_math.h ****    */
2206:.\Include/arm_math.h ****   typedef struct
2207:.\Include/arm_math.h ****   {
2208:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2209:.\Include/arm_math.h ****     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
2210:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2211:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2212:.\Include/arm_math.h ****   } arm_cfft_instance_f32;
2213:.\Include/arm_math.h **** 
2214:.\Include/arm_math.h ****   void arm_cfft_f32(
2215:.\Include/arm_math.h ****   const arm_cfft_instance_f32 * S,
2216:.\Include/arm_math.h ****   float32_t * p1,
2217:.\Include/arm_math.h ****   uint8_t ifftFlag,
2218:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2219:.\Include/arm_math.h **** 
2220:.\Include/arm_math.h ****   /**
2221:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 RFFT/RIFFT function.
2222:.\Include/arm_math.h ****    */
2223:.\Include/arm_math.h ****   typedef struct
2224:.\Include/arm_math.h ****   {
2225:.\Include/arm_math.h ****     uint32_t fftLenReal;                      /**< length of the real FFT. */
2226:.\Include/arm_math.h ****     uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inver
2227:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disable
2228:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports diffe
2229:.\Include/arm_math.h ****     q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
2230:.\Include/arm_math.h ****     q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
2231:.\Include/arm_math.h ****     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
2232:.\Include/arm_math.h ****   } arm_rfft_instance_q15;
2233:.\Include/arm_math.h **** 
2234:.\Include/arm_math.h ****   arm_status arm_rfft_init_q15(
2235:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S,
2236:.\Include/arm_math.h ****   uint32_t fftLenReal,
2237:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2238:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2239:.\Include/arm_math.h **** 
2240:.\Include/arm_math.h ****   void arm_rfft_q15(
2241:.\Include/arm_math.h ****   const arm_rfft_instance_q15 * S,
2242:.\Include/arm_math.h ****   q15_t * pSrc,
2243:.\Include/arm_math.h ****   q15_t * pDst);
2244:.\Include/arm_math.h **** 
2245:.\Include/arm_math.h ****   /**
2246:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 RFFT/RIFFT function.
2247:.\Include/arm_math.h ****    */
2248:.\Include/arm_math.h ****   typedef struct
2249:.\Include/arm_math.h ****   {
2250:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2251:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2252:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2253:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports dif
2254:.\Include/arm_math.h ****     q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
2255:.\Include/arm_math.h ****     q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
2256:.\Include/arm_math.h ****     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
2257:.\Include/arm_math.h ****   } arm_rfft_instance_q31;
2258:.\Include/arm_math.h **** 
2259:.\Include/arm_math.h ****   arm_status arm_rfft_init_q31(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 49


2260:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S,
2261:.\Include/arm_math.h ****   uint32_t fftLenReal,
2262:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2263:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2264:.\Include/arm_math.h **** 
2265:.\Include/arm_math.h ****   void arm_rfft_q31(
2266:.\Include/arm_math.h ****   const arm_rfft_instance_q31 * S,
2267:.\Include/arm_math.h ****   q31_t * pSrc,
2268:.\Include/arm_math.h ****   q31_t * pDst);
2269:.\Include/arm_math.h **** 
2270:.\Include/arm_math.h ****   /**
2271:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2272:.\Include/arm_math.h ****    */
2273:.\Include/arm_math.h ****   typedef struct
2274:.\Include/arm_math.h ****   {
2275:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2276:.\Include/arm_math.h ****     uint16_t fftLenBy2;                         /**< length of the complex FFT. */
2277:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2278:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2279:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports
2280:.\Include/arm_math.h ****     float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
2281:.\Include/arm_math.h ****     float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
2282:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
2283:.\Include/arm_math.h ****   } arm_rfft_instance_f32;
2284:.\Include/arm_math.h **** 
2285:.\Include/arm_math.h ****   arm_status arm_rfft_init_f32(
2286:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S,
2287:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2288:.\Include/arm_math.h ****   uint32_t fftLenReal,
2289:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2290:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2291:.\Include/arm_math.h **** 
2292:.\Include/arm_math.h ****   void arm_rfft_f32(
2293:.\Include/arm_math.h ****   const arm_rfft_instance_f32 * S,
2294:.\Include/arm_math.h ****   float32_t * pSrc,
2295:.\Include/arm_math.h ****   float32_t * pDst);
2296:.\Include/arm_math.h **** 
2297:.\Include/arm_math.h ****   /**
2298:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2299:.\Include/arm_math.h ****    */
2300:.\Include/arm_math.h **** typedef struct
2301:.\Include/arm_math.h ****   {
2302:.\Include/arm_math.h ****     arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
2303:.\Include/arm_math.h ****     uint16_t fftLenRFFT;             /**< length of the real sequence */
2304:.\Include/arm_math.h ****     float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
2305:.\Include/arm_math.h ****   } arm_rfft_fast_instance_f32 ;
2306:.\Include/arm_math.h **** 
2307:.\Include/arm_math.h **** arm_status arm_rfft_fast_init_f32 (
2308:.\Include/arm_math.h ****    arm_rfft_fast_instance_f32 * S,
2309:.\Include/arm_math.h ****    uint16_t fftLen);
2310:.\Include/arm_math.h **** 
2311:.\Include/arm_math.h **** void arm_rfft_fast_f32(
2312:.\Include/arm_math.h ****   arm_rfft_fast_instance_f32 * S,
2313:.\Include/arm_math.h ****   float32_t * p, float32_t * pOut,
2314:.\Include/arm_math.h ****   uint8_t ifftFlag);
2315:.\Include/arm_math.h **** 
2316:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 50


2317:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
2318:.\Include/arm_math.h ****    */
2319:.\Include/arm_math.h ****   typedef struct
2320:.\Include/arm_math.h ****   {
2321:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2322:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2323:.\Include/arm_math.h ****     float32_t normalize;                 /**< normalizing factor. */
2324:.\Include/arm_math.h ****     float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
2325:.\Include/arm_math.h ****     float32_t *pCosFactor;               /**< points to the cosFactor table. */
2326:.\Include/arm_math.h ****     arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
2327:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
2328:.\Include/arm_math.h ****   } arm_dct4_instance_f32;
2329:.\Include/arm_math.h **** 
2330:.\Include/arm_math.h **** 
2331:.\Include/arm_math.h ****   /**
2332:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point DCT4/IDCT4.
2333:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
2334:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
2335:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
2336:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2337:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2338:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2339:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2340:.\Include/arm_math.h ****    */
2341:.\Include/arm_math.h ****   arm_status arm_dct4_init_f32(
2342:.\Include/arm_math.h ****   arm_dct4_instance_f32 * S,
2343:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S_RFFT,
2344:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2345:.\Include/arm_math.h ****   uint16_t N,
2346:.\Include/arm_math.h ****   uint16_t Nby2,
2347:.\Include/arm_math.h ****   float32_t normalize);
2348:.\Include/arm_math.h **** 
2349:.\Include/arm_math.h **** 
2350:.\Include/arm_math.h ****   /**
2351:.\Include/arm_math.h ****    * @brief Processing function for the floating-point DCT4/IDCT4.
2352:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure
2353:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2354:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2355:.\Include/arm_math.h ****    */
2356:.\Include/arm_math.h ****   void arm_dct4_f32(
2357:.\Include/arm_math.h ****   const arm_dct4_instance_f32 * S,
2358:.\Include/arm_math.h ****   float32_t * pState,
2359:.\Include/arm_math.h ****   float32_t * pInlineBuffer);
2360:.\Include/arm_math.h **** 
2361:.\Include/arm_math.h **** 
2362:.\Include/arm_math.h ****   /**
2363:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 DCT4/IDCT4 function.
2364:.\Include/arm_math.h ****    */
2365:.\Include/arm_math.h ****   typedef struct
2366:.\Include/arm_math.h ****   {
2367:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2368:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2369:.\Include/arm_math.h ****     q31_t normalize;                     /**< normalizing factor. */
2370:.\Include/arm_math.h ****     q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
2371:.\Include/arm_math.h ****     q31_t *pCosFactor;                   /**< points to the cosFactor table. */
2372:.\Include/arm_math.h ****     arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
2373:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 51


2374:.\Include/arm_math.h ****   } arm_dct4_instance_q31;
2375:.\Include/arm_math.h **** 
2376:.\Include/arm_math.h **** 
2377:.\Include/arm_math.h ****   /**
2378:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 DCT4/IDCT4.
2379:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
2380:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
2381:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
2382:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2383:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2384:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2385:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2386:.\Include/arm_math.h ****    */
2387:.\Include/arm_math.h ****   arm_status arm_dct4_init_q31(
2388:.\Include/arm_math.h ****   arm_dct4_instance_q31 * S,
2389:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S_RFFT,
2390:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S_CFFT,
2391:.\Include/arm_math.h ****   uint16_t N,
2392:.\Include/arm_math.h ****   uint16_t Nby2,
2393:.\Include/arm_math.h ****   q31_t normalize);
2394:.\Include/arm_math.h **** 
2395:.\Include/arm_math.h **** 
2396:.\Include/arm_math.h ****   /**
2397:.\Include/arm_math.h ****    * @brief Processing function for the Q31 DCT4/IDCT4.
2398:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q31 DCT4 structure.
2399:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2400:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2401:.\Include/arm_math.h ****    */
2402:.\Include/arm_math.h ****   void arm_dct4_q31(
2403:.\Include/arm_math.h ****   const arm_dct4_instance_q31 * S,
2404:.\Include/arm_math.h ****   q31_t * pState,
2405:.\Include/arm_math.h ****   q31_t * pInlineBuffer);
2406:.\Include/arm_math.h **** 
2407:.\Include/arm_math.h **** 
2408:.\Include/arm_math.h ****   /**
2409:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 DCT4/IDCT4 function.
2410:.\Include/arm_math.h ****    */
2411:.\Include/arm_math.h ****   typedef struct
2412:.\Include/arm_math.h ****   {
2413:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2414:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2415:.\Include/arm_math.h ****     q15_t normalize;                     /**< normalizing factor. */
2416:.\Include/arm_math.h ****     q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
2417:.\Include/arm_math.h ****     q15_t *pCosFactor;                   /**< points to the cosFactor table. */
2418:.\Include/arm_math.h ****     arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
2419:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
2420:.\Include/arm_math.h ****   } arm_dct4_instance_q15;
2421:.\Include/arm_math.h **** 
2422:.\Include/arm_math.h **** 
2423:.\Include/arm_math.h ****   /**
2424:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 DCT4/IDCT4.
2425:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
2426:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
2427:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
2428:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2429:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2430:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 52


2431:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2432:.\Include/arm_math.h ****    */
2433:.\Include/arm_math.h ****   arm_status arm_dct4_init_q15(
2434:.\Include/arm_math.h ****   arm_dct4_instance_q15 * S,
2435:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S_RFFT,
2436:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S_CFFT,
2437:.\Include/arm_math.h ****   uint16_t N,
2438:.\Include/arm_math.h ****   uint16_t Nby2,
2439:.\Include/arm_math.h ****   q15_t normalize);
2440:.\Include/arm_math.h **** 
2441:.\Include/arm_math.h **** 
2442:.\Include/arm_math.h ****   /**
2443:.\Include/arm_math.h ****    * @brief Processing function for the Q15 DCT4/IDCT4.
2444:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q15 DCT4 structure.
2445:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2446:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2447:.\Include/arm_math.h ****    */
2448:.\Include/arm_math.h ****   void arm_dct4_q15(
2449:.\Include/arm_math.h ****   const arm_dct4_instance_q15 * S,
2450:.\Include/arm_math.h ****   q15_t * pState,
2451:.\Include/arm_math.h ****   q15_t * pInlineBuffer);
2452:.\Include/arm_math.h **** 
2453:.\Include/arm_math.h **** 
2454:.\Include/arm_math.h ****   /**
2455:.\Include/arm_math.h ****    * @brief Floating-point vector addition.
2456:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2457:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2458:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2459:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2460:.\Include/arm_math.h ****    */
2461:.\Include/arm_math.h ****   void arm_add_f32(
2462:.\Include/arm_math.h ****   float32_t * pSrcA,
2463:.\Include/arm_math.h ****   float32_t * pSrcB,
2464:.\Include/arm_math.h ****   float32_t * pDst,
2465:.\Include/arm_math.h ****   uint32_t blockSize);
2466:.\Include/arm_math.h **** 
2467:.\Include/arm_math.h **** 
2468:.\Include/arm_math.h ****   /**
2469:.\Include/arm_math.h ****    * @brief Q7 vector addition.
2470:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2471:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2472:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2473:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2474:.\Include/arm_math.h ****    */
2475:.\Include/arm_math.h ****   void arm_add_q7(
2476:.\Include/arm_math.h ****   q7_t * pSrcA,
2477:.\Include/arm_math.h ****   q7_t * pSrcB,
2478:.\Include/arm_math.h ****   q7_t * pDst,
2479:.\Include/arm_math.h ****   uint32_t blockSize);
2480:.\Include/arm_math.h **** 
2481:.\Include/arm_math.h **** 
2482:.\Include/arm_math.h ****   /**
2483:.\Include/arm_math.h ****    * @brief Q15 vector addition.
2484:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2485:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2486:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2487:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 53


2488:.\Include/arm_math.h ****    */
2489:.\Include/arm_math.h ****   void arm_add_q15(
2490:.\Include/arm_math.h ****   q15_t * pSrcA,
2491:.\Include/arm_math.h ****   q15_t * pSrcB,
2492:.\Include/arm_math.h ****   q15_t * pDst,
2493:.\Include/arm_math.h ****   uint32_t blockSize);
2494:.\Include/arm_math.h **** 
2495:.\Include/arm_math.h **** 
2496:.\Include/arm_math.h ****   /**
2497:.\Include/arm_math.h ****    * @brief Q31 vector addition.
2498:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2499:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2500:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2501:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2502:.\Include/arm_math.h ****    */
2503:.\Include/arm_math.h ****   void arm_add_q31(
2504:.\Include/arm_math.h ****   q31_t * pSrcA,
2505:.\Include/arm_math.h ****   q31_t * pSrcB,
2506:.\Include/arm_math.h ****   q31_t * pDst,
2507:.\Include/arm_math.h ****   uint32_t blockSize);
2508:.\Include/arm_math.h **** 
2509:.\Include/arm_math.h **** 
2510:.\Include/arm_math.h ****   /**
2511:.\Include/arm_math.h ****    * @brief Floating-point vector subtraction.
2512:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2513:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2514:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2515:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2516:.\Include/arm_math.h ****    */
2517:.\Include/arm_math.h ****   void arm_sub_f32(
2518:.\Include/arm_math.h ****   float32_t * pSrcA,
2519:.\Include/arm_math.h ****   float32_t * pSrcB,
2520:.\Include/arm_math.h ****   float32_t * pDst,
2521:.\Include/arm_math.h ****   uint32_t blockSize);
2522:.\Include/arm_math.h **** 
2523:.\Include/arm_math.h **** 
2524:.\Include/arm_math.h ****   /**
2525:.\Include/arm_math.h ****    * @brief Q7 vector subtraction.
2526:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2527:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2528:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2529:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2530:.\Include/arm_math.h ****    */
2531:.\Include/arm_math.h ****   void arm_sub_q7(
2532:.\Include/arm_math.h ****   q7_t * pSrcA,
2533:.\Include/arm_math.h ****   q7_t * pSrcB,
2534:.\Include/arm_math.h ****   q7_t * pDst,
2535:.\Include/arm_math.h ****   uint32_t blockSize);
2536:.\Include/arm_math.h **** 
2537:.\Include/arm_math.h **** 
2538:.\Include/arm_math.h ****   /**
2539:.\Include/arm_math.h ****    * @brief Q15 vector subtraction.
2540:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2541:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2542:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2543:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2544:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 54


2545:.\Include/arm_math.h ****   void arm_sub_q15(
2546:.\Include/arm_math.h ****   q15_t * pSrcA,
2547:.\Include/arm_math.h ****   q15_t * pSrcB,
2548:.\Include/arm_math.h ****   q15_t * pDst,
2549:.\Include/arm_math.h ****   uint32_t blockSize);
2550:.\Include/arm_math.h **** 
2551:.\Include/arm_math.h **** 
2552:.\Include/arm_math.h ****   /**
2553:.\Include/arm_math.h ****    * @brief Q31 vector subtraction.
2554:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2555:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2556:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2557:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2558:.\Include/arm_math.h ****    */
2559:.\Include/arm_math.h ****   void arm_sub_q31(
2560:.\Include/arm_math.h ****   q31_t * pSrcA,
2561:.\Include/arm_math.h ****   q31_t * pSrcB,
2562:.\Include/arm_math.h ****   q31_t * pDst,
2563:.\Include/arm_math.h ****   uint32_t blockSize);
2564:.\Include/arm_math.h **** 
2565:.\Include/arm_math.h **** 
2566:.\Include/arm_math.h ****   /**
2567:.\Include/arm_math.h ****    * @brief Multiplies a floating-point vector by a scalar.
2568:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2569:.\Include/arm_math.h ****    * @param[in]  scale      scale factor to be applied
2570:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2571:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2572:.\Include/arm_math.h ****    */
2573:.\Include/arm_math.h ****   void arm_scale_f32(
2574:.\Include/arm_math.h ****   float32_t * pSrc,
2575:.\Include/arm_math.h ****   float32_t scale,
2576:.\Include/arm_math.h ****   float32_t * pDst,
2577:.\Include/arm_math.h ****   uint32_t blockSize);
2578:.\Include/arm_math.h **** 
2579:.\Include/arm_math.h **** 
2580:.\Include/arm_math.h ****   /**
2581:.\Include/arm_math.h ****    * @brief Multiplies a Q7 vector by a scalar.
2582:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2583:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2584:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2585:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2586:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2587:.\Include/arm_math.h ****    */
2588:.\Include/arm_math.h ****   void arm_scale_q7(
2589:.\Include/arm_math.h ****   q7_t * pSrc,
2590:.\Include/arm_math.h ****   q7_t scaleFract,
2591:.\Include/arm_math.h ****   int8_t shift,
2592:.\Include/arm_math.h ****   q7_t * pDst,
2593:.\Include/arm_math.h ****   uint32_t blockSize);
2594:.\Include/arm_math.h **** 
2595:.\Include/arm_math.h **** 
2596:.\Include/arm_math.h ****   /**
2597:.\Include/arm_math.h ****    * @brief Multiplies a Q15 vector by a scalar.
2598:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2599:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2600:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2601:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 55


2602:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2603:.\Include/arm_math.h ****    */
2604:.\Include/arm_math.h ****   void arm_scale_q15(
2605:.\Include/arm_math.h ****   q15_t * pSrc,
2606:.\Include/arm_math.h ****   q15_t scaleFract,
2607:.\Include/arm_math.h ****   int8_t shift,
2608:.\Include/arm_math.h ****   q15_t * pDst,
2609:.\Include/arm_math.h ****   uint32_t blockSize);
2610:.\Include/arm_math.h **** 
2611:.\Include/arm_math.h **** 
2612:.\Include/arm_math.h ****   /**
2613:.\Include/arm_math.h ****    * @brief Multiplies a Q31 vector by a scalar.
2614:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2615:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2616:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2617:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2618:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2619:.\Include/arm_math.h ****    */
2620:.\Include/arm_math.h ****   void arm_scale_q31(
2621:.\Include/arm_math.h ****   q31_t * pSrc,
2622:.\Include/arm_math.h ****   q31_t scaleFract,
2623:.\Include/arm_math.h ****   int8_t shift,
2624:.\Include/arm_math.h ****   q31_t * pDst,
2625:.\Include/arm_math.h ****   uint32_t blockSize);
2626:.\Include/arm_math.h **** 
2627:.\Include/arm_math.h **** 
2628:.\Include/arm_math.h ****   /**
2629:.\Include/arm_math.h ****    * @brief Q7 vector absolute value.
2630:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2631:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2632:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2633:.\Include/arm_math.h ****    */
2634:.\Include/arm_math.h ****   void arm_abs_q7(
2635:.\Include/arm_math.h ****   q7_t * pSrc,
2636:.\Include/arm_math.h ****   q7_t * pDst,
2637:.\Include/arm_math.h ****   uint32_t blockSize);
2638:.\Include/arm_math.h **** 
2639:.\Include/arm_math.h **** 
2640:.\Include/arm_math.h ****   /**
2641:.\Include/arm_math.h ****    * @brief Floating-point vector absolute value.
2642:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2643:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2644:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2645:.\Include/arm_math.h ****    */
2646:.\Include/arm_math.h ****   void arm_abs_f32(
2647:.\Include/arm_math.h ****   float32_t * pSrc,
2648:.\Include/arm_math.h ****   float32_t * pDst,
2649:.\Include/arm_math.h ****   uint32_t blockSize);
2650:.\Include/arm_math.h **** 
2651:.\Include/arm_math.h **** 
2652:.\Include/arm_math.h ****   /**
2653:.\Include/arm_math.h ****    * @brief Q15 vector absolute value.
2654:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2655:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2656:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2657:.\Include/arm_math.h ****    */
2658:.\Include/arm_math.h ****   void arm_abs_q15(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 56


2659:.\Include/arm_math.h ****   q15_t * pSrc,
2660:.\Include/arm_math.h ****   q15_t * pDst,
2661:.\Include/arm_math.h ****   uint32_t blockSize);
2662:.\Include/arm_math.h **** 
2663:.\Include/arm_math.h **** 
2664:.\Include/arm_math.h ****   /**
2665:.\Include/arm_math.h ****    * @brief Q31 vector absolute value.
2666:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2667:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2668:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2669:.\Include/arm_math.h ****    */
2670:.\Include/arm_math.h ****   void arm_abs_q31(
2671:.\Include/arm_math.h ****   q31_t * pSrc,
2672:.\Include/arm_math.h ****   q31_t * pDst,
2673:.\Include/arm_math.h ****   uint32_t blockSize);
2674:.\Include/arm_math.h **** 
2675:.\Include/arm_math.h **** 
2676:.\Include/arm_math.h ****   /**
2677:.\Include/arm_math.h ****    * @brief Dot product of floating-point vectors.
2678:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2679:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2680:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2681:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2682:.\Include/arm_math.h ****    */
2683:.\Include/arm_math.h ****   void arm_dot_prod_f32(
2684:.\Include/arm_math.h ****   float32_t * pSrcA,
2685:.\Include/arm_math.h ****   float32_t * pSrcB,
2686:.\Include/arm_math.h ****   uint32_t blockSize,
2687:.\Include/arm_math.h ****   float32_t * result);
2688:.\Include/arm_math.h **** 
2689:.\Include/arm_math.h **** 
2690:.\Include/arm_math.h ****   /**
2691:.\Include/arm_math.h ****    * @brief Dot product of Q7 vectors.
2692:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2693:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2694:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2695:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2696:.\Include/arm_math.h ****    */
2697:.\Include/arm_math.h ****   void arm_dot_prod_q7(
2698:.\Include/arm_math.h ****   q7_t * pSrcA,
2699:.\Include/arm_math.h ****   q7_t * pSrcB,
2700:.\Include/arm_math.h ****   uint32_t blockSize,
2701:.\Include/arm_math.h ****   q31_t * result);
2702:.\Include/arm_math.h **** 
2703:.\Include/arm_math.h **** 
2704:.\Include/arm_math.h ****   /**
2705:.\Include/arm_math.h ****    * @brief Dot product of Q15 vectors.
2706:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2707:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2708:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2709:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2710:.\Include/arm_math.h ****    */
2711:.\Include/arm_math.h ****   void arm_dot_prod_q15(
2712:.\Include/arm_math.h ****   q15_t * pSrcA,
2713:.\Include/arm_math.h ****   q15_t * pSrcB,
2714:.\Include/arm_math.h ****   uint32_t blockSize,
2715:.\Include/arm_math.h ****   q63_t * result);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 57


2716:.\Include/arm_math.h **** 
2717:.\Include/arm_math.h **** 
2718:.\Include/arm_math.h ****   /**
2719:.\Include/arm_math.h ****    * @brief Dot product of Q31 vectors.
2720:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2721:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2722:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2723:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2724:.\Include/arm_math.h ****    */
2725:.\Include/arm_math.h ****   void arm_dot_prod_q31(
2726:.\Include/arm_math.h ****   q31_t * pSrcA,
2727:.\Include/arm_math.h ****   q31_t * pSrcB,
2728:.\Include/arm_math.h ****   uint32_t blockSize,
2729:.\Include/arm_math.h ****   q63_t * result);
2730:.\Include/arm_math.h **** 
2731:.\Include/arm_math.h **** 
2732:.\Include/arm_math.h ****   /**
2733:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q7 vector a specified number of bits.
2734:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2735:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2736:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2737:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2738:.\Include/arm_math.h ****    */
2739:.\Include/arm_math.h ****   void arm_shift_q7(
2740:.\Include/arm_math.h ****   q7_t * pSrc,
2741:.\Include/arm_math.h ****   int8_t shiftBits,
2742:.\Include/arm_math.h ****   q7_t * pDst,
2743:.\Include/arm_math.h ****   uint32_t blockSize);
2744:.\Include/arm_math.h **** 
2745:.\Include/arm_math.h **** 
2746:.\Include/arm_math.h ****   /**
2747:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q15 vector a specified number of bits.
2748:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2749:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2750:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2751:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2752:.\Include/arm_math.h ****    */
2753:.\Include/arm_math.h ****   void arm_shift_q15(
2754:.\Include/arm_math.h ****   q15_t * pSrc,
2755:.\Include/arm_math.h ****   int8_t shiftBits,
2756:.\Include/arm_math.h ****   q15_t * pDst,
2757:.\Include/arm_math.h ****   uint32_t blockSize);
2758:.\Include/arm_math.h **** 
2759:.\Include/arm_math.h **** 
2760:.\Include/arm_math.h ****   /**
2761:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q31 vector a specified number of bits.
2762:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2763:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2764:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2765:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2766:.\Include/arm_math.h ****    */
2767:.\Include/arm_math.h ****   void arm_shift_q31(
2768:.\Include/arm_math.h ****   q31_t * pSrc,
2769:.\Include/arm_math.h ****   int8_t shiftBits,
2770:.\Include/arm_math.h ****   q31_t * pDst,
2771:.\Include/arm_math.h ****   uint32_t blockSize);
2772:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 58


2773:.\Include/arm_math.h **** 
2774:.\Include/arm_math.h ****   /**
2775:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a floating-point vector.
2776:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2777:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2778:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2779:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2780:.\Include/arm_math.h ****    */
2781:.\Include/arm_math.h ****   void arm_offset_f32(
2782:.\Include/arm_math.h ****   float32_t * pSrc,
2783:.\Include/arm_math.h ****   float32_t offset,
2784:.\Include/arm_math.h ****   float32_t * pDst,
2785:.\Include/arm_math.h ****   uint32_t blockSize);
2786:.\Include/arm_math.h **** 
2787:.\Include/arm_math.h **** 
2788:.\Include/arm_math.h ****   /**
2789:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q7 vector.
2790:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2791:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2792:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2793:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2794:.\Include/arm_math.h ****    */
2795:.\Include/arm_math.h ****   void arm_offset_q7(
2796:.\Include/arm_math.h ****   q7_t * pSrc,
2797:.\Include/arm_math.h ****   q7_t offset,
2798:.\Include/arm_math.h ****   q7_t * pDst,
2799:.\Include/arm_math.h ****   uint32_t blockSize);
2800:.\Include/arm_math.h **** 
2801:.\Include/arm_math.h **** 
2802:.\Include/arm_math.h ****   /**
2803:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q15 vector.
2804:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2805:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2806:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2807:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2808:.\Include/arm_math.h ****    */
2809:.\Include/arm_math.h ****   void arm_offset_q15(
2810:.\Include/arm_math.h ****   q15_t * pSrc,
2811:.\Include/arm_math.h ****   q15_t offset,
2812:.\Include/arm_math.h ****   q15_t * pDst,
2813:.\Include/arm_math.h ****   uint32_t blockSize);
2814:.\Include/arm_math.h **** 
2815:.\Include/arm_math.h **** 
2816:.\Include/arm_math.h ****   /**
2817:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q31 vector.
2818:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2819:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2820:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2821:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2822:.\Include/arm_math.h ****    */
2823:.\Include/arm_math.h ****   void arm_offset_q31(
2824:.\Include/arm_math.h ****   q31_t * pSrc,
2825:.\Include/arm_math.h ****   q31_t offset,
2826:.\Include/arm_math.h ****   q31_t * pDst,
2827:.\Include/arm_math.h ****   uint32_t blockSize);
2828:.\Include/arm_math.h **** 
2829:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 59


2830:.\Include/arm_math.h ****   /**
2831:.\Include/arm_math.h ****    * @brief  Negates the elements of a floating-point vector.
2832:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2833:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2834:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2835:.\Include/arm_math.h ****    */
2836:.\Include/arm_math.h ****   void arm_negate_f32(
2837:.\Include/arm_math.h ****   float32_t * pSrc,
2838:.\Include/arm_math.h ****   float32_t * pDst,
2839:.\Include/arm_math.h ****   uint32_t blockSize);
2840:.\Include/arm_math.h **** 
2841:.\Include/arm_math.h **** 
2842:.\Include/arm_math.h ****   /**
2843:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q7 vector.
2844:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2845:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2846:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2847:.\Include/arm_math.h ****    */
2848:.\Include/arm_math.h ****   void arm_negate_q7(
2849:.\Include/arm_math.h ****   q7_t * pSrc,
2850:.\Include/arm_math.h ****   q7_t * pDst,
2851:.\Include/arm_math.h ****   uint32_t blockSize);
2852:.\Include/arm_math.h **** 
2853:.\Include/arm_math.h **** 
2854:.\Include/arm_math.h ****   /**
2855:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q15 vector.
2856:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2857:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2858:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2859:.\Include/arm_math.h ****    */
2860:.\Include/arm_math.h ****   void arm_negate_q15(
2861:.\Include/arm_math.h ****   q15_t * pSrc,
2862:.\Include/arm_math.h ****   q15_t * pDst,
2863:.\Include/arm_math.h ****   uint32_t blockSize);
2864:.\Include/arm_math.h **** 
2865:.\Include/arm_math.h **** 
2866:.\Include/arm_math.h ****   /**
2867:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q31 vector.
2868:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2869:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2870:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2871:.\Include/arm_math.h ****    */
2872:.\Include/arm_math.h ****   void arm_negate_q31(
2873:.\Include/arm_math.h ****   q31_t * pSrc,
2874:.\Include/arm_math.h ****   q31_t * pDst,
2875:.\Include/arm_math.h ****   uint32_t blockSize);
2876:.\Include/arm_math.h **** 
2877:.\Include/arm_math.h **** 
2878:.\Include/arm_math.h ****   /**
2879:.\Include/arm_math.h ****    * @brief  Copies the elements of a floating-point vector.
2880:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2881:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2882:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2883:.\Include/arm_math.h ****    */
2884:.\Include/arm_math.h ****   void arm_copy_f32(
2885:.\Include/arm_math.h ****   float32_t * pSrc,
2886:.\Include/arm_math.h ****   float32_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 60


2887:.\Include/arm_math.h ****   uint32_t blockSize);
2888:.\Include/arm_math.h **** 
2889:.\Include/arm_math.h **** 
2890:.\Include/arm_math.h ****   /**
2891:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q7 vector.
2892:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2893:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2894:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2895:.\Include/arm_math.h ****    */
2896:.\Include/arm_math.h ****   void arm_copy_q7(
2897:.\Include/arm_math.h ****   q7_t * pSrc,
2898:.\Include/arm_math.h ****   q7_t * pDst,
2899:.\Include/arm_math.h ****   uint32_t blockSize);
2900:.\Include/arm_math.h **** 
2901:.\Include/arm_math.h **** 
2902:.\Include/arm_math.h ****   /**
2903:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q15 vector.
2904:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2905:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2906:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2907:.\Include/arm_math.h ****    */
2908:.\Include/arm_math.h ****   void arm_copy_q15(
2909:.\Include/arm_math.h ****   q15_t * pSrc,
2910:.\Include/arm_math.h ****   q15_t * pDst,
2911:.\Include/arm_math.h ****   uint32_t blockSize);
2912:.\Include/arm_math.h **** 
2913:.\Include/arm_math.h **** 
2914:.\Include/arm_math.h ****   /**
2915:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q31 vector.
2916:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2917:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2918:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2919:.\Include/arm_math.h ****    */
2920:.\Include/arm_math.h ****   void arm_copy_q31(
2921:.\Include/arm_math.h ****   q31_t * pSrc,
2922:.\Include/arm_math.h ****   q31_t * pDst,
2923:.\Include/arm_math.h ****   uint32_t blockSize);
2924:.\Include/arm_math.h **** 
2925:.\Include/arm_math.h **** 
2926:.\Include/arm_math.h ****   /**
2927:.\Include/arm_math.h ****    * @brief  Fills a constant value into a floating-point vector.
2928:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2929:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2930:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2931:.\Include/arm_math.h ****    */
2932:.\Include/arm_math.h ****   void arm_fill_f32(
2933:.\Include/arm_math.h ****   float32_t value,
2934:.\Include/arm_math.h ****   float32_t * pDst,
2935:.\Include/arm_math.h ****   uint32_t blockSize);
2936:.\Include/arm_math.h **** 
2937:.\Include/arm_math.h **** 
2938:.\Include/arm_math.h ****   /**
2939:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q7 vector.
2940:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2941:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2942:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2943:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 61


2944:.\Include/arm_math.h ****   void arm_fill_q7(
2945:.\Include/arm_math.h ****   q7_t value,
2946:.\Include/arm_math.h ****   q7_t * pDst,
2947:.\Include/arm_math.h ****   uint32_t blockSize);
2948:.\Include/arm_math.h **** 
2949:.\Include/arm_math.h **** 
2950:.\Include/arm_math.h ****   /**
2951:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q15 vector.
2952:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2953:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2954:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2955:.\Include/arm_math.h ****    */
2956:.\Include/arm_math.h ****   void arm_fill_q15(
2957:.\Include/arm_math.h ****   q15_t value,
2958:.\Include/arm_math.h ****   q15_t * pDst,
2959:.\Include/arm_math.h ****   uint32_t blockSize);
2960:.\Include/arm_math.h **** 
2961:.\Include/arm_math.h **** 
2962:.\Include/arm_math.h ****   /**
2963:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q31 vector.
2964:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2965:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2966:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2967:.\Include/arm_math.h ****    */
2968:.\Include/arm_math.h ****   void arm_fill_q31(
2969:.\Include/arm_math.h ****   q31_t value,
2970:.\Include/arm_math.h ****   q31_t * pDst,
2971:.\Include/arm_math.h ****   uint32_t blockSize);
2972:.\Include/arm_math.h **** 
2973:.\Include/arm_math.h **** 
2974:.\Include/arm_math.h **** /**
2975:.\Include/arm_math.h ****  * @brief Convolution of floating-point sequences.
2976:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2977:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2978:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2979:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2980:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2981:.\Include/arm_math.h ****  */
2982:.\Include/arm_math.h ****   void arm_conv_f32(
2983:.\Include/arm_math.h ****   float32_t * pSrcA,
2984:.\Include/arm_math.h ****   uint32_t srcALen,
2985:.\Include/arm_math.h ****   float32_t * pSrcB,
2986:.\Include/arm_math.h ****   uint32_t srcBLen,
2987:.\Include/arm_math.h ****   float32_t * pDst);
2988:.\Include/arm_math.h **** 
2989:.\Include/arm_math.h **** 
2990:.\Include/arm_math.h ****   /**
2991:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences.
2992:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2993:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2994:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2995:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2996:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2997:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2998:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2999:.\Include/arm_math.h ****    */
3000:.\Include/arm_math.h ****   void arm_conv_opt_q15(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 62


3001:.\Include/arm_math.h ****   q15_t * pSrcA,
3002:.\Include/arm_math.h ****   uint32_t srcALen,
3003:.\Include/arm_math.h ****   q15_t * pSrcB,
3004:.\Include/arm_math.h ****   uint32_t srcBLen,
3005:.\Include/arm_math.h ****   q15_t * pDst,
3006:.\Include/arm_math.h ****   q15_t * pScratch1,
3007:.\Include/arm_math.h ****   q15_t * pScratch2);
3008:.\Include/arm_math.h **** 
3009:.\Include/arm_math.h **** 
3010:.\Include/arm_math.h **** /**
3011:.\Include/arm_math.h ****  * @brief Convolution of Q15 sequences.
3012:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
3013:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
3014:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
3015:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
3016:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
3017:.\Include/arm_math.h ****  */
3018:.\Include/arm_math.h ****   void arm_conv_q15(
3019:.\Include/arm_math.h ****   q15_t * pSrcA,
3020:.\Include/arm_math.h ****   uint32_t srcALen,
3021:.\Include/arm_math.h ****   q15_t * pSrcB,
3022:.\Include/arm_math.h ****   uint32_t srcBLen,
3023:.\Include/arm_math.h ****   q15_t * pDst);
3024:.\Include/arm_math.h **** 
3025:.\Include/arm_math.h **** 
3026:.\Include/arm_math.h ****   /**
3027:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3028:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3029:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3030:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3031:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3032:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3033:.\Include/arm_math.h ****    */
3034:.\Include/arm_math.h ****   void arm_conv_fast_q15(
3035:.\Include/arm_math.h ****           q15_t * pSrcA,
3036:.\Include/arm_math.h ****           uint32_t srcALen,
3037:.\Include/arm_math.h ****           q15_t * pSrcB,
3038:.\Include/arm_math.h ****           uint32_t srcBLen,
3039:.\Include/arm_math.h ****           q15_t * pDst);
3040:.\Include/arm_math.h **** 
3041:.\Include/arm_math.h **** 
3042:.\Include/arm_math.h ****   /**
3043:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3044:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3045:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3046:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3047:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3048:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3049:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
3050:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
3051:.\Include/arm_math.h ****    */
3052:.\Include/arm_math.h ****   void arm_conv_fast_opt_q15(
3053:.\Include/arm_math.h ****   q15_t * pSrcA,
3054:.\Include/arm_math.h ****   uint32_t srcALen,
3055:.\Include/arm_math.h ****   q15_t * pSrcB,
3056:.\Include/arm_math.h ****   uint32_t srcBLen,
3057:.\Include/arm_math.h ****   q15_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 63


3058:.\Include/arm_math.h ****   q15_t * pScratch1,
3059:.\Include/arm_math.h ****   q15_t * pScratch2);
3060:.\Include/arm_math.h **** 
3061:.\Include/arm_math.h **** 
3062:.\Include/arm_math.h ****   /**
3063:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences.
3064:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3065:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3066:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3067:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3068:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3069:.\Include/arm_math.h ****    */
3070:.\Include/arm_math.h ****   void arm_conv_q31(
3071:.\Include/arm_math.h ****   q31_t * pSrcA,
3072:.\Include/arm_math.h ****   uint32_t srcALen,
3073:.\Include/arm_math.h ****   q31_t * pSrcB,
3074:.\Include/arm_math.h ****   uint32_t srcBLen,
3075:.\Include/arm_math.h ****   q31_t * pDst);
3076:.\Include/arm_math.h **** 
3077:.\Include/arm_math.h **** 
3078:.\Include/arm_math.h ****   /**
3079:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3080:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3081:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3082:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3083:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3084:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3085:.\Include/arm_math.h ****    */
3086:.\Include/arm_math.h ****   void arm_conv_fast_q31(
3087:.\Include/arm_math.h ****   q31_t * pSrcA,
3088:.\Include/arm_math.h ****   uint32_t srcALen,
3089:.\Include/arm_math.h ****   q31_t * pSrcB,
3090:.\Include/arm_math.h ****   uint32_t srcBLen,
3091:.\Include/arm_math.h ****   q31_t * pDst);
3092:.\Include/arm_math.h **** 
3093:.\Include/arm_math.h **** 
3094:.\Include/arm_math.h ****     /**
3095:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3096:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3097:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3098:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3099:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3100:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3101:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
3102:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
3103:.\Include/arm_math.h ****    */
3104:.\Include/arm_math.h ****   void arm_conv_opt_q7(
3105:.\Include/arm_math.h ****   q7_t * pSrcA,
3106:.\Include/arm_math.h ****   uint32_t srcALen,
3107:.\Include/arm_math.h ****   q7_t * pSrcB,
3108:.\Include/arm_math.h ****   uint32_t srcBLen,
3109:.\Include/arm_math.h ****   q7_t * pDst,
3110:.\Include/arm_math.h ****   q15_t * pScratch1,
3111:.\Include/arm_math.h ****   q15_t * pScratch2);
3112:.\Include/arm_math.h **** 
3113:.\Include/arm_math.h **** 
3114:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 64


3115:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3116:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3117:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3118:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3119:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3120:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3121:.\Include/arm_math.h ****    */
3122:.\Include/arm_math.h ****   void arm_conv_q7(
3123:.\Include/arm_math.h ****   q7_t * pSrcA,
3124:.\Include/arm_math.h ****   uint32_t srcALen,
3125:.\Include/arm_math.h ****   q7_t * pSrcB,
3126:.\Include/arm_math.h ****   uint32_t srcBLen,
3127:.\Include/arm_math.h ****   q7_t * pDst);
3128:.\Include/arm_math.h **** 
3129:.\Include/arm_math.h **** 
3130:.\Include/arm_math.h ****   /**
3131:.\Include/arm_math.h ****    * @brief Partial convolution of floating-point sequences.
3132:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3133:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3134:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3135:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3136:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3137:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3138:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3139:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3140:.\Include/arm_math.h ****    */
3141:.\Include/arm_math.h ****   arm_status arm_conv_partial_f32(
3142:.\Include/arm_math.h ****   float32_t * pSrcA,
3143:.\Include/arm_math.h ****   uint32_t srcALen,
3144:.\Include/arm_math.h ****   float32_t * pSrcB,
3145:.\Include/arm_math.h ****   uint32_t srcBLen,
3146:.\Include/arm_math.h ****   float32_t * pDst,
3147:.\Include/arm_math.h ****   uint32_t firstIndex,
3148:.\Include/arm_math.h ****   uint32_t numPoints);
3149:.\Include/arm_math.h **** 
3150:.\Include/arm_math.h **** 
3151:.\Include/arm_math.h ****   /**
3152:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3153:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3154:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3155:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3156:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3157:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3158:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3159:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3160:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3161:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3162:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3163:.\Include/arm_math.h ****    */
3164:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q15(
3165:.\Include/arm_math.h ****   q15_t * pSrcA,
3166:.\Include/arm_math.h ****   uint32_t srcALen,
3167:.\Include/arm_math.h ****   q15_t * pSrcB,
3168:.\Include/arm_math.h ****   uint32_t srcBLen,
3169:.\Include/arm_math.h ****   q15_t * pDst,
3170:.\Include/arm_math.h ****   uint32_t firstIndex,
3171:.\Include/arm_math.h ****   uint32_t numPoints,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 65


3172:.\Include/arm_math.h ****   q15_t * pScratch1,
3173:.\Include/arm_math.h ****   q15_t * pScratch2);
3174:.\Include/arm_math.h **** 
3175:.\Include/arm_math.h **** 
3176:.\Include/arm_math.h ****   /**
3177:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3178:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3179:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3180:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3181:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3182:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3183:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3184:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3185:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3186:.\Include/arm_math.h ****    */
3187:.\Include/arm_math.h ****   arm_status arm_conv_partial_q15(
3188:.\Include/arm_math.h ****   q15_t * pSrcA,
3189:.\Include/arm_math.h ****   uint32_t srcALen,
3190:.\Include/arm_math.h ****   q15_t * pSrcB,
3191:.\Include/arm_math.h ****   uint32_t srcBLen,
3192:.\Include/arm_math.h ****   q15_t * pDst,
3193:.\Include/arm_math.h ****   uint32_t firstIndex,
3194:.\Include/arm_math.h ****   uint32_t numPoints);
3195:.\Include/arm_math.h **** 
3196:.\Include/arm_math.h **** 
3197:.\Include/arm_math.h ****   /**
3198:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3199:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3200:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3201:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3202:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3203:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3204:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3205:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3206:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3207:.\Include/arm_math.h ****    */
3208:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q15(
3209:.\Include/arm_math.h ****   q15_t * pSrcA,
3210:.\Include/arm_math.h ****   uint32_t srcALen,
3211:.\Include/arm_math.h ****   q15_t * pSrcB,
3212:.\Include/arm_math.h ****   uint32_t srcBLen,
3213:.\Include/arm_math.h ****   q15_t * pDst,
3214:.\Include/arm_math.h ****   uint32_t firstIndex,
3215:.\Include/arm_math.h ****   uint32_t numPoints);
3216:.\Include/arm_math.h **** 
3217:.\Include/arm_math.h **** 
3218:.\Include/arm_math.h ****   /**
3219:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3220:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3221:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3222:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3223:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3224:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3225:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3226:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3227:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3228:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 66


3229:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3230:.\Include/arm_math.h ****    */
3231:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_opt_q15(
3232:.\Include/arm_math.h ****   q15_t * pSrcA,
3233:.\Include/arm_math.h ****   uint32_t srcALen,
3234:.\Include/arm_math.h ****   q15_t * pSrcB,
3235:.\Include/arm_math.h ****   uint32_t srcBLen,
3236:.\Include/arm_math.h ****   q15_t * pDst,
3237:.\Include/arm_math.h ****   uint32_t firstIndex,
3238:.\Include/arm_math.h ****   uint32_t numPoints,
3239:.\Include/arm_math.h ****   q15_t * pScratch1,
3240:.\Include/arm_math.h ****   q15_t * pScratch2);
3241:.\Include/arm_math.h **** 
3242:.\Include/arm_math.h **** 
3243:.\Include/arm_math.h ****   /**
3244:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences.
3245:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3246:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3247:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3248:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3249:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3250:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3251:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3252:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3253:.\Include/arm_math.h ****    */
3254:.\Include/arm_math.h ****   arm_status arm_conv_partial_q31(
3255:.\Include/arm_math.h ****   q31_t * pSrcA,
3256:.\Include/arm_math.h ****   uint32_t srcALen,
3257:.\Include/arm_math.h ****   q31_t * pSrcB,
3258:.\Include/arm_math.h ****   uint32_t srcBLen,
3259:.\Include/arm_math.h ****   q31_t * pDst,
3260:.\Include/arm_math.h ****   uint32_t firstIndex,
3261:.\Include/arm_math.h ****   uint32_t numPoints);
3262:.\Include/arm_math.h **** 
3263:.\Include/arm_math.h **** 
3264:.\Include/arm_math.h ****   /**
3265:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3266:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3267:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3268:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3269:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3270:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3271:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3272:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3273:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3274:.\Include/arm_math.h ****    */
3275:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q31(
3276:.\Include/arm_math.h ****   q31_t * pSrcA,
3277:.\Include/arm_math.h ****   uint32_t srcALen,
3278:.\Include/arm_math.h ****   q31_t * pSrcB,
3279:.\Include/arm_math.h ****   uint32_t srcBLen,
3280:.\Include/arm_math.h ****   q31_t * pDst,
3281:.\Include/arm_math.h ****   uint32_t firstIndex,
3282:.\Include/arm_math.h ****   uint32_t numPoints);
3283:.\Include/arm_math.h **** 
3284:.\Include/arm_math.h **** 
3285:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 67


3286:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences
3287:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3288:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3289:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3290:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3291:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3292:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3293:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3294:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) 
3295:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)
3296:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3297:.\Include/arm_math.h ****    */
3298:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q7(
3299:.\Include/arm_math.h ****   q7_t * pSrcA,
3300:.\Include/arm_math.h ****   uint32_t srcALen,
3301:.\Include/arm_math.h ****   q7_t * pSrcB,
3302:.\Include/arm_math.h ****   uint32_t srcBLen,
3303:.\Include/arm_math.h ****   q7_t * pDst,
3304:.\Include/arm_math.h ****   uint32_t firstIndex,
3305:.\Include/arm_math.h ****   uint32_t numPoints,
3306:.\Include/arm_math.h ****   q15_t * pScratch1,
3307:.\Include/arm_math.h ****   q15_t * pScratch2);
3308:.\Include/arm_math.h **** 
3309:.\Include/arm_math.h **** 
3310:.\Include/arm_math.h **** /**
3311:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences.
3312:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3313:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3314:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3315:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3316:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3317:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3318:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3319:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3320:.\Include/arm_math.h ****    */
3321:.\Include/arm_math.h ****   arm_status arm_conv_partial_q7(
3322:.\Include/arm_math.h ****   q7_t * pSrcA,
3323:.\Include/arm_math.h ****   uint32_t srcALen,
3324:.\Include/arm_math.h ****   q7_t * pSrcB,
3325:.\Include/arm_math.h ****   uint32_t srcBLen,
3326:.\Include/arm_math.h ****   q7_t * pDst,
3327:.\Include/arm_math.h ****   uint32_t firstIndex,
3328:.\Include/arm_math.h ****   uint32_t numPoints);
3329:.\Include/arm_math.h **** 
3330:.\Include/arm_math.h **** 
3331:.\Include/arm_math.h ****   /**
3332:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR decimator.
3333:.\Include/arm_math.h ****    */
3334:.\Include/arm_math.h ****   typedef struct
3335:.\Include/arm_math.h ****   {
3336:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3337:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3338:.\Include/arm_math.h ****     q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3339:.\Include/arm_math.h ****     q15_t *pState;              /**< points to the state variable array. The array is of length num
3340:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q15;
3341:.\Include/arm_math.h **** 
3342:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 68


3343:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR decimator.
3344:.\Include/arm_math.h ****    */
3345:.\Include/arm_math.h ****   typedef struct
3346:.\Include/arm_math.h ****   {
3347:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3348:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3349:.\Include/arm_math.h ****     q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3350:.\Include/arm_math.h ****     q31_t *pState;              /**< points to the state variable array. The array is of length num
3351:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q31;
3352:.\Include/arm_math.h **** 
3353:.\Include/arm_math.h ****   /**
3354:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR decimator.
3355:.\Include/arm_math.h ****    */
3356:.\Include/arm_math.h ****   typedef struct
3357:.\Include/arm_math.h ****   {
3358:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3359:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3360:.\Include/arm_math.h ****     float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTap
3361:.\Include/arm_math.h ****     float32_t *pState;          /**< points to the state variable array. The array is of length num
3362:.\Include/arm_math.h ****   } arm_fir_decimate_instance_f32;
3363:.\Include/arm_math.h **** 
3364:.\Include/arm_math.h **** 
3365:.\Include/arm_math.h ****   /**
3366:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR decimator.
3367:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
3368:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3369:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3370:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3371:.\Include/arm_math.h ****    */
3372:.\Include/arm_math.h ****   void arm_fir_decimate_f32(
3373:.\Include/arm_math.h ****   const arm_fir_decimate_instance_f32 * S,
3374:.\Include/arm_math.h ****   float32_t * pSrc,
3375:.\Include/arm_math.h ****   float32_t * pDst,
3376:.\Include/arm_math.h ****   uint32_t blockSize);
3377:.\Include/arm_math.h **** 
3378:.\Include/arm_math.h **** 
3379:.\Include/arm_math.h ****   /**
3380:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR decimator.
3381:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
3382:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3383:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3384:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3385:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3386:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3387:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3388:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3389:.\Include/arm_math.h ****    */
3390:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_f32(
3391:.\Include/arm_math.h ****   arm_fir_decimate_instance_f32 * S,
3392:.\Include/arm_math.h ****   uint16_t numTaps,
3393:.\Include/arm_math.h ****   uint8_t M,
3394:.\Include/arm_math.h ****   float32_t * pCoeffs,
3395:.\Include/arm_math.h ****   float32_t * pState,
3396:.\Include/arm_math.h ****   uint32_t blockSize);
3397:.\Include/arm_math.h **** 
3398:.\Include/arm_math.h **** 
3399:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 69


3400:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator.
3401:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3402:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3403:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3404:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3405:.\Include/arm_math.h ****    */
3406:.\Include/arm_math.h ****   void arm_fir_decimate_q15(
3407:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3408:.\Include/arm_math.h ****   q15_t * pSrc,
3409:.\Include/arm_math.h ****   q15_t * pDst,
3410:.\Include/arm_math.h ****   uint32_t blockSize);
3411:.\Include/arm_math.h **** 
3412:.\Include/arm_math.h **** 
3413:.\Include/arm_math.h ****   /**
3414:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3415:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3416:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3417:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3418:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3419:.\Include/arm_math.h ****    */
3420:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q15(
3421:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3422:.\Include/arm_math.h ****   q15_t * pSrc,
3423:.\Include/arm_math.h ****   q15_t * pDst,
3424:.\Include/arm_math.h ****   uint32_t blockSize);
3425:.\Include/arm_math.h **** 
3426:.\Include/arm_math.h **** 
3427:.\Include/arm_math.h ****   /**
3428:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR decimator.
3429:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
3430:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3431:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3432:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3433:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3434:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3435:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3436:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3437:.\Include/arm_math.h ****    */
3438:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q15(
3439:.\Include/arm_math.h ****   arm_fir_decimate_instance_q15 * S,
3440:.\Include/arm_math.h ****   uint16_t numTaps,
3441:.\Include/arm_math.h ****   uint8_t M,
3442:.\Include/arm_math.h ****   q15_t * pCoeffs,
3443:.\Include/arm_math.h ****   q15_t * pState,
3444:.\Include/arm_math.h ****   uint32_t blockSize);
3445:.\Include/arm_math.h **** 
3446:.\Include/arm_math.h **** 
3447:.\Include/arm_math.h ****   /**
3448:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator.
3449:.\Include/arm_math.h ****    * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
3450:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the block of input data.
3451:.\Include/arm_math.h ****    * @param[out] pDst  points to the block of output data
3452:.\Include/arm_math.h ****    * @param[in] blockSize number of input samples to process per call.
3453:.\Include/arm_math.h ****    */
3454:.\Include/arm_math.h ****   void arm_fir_decimate_q31(
3455:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q31 * S,
3456:.\Include/arm_math.h ****   q31_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 70


3457:.\Include/arm_math.h ****   q31_t * pDst,
3458:.\Include/arm_math.h ****   uint32_t blockSize);
3459:.\Include/arm_math.h **** 
3460:.\Include/arm_math.h ****   /**
3461:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3462:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
3463:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3464:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3465:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3466:.\Include/arm_math.h ****    */
3467:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q31(
3468:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3469:.\Include/arm_math.h ****   q31_t * pSrc,
3470:.\Include/arm_math.h ****   q31_t * pDst,
3471:.\Include/arm_math.h ****   uint32_t blockSize);
3472:.\Include/arm_math.h **** 
3473:.\Include/arm_math.h **** 
3474:.\Include/arm_math.h ****   /**
3475:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR decimator.
3476:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
3477:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3478:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3479:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3480:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3481:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3482:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3483:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3484:.\Include/arm_math.h ****    */
3485:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q31(
3486:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3487:.\Include/arm_math.h ****   uint16_t numTaps,
3488:.\Include/arm_math.h ****   uint8_t M,
3489:.\Include/arm_math.h ****   q31_t * pCoeffs,
3490:.\Include/arm_math.h ****   q31_t * pState,
3491:.\Include/arm_math.h ****   uint32_t blockSize);
3492:.\Include/arm_math.h **** 
3493:.\Include/arm_math.h **** 
3494:.\Include/arm_math.h ****   /**
3495:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR interpolator.
3496:.\Include/arm_math.h ****    */
3497:.\Include/arm_math.h ****   typedef struct
3498:.\Include/arm_math.h ****   {
3499:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3500:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3501:.\Include/arm_math.h ****     q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3502:.\Include/arm_math.h ****     q15_t *pState;                  /**< points to the state variable array. The array is of length
3503:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q15;
3504:.\Include/arm_math.h **** 
3505:.\Include/arm_math.h ****   /**
3506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR interpolator.
3507:.\Include/arm_math.h ****    */
3508:.\Include/arm_math.h ****   typedef struct
3509:.\Include/arm_math.h ****   {
3510:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3511:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3512:.\Include/arm_math.h ****     q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3513:.\Include/arm_math.h ****     q31_t *pState;                  /**< points to the state variable array. The array is of length
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 71


3514:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q31;
3515:.\Include/arm_math.h **** 
3516:.\Include/arm_math.h ****   /**
3517:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR interpolator.
3518:.\Include/arm_math.h ****    */
3519:.\Include/arm_math.h ****   typedef struct
3520:.\Include/arm_math.h ****   {
3521:.\Include/arm_math.h ****     uint8_t L;                     /**< upsample factor. */
3522:.\Include/arm_math.h ****     uint16_t phaseLength;          /**< length of each polyphase filter component. */
3523:.\Include/arm_math.h ****     float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*p
3524:.\Include/arm_math.h ****     float32_t *pState;             /**< points to the state variable array. The array is of length 
3525:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_f32;
3526:.\Include/arm_math.h **** 
3527:.\Include/arm_math.h **** 
3528:.\Include/arm_math.h ****   /**
3529:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR interpolator.
3530:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3531:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3532:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3533:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3534:.\Include/arm_math.h ****    */
3535:.\Include/arm_math.h ****   void arm_fir_interpolate_q15(
3536:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q15 * S,
3537:.\Include/arm_math.h ****   q15_t * pSrc,
3538:.\Include/arm_math.h ****   q15_t * pDst,
3539:.\Include/arm_math.h ****   uint32_t blockSize);
3540:.\Include/arm_math.h **** 
3541:.\Include/arm_math.h **** 
3542:.\Include/arm_math.h ****   /**
3543:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR interpolator.
3544:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
3545:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3546:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3547:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3548:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3549:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3550:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3551:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3552:.\Include/arm_math.h ****    */
3553:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q15(
3554:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q15 * S,
3555:.\Include/arm_math.h ****   uint8_t L,
3556:.\Include/arm_math.h ****   uint16_t numTaps,
3557:.\Include/arm_math.h ****   q15_t * pCoeffs,
3558:.\Include/arm_math.h ****   q15_t * pState,
3559:.\Include/arm_math.h ****   uint32_t blockSize);
3560:.\Include/arm_math.h **** 
3561:.\Include/arm_math.h **** 
3562:.\Include/arm_math.h ****   /**
3563:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR interpolator.
3564:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3565:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3566:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3567:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3568:.\Include/arm_math.h ****    */
3569:.\Include/arm_math.h ****   void arm_fir_interpolate_q31(
3570:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q31 * S,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 72


3571:.\Include/arm_math.h ****   q31_t * pSrc,
3572:.\Include/arm_math.h ****   q31_t * pDst,
3573:.\Include/arm_math.h ****   uint32_t blockSize);
3574:.\Include/arm_math.h **** 
3575:.\Include/arm_math.h **** 
3576:.\Include/arm_math.h ****   /**
3577:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR interpolator.
3578:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
3579:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3580:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3581:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3582:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3583:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3584:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3585:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3586:.\Include/arm_math.h ****    */
3587:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q31(
3588:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q31 * S,
3589:.\Include/arm_math.h ****   uint8_t L,
3590:.\Include/arm_math.h ****   uint16_t numTaps,
3591:.\Include/arm_math.h ****   q31_t * pCoeffs,
3592:.\Include/arm_math.h ****   q31_t * pState,
3593:.\Include/arm_math.h ****   uint32_t blockSize);
3594:.\Include/arm_math.h **** 
3595:.\Include/arm_math.h **** 
3596:.\Include/arm_math.h ****   /**
3597:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR interpolator.
3598:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
3599:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3600:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3601:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3602:.\Include/arm_math.h ****    */
3603:.\Include/arm_math.h ****   void arm_fir_interpolate_f32(
3604:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_f32 * S,
3605:.\Include/arm_math.h ****   float32_t * pSrc,
3606:.\Include/arm_math.h ****   float32_t * pDst,
3607:.\Include/arm_math.h ****   uint32_t blockSize);
3608:.\Include/arm_math.h **** 
3609:.\Include/arm_math.h **** 
3610:.\Include/arm_math.h ****   /**
3611:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR interpolator.
3612:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR interpolator structu
3613:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3614:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3615:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3616:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3617:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3618:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3619:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3620:.\Include/arm_math.h ****    */
3621:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_f32(
3622:.\Include/arm_math.h ****   arm_fir_interpolate_instance_f32 * S,
3623:.\Include/arm_math.h ****   uint8_t L,
3624:.\Include/arm_math.h ****   uint16_t numTaps,
3625:.\Include/arm_math.h ****   float32_t * pCoeffs,
3626:.\Include/arm_math.h ****   float32_t * pState,
3627:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 73


3628:.\Include/arm_math.h **** 
3629:.\Include/arm_math.h **** 
3630:.\Include/arm_math.h ****   /**
3631:.\Include/arm_math.h ****    * @brief Instance structure for the high precision Q31 Biquad cascade filter.
3632:.\Include/arm_math.h ****    */
3633:.\Include/arm_math.h ****   typedef struct
3634:.\Include/arm_math.h ****   {
3635:.\Include/arm_math.h ****     uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*num
3636:.\Include/arm_math.h ****     q63_t *pState;           /**< points to the array of state coefficients.  The array is of lengt
3637:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*nu
3638:.\Include/arm_math.h ****     uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
3639:.\Include/arm_math.h ****   } arm_biquad_cas_df1_32x64_ins_q31;
3640:.\Include/arm_math.h **** 
3641:.\Include/arm_math.h **** 
3642:.\Include/arm_math.h ****   /**
3643:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter s
3644:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3645:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3646:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3647:.\Include/arm_math.h ****    */
3648:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_q31(
3649:.\Include/arm_math.h ****   const arm_biquad_cas_df1_32x64_ins_q31 * S,
3650:.\Include/arm_math.h ****   q31_t * pSrc,
3651:.\Include/arm_math.h ****   q31_t * pDst,
3652:.\Include/arm_math.h ****   uint32_t blockSize);
3653:.\Include/arm_math.h **** 
3654:.\Include/arm_math.h **** 
3655:.\Include/arm_math.h ****   /**
3656:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filte
3657:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3658:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3659:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3660:.\Include/arm_math.h ****    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficie
3661:.\Include/arm_math.h ****    */
3662:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_init_q31(
3663:.\Include/arm_math.h ****   arm_biquad_cas_df1_32x64_ins_q31 * S,
3664:.\Include/arm_math.h ****   uint8_t numStages,
3665:.\Include/arm_math.h ****   q31_t * pCoeffs,
3666:.\Include/arm_math.h ****   q63_t * pState,
3667:.\Include/arm_math.h ****   uint8_t postShift);
3668:.\Include/arm_math.h **** 
3669:.\Include/arm_math.h **** 
3670:.\Include/arm_math.h ****   /**
3671:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3672:.\Include/arm_math.h ****    */
3673:.\Include/arm_math.h ****   typedef struct
3674:.\Include/arm_math.h ****   {
3675:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3676:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3677:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3678:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f32;
3679:.\Include/arm_math.h **** 
3680:.\Include/arm_math.h ****   /**
3681:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3682:.\Include/arm_math.h ****    */
3683:.\Include/arm_math.h ****   typedef struct
3684:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 74


3685:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3686:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3687:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3688:.\Include/arm_math.h ****   } arm_biquad_cascade_stereo_df2T_instance_f32;
3689:.\Include/arm_math.h **** 
3690:.\Include/arm_math.h ****   /**
3691:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3692:.\Include/arm_math.h ****    */
3693:.\Include/arm_math.h ****   typedef struct
3694:.\Include/arm_math.h ****   {
3695:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3696:.\Include/arm_math.h ****     float64_t *pState;         /**< points to the array of state coefficients.  The array is of len
3697:.\Include/arm_math.h ****     float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3698:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f64;
3699:.\Include/arm_math.h **** 
3700:.\Include/arm_math.h **** 
3701:.\Include/arm_math.h ****   /**
3702:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3703:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3704:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3705:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3706:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3707:.\Include/arm_math.h ****    */
3708:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f32(
3709:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f32 * S,
3710:.\Include/arm_math.h ****   float32_t * pSrc,
3711:.\Include/arm_math.h ****   float32_t * pDst,
3712:.\Include/arm_math.h ****   uint32_t blockSize);
3713:.\Include/arm_math.h **** 
3714:.\Include/arm_math.h **** 
3715:.\Include/arm_math.h ****   /**
3716:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3717:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3718:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3719:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3720:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3721:.\Include/arm_math.h ****    */
3722:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_f32(
3723:.\Include/arm_math.h ****   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3724:.\Include/arm_math.h ****   float32_t * pSrc,
3725:.\Include/arm_math.h ****   float32_t * pDst,
3726:.\Include/arm_math.h ****   uint32_t blockSize);
3727:.\Include/arm_math.h **** 
3728:.\Include/arm_math.h **** 
3729:.\Include/arm_math.h ****   /**
3730:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3731:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3732:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3733:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3734:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3735:.\Include/arm_math.h ****    */
3736:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f64(
3737:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f64 * S,
3738:.\Include/arm_math.h ****   float64_t * pSrc,
3739:.\Include/arm_math.h ****   float64_t * pDst,
3740:.\Include/arm_math.h ****   uint32_t blockSize);
3741:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 75


3742:.\Include/arm_math.h **** 
3743:.\Include/arm_math.h ****   /**
3744:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3745:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3746:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3747:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3748:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3749:.\Include/arm_math.h ****    */
3750:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f32(
3751:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f32 * S,
3752:.\Include/arm_math.h ****   uint8_t numStages,
3753:.\Include/arm_math.h ****   float32_t * pCoeffs,
3754:.\Include/arm_math.h ****   float32_t * pState);
3755:.\Include/arm_math.h **** 
3756:.\Include/arm_math.h **** 
3757:.\Include/arm_math.h ****   /**
3758:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3759:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3760:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3761:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3762:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3763:.\Include/arm_math.h ****    */
3764:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_init_f32(
3765:.\Include/arm_math.h ****   arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3766:.\Include/arm_math.h ****   uint8_t numStages,
3767:.\Include/arm_math.h ****   float32_t * pCoeffs,
3768:.\Include/arm_math.h ****   float32_t * pState);
3769:.\Include/arm_math.h **** 
3770:.\Include/arm_math.h **** 
3771:.\Include/arm_math.h ****   /**
3772:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3773:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3774:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3775:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3776:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3777:.\Include/arm_math.h ****    */
3778:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f64(
3779:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f64 * S,
3780:.\Include/arm_math.h ****   uint8_t numStages,
3781:.\Include/arm_math.h ****   float64_t * pCoeffs,
3782:.\Include/arm_math.h ****   float64_t * pState);
3783:.\Include/arm_math.h **** 
3784:.\Include/arm_math.h **** 
3785:.\Include/arm_math.h ****   /**
3786:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR lattice filter.
3787:.\Include/arm_math.h ****    */
3788:.\Include/arm_math.h ****   typedef struct
3789:.\Include/arm_math.h ****   {
3790:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3791:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3792:.\Include/arm_math.h ****     q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3793:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q15;
3794:.\Include/arm_math.h **** 
3795:.\Include/arm_math.h ****   /**
3796:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR lattice filter.
3797:.\Include/arm_math.h ****    */
3798:.\Include/arm_math.h ****   typedef struct
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 76


3799:.\Include/arm_math.h ****   {
3800:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3801:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3802:.\Include/arm_math.h ****     q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3803:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q31;
3804:.\Include/arm_math.h **** 
3805:.\Include/arm_math.h ****   /**
3806:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR lattice filter.
3807:.\Include/arm_math.h ****    */
3808:.\Include/arm_math.h ****   typedef struct
3809:.\Include/arm_math.h ****   {
3810:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3811:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3812:.\Include/arm_math.h ****     float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of leng
3813:.\Include/arm_math.h ****   } arm_fir_lattice_instance_f32;
3814:.\Include/arm_math.h **** 
3815:.\Include/arm_math.h **** 
3816:.\Include/arm_math.h ****   /**
3817:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 FIR lattice filter.
3818:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 FIR lattice structure.
3819:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3820:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3821:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages.
3822:.\Include/arm_math.h ****    */
3823:.\Include/arm_math.h ****   void arm_fir_lattice_init_q15(
3824:.\Include/arm_math.h ****   arm_fir_lattice_instance_q15 * S,
3825:.\Include/arm_math.h ****   uint16_t numStages,
3826:.\Include/arm_math.h ****   q15_t * pCoeffs,
3827:.\Include/arm_math.h ****   q15_t * pState);
3828:.\Include/arm_math.h **** 
3829:.\Include/arm_math.h **** 
3830:.\Include/arm_math.h ****   /**
3831:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR lattice filter.
3832:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
3833:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3834:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3835:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3836:.\Include/arm_math.h ****    */
3837:.\Include/arm_math.h ****   void arm_fir_lattice_q15(
3838:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q15 * S,
3839:.\Include/arm_math.h ****   q15_t * pSrc,
3840:.\Include/arm_math.h ****   q15_t * pDst,
3841:.\Include/arm_math.h ****   uint32_t blockSize);
3842:.\Include/arm_math.h **** 
3843:.\Include/arm_math.h **** 
3844:.\Include/arm_math.h ****   /**
3845:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 FIR lattice filter.
3846:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 FIR lattice structure.
3847:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3848:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3849:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.   The array is of length numStages.
3850:.\Include/arm_math.h ****    */
3851:.\Include/arm_math.h ****   void arm_fir_lattice_init_q31(
3852:.\Include/arm_math.h ****   arm_fir_lattice_instance_q31 * S,
3853:.\Include/arm_math.h ****   uint16_t numStages,
3854:.\Include/arm_math.h ****   q31_t * pCoeffs,
3855:.\Include/arm_math.h ****   q31_t * pState);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 77


3856:.\Include/arm_math.h **** 
3857:.\Include/arm_math.h **** 
3858:.\Include/arm_math.h ****   /**
3859:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR lattice filter.
3860:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
3861:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3862:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3863:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3864:.\Include/arm_math.h ****    */
3865:.\Include/arm_math.h ****   void arm_fir_lattice_q31(
3866:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q31 * S,
3867:.\Include/arm_math.h ****   q31_t * pSrc,
3868:.\Include/arm_math.h ****   q31_t * pDst,
3869:.\Include/arm_math.h ****   uint32_t blockSize);
3870:.\Include/arm_math.h **** 
3871:.\Include/arm_math.h **** 
3872:.\Include/arm_math.h **** /**
3873:.\Include/arm_math.h ****  * @brief Initialization function for the floating-point FIR lattice filter.
3874:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the floating-point FIR lattice structure.
3875:.\Include/arm_math.h ****  * @param[in] numStages  number of filter stages.
3876:.\Include/arm_math.h ****  * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3877:.\Include/arm_math.h ****  * @param[in] pState     points to the state buffer.  The array is of length numStages.
3878:.\Include/arm_math.h ****  */
3879:.\Include/arm_math.h ****   void arm_fir_lattice_init_f32(
3880:.\Include/arm_math.h ****   arm_fir_lattice_instance_f32 * S,
3881:.\Include/arm_math.h ****   uint16_t numStages,
3882:.\Include/arm_math.h ****   float32_t * pCoeffs,
3883:.\Include/arm_math.h ****   float32_t * pState);
3884:.\Include/arm_math.h **** 
3885:.\Include/arm_math.h **** 
3886:.\Include/arm_math.h ****   /**
3887:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR lattice filter.
3888:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
3889:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3890:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3891:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3892:.\Include/arm_math.h ****    */
3893:.\Include/arm_math.h ****   void arm_fir_lattice_f32(
3894:.\Include/arm_math.h ****   const arm_fir_lattice_instance_f32 * S,
3895:.\Include/arm_math.h ****   float32_t * pSrc,
3896:.\Include/arm_math.h ****   float32_t * pDst,
3897:.\Include/arm_math.h ****   uint32_t blockSize);
3898:.\Include/arm_math.h **** 
3899:.\Include/arm_math.h **** 
3900:.\Include/arm_math.h ****   /**
3901:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 IIR lattice filter.
3902:.\Include/arm_math.h ****    */
3903:.\Include/arm_math.h ****   typedef struct
3904:.\Include/arm_math.h ****   {
3905:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3906:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3907:.\Include/arm_math.h ****     q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3908:.\Include/arm_math.h ****     q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3909:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q15;
3910:.\Include/arm_math.h **** 
3911:.\Include/arm_math.h ****   /**
3912:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 IIR lattice filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 78


3913:.\Include/arm_math.h ****    */
3914:.\Include/arm_math.h ****   typedef struct
3915:.\Include/arm_math.h ****   {
3916:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3917:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3918:.\Include/arm_math.h ****     q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3919:.\Include/arm_math.h ****     q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3920:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q31;
3921:.\Include/arm_math.h **** 
3922:.\Include/arm_math.h ****   /**
3923:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point IIR lattice filter.
3924:.\Include/arm_math.h ****    */
3925:.\Include/arm_math.h ****   typedef struct
3926:.\Include/arm_math.h ****   {
3927:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3928:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3929:.\Include/arm_math.h ****     float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array
3930:.\Include/arm_math.h ****     float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is 
3931:.\Include/arm_math.h ****   } arm_iir_lattice_instance_f32;
3932:.\Include/arm_math.h **** 
3933:.\Include/arm_math.h **** 
3934:.\Include/arm_math.h ****   /**
3935:.\Include/arm_math.h ****    * @brief Processing function for the floating-point IIR lattice filter.
3936:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
3937:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3938:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3939:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3940:.\Include/arm_math.h ****    */
3941:.\Include/arm_math.h ****   void arm_iir_lattice_f32(
3942:.\Include/arm_math.h ****   const arm_iir_lattice_instance_f32 * S,
3943:.\Include/arm_math.h ****   float32_t * pSrc,
3944:.\Include/arm_math.h ****   float32_t * pDst,
3945:.\Include/arm_math.h ****   uint32_t blockSize);
3946:.\Include/arm_math.h **** 
3947:.\Include/arm_math.h **** 
3948:.\Include/arm_math.h ****   /**
3949:.\Include/arm_math.h ****    * @brief Initialization function for the floating-point IIR lattice filter.
3950:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point IIR lattice structure.
3951:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3952:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3953:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3954:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-
3955:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3956:.\Include/arm_math.h ****    */
3957:.\Include/arm_math.h ****   void arm_iir_lattice_init_f32(
3958:.\Include/arm_math.h ****   arm_iir_lattice_instance_f32 * S,
3959:.\Include/arm_math.h ****   uint16_t numStages,
3960:.\Include/arm_math.h ****   float32_t * pkCoeffs,
3961:.\Include/arm_math.h ****   float32_t * pvCoeffs,
3962:.\Include/arm_math.h ****   float32_t * pState,
3963:.\Include/arm_math.h ****   uint32_t blockSize);
3964:.\Include/arm_math.h **** 
3965:.\Include/arm_math.h **** 
3966:.\Include/arm_math.h ****   /**
3967:.\Include/arm_math.h ****    * @brief Processing function for the Q31 IIR lattice filter.
3968:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
3969:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 79


3970:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3971:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3972:.\Include/arm_math.h ****    */
3973:.\Include/arm_math.h ****   void arm_iir_lattice_q31(
3974:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q31 * S,
3975:.\Include/arm_math.h ****   q31_t * pSrc,
3976:.\Include/arm_math.h ****   q31_t * pDst,
3977:.\Include/arm_math.h ****   uint32_t blockSize);
3978:.\Include/arm_math.h **** 
3979:.\Include/arm_math.h **** 
3980:.\Include/arm_math.h ****   /**
3981:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 IIR lattice filter.
3982:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 IIR lattice structure.
3983:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3984:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3985:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3986:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
3987:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3988:.\Include/arm_math.h ****    */
3989:.\Include/arm_math.h ****   void arm_iir_lattice_init_q31(
3990:.\Include/arm_math.h ****   arm_iir_lattice_instance_q31 * S,
3991:.\Include/arm_math.h ****   uint16_t numStages,
3992:.\Include/arm_math.h ****   q31_t * pkCoeffs,
3993:.\Include/arm_math.h ****   q31_t * pvCoeffs,
3994:.\Include/arm_math.h ****   q31_t * pState,
3995:.\Include/arm_math.h ****   uint32_t blockSize);
3996:.\Include/arm_math.h **** 
3997:.\Include/arm_math.h **** 
3998:.\Include/arm_math.h ****   /**
3999:.\Include/arm_math.h ****    * @brief Processing function for the Q15 IIR lattice filter.
4000:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
4001:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4002:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
4003:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4004:.\Include/arm_math.h ****    */
4005:.\Include/arm_math.h ****   void arm_iir_lattice_q15(
4006:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q15 * S,
4007:.\Include/arm_math.h ****   q15_t * pSrc,
4008:.\Include/arm_math.h ****   q15_t * pDst,
4009:.\Include/arm_math.h ****   uint32_t blockSize);
4010:.\Include/arm_math.h **** 
4011:.\Include/arm_math.h **** 
4012:.\Include/arm_math.h **** /**
4013:.\Include/arm_math.h ****  * @brief Initialization function for the Q15 IIR lattice filter.
4014:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
4015:.\Include/arm_math.h ****  * @param[in] numStages  number of stages in the filter.
4016:.\Include/arm_math.h ****  * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages
4017:.\Include/arm_math.h ****  * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
4018:.\Include/arm_math.h ****  * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
4019:.\Include/arm_math.h ****  * @param[in] blockSize  number of samples to process per call.
4020:.\Include/arm_math.h ****  */
4021:.\Include/arm_math.h ****   void arm_iir_lattice_init_q15(
4022:.\Include/arm_math.h ****   arm_iir_lattice_instance_q15 * S,
4023:.\Include/arm_math.h ****   uint16_t numStages,
4024:.\Include/arm_math.h ****   q15_t * pkCoeffs,
4025:.\Include/arm_math.h ****   q15_t * pvCoeffs,
4026:.\Include/arm_math.h ****   q15_t * pState,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 80


4027:.\Include/arm_math.h ****   uint32_t blockSize);
4028:.\Include/arm_math.h **** 
4029:.\Include/arm_math.h **** 
4030:.\Include/arm_math.h ****   /**
4031:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point LMS filter.
4032:.\Include/arm_math.h ****    */
4033:.\Include/arm_math.h ****   typedef struct
4034:.\Include/arm_math.h ****   {
4035:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4036:.\Include/arm_math.h ****     float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+bl
4037:.\Include/arm_math.h ****     float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
4038:.\Include/arm_math.h ****     float32_t mu;        /**< step size that controls filter coefficient updates. */
4039:.\Include/arm_math.h ****   } arm_lms_instance_f32;
4040:.\Include/arm_math.h **** 
4041:.\Include/arm_math.h **** 
4042:.\Include/arm_math.h ****   /**
4043:.\Include/arm_math.h ****    * @brief Processing function for floating-point LMS filter.
4044:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point LMS filter structure.
4045:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4046:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4047:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4048:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4049:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4050:.\Include/arm_math.h ****    */
4051:.\Include/arm_math.h ****   void arm_lms_f32(
4052:.\Include/arm_math.h ****   const arm_lms_instance_f32 * S,
4053:.\Include/arm_math.h ****   float32_t * pSrc,
4054:.\Include/arm_math.h ****   float32_t * pRef,
4055:.\Include/arm_math.h ****   float32_t * pOut,
4056:.\Include/arm_math.h ****   float32_t * pErr,
4057:.\Include/arm_math.h ****   uint32_t blockSize);
4058:.\Include/arm_math.h **** 
4059:.\Include/arm_math.h **** 
4060:.\Include/arm_math.h ****   /**
4061:.\Include/arm_math.h ****    * @brief Initialization function for floating-point LMS filter.
4062:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4063:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4064:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4065:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4066:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4067:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4068:.\Include/arm_math.h ****    */
4069:.\Include/arm_math.h ****   void arm_lms_init_f32(
4070:.\Include/arm_math.h ****   arm_lms_instance_f32 * S,
4071:.\Include/arm_math.h ****   uint16_t numTaps,
4072:.\Include/arm_math.h ****   float32_t * pCoeffs,
4073:.\Include/arm_math.h ****   float32_t * pState,
4074:.\Include/arm_math.h ****   float32_t mu,
4075:.\Include/arm_math.h ****   uint32_t blockSize);
4076:.\Include/arm_math.h **** 
4077:.\Include/arm_math.h **** 
4078:.\Include/arm_math.h ****   /**
4079:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 LMS filter.
4080:.\Include/arm_math.h ****    */
4081:.\Include/arm_math.h ****   typedef struct
4082:.\Include/arm_math.h ****   {
4083:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 81


4084:.\Include/arm_math.h ****     q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4085:.\Include/arm_math.h ****     q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4086:.\Include/arm_math.h ****     q15_t mu;            /**< step size that controls filter coefficient updates. */
4087:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4088:.\Include/arm_math.h ****   } arm_lms_instance_q15;
4089:.\Include/arm_math.h **** 
4090:.\Include/arm_math.h **** 
4091:.\Include/arm_math.h ****   /**
4092:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 LMS filter.
4093:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 LMS filter structure.
4094:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4095:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4096:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.
4097:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4098:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4099:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4100:.\Include/arm_math.h ****    */
4101:.\Include/arm_math.h ****   void arm_lms_init_q15(
4102:.\Include/arm_math.h ****   arm_lms_instance_q15 * S,
4103:.\Include/arm_math.h ****   uint16_t numTaps,
4104:.\Include/arm_math.h ****   q15_t * pCoeffs,
4105:.\Include/arm_math.h ****   q15_t * pState,
4106:.\Include/arm_math.h ****   q15_t mu,
4107:.\Include/arm_math.h ****   uint32_t blockSize,
4108:.\Include/arm_math.h ****   uint32_t postShift);
4109:.\Include/arm_math.h **** 
4110:.\Include/arm_math.h **** 
4111:.\Include/arm_math.h ****   /**
4112:.\Include/arm_math.h ****    * @brief Processing function for Q15 LMS filter.
4113:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4114:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4115:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4116:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4117:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4118:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4119:.\Include/arm_math.h ****    */
4120:.\Include/arm_math.h ****   void arm_lms_q15(
4121:.\Include/arm_math.h ****   const arm_lms_instance_q15 * S,
4122:.\Include/arm_math.h ****   q15_t * pSrc,
4123:.\Include/arm_math.h ****   q15_t * pRef,
4124:.\Include/arm_math.h ****   q15_t * pOut,
4125:.\Include/arm_math.h ****   q15_t * pErr,
4126:.\Include/arm_math.h ****   uint32_t blockSize);
4127:.\Include/arm_math.h **** 
4128:.\Include/arm_math.h **** 
4129:.\Include/arm_math.h ****   /**
4130:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 LMS filter.
4131:.\Include/arm_math.h ****    */
4132:.\Include/arm_math.h ****   typedef struct
4133:.\Include/arm_math.h ****   {
4134:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4135:.\Include/arm_math.h ****     q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4136:.\Include/arm_math.h ****     q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4137:.\Include/arm_math.h ****     q31_t mu;            /**< step size that controls filter coefficient updates. */
4138:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4139:.\Include/arm_math.h ****   } arm_lms_instance_q31;
4140:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 82


4141:.\Include/arm_math.h **** 
4142:.\Include/arm_math.h ****   /**
4143:.\Include/arm_math.h ****    * @brief Processing function for Q31 LMS filter.
4144:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4145:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4146:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4147:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4148:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4149:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4150:.\Include/arm_math.h ****    */
4151:.\Include/arm_math.h ****   void arm_lms_q31(
4152:.\Include/arm_math.h ****   const arm_lms_instance_q31 * S,
4153:.\Include/arm_math.h ****   q31_t * pSrc,
4154:.\Include/arm_math.h ****   q31_t * pRef,
4155:.\Include/arm_math.h ****   q31_t * pOut,
4156:.\Include/arm_math.h ****   q31_t * pErr,
4157:.\Include/arm_math.h ****   uint32_t blockSize);
4158:.\Include/arm_math.h **** 
4159:.\Include/arm_math.h **** 
4160:.\Include/arm_math.h ****   /**
4161:.\Include/arm_math.h ****    * @brief Initialization function for Q31 LMS filter.
4162:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 LMS filter structure.
4163:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4164:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4165:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4166:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4167:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4168:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4169:.\Include/arm_math.h ****    */
4170:.\Include/arm_math.h ****   void arm_lms_init_q31(
4171:.\Include/arm_math.h ****   arm_lms_instance_q31 * S,
4172:.\Include/arm_math.h ****   uint16_t numTaps,
4173:.\Include/arm_math.h ****   q31_t * pCoeffs,
4174:.\Include/arm_math.h ****   q31_t * pState,
4175:.\Include/arm_math.h ****   q31_t mu,
4176:.\Include/arm_math.h ****   uint32_t blockSize,
4177:.\Include/arm_math.h ****   uint32_t postShift);
4178:.\Include/arm_math.h **** 
4179:.\Include/arm_math.h **** 
4180:.\Include/arm_math.h ****   /**
4181:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point normalized LMS filter.
4182:.\Include/arm_math.h ****    */
4183:.\Include/arm_math.h ****   typedef struct
4184:.\Include/arm_math.h ****   {
4185:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4186:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
4187:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
4188:.\Include/arm_math.h ****     float32_t mu;         /**< step size that control filter coefficient updates. */
4189:.\Include/arm_math.h ****     float32_t energy;     /**< saves previous frame energy. */
4190:.\Include/arm_math.h ****     float32_t x0;         /**< saves previous input sample. */
4191:.\Include/arm_math.h ****   } arm_lms_norm_instance_f32;
4192:.\Include/arm_math.h **** 
4193:.\Include/arm_math.h **** 
4194:.\Include/arm_math.h ****   /**
4195:.\Include/arm_math.h ****    * @brief Processing function for floating-point normalized LMS filter.
4196:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point normalized LMS filter struc
4197:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 83


4198:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4199:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4200:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4201:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4202:.\Include/arm_math.h ****    */
4203:.\Include/arm_math.h ****   void arm_lms_norm_f32(
4204:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4205:.\Include/arm_math.h ****   float32_t * pSrc,
4206:.\Include/arm_math.h ****   float32_t * pRef,
4207:.\Include/arm_math.h ****   float32_t * pOut,
4208:.\Include/arm_math.h ****   float32_t * pErr,
4209:.\Include/arm_math.h ****   uint32_t blockSize);
4210:.\Include/arm_math.h **** 
4211:.\Include/arm_math.h **** 
4212:.\Include/arm_math.h ****   /**
4213:.\Include/arm_math.h ****    * @brief Initialization function for floating-point normalized LMS filter.
4214:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4215:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4216:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4217:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4218:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4219:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4220:.\Include/arm_math.h ****    */
4221:.\Include/arm_math.h ****   void arm_lms_norm_init_f32(
4222:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4223:.\Include/arm_math.h ****   uint16_t numTaps,
4224:.\Include/arm_math.h ****   float32_t * pCoeffs,
4225:.\Include/arm_math.h ****   float32_t * pState,
4226:.\Include/arm_math.h ****   float32_t mu,
4227:.\Include/arm_math.h ****   uint32_t blockSize);
4228:.\Include/arm_math.h **** 
4229:.\Include/arm_math.h **** 
4230:.\Include/arm_math.h ****   /**
4231:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 normalized LMS filter.
4232:.\Include/arm_math.h ****    */
4233:.\Include/arm_math.h ****   typedef struct
4234:.\Include/arm_math.h ****   {
4235:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4236:.\Include/arm_math.h ****     q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4237:.\Include/arm_math.h ****     q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4238:.\Include/arm_math.h ****     q31_t mu;             /**< step size that controls filter coefficient updates. */
4239:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4240:.\Include/arm_math.h ****     q31_t *recipTable;    /**< points to the reciprocal initial value table. */
4241:.\Include/arm_math.h ****     q31_t energy;         /**< saves previous frame energy. */
4242:.\Include/arm_math.h ****     q31_t x0;             /**< saves previous input sample. */
4243:.\Include/arm_math.h ****   } arm_lms_norm_instance_q31;
4244:.\Include/arm_math.h **** 
4245:.\Include/arm_math.h **** 
4246:.\Include/arm_math.h ****   /**
4247:.\Include/arm_math.h ****    * @brief Processing function for Q31 normalized LMS filter.
4248:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
4249:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4250:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4251:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4252:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4253:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4254:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 84


4255:.\Include/arm_math.h ****   void arm_lms_norm_q31(
4256:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4257:.\Include/arm_math.h ****   q31_t * pSrc,
4258:.\Include/arm_math.h ****   q31_t * pRef,
4259:.\Include/arm_math.h ****   q31_t * pOut,
4260:.\Include/arm_math.h ****   q31_t * pErr,
4261:.\Include/arm_math.h ****   uint32_t blockSize);
4262:.\Include/arm_math.h **** 
4263:.\Include/arm_math.h **** 
4264:.\Include/arm_math.h ****   /**
4265:.\Include/arm_math.h ****    * @brief Initialization function for Q31 normalized LMS filter.
4266:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
4267:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4268:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4269:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4270:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4271:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4272:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4273:.\Include/arm_math.h ****    */
4274:.\Include/arm_math.h ****   void arm_lms_norm_init_q31(
4275:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4276:.\Include/arm_math.h ****   uint16_t numTaps,
4277:.\Include/arm_math.h ****   q31_t * pCoeffs,
4278:.\Include/arm_math.h ****   q31_t * pState,
4279:.\Include/arm_math.h ****   q31_t mu,
4280:.\Include/arm_math.h ****   uint32_t blockSize,
4281:.\Include/arm_math.h ****   uint8_t postShift);
4282:.\Include/arm_math.h **** 
4283:.\Include/arm_math.h **** 
4284:.\Include/arm_math.h ****   /**
4285:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 normalized LMS filter.
4286:.\Include/arm_math.h ****    */
4287:.\Include/arm_math.h ****   typedef struct
4288:.\Include/arm_math.h ****   {
4289:.\Include/arm_math.h ****     uint16_t numTaps;     /**< Number of coefficients in the filter. */
4290:.\Include/arm_math.h ****     q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4291:.\Include/arm_math.h ****     q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4292:.\Include/arm_math.h ****     q15_t mu;             /**< step size that controls filter coefficient updates. */
4293:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4294:.\Include/arm_math.h ****     q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
4295:.\Include/arm_math.h ****     q15_t energy;         /**< saves previous frame energy. */
4296:.\Include/arm_math.h ****     q15_t x0;             /**< saves previous input sample. */
4297:.\Include/arm_math.h ****   } arm_lms_norm_instance_q15;
4298:.\Include/arm_math.h **** 
4299:.\Include/arm_math.h **** 
4300:.\Include/arm_math.h ****   /**
4301:.\Include/arm_math.h ****    * @brief Processing function for Q15 normalized LMS filter.
4302:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
4303:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4304:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4305:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4306:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4307:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4308:.\Include/arm_math.h ****    */
4309:.\Include/arm_math.h ****   void arm_lms_norm_q15(
4310:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4311:.\Include/arm_math.h ****   q15_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 85


4312:.\Include/arm_math.h ****   q15_t * pRef,
4313:.\Include/arm_math.h ****   q15_t * pOut,
4314:.\Include/arm_math.h ****   q15_t * pErr,
4315:.\Include/arm_math.h ****   uint32_t blockSize);
4316:.\Include/arm_math.h **** 
4317:.\Include/arm_math.h **** 
4318:.\Include/arm_math.h ****   /**
4319:.\Include/arm_math.h ****    * @brief Initialization function for Q15 normalized LMS filter.
4320:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
4321:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4322:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4323:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4324:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4325:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4326:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4327:.\Include/arm_math.h ****    */
4328:.\Include/arm_math.h ****   void arm_lms_norm_init_q15(
4329:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4330:.\Include/arm_math.h ****   uint16_t numTaps,
4331:.\Include/arm_math.h ****   q15_t * pCoeffs,
4332:.\Include/arm_math.h ****   q15_t * pState,
4333:.\Include/arm_math.h ****   q15_t mu,
4334:.\Include/arm_math.h ****   uint32_t blockSize,
4335:.\Include/arm_math.h ****   uint8_t postShift);
4336:.\Include/arm_math.h **** 
4337:.\Include/arm_math.h **** 
4338:.\Include/arm_math.h ****   /**
4339:.\Include/arm_math.h ****    * @brief Correlation of floating-point sequences.
4340:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4341:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4342:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4343:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4344:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4345:.\Include/arm_math.h ****    */
4346:.\Include/arm_math.h ****   void arm_correlate_f32(
4347:.\Include/arm_math.h ****   float32_t * pSrcA,
4348:.\Include/arm_math.h ****   uint32_t srcALen,
4349:.\Include/arm_math.h ****   float32_t * pSrcB,
4350:.\Include/arm_math.h ****   uint32_t srcBLen,
4351:.\Include/arm_math.h ****   float32_t * pDst);
4352:.\Include/arm_math.h **** 
4353:.\Include/arm_math.h **** 
4354:.\Include/arm_math.h ****    /**
4355:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences
4356:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4357:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4358:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4359:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4360:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4361:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4362:.\Include/arm_math.h ****    */
4363:.\Include/arm_math.h ****   void arm_correlate_opt_q15(
4364:.\Include/arm_math.h ****   q15_t * pSrcA,
4365:.\Include/arm_math.h ****   uint32_t srcALen,
4366:.\Include/arm_math.h ****   q15_t * pSrcB,
4367:.\Include/arm_math.h ****   uint32_t srcBLen,
4368:.\Include/arm_math.h ****   q15_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 86


4369:.\Include/arm_math.h ****   q15_t * pScratch);
4370:.\Include/arm_math.h **** 
4371:.\Include/arm_math.h **** 
4372:.\Include/arm_math.h ****   /**
4373:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences.
4374:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4375:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4376:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4377:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4378:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4379:.\Include/arm_math.h ****    */
4380:.\Include/arm_math.h **** 
4381:.\Include/arm_math.h ****   void arm_correlate_q15(
4382:.\Include/arm_math.h ****   q15_t * pSrcA,
4383:.\Include/arm_math.h ****   uint32_t srcALen,
4384:.\Include/arm_math.h ****   q15_t * pSrcB,
4385:.\Include/arm_math.h ****   uint32_t srcBLen,
4386:.\Include/arm_math.h ****   q15_t * pDst);
4387:.\Include/arm_math.h **** 
4388:.\Include/arm_math.h **** 
4389:.\Include/arm_math.h ****   /**
4390:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4391:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4392:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4393:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4394:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4395:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4396:.\Include/arm_math.h ****    */
4397:.\Include/arm_math.h **** 
4398:.\Include/arm_math.h ****   void arm_correlate_fast_q15(
4399:.\Include/arm_math.h ****   q15_t * pSrcA,
4400:.\Include/arm_math.h ****   uint32_t srcALen,
4401:.\Include/arm_math.h ****   q15_t * pSrcB,
4402:.\Include/arm_math.h ****   uint32_t srcBLen,
4403:.\Include/arm_math.h ****   q15_t * pDst);
4404:.\Include/arm_math.h **** 
4405:.\Include/arm_math.h **** 
4406:.\Include/arm_math.h ****   /**
4407:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4408:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4409:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4410:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4411:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4412:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4413:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4414:.\Include/arm_math.h ****    */
4415:.\Include/arm_math.h ****   void arm_correlate_fast_opt_q15(
4416:.\Include/arm_math.h ****   q15_t * pSrcA,
4417:.\Include/arm_math.h ****   uint32_t srcALen,
4418:.\Include/arm_math.h ****   q15_t * pSrcB,
4419:.\Include/arm_math.h ****   uint32_t srcBLen,
4420:.\Include/arm_math.h ****   q15_t * pDst,
4421:.\Include/arm_math.h ****   q15_t * pScratch);
4422:.\Include/arm_math.h **** 
4423:.\Include/arm_math.h **** 
4424:.\Include/arm_math.h ****   /**
4425:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 87


4426:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4427:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4428:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4429:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4430:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4431:.\Include/arm_math.h ****    */
4432:.\Include/arm_math.h ****   void arm_correlate_q31(
4433:.\Include/arm_math.h ****   q31_t * pSrcA,
4434:.\Include/arm_math.h ****   uint32_t srcALen,
4435:.\Include/arm_math.h ****   q31_t * pSrcB,
4436:.\Include/arm_math.h ****   uint32_t srcBLen,
4437:.\Include/arm_math.h ****   q31_t * pDst);
4438:.\Include/arm_math.h **** 
4439:.\Include/arm_math.h **** 
4440:.\Include/arm_math.h ****   /**
4441:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
4442:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4443:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4444:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4445:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4446:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4447:.\Include/arm_math.h ****    */
4448:.\Include/arm_math.h ****   void arm_correlate_fast_q31(
4449:.\Include/arm_math.h ****   q31_t * pSrcA,
4450:.\Include/arm_math.h ****   uint32_t srcALen,
4451:.\Include/arm_math.h ****   q31_t * pSrcB,
4452:.\Include/arm_math.h ****   uint32_t srcBLen,
4453:.\Include/arm_math.h ****   q31_t * pDst);
4454:.\Include/arm_math.h **** 
4455:.\Include/arm_math.h **** 
4456:.\Include/arm_math.h ****  /**
4457:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4458:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
4459:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
4460:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
4461:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
4462:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 
4463:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
4464:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
4465:.\Include/arm_math.h ****    */
4466:.\Include/arm_math.h ****   void arm_correlate_opt_q7(
4467:.\Include/arm_math.h ****   q7_t * pSrcA,
4468:.\Include/arm_math.h ****   uint32_t srcALen,
4469:.\Include/arm_math.h ****   q7_t * pSrcB,
4470:.\Include/arm_math.h ****   uint32_t srcBLen,
4471:.\Include/arm_math.h ****   q7_t * pDst,
4472:.\Include/arm_math.h ****   q15_t * pScratch1,
4473:.\Include/arm_math.h ****   q15_t * pScratch2);
4474:.\Include/arm_math.h **** 
4475:.\Include/arm_math.h **** 
4476:.\Include/arm_math.h ****   /**
4477:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4478:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4479:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4480:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4481:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4482:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 88


4483:.\Include/arm_math.h ****    */
4484:.\Include/arm_math.h ****   void arm_correlate_q7(
4485:.\Include/arm_math.h ****   q7_t * pSrcA,
4486:.\Include/arm_math.h ****   uint32_t srcALen,
4487:.\Include/arm_math.h ****   q7_t * pSrcB,
4488:.\Include/arm_math.h ****   uint32_t srcBLen,
4489:.\Include/arm_math.h ****   q7_t * pDst);
4490:.\Include/arm_math.h **** 
4491:.\Include/arm_math.h **** 
4492:.\Include/arm_math.h ****   /**
4493:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point sparse FIR filter.
4494:.\Include/arm_math.h ****    */
4495:.\Include/arm_math.h ****   typedef struct
4496:.\Include/arm_math.h ****   {
4497:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4498:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4499:.\Include/arm_math.h ****     float32_t *pState;            /**< points to the state buffer array. The array is of length max
4500:.\Include/arm_math.h ****     float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numT
4501:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4502:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4503:.\Include/arm_math.h ****   } arm_fir_sparse_instance_f32;
4504:.\Include/arm_math.h **** 
4505:.\Include/arm_math.h ****   /**
4506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 sparse FIR filter.
4507:.\Include/arm_math.h ****    */
4508:.\Include/arm_math.h ****   typedef struct
4509:.\Include/arm_math.h ****   {
4510:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4511:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4512:.\Include/arm_math.h ****     q31_t *pState;                /**< points to the state buffer array. The array is of length max
4513:.\Include/arm_math.h ****     q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4514:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4515:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4516:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q31;
4517:.\Include/arm_math.h **** 
4518:.\Include/arm_math.h ****   /**
4519:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 sparse FIR filter.
4520:.\Include/arm_math.h ****    */
4521:.\Include/arm_math.h ****   typedef struct
4522:.\Include/arm_math.h ****   {
4523:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4524:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4525:.\Include/arm_math.h ****     q15_t *pState;                /**< points to the state buffer array. The array is of length max
4526:.\Include/arm_math.h ****     q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4527:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4528:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4529:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q15;
4530:.\Include/arm_math.h **** 
4531:.\Include/arm_math.h ****   /**
4532:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 sparse FIR filter.
4533:.\Include/arm_math.h ****    */
4534:.\Include/arm_math.h ****   typedef struct
4535:.\Include/arm_math.h ****   {
4536:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4537:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4538:.\Include/arm_math.h ****     q7_t *pState;                 /**< points to the state buffer array. The array is of length max
4539:.\Include/arm_math.h ****     q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numT
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 89


4540:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4541:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4542:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q7;
4543:.\Include/arm_math.h **** 
4544:.\Include/arm_math.h **** 
4545:.\Include/arm_math.h ****   /**
4546:.\Include/arm_math.h ****    * @brief Processing function for the floating-point sparse FIR filter.
4547:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
4548:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4549:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4550:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4551:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4552:.\Include/arm_math.h ****    */
4553:.\Include/arm_math.h ****   void arm_fir_sparse_f32(
4554:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4555:.\Include/arm_math.h ****   float32_t * pSrc,
4556:.\Include/arm_math.h ****   float32_t * pDst,
4557:.\Include/arm_math.h ****   float32_t * pScratchIn,
4558:.\Include/arm_math.h ****   uint32_t blockSize);
4559:.\Include/arm_math.h **** 
4560:.\Include/arm_math.h **** 
4561:.\Include/arm_math.h ****   /**
4562:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point sparse FIR filter.
4563:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
4564:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4565:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4566:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4567:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4568:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4569:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4570:.\Include/arm_math.h ****    */
4571:.\Include/arm_math.h ****   void arm_fir_sparse_init_f32(
4572:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4573:.\Include/arm_math.h ****   uint16_t numTaps,
4574:.\Include/arm_math.h ****   float32_t * pCoeffs,
4575:.\Include/arm_math.h ****   float32_t * pState,
4576:.\Include/arm_math.h ****   int32_t * pTapDelay,
4577:.\Include/arm_math.h ****   uint16_t maxDelay,
4578:.\Include/arm_math.h ****   uint32_t blockSize);
4579:.\Include/arm_math.h **** 
4580:.\Include/arm_math.h **** 
4581:.\Include/arm_math.h ****   /**
4582:.\Include/arm_math.h ****    * @brief Processing function for the Q31 sparse FIR filter.
4583:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
4584:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4585:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4586:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4587:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4588:.\Include/arm_math.h ****    */
4589:.\Include/arm_math.h ****   void arm_fir_sparse_q31(
4590:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4591:.\Include/arm_math.h ****   q31_t * pSrc,
4592:.\Include/arm_math.h ****   q31_t * pDst,
4593:.\Include/arm_math.h ****   q31_t * pScratchIn,
4594:.\Include/arm_math.h ****   uint32_t blockSize);
4595:.\Include/arm_math.h **** 
4596:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 90


4597:.\Include/arm_math.h ****   /**
4598:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 sparse FIR filter.
4599:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
4600:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4601:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4602:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4603:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4604:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4605:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4606:.\Include/arm_math.h ****    */
4607:.\Include/arm_math.h ****   void arm_fir_sparse_init_q31(
4608:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4609:.\Include/arm_math.h ****   uint16_t numTaps,
4610:.\Include/arm_math.h ****   q31_t * pCoeffs,
4611:.\Include/arm_math.h ****   q31_t * pState,
4612:.\Include/arm_math.h ****   int32_t * pTapDelay,
4613:.\Include/arm_math.h ****   uint16_t maxDelay,
4614:.\Include/arm_math.h ****   uint32_t blockSize);
4615:.\Include/arm_math.h **** 
4616:.\Include/arm_math.h **** 
4617:.\Include/arm_math.h ****   /**
4618:.\Include/arm_math.h ****    * @brief Processing function for the Q15 sparse FIR filter.
4619:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
4620:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4621:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4622:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4623:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4624:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4625:.\Include/arm_math.h ****    */
4626:.\Include/arm_math.h ****   void arm_fir_sparse_q15(
4627:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4628:.\Include/arm_math.h ****   q15_t * pSrc,
4629:.\Include/arm_math.h ****   q15_t * pDst,
4630:.\Include/arm_math.h ****   q15_t * pScratchIn,
4631:.\Include/arm_math.h ****   q31_t * pScratchOut,
4632:.\Include/arm_math.h ****   uint32_t blockSize);
4633:.\Include/arm_math.h **** 
4634:.\Include/arm_math.h **** 
4635:.\Include/arm_math.h ****   /**
4636:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 sparse FIR filter.
4637:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
4638:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4639:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4640:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4641:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4642:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4643:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4644:.\Include/arm_math.h ****    */
4645:.\Include/arm_math.h ****   void arm_fir_sparse_init_q15(
4646:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4647:.\Include/arm_math.h ****   uint16_t numTaps,
4648:.\Include/arm_math.h ****   q15_t * pCoeffs,
4649:.\Include/arm_math.h ****   q15_t * pState,
4650:.\Include/arm_math.h ****   int32_t * pTapDelay,
4651:.\Include/arm_math.h ****   uint16_t maxDelay,
4652:.\Include/arm_math.h ****   uint32_t blockSize);
4653:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 91


4654:.\Include/arm_math.h **** 
4655:.\Include/arm_math.h ****   /**
4656:.\Include/arm_math.h ****    * @brief Processing function for the Q7 sparse FIR filter.
4657:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
4658:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4659:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4660:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4661:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4662:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4663:.\Include/arm_math.h ****    */
4664:.\Include/arm_math.h ****   void arm_fir_sparse_q7(
4665:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4666:.\Include/arm_math.h ****   q7_t * pSrc,
4667:.\Include/arm_math.h ****   q7_t * pDst,
4668:.\Include/arm_math.h ****   q7_t * pScratchIn,
4669:.\Include/arm_math.h ****   q31_t * pScratchOut,
4670:.\Include/arm_math.h ****   uint32_t blockSize);
4671:.\Include/arm_math.h **** 
4672:.\Include/arm_math.h **** 
4673:.\Include/arm_math.h ****   /**
4674:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 sparse FIR filter.
4675:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
4676:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4677:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4678:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4679:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4680:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4681:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4682:.\Include/arm_math.h ****    */
4683:.\Include/arm_math.h ****   void arm_fir_sparse_init_q7(
4684:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4685:.\Include/arm_math.h ****   uint16_t numTaps,
4686:.\Include/arm_math.h ****   q7_t * pCoeffs,
4687:.\Include/arm_math.h ****   q7_t * pState,
4688:.\Include/arm_math.h ****   int32_t * pTapDelay,
4689:.\Include/arm_math.h ****   uint16_t maxDelay,
4690:.\Include/arm_math.h ****   uint32_t blockSize);
4691:.\Include/arm_math.h **** 
4692:.\Include/arm_math.h **** 
4693:.\Include/arm_math.h ****   /**
4694:.\Include/arm_math.h ****    * @brief  Floating-point sin_cos function.
4695:.\Include/arm_math.h ****    * @param[in]  theta   input value in degrees
4696:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4697:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cos output.
4698:.\Include/arm_math.h ****    */
4699:.\Include/arm_math.h ****   void arm_sin_cos_f32(
4700:.\Include/arm_math.h ****   float32_t theta,
4701:.\Include/arm_math.h ****   float32_t * pSinVal,
4702:.\Include/arm_math.h ****   float32_t * pCosVal);
4703:.\Include/arm_math.h **** 
4704:.\Include/arm_math.h **** 
4705:.\Include/arm_math.h ****   /**
4706:.\Include/arm_math.h ****    * @brief  Q31 sin_cos function.
4707:.\Include/arm_math.h ****    * @param[in]  theta    scaled input value in degrees
4708:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4709:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cosine output.
4710:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 92


4711:.\Include/arm_math.h ****   void arm_sin_cos_q31(
4712:.\Include/arm_math.h ****   q31_t theta,
4713:.\Include/arm_math.h ****   q31_t * pSinVal,
4714:.\Include/arm_math.h ****   q31_t * pCosVal);
4715:.\Include/arm_math.h **** 
4716:.\Include/arm_math.h **** 
4717:.\Include/arm_math.h ****   /**
4718:.\Include/arm_math.h ****    * @brief  Floating-point complex conjugate.
4719:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4720:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4721:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4722:.\Include/arm_math.h ****    */
4723:.\Include/arm_math.h ****   void arm_cmplx_conj_f32(
4724:.\Include/arm_math.h ****   float32_t * pSrc,
4725:.\Include/arm_math.h ****   float32_t * pDst,
4726:.\Include/arm_math.h ****   uint32_t numSamples);
4727:.\Include/arm_math.h **** 
4728:.\Include/arm_math.h ****   /**
4729:.\Include/arm_math.h ****    * @brief  Q31 complex conjugate.
4730:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4731:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4732:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4733:.\Include/arm_math.h ****    */
4734:.\Include/arm_math.h ****   void arm_cmplx_conj_q31(
4735:.\Include/arm_math.h ****   q31_t * pSrc,
4736:.\Include/arm_math.h ****   q31_t * pDst,
4737:.\Include/arm_math.h ****   uint32_t numSamples);
4738:.\Include/arm_math.h **** 
4739:.\Include/arm_math.h **** 
4740:.\Include/arm_math.h ****   /**
4741:.\Include/arm_math.h ****    * @brief  Q15 complex conjugate.
4742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4743:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4744:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4745:.\Include/arm_math.h ****    */
4746:.\Include/arm_math.h ****   void arm_cmplx_conj_q15(
4747:.\Include/arm_math.h ****   q15_t * pSrc,
4748:.\Include/arm_math.h ****   q15_t * pDst,
4749:.\Include/arm_math.h ****   uint32_t numSamples);
4750:.\Include/arm_math.h **** 
4751:.\Include/arm_math.h **** 
4752:.\Include/arm_math.h ****   /**
4753:.\Include/arm_math.h ****    * @brief  Floating-point complex magnitude squared
4754:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4755:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4756:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4757:.\Include/arm_math.h ****    */
4758:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_f32(
4759:.\Include/arm_math.h ****   float32_t * pSrc,
4760:.\Include/arm_math.h ****   float32_t * pDst,
4761:.\Include/arm_math.h ****   uint32_t numSamples);
4762:.\Include/arm_math.h **** 
4763:.\Include/arm_math.h **** 
4764:.\Include/arm_math.h ****   /**
4765:.\Include/arm_math.h ****    * @brief  Q31 complex magnitude squared
4766:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4767:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 93


4768:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4769:.\Include/arm_math.h ****    */
4770:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q31(
4771:.\Include/arm_math.h ****   q31_t * pSrc,
4772:.\Include/arm_math.h ****   q31_t * pDst,
4773:.\Include/arm_math.h ****   uint32_t numSamples);
4774:.\Include/arm_math.h **** 
4775:.\Include/arm_math.h **** 
4776:.\Include/arm_math.h ****   /**
4777:.\Include/arm_math.h ****    * @brief  Q15 complex magnitude squared
4778:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4779:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4780:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4781:.\Include/arm_math.h ****    */
4782:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q15(
4783:.\Include/arm_math.h ****   q15_t * pSrc,
4784:.\Include/arm_math.h ****   q15_t * pDst,
4785:.\Include/arm_math.h ****   uint32_t numSamples);
4786:.\Include/arm_math.h **** 
4787:.\Include/arm_math.h **** 
4788:.\Include/arm_math.h ****  /**
4789:.\Include/arm_math.h ****    * @ingroup groupController
4790:.\Include/arm_math.h ****    */
4791:.\Include/arm_math.h **** 
4792:.\Include/arm_math.h ****   /**
4793:.\Include/arm_math.h ****    * @defgroup PID PID Motor Control
4794:.\Include/arm_math.h ****    *
4795:.\Include/arm_math.h ****    * A Proportional Integral Derivative (PID) controller is a generic feedback control
4796:.\Include/arm_math.h ****    * loop mechanism widely used in industrial control systems.
4797:.\Include/arm_math.h ****    * A PID controller is the most commonly used type of feedback controller.
4798:.\Include/arm_math.h ****    *
4799:.\Include/arm_math.h ****    * This set of functions implements (PID) controllers
4800:.\Include/arm_math.h ****    * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
4801:.\Include/arm_math.h ****    * of data and each call to the function returns a single processed value.
4802:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
4803:.\Include/arm_math.h ****    * is the input sample value. The functions return the output value.
4804:.\Include/arm_math.h ****    *
4805:.\Include/arm_math.h ****    * \par Algorithm:
4806:.\Include/arm_math.h ****    * <pre>
4807:.\Include/arm_math.h ****    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
4808:.\Include/arm_math.h ****    *    A0 = Kp + Ki + Kd
4809:.\Include/arm_math.h ****    *    A1 = (-Kp ) - (2 * Kd )
4810:.\Include/arm_math.h ****    *    A2 = Kd  </pre>
4811:.\Include/arm_math.h ****    *
4812:.\Include/arm_math.h ****    * \par
4813:.\Include/arm_math.h ****    * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative const
4814:.\Include/arm_math.h ****    *
4815:.\Include/arm_math.h ****    * \par
4816:.\Include/arm_math.h ****    * \image html PID.gif "Proportional Integral Derivative Controller"
4817:.\Include/arm_math.h ****    *
4818:.\Include/arm_math.h ****    * \par
4819:.\Include/arm_math.h ****    * The PID controller calculates an "error" value as the difference between
4820:.\Include/arm_math.h ****    * the measured output and the reference input.
4821:.\Include/arm_math.h ****    * The controller attempts to minimize the error by adjusting the process control inputs.
4822:.\Include/arm_math.h ****    * The proportional value determines the reaction to the current error,
4823:.\Include/arm_math.h ****    * the integral value determines the reaction based on the sum of recent errors,
4824:.\Include/arm_math.h ****    * and the derivative value determines the reaction based on the rate at which the error has been
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 94


4825:.\Include/arm_math.h ****    *
4826:.\Include/arm_math.h ****    * \par Instance Structure
4827:.\Include/arm_math.h ****    * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instan
4828:.\Include/arm_math.h ****    * A separate instance structure must be defined for each PID Controller.
4829:.\Include/arm_math.h ****    * There are separate instance structure declarations for each of the 3 supported data types.
4830:.\Include/arm_math.h ****    *
4831:.\Include/arm_math.h ****    * \par Reset Functions
4832:.\Include/arm_math.h ****    * There is also an associated reset function for each data type which clears the state array.
4833:.\Include/arm_math.h ****    *
4834:.\Include/arm_math.h ****    * \par Initialization Functions
4835:.\Include/arm_math.h ****    * There is also an associated initialization function for each data type.
4836:.\Include/arm_math.h ****    * The initialization function performs the following operations:
4837:.\Include/arm_math.h ****    * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
4838:.\Include/arm_math.h ****    * - Zeros out the values in the state buffer.
4839:.\Include/arm_math.h ****    *
4840:.\Include/arm_math.h ****    * \par
4841:.\Include/arm_math.h ****    * Instance structure cannot be placed into a const data section and it is recommended to use the
4842:.\Include/arm_math.h ****    *
4843:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
4844:.\Include/arm_math.h ****    * Care must be taken when using the fixed-point versions of the PID Controller functions.
4845:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used in each function m
4846:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4847:.\Include/arm_math.h ****    */
4848:.\Include/arm_math.h **** 
4849:.\Include/arm_math.h ****   /**
4850:.\Include/arm_math.h ****    * @addtogroup PID
4851:.\Include/arm_math.h ****    * @{
4852:.\Include/arm_math.h ****    */
4853:.\Include/arm_math.h **** 
4854:.\Include/arm_math.h ****   /**
4855:.\Include/arm_math.h ****    * @brief  Process function for the floating-point PID Control.
4856:.\Include/arm_math.h ****    * @param[in,out] S   is an instance of the floating-point PID Control structure
4857:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4858:.\Include/arm_math.h ****    * @return out processed output sample.
4859:.\Include/arm_math.h ****    */
4860:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_pid_f32(
4861:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
4862:.\Include/arm_math.h ****   float32_t in)
4863:.\Include/arm_math.h ****   {
4864:.\Include/arm_math.h ****     float32_t out;
4865:.\Include/arm_math.h **** 
4866:.\Include/arm_math.h ****     /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
4867:.\Include/arm_math.h ****     out = (S->A0 * in) +
4868:.\Include/arm_math.h ****       (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
4869:.\Include/arm_math.h **** 
4870:.\Include/arm_math.h ****     /* Update state */
4871:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4872:.\Include/arm_math.h ****     S->state[0] = in;
4873:.\Include/arm_math.h ****     S->state[2] = out;
4874:.\Include/arm_math.h **** 
4875:.\Include/arm_math.h ****     /* return to application */
4876:.\Include/arm_math.h ****     return (out);
4877:.\Include/arm_math.h **** 
4878:.\Include/arm_math.h ****   }
4879:.\Include/arm_math.h **** 
4880:.\Include/arm_math.h ****   /**
4881:.\Include/arm_math.h ****    * @brief  Process function for the Q31 PID Control.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 95


4882:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the Q31 PID Control structure
4883:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4884:.\Include/arm_math.h ****    * @return out processed output sample.
4885:.\Include/arm_math.h ****    *
4886:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4887:.\Include/arm_math.h ****    * \par
4888:.\Include/arm_math.h ****    * The function is implemented using an internal 64-bit accumulator.
4889:.\Include/arm_math.h ****    * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplicat
4890:.\Include/arm_math.h ****    * Thus, if the accumulator result overflows it wraps around rather than clip.
4891:.\Include/arm_math.h ****    * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there
4892:.\Include/arm_math.h ****    * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format
4893:.\Include/arm_math.h ****    */
4894:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_pid_q31(
4895:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
4896:.\Include/arm_math.h ****   q31_t in)
4897:.\Include/arm_math.h ****   {
4898:.\Include/arm_math.h ****     q63_t acc;
4899:.\Include/arm_math.h ****     q31_t out;
4900:.\Include/arm_math.h **** 
4901:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4902:.\Include/arm_math.h ****     acc = (q63_t) S->A0 * in;
4903:.\Include/arm_math.h **** 
4904:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] */
4905:.\Include/arm_math.h ****     acc += (q63_t) S->A1 * S->state[0];
4906:.\Include/arm_math.h **** 
4907:.\Include/arm_math.h ****     /* acc += A2 * x[n-2]  */
4908:.\Include/arm_math.h ****     acc += (q63_t) S->A2 * S->state[1];
4909:.\Include/arm_math.h **** 
4910:.\Include/arm_math.h ****     /* convert output to 1.31 format to add y[n-1] */
4911:.\Include/arm_math.h ****     out = (q31_t) (acc >> 31u);
4912:.\Include/arm_math.h **** 
4913:.\Include/arm_math.h ****     /* out += y[n-1] */
4914:.\Include/arm_math.h ****     out += S->state[2];
4915:.\Include/arm_math.h **** 
4916:.\Include/arm_math.h ****     /* Update state */
4917:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4918:.\Include/arm_math.h ****     S->state[0] = in;
4919:.\Include/arm_math.h ****     S->state[2] = out;
4920:.\Include/arm_math.h **** 
4921:.\Include/arm_math.h ****     /* return to application */
4922:.\Include/arm_math.h ****     return (out);
4923:.\Include/arm_math.h ****   }
4924:.\Include/arm_math.h **** 
4925:.\Include/arm_math.h **** 
4926:.\Include/arm_math.h ****   /**
4927:.\Include/arm_math.h ****    * @brief  Process function for the Q15 PID Control.
4928:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q15 PID Control structure
4929:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4930:.\Include/arm_math.h ****    * @return out processed output sample.
4931:.\Include/arm_math.h ****    *
4932:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4933:.\Include/arm_math.h ****    * \par
4934:.\Include/arm_math.h ****    * The function is implemented using a 64-bit internal accumulator.
4935:.\Include/arm_math.h ****    * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30
4936:.\Include/arm_math.h ****    * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
4937:.\Include/arm_math.h ****    * There is no risk of internal overflow with this approach and the full precision of intermediat
4938:.\Include/arm_math.h ****    * After all additions have been performed, the accumulator is truncated to 34.15 format by disca
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 96


4939:.\Include/arm_math.h ****    * Lastly, the accumulator is saturated to yield a result in 1.15 format.
4940:.\Include/arm_math.h ****    */
4941:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_pid_q15(
4942:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
4943:.\Include/arm_math.h ****   q15_t in)
4944:.\Include/arm_math.h ****   {
4945:.\Include/arm_math.h ****     q63_t acc;
4946:.\Include/arm_math.h ****     q15_t out;
4947:.\Include/arm_math.h **** 
4948:.\Include/arm_math.h **** #if defined (ARM_MATH_DSP)
4949:.\Include/arm_math.h ****     __SIMD32_TYPE *vstate;
4950:.\Include/arm_math.h **** 
4951:.\Include/arm_math.h ****     /* Implementation of PID controller */
4952:.\Include/arm_math.h **** 
4953:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4954:.\Include/arm_math.h ****     acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
4955:.\Include/arm_math.h **** 
4956:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4957:.\Include/arm_math.h ****     vstate = __SIMD32_CONST(S->state);
4958:.\Include/arm_math.h ****     acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
4959:.\Include/arm_math.h **** #else
4960:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4961:.\Include/arm_math.h ****     acc = ((q31_t) S->A0) * in;
4962:.\Include/arm_math.h **** 
4963:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4964:.\Include/arm_math.h ****     acc += (q31_t) S->A1 * S->state[0];
4965:.\Include/arm_math.h ****     acc += (q31_t) S->A2 * S->state[1];
4966:.\Include/arm_math.h **** #endif
4967:.\Include/arm_math.h **** 
4968:.\Include/arm_math.h ****     /* acc += y[n-1] */
4969:.\Include/arm_math.h ****     acc += (q31_t) S->state[2] << 15;
4970:.\Include/arm_math.h **** 
4971:.\Include/arm_math.h ****     /* saturate the output */
4972:.\Include/arm_math.h ****     out = (q15_t) (__SSAT((acc >> 15), 16));
4973:.\Include/arm_math.h **** 
4974:.\Include/arm_math.h ****     /* Update state */
4975:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4976:.\Include/arm_math.h ****     S->state[0] = in;
4977:.\Include/arm_math.h ****     S->state[2] = out;
4978:.\Include/arm_math.h **** 
4979:.\Include/arm_math.h ****     /* return to application */
4980:.\Include/arm_math.h ****     return (out);
4981:.\Include/arm_math.h ****   }
4982:.\Include/arm_math.h **** 
4983:.\Include/arm_math.h ****   /**
4984:.\Include/arm_math.h ****    * @} end of PID group
4985:.\Include/arm_math.h ****    */
4986:.\Include/arm_math.h **** 
4987:.\Include/arm_math.h **** 
4988:.\Include/arm_math.h ****   /**
4989:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
4990:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4991:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4992:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4993:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4994:.\Include/arm_math.h ****    */
4995:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 97


4996:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * src,
4997:.\Include/arm_math.h ****   arm_matrix_instance_f32 * dst);
4998:.\Include/arm_math.h **** 
4999:.\Include/arm_math.h **** 
5000:.\Include/arm_math.h ****   /**
5001:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
5002:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
5003:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
5004:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
5005:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
5006:.\Include/arm_math.h ****    */
5007:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f64(
5008:.\Include/arm_math.h ****   const arm_matrix_instance_f64 * src,
5009:.\Include/arm_math.h ****   arm_matrix_instance_f64 * dst);
5010:.\Include/arm_math.h **** 
5011:.\Include/arm_math.h **** 
5012:.\Include/arm_math.h **** 
5013:.\Include/arm_math.h ****   /**
5014:.\Include/arm_math.h ****    * @ingroup groupController
5015:.\Include/arm_math.h ****    */
5016:.\Include/arm_math.h **** 
5017:.\Include/arm_math.h ****   /**
5018:.\Include/arm_math.h ****    * @defgroup clarke Vector Clarke Transform
5019:.\Include/arm_math.h ****    * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time i
5020:.\Include/arm_math.h ****    * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calcula
5021:.\Include/arm_math.h ****    * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
5022:.\Include/arm_math.h ****    * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
5023:.\Include/arm_math.h ****    * \image html clarke.gif Stator current space vector and its components in (a,b).
5024:.\Include/arm_math.h ****    * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code
5025:.\Include/arm_math.h ****    * can be calculated using only <code>Ia</code> and <code>Ib</code>.
5026:.\Include/arm_math.h ****    *
5027:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5028:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5029:.\Include/arm_math.h ****    * \par Algorithm
5030:.\Include/arm_math.h ****    * \image html clarkeFormula.gif
5031:.\Include/arm_math.h ****    * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
5032:.\Include/arm_math.h ****    * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
5033:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5034:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5035:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5036:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5037:.\Include/arm_math.h ****    */
5038:.\Include/arm_math.h **** 
5039:.\Include/arm_math.h ****   /**
5040:.\Include/arm_math.h ****    * @addtogroup clarke
5041:.\Include/arm_math.h ****    * @{
5042:.\Include/arm_math.h ****    */
5043:.\Include/arm_math.h **** 
5044:.\Include/arm_math.h ****   /**
5045:.\Include/arm_math.h ****    *
5046:.\Include/arm_math.h ****    * @brief  Floating-point Clarke transform
5047:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5048:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5049:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5050:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5051:.\Include/arm_math.h ****    */
5052:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 98


5053:.\Include/arm_math.h ****   float32_t Ia,
5054:.\Include/arm_math.h ****   float32_t Ib,
5055:.\Include/arm_math.h ****   float32_t * pIalpha,
5056:.\Include/arm_math.h ****   float32_t * pIbeta)
5057:.\Include/arm_math.h ****   {
5058:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Ia */
5059:.\Include/arm_math.h ****     *pIalpha = Ia;
5060:.\Include/arm_math.h **** 
5061:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
5062:.\Include/arm_math.h ****     *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
5063:.\Include/arm_math.h ****   }
5064:.\Include/arm_math.h **** 
5065:.\Include/arm_math.h **** 
5066:.\Include/arm_math.h ****   /**
5067:.\Include/arm_math.h ****    * @brief  Clarke transform for Q31 version
5068:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5069:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5070:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5071:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5072:.\Include/arm_math.h ****    *
5073:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5074:.\Include/arm_math.h ****    * \par
5075:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5076:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5077:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5078:.\Include/arm_math.h ****    */
5079:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_q31(
5080:.\Include/arm_math.h ****   q31_t Ia,
5081:.\Include/arm_math.h ****   q31_t Ib,
5082:.\Include/arm_math.h ****   q31_t * pIalpha,
5083:.\Include/arm_math.h ****   q31_t * pIbeta)
5084:.\Include/arm_math.h ****   {
5085:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5086:.\Include/arm_math.h **** 
5087:.\Include/arm_math.h ****     /* Calculating pIalpha from Ia by equation pIalpha = Ia */
5088:.\Include/arm_math.h ****     *pIalpha = Ia;
5089:.\Include/arm_math.h **** 
5090:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
5091:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
5092:.\Include/arm_math.h **** 
5093:.\Include/arm_math.h ****     /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
5094:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
5095:.\Include/arm_math.h **** 
5096:.\Include/arm_math.h ****     /* pIbeta is calculated by adding the intermediate products */
5097:.\Include/arm_math.h ****     *pIbeta = __QADD(product1, product2);
5098:.\Include/arm_math.h ****   }
5099:.\Include/arm_math.h **** 
5100:.\Include/arm_math.h ****   /**
5101:.\Include/arm_math.h ****    * @} end of clarke group
5102:.\Include/arm_math.h ****    */
5103:.\Include/arm_math.h **** 
5104:.\Include/arm_math.h ****   /**
5105:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q31 vector.
5106:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5107:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5108:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5109:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 99


5110:.\Include/arm_math.h ****   void arm_q7_to_q31(
5111:.\Include/arm_math.h ****   q7_t * pSrc,
5112:.\Include/arm_math.h ****   q31_t * pDst,
5113:.\Include/arm_math.h ****   uint32_t blockSize);
5114:.\Include/arm_math.h **** 
5115:.\Include/arm_math.h **** 
5116:.\Include/arm_math.h **** 
5117:.\Include/arm_math.h ****   /**
5118:.\Include/arm_math.h ****    * @ingroup groupController
5119:.\Include/arm_math.h ****    */
5120:.\Include/arm_math.h **** 
5121:.\Include/arm_math.h ****   /**
5122:.\Include/arm_math.h ****    * @defgroup inv_clarke Vector Inverse Clarke Transform
5123:.\Include/arm_math.h ****    * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous 
5124:.\Include/arm_math.h ****    *
5125:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5126:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5127:.\Include/arm_math.h ****    * \par Algorithm
5128:.\Include/arm_math.h ****    * \image html clarkeInvFormula.gif
5129:.\Include/arm_math.h ****    * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
5130:.\Include/arm_math.h ****    * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
5131:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5132:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5133:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5134:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5135:.\Include/arm_math.h ****    */
5136:.\Include/arm_math.h **** 
5137:.\Include/arm_math.h ****   /**
5138:.\Include/arm_math.h ****    * @addtogroup inv_clarke
5139:.\Include/arm_math.h ****    * @{
5140:.\Include/arm_math.h ****    */
5141:.\Include/arm_math.h **** 
5142:.\Include/arm_math.h ****    /**
5143:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Clarke transform
5144:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5145:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5146:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5147:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5148:.\Include/arm_math.h ****    */
5149:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_f32(
5150:.\Include/arm_math.h ****   float32_t Ialpha,
5151:.\Include/arm_math.h ****   float32_t Ibeta,
5152:.\Include/arm_math.h ****   float32_t * pIa,
5153:.\Include/arm_math.h ****   float32_t * pIb)
5154:.\Include/arm_math.h ****   {
5155:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5156:.\Include/arm_math.h ****     *pIa = Ialpha;
5157:.\Include/arm_math.h **** 
5158:.\Include/arm_math.h ****     /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibet
5159:.\Include/arm_math.h ****     *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
5160:.\Include/arm_math.h ****   }
5161:.\Include/arm_math.h **** 
5162:.\Include/arm_math.h **** 
5163:.\Include/arm_math.h ****   /**
5164:.\Include/arm_math.h ****    * @brief  Inverse Clarke transform for Q31 version
5165:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5166:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 100


5167:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5168:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5169:.\Include/arm_math.h ****    *
5170:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5171:.\Include/arm_math.h ****    * \par
5172:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5173:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5174:.\Include/arm_math.h ****    * There is saturation on the subtraction, hence there is no risk of overflow.
5175:.\Include/arm_math.h ****    */
5176:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_q31(
5177:.\Include/arm_math.h ****   q31_t Ialpha,
5178:.\Include/arm_math.h ****   q31_t Ibeta,
5179:.\Include/arm_math.h ****   q31_t * pIa,
5180:.\Include/arm_math.h ****   q31_t * pIb)
5181:.\Include/arm_math.h ****   {
5182:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5183:.\Include/arm_math.h **** 
5184:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5185:.\Include/arm_math.h ****     *pIa = Ialpha;
5186:.\Include/arm_math.h **** 
5187:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
5188:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
5189:.\Include/arm_math.h **** 
5190:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
5191:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
5192:.\Include/arm_math.h **** 
5193:.\Include/arm_math.h ****     /* pIb is calculated by subtracting the products */
5194:.\Include/arm_math.h ****     *pIb = __QSUB(product2, product1);
5195:.\Include/arm_math.h ****   }
5196:.\Include/arm_math.h **** 
5197:.\Include/arm_math.h ****   /**
5198:.\Include/arm_math.h ****    * @} end of inv_clarke group
5199:.\Include/arm_math.h ****    */
5200:.\Include/arm_math.h **** 
5201:.\Include/arm_math.h ****   /**
5202:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q15 vector.
5203:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5204:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5205:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5206:.\Include/arm_math.h ****    */
5207:.\Include/arm_math.h ****   void arm_q7_to_q15(
5208:.\Include/arm_math.h ****   q7_t * pSrc,
5209:.\Include/arm_math.h ****   q15_t * pDst,
5210:.\Include/arm_math.h ****   uint32_t blockSize);
5211:.\Include/arm_math.h **** 
5212:.\Include/arm_math.h **** 
5213:.\Include/arm_math.h **** 
5214:.\Include/arm_math.h ****   /**
5215:.\Include/arm_math.h ****    * @ingroup groupController
5216:.\Include/arm_math.h ****    */
5217:.\Include/arm_math.h **** 
5218:.\Include/arm_math.h ****   /**
5219:.\Include/arm_math.h ****    * @defgroup park Vector Park Transform
5220:.\Include/arm_math.h ****    *
5221:.\Include/arm_math.h ****    * Forward Park transform converts the input two-coordinate vector to flux and torque components.
5222:.\Include/arm_math.h ****    * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and th
5223:.\Include/arm_math.h ****    * from the stationary to the moving reference frame and control the spatial relationship between
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 101


5224:.\Include/arm_math.h ****    * the stator vector current and rotor flux vector.
5225:.\Include/arm_math.h ****    * If we consider the d axis aligned with the rotor flux, the diagram below shows the
5226:.\Include/arm_math.h ****    * current vector and the relationship from the two reference frames:
5227:.\Include/arm_math.h ****    * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q ro
5228:.\Include/arm_math.h ****    *
5229:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5230:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5231:.\Include/arm_math.h ****    * \par Algorithm
5232:.\Include/arm_math.h ****    * \image html parkFormula.gif
5233:.\Include/arm_math.h ****    * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
5234:.\Include/arm_math.h ****    * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and 
5235:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5236:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5237:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5238:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5239:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5240:.\Include/arm_math.h ****    */
5241:.\Include/arm_math.h **** 
5242:.\Include/arm_math.h ****   /**
5243:.\Include/arm_math.h ****    * @addtogroup park
5244:.\Include/arm_math.h ****    * @{
5245:.\Include/arm_math.h ****    */
5246:.\Include/arm_math.h **** 
5247:.\Include/arm_math.h ****   /**
5248:.\Include/arm_math.h ****    * @brief Floating-point Park transform
5249:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5250:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5251:.\Include/arm_math.h ****    * @param[out] pId     points to output   rotor reference frame d
5252:.\Include/arm_math.h ****    * @param[out] pIq     points to output   rotor reference frame q
5253:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5254:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5255:.\Include/arm_math.h ****    *
5256:.\Include/arm_math.h ****    * The function implements the forward Park transform.
5257:.\Include/arm_math.h ****    *
5258:.\Include/arm_math.h ****    */
5259:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_f32(
5260:.\Include/arm_math.h ****   float32_t Ialpha,
5261:.\Include/arm_math.h ****   float32_t Ibeta,
5262:.\Include/arm_math.h ****   float32_t * pId,
5263:.\Include/arm_math.h ****   float32_t * pIq,
5264:.\Include/arm_math.h ****   float32_t sinVal,
5265:.\Include/arm_math.h ****   float32_t cosVal)
5266:.\Include/arm_math.h ****   {
5267:.\Include/arm_math.h ****     /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
5268:.\Include/arm_math.h ****     *pId = Ialpha * cosVal + Ibeta * sinVal;
5269:.\Include/arm_math.h **** 
5270:.\Include/arm_math.h ****     /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
5271:.\Include/arm_math.h ****     *pIq = -Ialpha * sinVal + Ibeta * cosVal;
5272:.\Include/arm_math.h ****   }
5273:.\Include/arm_math.h **** 
5274:.\Include/arm_math.h **** 
5275:.\Include/arm_math.h ****   /**
5276:.\Include/arm_math.h ****    * @brief  Park transform for Q31 version
5277:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5278:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5279:.\Include/arm_math.h ****    * @param[out] pId     points to output rotor reference frame d
5280:.\Include/arm_math.h ****    * @param[out] pIq     points to output rotor reference frame q
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 102


5281:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5282:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5283:.\Include/arm_math.h ****    *
5284:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5285:.\Include/arm_math.h ****    * \par
5286:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5287:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5288:.\Include/arm_math.h ****    * There is saturation on the addition and subtraction, hence there is no risk of overflow.
5289:.\Include/arm_math.h ****    */
5290:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_q31(
5291:.\Include/arm_math.h ****   q31_t Ialpha,
5292:.\Include/arm_math.h ****   q31_t Ibeta,
5293:.\Include/arm_math.h ****   q31_t * pId,
5294:.\Include/arm_math.h ****   q31_t * pIq,
5295:.\Include/arm_math.h ****   q31_t sinVal,
5296:.\Include/arm_math.h ****   q31_t cosVal)
5297:.\Include/arm_math.h ****   {
5298:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5299:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5300:.\Include/arm_math.h **** 
5301:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * cosVal) */
5302:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
5303:.\Include/arm_math.h **** 
5304:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * sinVal) */
5305:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
5306:.\Include/arm_math.h **** 
5307:.\Include/arm_math.h **** 
5308:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * sinVal) */
5309:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
5310:.\Include/arm_math.h **** 
5311:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * cosVal) */
5312:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
5313:.\Include/arm_math.h **** 
5314:.\Include/arm_math.h ****     /* Calculate pId by adding the two intermediate products 1 and 2 */
5315:.\Include/arm_math.h ****     *pId = __QADD(product1, product2);
5316:.\Include/arm_math.h **** 
5317:.\Include/arm_math.h ****     /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
5318:.\Include/arm_math.h ****     *pIq = __QSUB(product4, product3);
5319:.\Include/arm_math.h ****   }
5320:.\Include/arm_math.h **** 
5321:.\Include/arm_math.h ****   /**
5322:.\Include/arm_math.h ****    * @} end of park group
5323:.\Include/arm_math.h ****    */
5324:.\Include/arm_math.h **** 
5325:.\Include/arm_math.h ****   /**
5326:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to floating-point vector.
5327:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5328:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5329:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5330:.\Include/arm_math.h ****    */
5331:.\Include/arm_math.h ****   void arm_q7_to_float(
5332:.\Include/arm_math.h ****   q7_t * pSrc,
5333:.\Include/arm_math.h ****   float32_t * pDst,
5334:.\Include/arm_math.h ****   uint32_t blockSize);
5335:.\Include/arm_math.h **** 
5336:.\Include/arm_math.h **** 
5337:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 103


5338:.\Include/arm_math.h ****    * @ingroup groupController
5339:.\Include/arm_math.h ****    */
5340:.\Include/arm_math.h **** 
5341:.\Include/arm_math.h ****   /**
5342:.\Include/arm_math.h ****    * @defgroup inv_park Vector Inverse Park transform
5343:.\Include/arm_math.h ****    * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
5344:.\Include/arm_math.h ****    *
5345:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5346:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5347:.\Include/arm_math.h ****    * \par Algorithm
5348:.\Include/arm_math.h ****    * \image html parkInvFormula.gif
5349:.\Include/arm_math.h ****    * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
5350:.\Include/arm_math.h ****    * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <c
5351:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5352:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5353:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5354:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5355:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5356:.\Include/arm_math.h ****    */
5357:.\Include/arm_math.h **** 
5358:.\Include/arm_math.h ****   /**
5359:.\Include/arm_math.h ****    * @addtogroup inv_park
5360:.\Include/arm_math.h ****    * @{
5361:.\Include/arm_math.h ****    */
5362:.\Include/arm_math.h **** 
5363:.\Include/arm_math.h ****    /**
5364:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Park transform
5365:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5366:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5367:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5368:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5369:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5370:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5371:.\Include/arm_math.h ****    */
5372:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_f32(
5373:.\Include/arm_math.h ****   float32_t Id,
5374:.\Include/arm_math.h ****   float32_t Iq,
5375:.\Include/arm_math.h ****   float32_t * pIalpha,
5376:.\Include/arm_math.h ****   float32_t * pIbeta,
5377:.\Include/arm_math.h ****   float32_t sinVal,
5378:.\Include/arm_math.h ****   float32_t cosVal)
5379:.\Include/arm_math.h ****   {
5380:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
5381:.\Include/arm_math.h ****     *pIalpha = Id * cosVal - Iq * sinVal;
5382:.\Include/arm_math.h **** 
5383:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
5384:.\Include/arm_math.h ****     *pIbeta = Id * sinVal + Iq * cosVal;
5385:.\Include/arm_math.h ****   }
5386:.\Include/arm_math.h **** 
5387:.\Include/arm_math.h **** 
5388:.\Include/arm_math.h ****   /**
5389:.\Include/arm_math.h ****    * @brief  Inverse Park transform for   Q31 version
5390:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5391:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5392:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5393:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5394:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 104


5395:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5396:.\Include/arm_math.h ****    *
5397:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5398:.\Include/arm_math.h ****    * \par
5399:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5400:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5401:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5402:.\Include/arm_math.h ****    */
5403:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_q31(
5404:.\Include/arm_math.h ****   q31_t Id,
5405:.\Include/arm_math.h ****   q31_t Iq,
5406:.\Include/arm_math.h ****   q31_t * pIalpha,
5407:.\Include/arm_math.h ****   q31_t * pIbeta,
5408:.\Include/arm_math.h ****   q31_t sinVal,
5409:.\Include/arm_math.h ****   q31_t cosVal)
5410:.\Include/arm_math.h ****   {
5411:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5412:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5413:.\Include/arm_math.h **** 
5414:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * cosVal) */
5415:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
5416:.\Include/arm_math.h **** 
5417:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * sinVal) */
5418:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
5419:.\Include/arm_math.h **** 
5420:.\Include/arm_math.h **** 
5421:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * sinVal) */
5422:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
5423:.\Include/arm_math.h **** 
5424:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * cosVal) */
5425:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
5426:.\Include/arm_math.h **** 
5427:.\Include/arm_math.h ****     /* Calculate pIalpha by using the two intermediate products 1 and 2 */
5428:.\Include/arm_math.h ****     *pIalpha = __QSUB(product1, product2);
5429:.\Include/arm_math.h **** 
5430:.\Include/arm_math.h ****     /* Calculate pIbeta by using the two intermediate products 3 and 4 */
5431:.\Include/arm_math.h ****     *pIbeta = __QADD(product4, product3);
5432:.\Include/arm_math.h ****   }
5433:.\Include/arm_math.h **** 
5434:.\Include/arm_math.h ****   /**
5435:.\Include/arm_math.h ****    * @} end of Inverse park group
5436:.\Include/arm_math.h ****    */
5437:.\Include/arm_math.h **** 
5438:.\Include/arm_math.h **** 
5439:.\Include/arm_math.h ****   /**
5440:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q31 vector to floating-point vector.
5441:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5442:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5443:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5444:.\Include/arm_math.h ****    */
5445:.\Include/arm_math.h ****   void arm_q31_to_float(
5446:.\Include/arm_math.h ****   q31_t * pSrc,
5447:.\Include/arm_math.h ****   float32_t * pDst,
5448:.\Include/arm_math.h ****   uint32_t blockSize);
5449:.\Include/arm_math.h **** 
5450:.\Include/arm_math.h ****   /**
5451:.\Include/arm_math.h ****    * @ingroup groupInterpolation
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 105


5452:.\Include/arm_math.h ****    */
5453:.\Include/arm_math.h **** 
5454:.\Include/arm_math.h ****   /**
5455:.\Include/arm_math.h ****    * @defgroup LinearInterpolate Linear Interpolation
5456:.\Include/arm_math.h ****    *
5457:.\Include/arm_math.h ****    * Linear interpolation is a method of curve fitting using linear polynomials.
5458:.\Include/arm_math.h ****    * Linear interpolation works by effectively drawing a straight line between two neighboring samp
5459:.\Include/arm_math.h ****    *
5460:.\Include/arm_math.h ****    * \par
5461:.\Include/arm_math.h ****    * \image html LinearInterp.gif "Linear interpolation"
5462:.\Include/arm_math.h ****    *
5463:.\Include/arm_math.h ****    * \par
5464:.\Include/arm_math.h ****    * A  Linear Interpolate function calculates an output value(y), for the input(x)
5465:.\Include/arm_math.h ****    * using linear interpolation of the input values x0, x1( nearest input values) and the output va
5466:.\Include/arm_math.h ****    *
5467:.\Include/arm_math.h ****    * \par Algorithm:
5468:.\Include/arm_math.h ****    * <pre>
5469:.\Include/arm_math.h ****    *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
5470:.\Include/arm_math.h ****    *       where x0, x1 are nearest values of input x
5471:.\Include/arm_math.h ****    *             y0, y1 are nearest values to output y
5472:.\Include/arm_math.h ****    * </pre>
5473:.\Include/arm_math.h ****    *
5474:.\Include/arm_math.h ****    * \par
5475:.\Include/arm_math.h ****    * This set of functions implements Linear interpolation process
5476:.\Include/arm_math.h ****    * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
5477:.\Include/arm_math.h ****    * sample of data and each call to the function returns a single processed value.
5478:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the Linear Interpolate function data structure.
5479:.\Include/arm_math.h ****    * <code>x</code> is the input sample value. The functions returns the output value.
5480:.\Include/arm_math.h ****    *
5481:.\Include/arm_math.h ****    * \par
5482:.\Include/arm_math.h ****    * if x is outside of the table boundary, Linear interpolation returns first value of the table
5483:.\Include/arm_math.h ****    * if x is below input range and returns last value of table if x is above range.
5484:.\Include/arm_math.h ****    */
5485:.\Include/arm_math.h **** 
5486:.\Include/arm_math.h ****   /**
5487:.\Include/arm_math.h ****    * @addtogroup LinearInterpolate
5488:.\Include/arm_math.h ****    * @{
5489:.\Include/arm_math.h ****    */
5490:.\Include/arm_math.h **** 
5491:.\Include/arm_math.h ****   /**
5492:.\Include/arm_math.h ****    * @brief  Process function for the floating-point Linear Interpolation Function.
5493:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
5494:.\Include/arm_math.h ****    * @param[in]     x  input sample to process
5495:.\Include/arm_math.h ****    * @return y processed output sample.
5496:.\Include/arm_math.h ****    *
5497:.\Include/arm_math.h ****    */
5498:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_linear_interp_f32(
5499:.\Include/arm_math.h ****   arm_linear_interp_instance_f32 * S,
5500:.\Include/arm_math.h ****   float32_t x)
5501:.\Include/arm_math.h ****   {
5502:.\Include/arm_math.h ****     float32_t y;
5503:.\Include/arm_math.h ****     float32_t x0, x1;                            /* Nearest input values */
5504:.\Include/arm_math.h ****     float32_t y0, y1;                            /* Nearest output values */
5505:.\Include/arm_math.h ****     float32_t xSpacing = S->xSpacing;            /* spacing between input values */
5506:.\Include/arm_math.h ****     int32_t i;                                   /* Index variable */
5507:.\Include/arm_math.h ****     float32_t *pYData = S->pYData;               /* pointer to output table */
5508:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 106


5509:.\Include/arm_math.h ****     /* Calculation of index */
5510:.\Include/arm_math.h ****     i = (int32_t) ((x - S->x1) / xSpacing);
5511:.\Include/arm_math.h **** 
5512:.\Include/arm_math.h ****     if (i < 0)
5513:.\Include/arm_math.h ****     {
5514:.\Include/arm_math.h ****       /* Iniatilize output for below specified range as least output value of table */
5515:.\Include/arm_math.h ****       y = pYData[0];
5516:.\Include/arm_math.h ****     }
5517:.\Include/arm_math.h ****     else if ((uint32_t)i >= S->nValues)
5518:.\Include/arm_math.h ****     {
5519:.\Include/arm_math.h ****       /* Iniatilize output for above specified range as last output value of table */
5520:.\Include/arm_math.h ****       y = pYData[S->nValues - 1];
5521:.\Include/arm_math.h ****     }
5522:.\Include/arm_math.h ****     else
5523:.\Include/arm_math.h ****     {
5524:.\Include/arm_math.h ****       /* Calculation of nearest input values */
5525:.\Include/arm_math.h ****       x0 = S->x1 +  i      * xSpacing;
5526:.\Include/arm_math.h ****       x1 = S->x1 + (i + 1) * xSpacing;
5527:.\Include/arm_math.h **** 
5528:.\Include/arm_math.h ****       /* Read of nearest output values */
5529:.\Include/arm_math.h ****       y0 = pYData[i];
5530:.\Include/arm_math.h ****       y1 = pYData[i + 1];
5531:.\Include/arm_math.h **** 
5532:.\Include/arm_math.h ****       /* Calculation of output */
5533:.\Include/arm_math.h ****       y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
5534:.\Include/arm_math.h **** 
5535:.\Include/arm_math.h ****     }
5536:.\Include/arm_math.h **** 
5537:.\Include/arm_math.h ****     /* returns output value */
5538:.\Include/arm_math.h ****     return (y);
5539:.\Include/arm_math.h ****   }
5540:.\Include/arm_math.h **** 
5541:.\Include/arm_math.h **** 
5542:.\Include/arm_math.h ****    /**
5543:.\Include/arm_math.h ****    *
5544:.\Include/arm_math.h ****    * @brief  Process function for the Q31 Linear Interpolation Function.
5545:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q31 Linear Interpolation table
5546:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5547:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5548:.\Include/arm_math.h ****    * @return y processed output sample.
5549:.\Include/arm_math.h ****    *
5550:.\Include/arm_math.h ****    * \par
5551:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5552:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5553:.\Include/arm_math.h ****    *
5554:.\Include/arm_math.h ****    */
5555:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_linear_interp_q31(
5556:.\Include/arm_math.h ****   q31_t * pYData,
5557:.\Include/arm_math.h ****   q31_t x,
5558:.\Include/arm_math.h ****   uint32_t nValues)
5559:.\Include/arm_math.h ****   {
5560:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5561:.\Include/arm_math.h ****     q31_t y0, y1;                                /* Nearest output values */
5562:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5563:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5564:.\Include/arm_math.h **** 
5565:.\Include/arm_math.h ****     /* Input is in 12.20 format */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 107


5566:.\Include/arm_math.h ****     /* 12 bits for the table index */
5567:.\Include/arm_math.h ****     /* Index value calculation */
5568:.\Include/arm_math.h ****     index = ((x & (q31_t)0xFFF00000) >> 20);
5569:.\Include/arm_math.h **** 
5570:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5571:.\Include/arm_math.h ****     {
5572:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5573:.\Include/arm_math.h ****     }
5574:.\Include/arm_math.h ****     else if (index < 0)
5575:.\Include/arm_math.h ****     {
5576:.\Include/arm_math.h ****       return (pYData[0]);
5577:.\Include/arm_math.h ****     }
5578:.\Include/arm_math.h ****     else
5579:.\Include/arm_math.h ****     {
5580:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5581:.\Include/arm_math.h ****       /* shift left by 11 to keep fract in 1.31 format */
5582:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF) << 11;
5583:.\Include/arm_math.h **** 
5584:.\Include/arm_math.h ****       /* Read two nearest output values from the index in 1.31(q31) format */
5585:.\Include/arm_math.h ****       y0 = pYData[index];
5586:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5587:.\Include/arm_math.h **** 
5588:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 2.30 format */
5589:.\Include/arm_math.h ****       y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
5590:.\Include/arm_math.h **** 
5591:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
5592:.\Include/arm_math.h ****       y += ((q31_t) (((q63_t) y1 * fract) >> 32));
5593:.\Include/arm_math.h **** 
5594:.\Include/arm_math.h ****       /* Convert y to 1.31 format */
5595:.\Include/arm_math.h ****       return (y << 1u);
5596:.\Include/arm_math.h ****     }
5597:.\Include/arm_math.h ****   }
5598:.\Include/arm_math.h **** 
5599:.\Include/arm_math.h **** 
5600:.\Include/arm_math.h ****   /**
5601:.\Include/arm_math.h ****    *
5602:.\Include/arm_math.h ****    * @brief  Process function for the Q15 Linear Interpolation Function.
5603:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q15 Linear Interpolation table
5604:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5605:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5606:.\Include/arm_math.h ****    * @return y processed output sample.
5607:.\Include/arm_math.h ****    *
5608:.\Include/arm_math.h ****    * \par
5609:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5610:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5611:.\Include/arm_math.h ****    *
5612:.\Include/arm_math.h ****    */
5613:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_linear_interp_q15(
5614:.\Include/arm_math.h ****   q15_t * pYData,
5615:.\Include/arm_math.h ****   q31_t x,
5616:.\Include/arm_math.h ****   uint32_t nValues)
5617:.\Include/arm_math.h ****   {
5618:.\Include/arm_math.h ****     q63_t y;                                     /* output */
5619:.\Include/arm_math.h ****     q15_t y0, y1;                                /* Nearest output values */
5620:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5621:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5622:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 108


5623:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5624:.\Include/arm_math.h ****     /* 12 bits for the table index */
5625:.\Include/arm_math.h ****     /* Index value calculation */
5626:.\Include/arm_math.h ****     index = ((x & (int32_t)0xFFF00000) >> 20);
5627:.\Include/arm_math.h **** 
5628:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5629:.\Include/arm_math.h ****     {
5630:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5631:.\Include/arm_math.h ****     }
5632:.\Include/arm_math.h ****     else if (index < 0)
5633:.\Include/arm_math.h ****     {
5634:.\Include/arm_math.h ****       return (pYData[0]);
5635:.\Include/arm_math.h ****     }
5636:.\Include/arm_math.h ****     else
5637:.\Include/arm_math.h ****     {
5638:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5639:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5640:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5641:.\Include/arm_math.h **** 
5642:.\Include/arm_math.h ****       /* Read two nearest output values from the index */
5643:.\Include/arm_math.h ****       y0 = pYData[index];
5644:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5645:.\Include/arm_math.h **** 
5646:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 13.35 format */
5647:.\Include/arm_math.h ****       y = ((q63_t) y0 * (0xFFFFF - fract));
5648:.\Include/arm_math.h **** 
5649:.\Include/arm_math.h ****       /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
5650:.\Include/arm_math.h ****       y += ((q63_t) y1 * (fract));
5651:.\Include/arm_math.h **** 
5652:.\Include/arm_math.h ****       /* convert y to 1.15 format */
5653:.\Include/arm_math.h ****       return (q15_t) (y >> 20);
5654:.\Include/arm_math.h ****     }
5655:.\Include/arm_math.h ****   }
5656:.\Include/arm_math.h **** 
5657:.\Include/arm_math.h **** 
5658:.\Include/arm_math.h ****   /**
5659:.\Include/arm_math.h ****    *
5660:.\Include/arm_math.h ****    * @brief  Process function for the Q7 Linear Interpolation Function.
5661:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q7 Linear Interpolation table
5662:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5663:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5664:.\Include/arm_math.h ****    * @return y processed output sample.
5665:.\Include/arm_math.h ****    *
5666:.\Include/arm_math.h ****    * \par
5667:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5668:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5669:.\Include/arm_math.h ****    */
5670:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t arm_linear_interp_q7(
5671:.\Include/arm_math.h ****   q7_t * pYData,
5672:.\Include/arm_math.h ****   q31_t x,
5673:.\Include/arm_math.h ****   uint32_t nValues)
5674:.\Include/arm_math.h ****   {
5675:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5676:.\Include/arm_math.h ****     q7_t y0, y1;                                 /* Nearest output values */
5677:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5678:.\Include/arm_math.h ****     uint32_t index;                              /* Index to read nearest output values */
5679:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 109


5680:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5681:.\Include/arm_math.h ****     /* 12 bits for the table index */
5682:.\Include/arm_math.h ****     /* Index value calculation */
5683:.\Include/arm_math.h ****     if (x < 0)
5684:.\Include/arm_math.h ****     {
5685:.\Include/arm_math.h ****       return (pYData[0]);
5686:.\Include/arm_math.h ****     }
5687:.\Include/arm_math.h ****     index = (x >> 20) & 0xfff;
5688:.\Include/arm_math.h **** 
5689:.\Include/arm_math.h ****     if (index >= (nValues - 1))
5690:.\Include/arm_math.h ****     {
5691:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5692:.\Include/arm_math.h ****     }
5693:.\Include/arm_math.h ****     else
5694:.\Include/arm_math.h ****     {
5695:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5696:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5697:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5698:.\Include/arm_math.h **** 
5699:.\Include/arm_math.h ****       /* Read two nearest output values from the index and are in 1.7(q7) format */
5700:.\Include/arm_math.h ****       y0 = pYData[index];
5701:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5702:.\Include/arm_math.h **** 
5703:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
5704:.\Include/arm_math.h ****       y = ((y0 * (0xFFFFF - fract)));
5705:.\Include/arm_math.h **** 
5706:.\Include/arm_math.h ****       /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
5707:.\Include/arm_math.h ****       y += (y1 * fract);
5708:.\Include/arm_math.h **** 
5709:.\Include/arm_math.h ****       /* convert y to 1.7(q7) format */
5710:.\Include/arm_math.h ****       return (q7_t) (y >> 20);
5711:.\Include/arm_math.h ****      }
5712:.\Include/arm_math.h ****   }
5713:.\Include/arm_math.h **** 
5714:.\Include/arm_math.h ****   /**
5715:.\Include/arm_math.h ****    * @} end of LinearInterpolate group
5716:.\Include/arm_math.h ****    */
5717:.\Include/arm_math.h **** 
5718:.\Include/arm_math.h ****   /**
5719:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for floating-point data.
5720:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5721:.\Include/arm_math.h ****    * @return  sin(x).
5722:.\Include/arm_math.h ****    */
5723:.\Include/arm_math.h ****   float32_t arm_sin_f32(
5724:.\Include/arm_math.h ****   float32_t x);
5725:.\Include/arm_math.h **** 
5726:.\Include/arm_math.h **** 
5727:.\Include/arm_math.h ****   /**
5728:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q31 data.
5729:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5730:.\Include/arm_math.h ****    * @return  sin(x).
5731:.\Include/arm_math.h ****    */
5732:.\Include/arm_math.h ****   q31_t arm_sin_q31(
5733:.\Include/arm_math.h ****   q31_t x);
5734:.\Include/arm_math.h **** 
5735:.\Include/arm_math.h **** 
5736:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 110


5737:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q15 data.
5738:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5739:.\Include/arm_math.h ****    * @return  sin(x).
5740:.\Include/arm_math.h ****    */
5741:.\Include/arm_math.h ****   q15_t arm_sin_q15(
5742:.\Include/arm_math.h ****   q15_t x);
5743:.\Include/arm_math.h **** 
5744:.\Include/arm_math.h **** 
5745:.\Include/arm_math.h ****   /**
5746:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
5747:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5748:.\Include/arm_math.h ****    * @return  cos(x).
5749:.\Include/arm_math.h ****    */
5750:.\Include/arm_math.h ****   float32_t arm_cos_f32(
5751:.\Include/arm_math.h ****   float32_t x);
5752:.\Include/arm_math.h **** 
5753:.\Include/arm_math.h **** 
5754:.\Include/arm_math.h ****   /**
5755:.\Include/arm_math.h ****    * @brief Fast approximation to the trigonometric cosine function for Q31 data.
5756:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5757:.\Include/arm_math.h ****    * @return  cos(x).
5758:.\Include/arm_math.h ****    */
5759:.\Include/arm_math.h ****   q31_t arm_cos_q31(
5760:.\Include/arm_math.h ****   q31_t x);
5761:.\Include/arm_math.h **** 
5762:.\Include/arm_math.h **** 
5763:.\Include/arm_math.h ****   /**
5764:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
5765:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5766:.\Include/arm_math.h ****    * @return  cos(x).
5767:.\Include/arm_math.h ****    */
5768:.\Include/arm_math.h ****   q15_t arm_cos_q15(
5769:.\Include/arm_math.h ****   q15_t x);
5770:.\Include/arm_math.h **** 
5771:.\Include/arm_math.h **** 
5772:.\Include/arm_math.h ****   /**
5773:.\Include/arm_math.h ****    * @ingroup groupFastMath
5774:.\Include/arm_math.h ****    */
5775:.\Include/arm_math.h **** 
5776:.\Include/arm_math.h **** 
5777:.\Include/arm_math.h ****   /**
5778:.\Include/arm_math.h ****    * @defgroup SQRT Square Root
5779:.\Include/arm_math.h ****    *
5780:.\Include/arm_math.h ****    * Computes the square root of a number.
5781:.\Include/arm_math.h ****    * There are separate functions for Q15, Q31, and floating-point data types.
5782:.\Include/arm_math.h ****    * The square root function is computed using the Newton-Raphson algorithm.
5783:.\Include/arm_math.h ****    * This is an iterative algorithm of the form:
5784:.\Include/arm_math.h ****    * <pre>
5785:.\Include/arm_math.h ****    *      x1 = x0 - f(x0)/f'(x0)
5786:.\Include/arm_math.h ****    * </pre>
5787:.\Include/arm_math.h ****    * where <code>x1</code> is the current estimate,
5788:.\Include/arm_math.h ****    * <code>x0</code> is the previous estimate, and
5789:.\Include/arm_math.h ****    * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
5790:.\Include/arm_math.h ****    * For the square root function, the algorithm reduces to:
5791:.\Include/arm_math.h ****    * <pre>
5792:.\Include/arm_math.h ****    *     x0 = in/2                         [initial guess]
5793:.\Include/arm_math.h ****    *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 111


5794:.\Include/arm_math.h ****    * </pre>
5795:.\Include/arm_math.h ****    */
5796:.\Include/arm_math.h **** 
5797:.\Include/arm_math.h **** 
5798:.\Include/arm_math.h ****   /**
5799:.\Include/arm_math.h ****    * @addtogroup SQRT
5800:.\Include/arm_math.h ****    * @{
5801:.\Include/arm_math.h ****    */
5802:.\Include/arm_math.h **** 
5803:.\Include/arm_math.h ****   /**
5804:.\Include/arm_math.h ****    * @brief  Floating-point square root function.
5805:.\Include/arm_math.h ****    * @param[in]  in    input value.
5806:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5807:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5808:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5809:.\Include/arm_math.h ****    */
5810:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
5811:.\Include/arm_math.h ****   float32_t in,
5812:.\Include/arm_math.h ****   float32_t * pOut)
5813:.\Include/arm_math.h ****   {
5814:.\Include/arm_math.h ****     if (in >= 0.0f)
5815:.\Include/arm_math.h ****     {
5816:.\Include/arm_math.h **** 
5817:.\Include/arm_math.h **** #if   (__FPU_USED == 1) && defined ( __CC_ARM   )
5818:.\Include/arm_math.h ****       *pOut = __sqrtf(in);
5819:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
5820:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5821:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined(__GNUC__)
5822:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5823:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
5824:.\Include/arm_math.h ****       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
5825:.\Include/arm_math.h **** #else
5826:.\Include/arm_math.h ****       *pOut = sqrtf(in);
5827:.\Include/arm_math.h **** #endif
5828:.\Include/arm_math.h **** 
5829:.\Include/arm_math.h ****       return (ARM_MATH_SUCCESS);
5830:.\Include/arm_math.h ****     }
5831:.\Include/arm_math.h ****     else
5832:.\Include/arm_math.h ****     {
5833:.\Include/arm_math.h ****       *pOut = 0.0f;
5834:.\Include/arm_math.h ****       return (ARM_MATH_ARGUMENT_ERROR);
5835:.\Include/arm_math.h ****     }
5836:.\Include/arm_math.h ****   }
5837:.\Include/arm_math.h **** 
5838:.\Include/arm_math.h **** 
5839:.\Include/arm_math.h ****   /**
5840:.\Include/arm_math.h ****    * @brief Q31 square root function.
5841:.\Include/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFF
5842:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5843:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5844:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5845:.\Include/arm_math.h ****    */
5846:.\Include/arm_math.h ****   arm_status arm_sqrt_q31(
5847:.\Include/arm_math.h ****   q31_t in,
5848:.\Include/arm_math.h ****   q31_t * pOut);
5849:.\Include/arm_math.h **** 
5850:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 112


5851:.\Include/arm_math.h ****   /**
5852:.\Include/arm_math.h ****    * @brief  Q15 square root function.
5853:.\Include/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
5854:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5855:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5856:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5857:.\Include/arm_math.h ****    */
5858:.\Include/arm_math.h ****   arm_status arm_sqrt_q15(
5859:.\Include/arm_math.h ****   q15_t in,
5860:.\Include/arm_math.h ****   q15_t * pOut);
5861:.\Include/arm_math.h **** 
5862:.\Include/arm_math.h ****   /**
5863:.\Include/arm_math.h ****    * @} end of SQRT group
5864:.\Include/arm_math.h ****    */
5865:.\Include/arm_math.h **** 
5866:.\Include/arm_math.h **** 
5867:.\Include/arm_math.h ****   /**
5868:.\Include/arm_math.h ****    * @brief floating-point Circular write function.
5869:.\Include/arm_math.h ****    */
5870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_f32(
5871:.\Include/arm_math.h ****   int32_t * circBuffer,
5872:.\Include/arm_math.h ****   int32_t L,
5873:.\Include/arm_math.h ****   uint16_t * writeOffset,
5874:.\Include/arm_math.h ****   int32_t bufferInc,
5875:.\Include/arm_math.h ****   const int32_t * src,
5876:.\Include/arm_math.h ****   int32_t srcInc,
5877:.\Include/arm_math.h ****   uint32_t blockSize)
5878:.\Include/arm_math.h ****   {
5879:.\Include/arm_math.h ****     uint32_t i = 0u;
5880:.\Include/arm_math.h ****     int32_t wOffset;
5881:.\Include/arm_math.h **** 
5882:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5883:.\Include/arm_math.h ****      * to the current location where the input samples to be copied */
5884:.\Include/arm_math.h ****     wOffset = *writeOffset;
5885:.\Include/arm_math.h **** 
5886:.\Include/arm_math.h ****     /* Loop over the blockSize */
5887:.\Include/arm_math.h ****     i = blockSize;
5888:.\Include/arm_math.h **** 
5889:.\Include/arm_math.h ****     while (i > 0u)
5890:.\Include/arm_math.h ****     {
5891:.\Include/arm_math.h ****       /* copy the input sample to the circular buffer */
5892:.\Include/arm_math.h ****       circBuffer[wOffset] = *src;
5893:.\Include/arm_math.h **** 
5894:.\Include/arm_math.h ****       /* Update the input pointer */
5895:.\Include/arm_math.h ****       src += srcInc;
5896:.\Include/arm_math.h **** 
5897:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
5898:.\Include/arm_math.h ****       wOffset += bufferInc;
5899:.\Include/arm_math.h ****       if (wOffset >= L)
5900:.\Include/arm_math.h ****         wOffset -= L;
5901:.\Include/arm_math.h **** 
5902:.\Include/arm_math.h ****       /* Decrement the loop counter */
5903:.\Include/arm_math.h ****       i--;
5904:.\Include/arm_math.h ****     }
5905:.\Include/arm_math.h **** 
5906:.\Include/arm_math.h ****     /* Update the index pointer */
5907:.\Include/arm_math.h ****     *writeOffset = (uint16_t)wOffset;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 113


5908:.\Include/arm_math.h ****   }
5909:.\Include/arm_math.h **** 
5910:.\Include/arm_math.h **** 
5911:.\Include/arm_math.h **** 
5912:.\Include/arm_math.h ****   /**
5913:.\Include/arm_math.h ****    * @brief floating-point Circular Read function.
5914:.\Include/arm_math.h ****    */
5915:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularRead_f32(
5916:.\Include/arm_math.h ****   int32_t * circBuffer,
5917:.\Include/arm_math.h ****   int32_t L,
5918:.\Include/arm_math.h ****   int32_t * readOffset,
5919:.\Include/arm_math.h ****   int32_t bufferInc,
5920:.\Include/arm_math.h ****   int32_t * dst,
5921:.\Include/arm_math.h ****   int32_t * dst_base,
5922:.\Include/arm_math.h ****   int32_t dst_length,
5923:.\Include/arm_math.h ****   int32_t dstInc,
5924:.\Include/arm_math.h ****   uint32_t blockSize)
5925:.\Include/arm_math.h ****   {
5926:.\Include/arm_math.h ****     uint32_t i = 0u;
5927:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
5928:.\Include/arm_math.h **** 
5929:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5930:.\Include/arm_math.h ****      * to the current location from where the input samples to be read */
5931:.\Include/arm_math.h ****     rOffset = *readOffset;
5932:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
5933:.\Include/arm_math.h **** 
5934:.\Include/arm_math.h ****     /* Loop over the blockSize */
5935:.\Include/arm_math.h ****     i = blockSize;
5936:.\Include/arm_math.h **** 
5937:.\Include/arm_math.h ****     while (i > 0u)
5938:.\Include/arm_math.h ****     {
5939:.\Include/arm_math.h ****       /* copy the sample from the circular buffer to the destination buffer */
5940:.\Include/arm_math.h ****       *dst = circBuffer[rOffset];
5941:.\Include/arm_math.h **** 
5942:.\Include/arm_math.h ****       /* Update the input pointer */
5943:.\Include/arm_math.h ****       dst += dstInc;
5944:.\Include/arm_math.h **** 
5945:.\Include/arm_math.h ****       if (dst == (int32_t *) dst_end)
5946:.\Include/arm_math.h ****       {
5947:.\Include/arm_math.h ****         dst = dst_base;
5948:.\Include/arm_math.h ****       }
5949:.\Include/arm_math.h **** 
5950:.\Include/arm_math.h ****       /* Circularly update rOffset.  Watch out for positive and negative value  */
5951:.\Include/arm_math.h ****       rOffset += bufferInc;
5952:.\Include/arm_math.h **** 
5953:.\Include/arm_math.h ****       if (rOffset >= L)
5954:.\Include/arm_math.h ****       {
5955:.\Include/arm_math.h ****         rOffset -= L;
5956:.\Include/arm_math.h ****       }
5957:.\Include/arm_math.h **** 
5958:.\Include/arm_math.h ****       /* Decrement the loop counter */
5959:.\Include/arm_math.h ****       i--;
5960:.\Include/arm_math.h ****     }
5961:.\Include/arm_math.h **** 
5962:.\Include/arm_math.h ****     /* Update the index pointer */
5963:.\Include/arm_math.h ****     *readOffset = rOffset;
5964:.\Include/arm_math.h ****   }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 114


5965:.\Include/arm_math.h **** 
5966:.\Include/arm_math.h **** 
5967:.\Include/arm_math.h ****   /**
5968:.\Include/arm_math.h ****    * @brief Q15 Circular write function.
5969:.\Include/arm_math.h ****    */
5970:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_q15(
5971:.\Include/arm_math.h ****   q15_t * circBuffer,
5972:.\Include/arm_math.h ****   int32_t L,
5973:.\Include/arm_math.h ****   uint16_t * writeOffset,
5974:.\Include/arm_math.h ****   int32_t bufferInc,
5975:.\Include/arm_math.h ****   const q15_t * src,
5976:.\Include/arm_math.h ****   int32_t srcInc,
5977:.\Include/arm_math.h ****   uint32_t blockSize)
5978:.\Include/arm_math.h ****   {
5979:.\Include/arm_math.h ****     uint32_t i = 0u;
5980:.\Include/arm_math.h ****     int32_t wOffset;
5981:.\Include/arm_math.h **** 
5982:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5983:.\Include/arm_math.h ****      * to the current location where the input samples to be copied */
5984:.\Include/arm_math.h ****     wOffset = *writeOffset;
5985:.\Include/arm_math.h **** 
5986:.\Include/arm_math.h ****     /* Loop over the blockSize */
5987:.\Include/arm_math.h ****     i = blockSize;
5988:.\Include/arm_math.h **** 
5989:.\Include/arm_math.h ****     while (i > 0u)
5990:.\Include/arm_math.h ****     {
5991:.\Include/arm_math.h ****       /* copy the input sample to the circular buffer */
5992:.\Include/arm_math.h ****       circBuffer[wOffset] = *src;
5993:.\Include/arm_math.h **** 
5994:.\Include/arm_math.h ****       /* Update the input pointer */
5995:.\Include/arm_math.h ****       src += srcInc;
5996:.\Include/arm_math.h **** 
5997:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
5998:.\Include/arm_math.h ****       wOffset += bufferInc;
5999:.\Include/arm_math.h ****       if (wOffset >= L)
6000:.\Include/arm_math.h ****         wOffset -= L;
6001:.\Include/arm_math.h **** 
6002:.\Include/arm_math.h ****       /* Decrement the loop counter */
6003:.\Include/arm_math.h ****       i--;
6004:.\Include/arm_math.h ****     }
6005:.\Include/arm_math.h **** 
6006:.\Include/arm_math.h ****     /* Update the index pointer */
6007:.\Include/arm_math.h ****     *writeOffset = (uint16_t)wOffset;
6008:.\Include/arm_math.h ****   }
6009:.\Include/arm_math.h **** 
6010:.\Include/arm_math.h **** 
6011:.\Include/arm_math.h ****   /**
6012:.\Include/arm_math.h ****    * @brief Q15 Circular Read function.
6013:.\Include/arm_math.h ****    */
6014:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularRead_q15(
6015:.\Include/arm_math.h ****   q15_t * circBuffer,
6016:.\Include/arm_math.h ****   int32_t L,
6017:.\Include/arm_math.h ****   int32_t * readOffset,
6018:.\Include/arm_math.h ****   int32_t bufferInc,
6019:.\Include/arm_math.h ****   q15_t * dst,
6020:.\Include/arm_math.h ****   q15_t * dst_base,
6021:.\Include/arm_math.h ****   int32_t dst_length,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 115


6022:.\Include/arm_math.h ****   int32_t dstInc,
6023:.\Include/arm_math.h ****   uint32_t blockSize)
6024:.\Include/arm_math.h ****   {
6025:.\Include/arm_math.h ****     uint32_t i = 0;
6026:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
6027:.\Include/arm_math.h **** 
6028:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
6029:.\Include/arm_math.h ****      * to the current location from where the input samples to be read */
6030:.\Include/arm_math.h ****     rOffset = *readOffset;
6031:.\Include/arm_math.h **** 
6032:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
6033:.\Include/arm_math.h **** 
6034:.\Include/arm_math.h ****     /* Loop over the blockSize */
6035:.\Include/arm_math.h ****     i = blockSize;
6036:.\Include/arm_math.h **** 
6037:.\Include/arm_math.h ****     while (i > 0u)
6038:.\Include/arm_math.h ****     {
6039:.\Include/arm_math.h ****       /* copy the sample from the circular buffer to the destination buffer */
6040:.\Include/arm_math.h ****       *dst = circBuffer[rOffset];
6041:.\Include/arm_math.h **** 
6042:.\Include/arm_math.h ****       /* Update the input pointer */
6043:.\Include/arm_math.h ****       dst += dstInc;
6044:.\Include/arm_math.h **** 
6045:.\Include/arm_math.h ****       if (dst == (q15_t *) dst_end)
6046:.\Include/arm_math.h ****       {
6047:.\Include/arm_math.h ****         dst = dst_base;
6048:.\Include/arm_math.h ****       }
6049:.\Include/arm_math.h **** 
6050:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
6051:.\Include/arm_math.h ****       rOffset += bufferInc;
6052:.\Include/arm_math.h **** 
6053:.\Include/arm_math.h ****       if (rOffset >= L)
6054:.\Include/arm_math.h ****       {
6055:.\Include/arm_math.h ****         rOffset -= L;
6056:.\Include/arm_math.h ****       }
6057:.\Include/arm_math.h **** 
6058:.\Include/arm_math.h ****       /* Decrement the loop counter */
6059:.\Include/arm_math.h ****       i--;
6060:.\Include/arm_math.h ****     }
6061:.\Include/arm_math.h **** 
6062:.\Include/arm_math.h ****     /* Update the index pointer */
6063:.\Include/arm_math.h ****     *readOffset = rOffset;
6064:.\Include/arm_math.h ****   }
6065:.\Include/arm_math.h **** 
6066:.\Include/arm_math.h **** 
6067:.\Include/arm_math.h ****   /**
6068:.\Include/arm_math.h ****    * @brief Q7 Circular write function.
6069:.\Include/arm_math.h ****    */
6070:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_q7(
6071:.\Include/arm_math.h ****   q7_t * circBuffer,
6072:.\Include/arm_math.h ****   int32_t L,
6073:.\Include/arm_math.h ****   uint16_t * writeOffset,
6074:.\Include/arm_math.h ****   int32_t bufferInc,
6075:.\Include/arm_math.h ****   const q7_t * src,
6076:.\Include/arm_math.h ****   int32_t srcInc,
6077:.\Include/arm_math.h ****   uint32_t blockSize)
6078:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 116


6079:.\Include/arm_math.h ****     uint32_t i = 0u;
 158              		.loc 2 6079 0
 159 00de 0023     		mov	r3, #0
 160 00e0 C022     		mov	r2, #192
 161 00e2 BA18     		add	r2, r7, r2
 162 00e4 1360     		str	r3, [r2]
6080:.\Include/arm_math.h ****     int32_t wOffset;
6081:.\Include/arm_math.h **** 
6082:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
6083:.\Include/arm_math.h ****      * to the current location where the input samples to be copied */
6084:.\Include/arm_math.h ****     wOffset = *writeOffset;
 163              		.loc 2 6084 0
 164 00e6 D423     		mov	r3, #212
 165 00e8 FB18     		add	r3, r7, r3
 166 00ea 1B68     		ldr	r3, [r3]
 167 00ec 1B88     		ldrh	r3, [r3]
 168 00ee BC22     		mov	r2, #188
 169 00f0 BA18     		add	r2, r7, r2
 170 00f2 1360     		str	r3, [r2]
6085:.\Include/arm_math.h **** 
6086:.\Include/arm_math.h ****     /* Loop over the blockSize */
6087:.\Include/arm_math.h ****     i = blockSize;
 171              		.loc 2 6087 0
 172 00f4 C423     		mov	r3, #196
 173 00f6 FB18     		add	r3, r7, r3
 174 00f8 1B68     		ldr	r3, [r3]
 175 00fa C022     		mov	r2, #192
 176 00fc BA18     		add	r2, r7, r2
 177 00fe 1360     		str	r3, [r2]
 178 0100 38E0     		b	.L2
 179              	.L4:
6088:.\Include/arm_math.h **** 
6089:.\Include/arm_math.h ****     while (i > 0u)
6090:.\Include/arm_math.h ****     {
6091:.\Include/arm_math.h ****       /* copy the input sample to the circular buffer */
6092:.\Include/arm_math.h ****       circBuffer[wOffset] = *src;
 180              		.loc 2 6092 0
 181 0102 BC23     		mov	r3, #188
 182 0104 FB18     		add	r3, r7, r3
 183 0106 1B68     		ldr	r3, [r3]
 184 0108 DC22     		mov	r2, #220
 185 010a BA18     		add	r2, r7, r2
 186 010c 1268     		ldr	r2, [r2]
 187 010e D318     		add	r3, r2, r3
 188 0110 CC22     		mov	r2, #204
 189 0112 BA18     		add	r2, r7, r2
 190 0114 1268     		ldr	r2, [r2]
 191 0116 1278     		ldrb	r2, [r2]
 192 0118 1A70     		strb	r2, [r3]
6093:.\Include/arm_math.h **** 
6094:.\Include/arm_math.h ****       /* Update the input pointer */
6095:.\Include/arm_math.h ****       src += srcInc;
 193              		.loc 2 6095 0
 194 011a C823     		mov	r3, #200
 195 011c FB18     		add	r3, r7, r3
 196 011e 1B68     		ldr	r3, [r3]
 197 0120 CC22     		mov	r2, #204
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 117


 198 0122 BA18     		add	r2, r7, r2
 199 0124 1268     		ldr	r2, [r2]
 200 0126 D318     		add	r3, r2, r3
 201 0128 CC22     		mov	r2, #204
 202 012a BA18     		add	r2, r7, r2
 203 012c 1360     		str	r3, [r2]
6096:.\Include/arm_math.h **** 
6097:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
6098:.\Include/arm_math.h ****       wOffset += bufferInc;
 204              		.loc 2 6098 0
 205 012e BC23     		mov	r3, #188
 206 0130 FB18     		add	r3, r7, r3
 207 0132 1A68     		ldr	r2, [r3]
 208 0134 D023     		mov	r3, #208
 209 0136 FB18     		add	r3, r7, r3
 210 0138 1B68     		ldr	r3, [r3]
 211 013a D318     		add	r3, r2, r3
 212 013c BC22     		mov	r2, #188
 213 013e BA18     		add	r2, r7, r2
 214 0140 1360     		str	r3, [r2]
6099:.\Include/arm_math.h ****       if (wOffset >= L)
 215              		.loc 2 6099 0
 216 0142 D823     		mov	r3, #216
 217 0144 FB18     		add	r3, r7, r3
 218 0146 1A68     		ldr	r2, [r3]
 219 0148 BC23     		mov	r3, #188
 220 014a FB18     		add	r3, r7, r3
 221 014c 1B68     		ldr	r3, [r3]
 222 014e 9A42     		cmp	r2, r3
 223 0150 09DC     		bgt	.L3
6100:.\Include/arm_math.h ****         wOffset -= L;
 224              		.loc 2 6100 0
 225 0152 BC23     		mov	r3, #188
 226 0154 FB18     		add	r3, r7, r3
 227 0156 1A68     		ldr	r2, [r3]
 228 0158 D823     		mov	r3, #216
 229 015a FB18     		add	r3, r7, r3
 230 015c 1B68     		ldr	r3, [r3]
 231 015e D31A     		sub	r3, r2, r3
 232 0160 BC22     		mov	r2, #188
 233 0162 BA18     		add	r2, r7, r2
 234 0164 1360     		str	r3, [r2]
 235              	.L3:
6101:.\Include/arm_math.h **** 
6102:.\Include/arm_math.h ****       /* Decrement the loop counter */
6103:.\Include/arm_math.h ****       i--;
 236              		.loc 2 6103 0
 237 0166 C023     		mov	r3, #192
 238 0168 FB18     		add	r3, r7, r3
 239 016a 1B68     		ldr	r3, [r3]
 240 016c 013B     		sub	r3, r3, #1
 241 016e C022     		mov	r2, #192
 242 0170 BA18     		add	r2, r7, r2
 243 0172 1360     		str	r3, [r2]
 244              	.L2:
6089:.\Include/arm_math.h ****     {
 245              		.loc 2 6089 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 118


 246 0174 C023     		mov	r3, #192
 247 0176 FB18     		add	r3, r7, r3
 248 0178 1B68     		ldr	r3, [r3]
 249 017a 002B     		cmp	r3, #0
 250 017c C1D1     		bne	.L4
6104:.\Include/arm_math.h ****     }
6105:.\Include/arm_math.h **** 
6106:.\Include/arm_math.h ****     /* Update the index pointer */
6107:.\Include/arm_math.h ****     *writeOffset = (uint16_t)wOffset;
 251              		.loc 2 6107 0
 252 017e BC23     		mov	r3, #188
 253 0180 FB18     		add	r3, r7, r3
 254 0182 1B68     		ldr	r3, [r3]
 255 0184 9AB2     		uxth	r2, r3
 256 0186 D423     		mov	r3, #212
 257 0188 FB18     		add	r3, r7, r3
 258 018a 1B68     		ldr	r3, [r3]
 259 018c 1A80     		strh	r2, [r3]
 260              	.LBE13:
 261              	.LBE12:
 321:Source\FilteringFunctions/arm_fir_sparse_q7.c ****                        blockSize);
 322:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 323:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the number of taps. */
 324:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   tapCnt = numTaps;
 262              		.loc 1 324 0
 263 018e E623     		mov	r3, #230
 264 0190 FB18     		add	r3, r7, r3
 265 0192 1B88     		ldrh	r3, [r3]
 266 0194 7A1D     		add	r2, r7, #5
 267 0196 FF32     		add	r2, r2, #255
 268 0198 1360     		str	r3, [r2]
 325:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 326:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 327:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 269              		.loc 1 327 0
 270 019a FB68     		ldr	r3, [r7, #12]
 271 019c 5B88     		ldrh	r3, [r3, #2]
 272 019e 1A1C     		mov	r2, r3
 273 01a0 9223     		mov	r3, #146
 274 01a2 5B00     		lsl	r3, r3, #1
 275 01a4 FB18     		add	r3, r7, r3
 276 01a6 1B68     		ldr	r3, [r3]
 277 01a8 D21A     		sub	r2, r2, r3
 278 01aa 8423     		mov	r3, #132
 279 01ac 5B00     		lsl	r3, r3, #1
 280 01ae FB18     		add	r3, r7, r3
 281 01b0 1B68     		ldr	r3, [r3]
 282 01b2 191D     		add	r1, r3, #4
 283 01b4 8420     		mov	r0, #132
 284 01b6 4000     		lsl	r0, r0, #1
 285 01b8 3818     		add	r0, r7, r0
 286 01ba 0160     		str	r1, [r0]
 287 01bc 1B68     		ldr	r3, [r3]
 288 01be D31A     		sub	r3, r2, r3
 289 01c0 7B61     		str	r3, [r7, #20]
 328:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 329:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Wraparound of readIndex */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 119


 330:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   if (readIndex < 0)
 290              		.loc 1 330 0
 291 01c2 7B69     		ldr	r3, [r7, #20]
 292 01c4 002B     		cmp	r3, #0
 293 01c6 05DA     		bge	.L5
 331:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 332:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     readIndex += (int32_t) delaySize;
 294              		.loc 1 332 0
 295 01c8 7A69     		ldr	r2, [r7, #20]
 296 01ca E823     		mov	r3, #232
 297 01cc FB18     		add	r3, r7, r3
 298 01ce 1B68     		ldr	r3, [r3]
 299 01d0 D318     		add	r3, r2, r3
 300 01d2 7B61     		str	r3, [r7, #20]
 301              	.L5:
 333:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 334:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 335:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Working pointer for state buffer is updated */
 336:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   py = pState;
 302              		.loc 1 336 0
 303 01d4 F423     		mov	r3, #244
 304 01d6 FB18     		add	r3, r7, r3
 305 01d8 1B68     		ldr	r3, [r3]
 306 01da F022     		mov	r2, #240
 307 01dc BA18     		add	r2, r7, r2
 308 01de 1360     		str	r3, [r2]
 337:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 338:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* blockSize samples are read from the state buffer */
 339:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
 309              		.loc 1 339 0
 310 01e0 E823     		mov	r3, #232
 311 01e2 FB18     		add	r3, r7, r3
 312 01e4 1A68     		ldr	r2, [r3]
 313 01e6 9223     		mov	r3, #146
 314 01e8 5B00     		lsl	r3, r3, #1
 315 01ea FB18     		add	r3, r7, r3
 316 01ec 1B68     		ldr	r3, [r3]
 317 01ee F021     		mov	r1, #240
 318 01f0 7918     		add	r1, r7, r1
 319 01f2 0968     		ldr	r1, [r1]
 320 01f4 B820     		mov	r0, #184
 321 01f6 3818     		add	r0, r7, r0
 322 01f8 0160     		str	r1, [r0]
 323 01fa B421     		mov	r1, #180
 324 01fc 7918     		add	r1, r7, r1
 325 01fe 0A60     		str	r2, [r1]
 326 0200 1422     		mov	r2, #20
 327 0202 BA18     		add	r2, r7, r2
 328 0204 B021     		mov	r1, #176
 329 0206 7918     		add	r1, r7, r1
 330 0208 0A60     		str	r2, [r1]
 331 020a 0122     		mov	r2, #1
 332 020c AC21     		mov	r1, #172
 333 020e 7918     		add	r1, r7, r1
 334 0210 0A60     		str	r2, [r1]
 335 0212 EC22     		mov	r2, #236
 336 0214 BA18     		add	r2, r7, r2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 120


 337 0216 1268     		ldr	r2, [r2]
 338 0218 A821     		mov	r1, #168
 339 021a 7918     		add	r1, r7, r1
 340 021c 0A60     		str	r2, [r1]
 341 021e EC22     		mov	r2, #236
 342 0220 BA18     		add	r2, r7, r2
 343 0222 1268     		ldr	r2, [r2]
 344 0224 A421     		mov	r1, #164
 345 0226 7918     		add	r1, r7, r1
 346 0228 0A60     		str	r2, [r1]
 347 022a A022     		mov	r2, #160
 348 022c BA18     		add	r2, r7, r2
 349 022e 1360     		str	r3, [r2]
 350 0230 0123     		mov	r3, #1
 351 0232 9C22     		mov	r2, #156
 352 0234 BA18     		add	r2, r7, r2
 353 0236 1360     		str	r3, [r2]
 354 0238 9223     		mov	r3, #146
 355 023a 5B00     		lsl	r3, r3, #1
 356 023c FB18     		add	r3, r7, r3
 357 023e 1B68     		ldr	r3, [r3]
 358 0240 9822     		mov	r2, #152
 359 0242 BA18     		add	r2, r7, r2
 360 0244 1360     		str	r3, [r2]
 361              	.LBB14:
 362              	.LBB15:
6108:.\Include/arm_math.h ****   }
6109:.\Include/arm_math.h **** 
6110:.\Include/arm_math.h **** 
6111:.\Include/arm_math.h ****   /**
6112:.\Include/arm_math.h ****    * @brief Q7 Circular Read function.
6113:.\Include/arm_math.h ****    */
6114:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularRead_q7(
6115:.\Include/arm_math.h ****   q7_t * circBuffer,
6116:.\Include/arm_math.h ****   int32_t L,
6117:.\Include/arm_math.h ****   int32_t * readOffset,
6118:.\Include/arm_math.h ****   int32_t bufferInc,
6119:.\Include/arm_math.h ****   q7_t * dst,
6120:.\Include/arm_math.h ****   q7_t * dst_base,
6121:.\Include/arm_math.h ****   int32_t dst_length,
6122:.\Include/arm_math.h ****   int32_t dstInc,
6123:.\Include/arm_math.h ****   uint32_t blockSize)
6124:.\Include/arm_math.h ****   {
6125:.\Include/arm_math.h ****     uint32_t i = 0;
 363              		.loc 2 6125 0
 364 0246 0023     		mov	r3, #0
 365 0248 9422     		mov	r2, #148
 366 024a BA18     		add	r2, r7, r2
 367 024c 1360     		str	r3, [r2]
6126:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
6127:.\Include/arm_math.h **** 
6128:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
6129:.\Include/arm_math.h ****      * to the current location from where the input samples to be read */
6130:.\Include/arm_math.h ****     rOffset = *readOffset;
 368              		.loc 2 6130 0
 369 024e B023     		mov	r3, #176
 370 0250 FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 121


 371 0252 1B68     		ldr	r3, [r3]
 372 0254 1B68     		ldr	r3, [r3]
 373 0256 9022     		mov	r2, #144
 374 0258 BA18     		add	r2, r7, r2
 375 025a 1360     		str	r3, [r2]
6131:.\Include/arm_math.h **** 
6132:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
 376              		.loc 2 6132 0
 377 025c A023     		mov	r3, #160
 378 025e FB18     		add	r3, r7, r3
 379 0260 1B68     		ldr	r3, [r3]
 380 0262 A422     		mov	r2, #164
 381 0264 BA18     		add	r2, r7, r2
 382 0266 1268     		ldr	r2, [r2]
 383 0268 D318     		add	r3, r2, r3
 384 026a 8C22     		mov	r2, #140
 385 026c BA18     		add	r2, r7, r2
 386 026e 1360     		str	r3, [r2]
6133:.\Include/arm_math.h **** 
6134:.\Include/arm_math.h ****     /* Loop over the blockSize */
6135:.\Include/arm_math.h ****     i = blockSize;
 387              		.loc 2 6135 0
 388 0270 9823     		mov	r3, #152
 389 0272 FB18     		add	r3, r7, r3
 390 0274 1B68     		ldr	r3, [r3]
 391 0276 9422     		mov	r2, #148
 392 0278 BA18     		add	r2, r7, r2
 393 027a 1360     		str	r3, [r2]
 394 027c 46E0     		b	.L6
 395              	.L9:
6136:.\Include/arm_math.h **** 
6137:.\Include/arm_math.h ****     while (i > 0u)
6138:.\Include/arm_math.h ****     {
6139:.\Include/arm_math.h ****       /* copy the sample from the circular buffer to the destination buffer */
6140:.\Include/arm_math.h ****       *dst = circBuffer[rOffset];
 396              		.loc 2 6140 0
 397 027e 9023     		mov	r3, #144
 398 0280 FB18     		add	r3, r7, r3
 399 0282 1B68     		ldr	r3, [r3]
 400 0284 B822     		mov	r2, #184
 401 0286 BA18     		add	r2, r7, r2
 402 0288 1268     		ldr	r2, [r2]
 403 028a D318     		add	r3, r2, r3
 404 028c 1A78     		ldrb	r2, [r3]
 405 028e A823     		mov	r3, #168
 406 0290 FB18     		add	r3, r7, r3
 407 0292 1B68     		ldr	r3, [r3]
 408 0294 1A70     		strb	r2, [r3]
6141:.\Include/arm_math.h **** 
6142:.\Include/arm_math.h ****       /* Update the input pointer */
6143:.\Include/arm_math.h ****       dst += dstInc;
 409              		.loc 2 6143 0
 410 0296 9C23     		mov	r3, #156
 411 0298 FB18     		add	r3, r7, r3
 412 029a 1B68     		ldr	r3, [r3]
 413 029c A822     		mov	r2, #168
 414 029e BA18     		add	r2, r7, r2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 122


 415 02a0 1268     		ldr	r2, [r2]
 416 02a2 D318     		add	r3, r2, r3
 417 02a4 A822     		mov	r2, #168
 418 02a6 BA18     		add	r2, r7, r2
 419 02a8 1360     		str	r3, [r2]
6144:.\Include/arm_math.h **** 
6145:.\Include/arm_math.h ****       if (dst == (q7_t *) dst_end)
 420              		.loc 2 6145 0
 421 02aa 8C23     		mov	r3, #140
 422 02ac FB18     		add	r3, r7, r3
 423 02ae 1B68     		ldr	r3, [r3]
 424 02b0 A822     		mov	r2, #168
 425 02b2 BA18     		add	r2, r7, r2
 426 02b4 1268     		ldr	r2, [r2]
 427 02b6 9A42     		cmp	r2, r3
 428 02b8 05D1     		bne	.L7
6146:.\Include/arm_math.h ****       {
6147:.\Include/arm_math.h ****         dst = dst_base;
 429              		.loc 2 6147 0
 430 02ba A423     		mov	r3, #164
 431 02bc FB18     		add	r3, r7, r3
 432 02be 1B68     		ldr	r3, [r3]
 433 02c0 A822     		mov	r2, #168
 434 02c2 BA18     		add	r2, r7, r2
 435 02c4 1360     		str	r3, [r2]
 436              	.L7:
6148:.\Include/arm_math.h ****       }
6149:.\Include/arm_math.h **** 
6150:.\Include/arm_math.h ****       /* Circularly update rOffset.  Watch out for positive and negative value */
6151:.\Include/arm_math.h ****       rOffset += bufferInc;
 437              		.loc 2 6151 0
 438 02c6 9023     		mov	r3, #144
 439 02c8 FB18     		add	r3, r7, r3
 440 02ca 1A68     		ldr	r2, [r3]
 441 02cc AC23     		mov	r3, #172
 442 02ce FB18     		add	r3, r7, r3
 443 02d0 1B68     		ldr	r3, [r3]
 444 02d2 D318     		add	r3, r2, r3
 445 02d4 9022     		mov	r2, #144
 446 02d6 BA18     		add	r2, r7, r2
 447 02d8 1360     		str	r3, [r2]
6152:.\Include/arm_math.h **** 
6153:.\Include/arm_math.h ****       if (rOffset >= L)
 448              		.loc 2 6153 0
 449 02da B423     		mov	r3, #180
 450 02dc FB18     		add	r3, r7, r3
 451 02de 1A68     		ldr	r2, [r3]
 452 02e0 9023     		mov	r3, #144
 453 02e2 FB18     		add	r3, r7, r3
 454 02e4 1B68     		ldr	r3, [r3]
 455 02e6 9A42     		cmp	r2, r3
 456 02e8 09DC     		bgt	.L8
6154:.\Include/arm_math.h ****       {
6155:.\Include/arm_math.h ****         rOffset -= L;
 457              		.loc 2 6155 0
 458 02ea 9023     		mov	r3, #144
 459 02ec FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 123


 460 02ee 1A68     		ldr	r2, [r3]
 461 02f0 B423     		mov	r3, #180
 462 02f2 FB18     		add	r3, r7, r3
 463 02f4 1B68     		ldr	r3, [r3]
 464 02f6 D31A     		sub	r3, r2, r3
 465 02f8 9022     		mov	r2, #144
 466 02fa BA18     		add	r2, r7, r2
 467 02fc 1360     		str	r3, [r2]
 468              	.L8:
6156:.\Include/arm_math.h ****       }
6157:.\Include/arm_math.h **** 
6158:.\Include/arm_math.h ****       /* Decrement the loop counter */
6159:.\Include/arm_math.h ****       i--;
 469              		.loc 2 6159 0
 470 02fe 9423     		mov	r3, #148
 471 0300 FB18     		add	r3, r7, r3
 472 0302 1B68     		ldr	r3, [r3]
 473 0304 013B     		sub	r3, r3, #1
 474 0306 9422     		mov	r2, #148
 475 0308 BA18     		add	r2, r7, r2
 476 030a 1360     		str	r3, [r2]
 477              	.L6:
6137:.\Include/arm_math.h ****     {
 478              		.loc 2 6137 0
 479 030c 9423     		mov	r3, #148
 480 030e FB18     		add	r3, r7, r3
 481 0310 1B68     		ldr	r3, [r3]
 482 0312 002B     		cmp	r3, #0
 483 0314 B3D1     		bne	.L9
6160:.\Include/arm_math.h ****     }
6161:.\Include/arm_math.h **** 
6162:.\Include/arm_math.h ****     /* Update the index pointer */
6163:.\Include/arm_math.h ****     *readOffset = rOffset;
 484              		.loc 2 6163 0
 485 0316 B023     		mov	r3, #176
 486 0318 FB18     		add	r3, r7, r3
 487 031a 1B68     		ldr	r3, [r3]
 488 031c 9022     		mov	r2, #144
 489 031e BA18     		add	r2, r7, r2
 490 0320 1268     		ldr	r2, [r2]
 491 0322 1A60     		str	r2, [r3]
 492              	.LBE15:
 493              	.LBE14:
 340:Source\FilteringFunctions/arm_fir_sparse_q7.c ****                       (int32_t) blockSize, 1, blockSize);
 341:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 342:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Working pointer for the scratch buffer of state values */
 343:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   px = pb;
 494              		.loc 1 343 0
 495 0324 EC23     		mov	r3, #236
 496 0326 FB18     		add	r3, r7, r3
 497 0328 1B68     		ldr	r3, [r3]
 498 032a 8822     		mov	r2, #136
 499 032c 5200     		lsl	r2, r2, #1
 500 032e BA18     		add	r2, r7, r2
 501 0330 1360     		str	r3, [r2]
 344:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 345:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Working pointer for scratch buffer of output values */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 124


 346:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   pScratchOut = pScr2;
 502              		.loc 1 346 0
 503 0332 F823     		mov	r3, #248
 504 0334 FB18     		add	r3, r7, r3
 505 0336 1B68     		ldr	r3, [r3]
 506 0338 9022     		mov	r2, #144
 507 033a 5200     		lsl	r2, r2, #1
 508 033c BA18     		add	r2, r7, r2
 509 033e 1360     		str	r3, [r2]
 347:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 348:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the blockSize */
 349:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   blkCnt = blockSize;
 510              		.loc 1 349 0
 511 0340 9223     		mov	r3, #146
 512 0342 5B00     		lsl	r3, r3, #1
 513 0344 FB18     		add	r3, r7, r3
 514 0346 1B68     		ldr	r3, [r3]
 515 0348 7A1C     		add	r2, r7, #1
 516 034a FF32     		add	r2, r2, #255
 517 034c 1360     		str	r3, [r2]
 350:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 351:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (blkCnt > 0u)
 518              		.loc 1 351 0
 519 034e 20E0     		b	.L10
 520              	.L11:
 352:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 353:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Perform multiplication and store in the scratch buffer */
 354:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 521              		.loc 1 354 0
 522 0350 9023     		mov	r3, #144
 523 0352 5B00     		lsl	r3, r3, #1
 524 0354 FB18     		add	r3, r7, r3
 525 0356 1B68     		ldr	r3, [r3]
 526 0358 1A1D     		add	r2, r3, #4
 527 035a 9021     		mov	r1, #144
 528 035c 4900     		lsl	r1, r1, #1
 529 035e 7918     		add	r1, r7, r1
 530 0360 0A60     		str	r2, [r1]
 531 0362 8822     		mov	r2, #136
 532 0364 5200     		lsl	r2, r2, #1
 533 0366 BA18     		add	r2, r7, r2
 534 0368 1268     		ldr	r2, [r2]
 535 036a 511C     		add	r1, r2, #1
 536 036c 8820     		mov	r0, #136
 537 036e 4000     		lsl	r0, r0, #1
 538 0370 3818     		add	r0, r7, r0
 539 0372 0160     		str	r1, [r0]
 540 0374 1278     		ldrb	r2, [r2]
 541 0376 52B2     		sxtb	r2, r2
 542 0378 FF21     		mov	r1, #255
 543 037a 7918     		add	r1, r7, r1
 544 037c 0978     		ldrb	r1, [r1]
 545 037e 49B2     		sxtb	r1, r1
 546 0380 4A43     		mul	r2, r1
 547 0382 1A60     		str	r2, [r3]
 355:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 356:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the loop counter */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 125


 357:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt--;
 548              		.loc 1 357 0
 549 0384 7B1C     		add	r3, r7, #1
 550 0386 FF33     		add	r3, r3, #255
 551 0388 1B68     		ldr	r3, [r3]
 552 038a 013B     		sub	r3, r3, #1
 553 038c 7A1C     		add	r2, r7, #1
 554 038e FF32     		add	r2, r2, #255
 555 0390 1360     		str	r3, [r2]
 556              	.L10:
 351:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 557              		.loc 1 351 0
 558 0392 7B1C     		add	r3, r7, #1
 559 0394 FF33     		add	r3, r3, #255
 560 0396 1B68     		ldr	r3, [r3]
 561 0398 002B     		cmp	r3, #0
 562 039a D9D1     		bne	.L11
 358:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 359:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 360:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Load the coefficient value and
 361:Source\FilteringFunctions/arm_fir_sparse_q7.c ****    * increment the coefficient buffer for the next set of state values */
 362:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   coeff = *pCoeffs++;
 563              		.loc 1 362 0
 564 039c 8A23     		mov	r3, #138
 565 039e 5B00     		lsl	r3, r3, #1
 566 03a0 FB18     		add	r3, r7, r3
 567 03a2 1B68     		ldr	r3, [r3]
 568 03a4 5A1C     		add	r2, r3, #1
 569 03a6 8A21     		mov	r1, #138
 570 03a8 4900     		lsl	r1, r1, #1
 571 03aa 7918     		add	r1, r7, r1
 572 03ac 0A60     		str	r2, [r1]
 573 03ae FF22     		mov	r2, #255
 574 03b0 BA18     		add	r2, r7, r2
 575 03b2 1B78     		ldrb	r3, [r3]
 576 03b4 1370     		strb	r3, [r2]
 363:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 364:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 365:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 577              		.loc 1 365 0
 578 03b6 FB68     		ldr	r3, [r7, #12]
 579 03b8 5B88     		ldrh	r3, [r3, #2]
 580 03ba 1A1C     		mov	r2, r3
 581 03bc 9223     		mov	r3, #146
 582 03be 5B00     		lsl	r3, r3, #1
 583 03c0 FB18     		add	r3, r7, r3
 584 03c2 1B68     		ldr	r3, [r3]
 585 03c4 D21A     		sub	r2, r2, r3
 586 03c6 8423     		mov	r3, #132
 587 03c8 5B00     		lsl	r3, r3, #1
 588 03ca FB18     		add	r3, r7, r3
 589 03cc 1B68     		ldr	r3, [r3]
 590 03ce 191D     		add	r1, r3, #4
 591 03d0 8420     		mov	r0, #132
 592 03d2 4000     		lsl	r0, r0, #1
 593 03d4 3818     		add	r0, r7, r0
 594 03d6 0160     		str	r1, [r0]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 126


 595 03d8 1B68     		ldr	r3, [r3]
 596 03da D31A     		sub	r3, r2, r3
 597 03dc 7B61     		str	r3, [r7, #20]
 366:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 367:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Wraparound of readIndex */
 368:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   if (readIndex < 0)
 598              		.loc 1 368 0
 599 03de 7B69     		ldr	r3, [r7, #20]
 600 03e0 002B     		cmp	r3, #0
 601 03e2 05DA     		bge	.L12
 369:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 370:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     readIndex += (int32_t) delaySize;
 602              		.loc 1 370 0
 603 03e4 7A69     		ldr	r2, [r7, #20]
 604 03e6 E823     		mov	r3, #232
 605 03e8 FB18     		add	r3, r7, r3
 606 03ea 1B68     		ldr	r3, [r3]
 607 03ec D318     		add	r3, r2, r3
 608 03ee 7B61     		str	r3, [r7, #20]
 609              	.L12:
 371:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 372:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 373:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the number of taps. */
 374:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   tapCnt = (uint32_t) numTaps - 2u;
 610              		.loc 1 374 0
 611 03f0 E623     		mov	r3, #230
 612 03f2 FB18     		add	r3, r7, r3
 613 03f4 1B88     		ldrh	r3, [r3]
 614 03f6 023B     		sub	r3, r3, #2
 615 03f8 7A1D     		add	r2, r7, #5
 616 03fa FF32     		add	r2, r2, #255
 617 03fc 1360     		str	r3, [r2]
 375:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 376:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (tapCnt > 0u)
 618              		.loc 1 376 0
 619 03fe E0E0     		b	.L13
 620              	.L21:
 377:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 378:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Working pointer for state buffer is updated */
 379:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     py = pState;
 621              		.loc 1 379 0
 622 0400 F423     		mov	r3, #244
 623 0402 FB18     		add	r3, r7, r3
 624 0404 1B68     		ldr	r3, [r3]
 625 0406 F022     		mov	r2, #240
 626 0408 BA18     		add	r2, r7, r2
 627 040a 1360     		str	r3, [r2]
 380:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 381:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* blockSize samples are read from the state buffer */
 382:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
 628              		.loc 1 382 0
 629 040c E823     		mov	r3, #232
 630 040e FB18     		add	r3, r7, r3
 631 0410 1A68     		ldr	r2, [r3]
 632 0412 9223     		mov	r3, #146
 633 0414 5B00     		lsl	r3, r3, #1
 634 0416 FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 127


 635 0418 1B68     		ldr	r3, [r3]
 636 041a F021     		mov	r1, #240
 637 041c 7918     		add	r1, r7, r1
 638 041e 0968     		ldr	r1, [r1]
 639 0420 8820     		mov	r0, #136
 640 0422 3818     		add	r0, r7, r0
 641 0424 0160     		str	r1, [r0]
 642 0426 8421     		mov	r1, #132
 643 0428 7918     		add	r1, r7, r1
 644 042a 0A60     		str	r2, [r1]
 645 042c 1422     		mov	r2, #20
 646 042e BA18     		add	r2, r7, r2
 647 0430 8021     		mov	r1, #128
 648 0432 7918     		add	r1, r7, r1
 649 0434 0A60     		str	r2, [r1]
 650 0436 0122     		mov	r2, #1
 651 0438 FA67     		str	r2, [r7, #124]
 652 043a EC22     		mov	r2, #236
 653 043c BA18     		add	r2, r7, r2
 654 043e 1268     		ldr	r2, [r2]
 655 0440 BA67     		str	r2, [r7, #120]
 656 0442 EC22     		mov	r2, #236
 657 0444 BA18     		add	r2, r7, r2
 658 0446 1268     		ldr	r2, [r2]
 659 0448 7A67     		str	r2, [r7, #116]
 660 044a 3B67     		str	r3, [r7, #112]
 661 044c 0123     		mov	r3, #1
 662 044e FB66     		str	r3, [r7, #108]
 663 0450 9223     		mov	r3, #146
 664 0452 5B00     		lsl	r3, r3, #1
 665 0454 FB18     		add	r3, r7, r3
 666 0456 1B68     		ldr	r3, [r3]
 667 0458 BB66     		str	r3, [r7, #104]
 668              	.LBB16:
 669              	.LBB17:
6125:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
 670              		.loc 2 6125 0
 671 045a 0023     		mov	r3, #0
 672 045c 7B66     		str	r3, [r7, #100]
6130:.\Include/arm_math.h **** 
 673              		.loc 2 6130 0
 674 045e 8023     		mov	r3, #128
 675 0460 FB18     		add	r3, r7, r3
 676 0462 1B68     		ldr	r3, [r3]
 677 0464 1B68     		ldr	r3, [r3]
 678 0466 3B66     		str	r3, [r7, #96]
6132:.\Include/arm_math.h **** 
 679              		.loc 2 6132 0
 680 0468 3B6F     		ldr	r3, [r7, #112]
 681 046a 7A6F     		ldr	r2, [r7, #116]
 682 046c D318     		add	r3, r2, r3
 683 046e FB65     		str	r3, [r7, #92]
6135:.\Include/arm_math.h **** 
 684              		.loc 2 6135 0
 685 0470 BB6E     		ldr	r3, [r7, #104]
 686 0472 7B66     		str	r3, [r7, #100]
 687 0474 24E0     		b	.L14
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 128


 688              	.L17:
6140:.\Include/arm_math.h **** 
 689              		.loc 2 6140 0
 690 0476 3B6E     		ldr	r3, [r7, #96]
 691 0478 8822     		mov	r2, #136
 692 047a BA18     		add	r2, r7, r2
 693 047c 1268     		ldr	r2, [r2]
 694 047e D318     		add	r3, r2, r3
 695 0480 1A78     		ldrb	r2, [r3]
 696 0482 BB6F     		ldr	r3, [r7, #120]
 697 0484 1A70     		strb	r2, [r3]
6143:.\Include/arm_math.h **** 
 698              		.loc 2 6143 0
 699 0486 FB6E     		ldr	r3, [r7, #108]
 700 0488 BA6F     		ldr	r2, [r7, #120]
 701 048a D318     		add	r3, r2, r3
 702 048c BB67     		str	r3, [r7, #120]
6145:.\Include/arm_math.h ****       {
 703              		.loc 2 6145 0
 704 048e FB6D     		ldr	r3, [r7, #92]
 705 0490 BA6F     		ldr	r2, [r7, #120]
 706 0492 9A42     		cmp	r2, r3
 707 0494 01D1     		bne	.L15
6147:.\Include/arm_math.h ****       }
 708              		.loc 2 6147 0
 709 0496 7B6F     		ldr	r3, [r7, #116]
 710 0498 BB67     		str	r3, [r7, #120]
 711              	.L15:
6151:.\Include/arm_math.h **** 
 712              		.loc 2 6151 0
 713 049a 3A6E     		ldr	r2, [r7, #96]
 714 049c FB6F     		ldr	r3, [r7, #124]
 715 049e D318     		add	r3, r2, r3
 716 04a0 3B66     		str	r3, [r7, #96]
6153:.\Include/arm_math.h ****       {
 717              		.loc 2 6153 0
 718 04a2 8423     		mov	r3, #132
 719 04a4 FB18     		add	r3, r7, r3
 720 04a6 1A68     		ldr	r2, [r3]
 721 04a8 3B6E     		ldr	r3, [r7, #96]
 722 04aa 9A42     		cmp	r2, r3
 723 04ac 05DC     		bgt	.L16
6155:.\Include/arm_math.h ****       }
 724              		.loc 2 6155 0
 725 04ae 3A6E     		ldr	r2, [r7, #96]
 726 04b0 8423     		mov	r3, #132
 727 04b2 FB18     		add	r3, r7, r3
 728 04b4 1B68     		ldr	r3, [r3]
 729 04b6 D31A     		sub	r3, r2, r3
 730 04b8 3B66     		str	r3, [r7, #96]
 731              	.L16:
6159:.\Include/arm_math.h ****     }
 732              		.loc 2 6159 0
 733 04ba 7B6E     		ldr	r3, [r7, #100]
 734 04bc 013B     		sub	r3, r3, #1
 735 04be 7B66     		str	r3, [r7, #100]
 736              	.L14:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 129


6137:.\Include/arm_math.h ****     {
 737              		.loc 2 6137 0
 738 04c0 7B6E     		ldr	r3, [r7, #100]
 739 04c2 002B     		cmp	r3, #0
 740 04c4 D7D1     		bne	.L17
 741              		.loc 2 6163 0
 742 04c6 8023     		mov	r3, #128
 743 04c8 FB18     		add	r3, r7, r3
 744 04ca 1B68     		ldr	r3, [r3]
 745 04cc 3A6E     		ldr	r2, [r7, #96]
 746 04ce 1A60     		str	r2, [r3]
 747              	.LBE17:
 748              	.LBE16:
 383:Source\FilteringFunctions/arm_fir_sparse_q7.c ****                         (int32_t) blockSize, 1, blockSize);
 384:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 385:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Working pointer for the scratch buffer of state values */
 386:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     px = pb;
 749              		.loc 1 386 0
 750 04d0 EC23     		mov	r3, #236
 751 04d2 FB18     		add	r3, r7, r3
 752 04d4 1B68     		ldr	r3, [r3]
 753 04d6 8822     		mov	r2, #136
 754 04d8 5200     		lsl	r2, r2, #1
 755 04da BA18     		add	r2, r7, r2
 756 04dc 1360     		str	r3, [r2]
 387:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 388:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Working pointer for scratch buffer of output values */
 389:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     pScratchOut = pScr2;
 757              		.loc 1 389 0
 758 04de F823     		mov	r3, #248
 759 04e0 FB18     		add	r3, r7, r3
 760 04e2 1B68     		ldr	r3, [r3]
 761 04e4 9022     		mov	r2, #144
 762 04e6 5200     		lsl	r2, r2, #1
 763 04e8 BA18     		add	r2, r7, r2
 764 04ea 1360     		str	r3, [r2]
 390:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 391:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Loop over the blockSize */
 392:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt = blockSize;
 765              		.loc 1 392 0
 766 04ec 9223     		mov	r3, #146
 767 04ee 5B00     		lsl	r3, r3, #1
 768 04f0 FB18     		add	r3, r7, r3
 769 04f2 1B68     		ldr	r3, [r3]
 770 04f4 7A1C     		add	r2, r7, #1
 771 04f6 FF32     		add	r2, r2, #255
 772 04f8 1360     		str	r3, [r2]
 393:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 394:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     while (blkCnt > 0u)
 773              		.loc 1 394 0
 774 04fa 2CE0     		b	.L18
 775              	.L19:
 395:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     {
 396:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       /* Perform Multiply-Accumulate */
 397:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       in = *pScratchOut + ((q31_t) * px++ * coeff);
 776              		.loc 1 397 0
 777 04fc 9023     		mov	r3, #144
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 130


 778 04fe 5B00     		lsl	r3, r3, #1
 779 0500 FB18     		add	r3, r7, r3
 780 0502 1B68     		ldr	r3, [r3]
 781 0504 1A68     		ldr	r2, [r3]
 782 0506 8823     		mov	r3, #136
 783 0508 5B00     		lsl	r3, r3, #1
 784 050a FB18     		add	r3, r7, r3
 785 050c 1B68     		ldr	r3, [r3]
 786 050e 591C     		add	r1, r3, #1
 787 0510 8820     		mov	r0, #136
 788 0512 4000     		lsl	r0, r0, #1
 789 0514 3818     		add	r0, r7, r0
 790 0516 0160     		str	r1, [r0]
 791 0518 1B78     		ldrb	r3, [r3]
 792 051a 5BB2     		sxtb	r3, r3
 793 051c FF21     		mov	r1, #255
 794 051e 7918     		add	r1, r7, r1
 795 0520 0978     		ldrb	r1, [r1]
 796 0522 49B2     		sxtb	r1, r1
 797 0524 4B43     		mul	r3, r1
 798 0526 D318     		add	r3, r2, r3
 799 0528 E022     		mov	r2, #224
 800 052a BA18     		add	r2, r7, r2
 801 052c 1360     		str	r3, [r2]
 398:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       *pScratchOut++ = in;
 802              		.loc 1 398 0
 803 052e 9023     		mov	r3, #144
 804 0530 5B00     		lsl	r3, r3, #1
 805 0532 FB18     		add	r3, r7, r3
 806 0534 1B68     		ldr	r3, [r3]
 807 0536 1A1D     		add	r2, r3, #4
 808 0538 9021     		mov	r1, #144
 809 053a 4900     		lsl	r1, r1, #1
 810 053c 7918     		add	r1, r7, r1
 811 053e 0A60     		str	r2, [r1]
 812 0540 E022     		mov	r2, #224
 813 0542 BA18     		add	r2, r7, r2
 814 0544 1268     		ldr	r2, [r2]
 815 0546 1A60     		str	r2, [r3]
 399:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 400:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       /* Decrement the loop counter */
 401:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       blkCnt--;
 816              		.loc 1 401 0
 817 0548 7B1C     		add	r3, r7, #1
 818 054a FF33     		add	r3, r3, #255
 819 054c 1B68     		ldr	r3, [r3]
 820 054e 013B     		sub	r3, r3, #1
 821 0550 7A1C     		add	r2, r7, #1
 822 0552 FF32     		add	r2, r2, #255
 823 0554 1360     		str	r3, [r2]
 824              	.L18:
 394:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     {
 825              		.loc 1 394 0
 826 0556 7B1C     		add	r3, r7, #1
 827 0558 FF33     		add	r3, r3, #255
 828 055a 1B68     		ldr	r3, [r3]
 829 055c 002B     		cmp	r3, #0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 131


 830 055e CDD1     		bne	.L19
 402:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     }
 403:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 404:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Load the coefficient value and
 405:Source\FilteringFunctions/arm_fir_sparse_q7.c ****      * increment the coefficient buffer for the next set of state values */
 406:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     coeff = *pCoeffs++;
 831              		.loc 1 406 0
 832 0560 8A23     		mov	r3, #138
 833 0562 5B00     		lsl	r3, r3, #1
 834 0564 FB18     		add	r3, r7, r3
 835 0566 1B68     		ldr	r3, [r3]
 836 0568 5A1C     		add	r2, r3, #1
 837 056a 8A21     		mov	r1, #138
 838 056c 4900     		lsl	r1, r1, #1
 839 056e 7918     		add	r1, r7, r1
 840 0570 0A60     		str	r2, [r1]
 841 0572 FF22     		mov	r2, #255
 842 0574 BA18     		add	r2, r7, r2
 843 0576 1B78     		ldrb	r3, [r3]
 844 0578 1370     		strb	r3, [r2]
 407:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 408:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 409:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     readIndex =
 410:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 845              		.loc 1 410 0
 846 057a FB68     		ldr	r3, [r7, #12]
 847 057c 5B88     		ldrh	r3, [r3, #2]
 848 057e 1A1C     		mov	r2, r3
 849 0580 9223     		mov	r3, #146
 850 0582 5B00     		lsl	r3, r3, #1
 851 0584 FB18     		add	r3, r7, r3
 852 0586 1B68     		ldr	r3, [r3]
 853 0588 D21A     		sub	r2, r2, r3
 854 058a 8423     		mov	r3, #132
 855 058c 5B00     		lsl	r3, r3, #1
 856 058e FB18     		add	r3, r7, r3
 857 0590 1B68     		ldr	r3, [r3]
 858 0592 191D     		add	r1, r3, #4
 859 0594 8420     		mov	r0, #132
 860 0596 4000     		lsl	r0, r0, #1
 861 0598 3818     		add	r0, r7, r0
 862 059a 0160     		str	r1, [r0]
 863 059c 1B68     		ldr	r3, [r3]
 864 059e D31A     		sub	r3, r2, r3
 409:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 865              		.loc 1 409 0
 866 05a0 7B61     		str	r3, [r7, #20]
 411:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 412:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Wraparound of readIndex */
 413:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     if (readIndex < 0)
 867              		.loc 1 413 0
 868 05a2 7B69     		ldr	r3, [r7, #20]
 869 05a4 002B     		cmp	r3, #0
 870 05a6 05DA     		bge	.L20
 414:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     {
 415:Source\FilteringFunctions/arm_fir_sparse_q7.c ****       readIndex += (int32_t) delaySize;
 871              		.loc 1 415 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 132


 872 05a8 7A69     		ldr	r2, [r7, #20]
 873 05aa E823     		mov	r3, #232
 874 05ac FB18     		add	r3, r7, r3
 875 05ae 1B68     		ldr	r3, [r3]
 876 05b0 D318     		add	r3, r2, r3
 877 05b2 7B61     		str	r3, [r7, #20]
 878              	.L20:
 416:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     }
 417:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 418:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the tap loop counter */
 419:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     tapCnt--;
 879              		.loc 1 419 0
 880 05b4 7B1D     		add	r3, r7, #5
 881 05b6 FF33     		add	r3, r3, #255
 882 05b8 1B68     		ldr	r3, [r3]
 883 05ba 013B     		sub	r3, r3, #1
 884 05bc 7A1D     		add	r2, r7, #5
 885 05be FF32     		add	r2, r2, #255
 886 05c0 1360     		str	r3, [r2]
 887              	.L13:
 376:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 888              		.loc 1 376 0
 889 05c2 7B1D     		add	r3, r7, #5
 890 05c4 FF33     		add	r3, r3, #255
 891 05c6 1B68     		ldr	r3, [r3]
 892 05c8 002B     		cmp	r3, #0
 893 05ca 00D0     		beq	.LCB808
 894 05cc 18E7     		b	.L21	@long jump
 895              	.LCB808:
 420:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 421:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 422:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Compute last tap without the final read of pTapDelay */
 423:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 424:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Working pointer for state buffer is updated */
 425:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	py = pState;
 896              		.loc 1 425 0
 897 05ce F423     		mov	r3, #244
 898 05d0 FB18     		add	r3, r7, r3
 899 05d2 1B68     		ldr	r3, [r3]
 900 05d4 F022     		mov	r2, #240
 901 05d6 BA18     		add	r2, r7, r2
 902 05d8 1360     		str	r3, [r2]
 426:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 427:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* blockSize samples are read from the state buffer */
 428:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
 903              		.loc 1 428 0
 904 05da E823     		mov	r3, #232
 905 05dc FB18     		add	r3, r7, r3
 906 05de 1A68     		ldr	r2, [r3]
 907 05e0 9223     		mov	r3, #146
 908 05e2 5B00     		lsl	r3, r3, #1
 909 05e4 FB18     		add	r3, r7, r3
 910 05e6 1B68     		ldr	r3, [r3]
 911 05e8 F021     		mov	r1, #240
 912 05ea 7918     		add	r1, r7, r1
 913 05ec 0968     		ldr	r1, [r1]
 914 05ee B965     		str	r1, [r7, #88]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 133


 915 05f0 7A65     		str	r2, [r7, #84]
 916 05f2 1422     		mov	r2, #20
 917 05f4 BA18     		add	r2, r7, r2
 918 05f6 3A65     		str	r2, [r7, #80]
 919 05f8 0122     		mov	r2, #1
 920 05fa FA64     		str	r2, [r7, #76]
 921 05fc EC22     		mov	r2, #236
 922 05fe BA18     		add	r2, r7, r2
 923 0600 1268     		ldr	r2, [r2]
 924 0602 BA64     		str	r2, [r7, #72]
 925 0604 EC22     		mov	r2, #236
 926 0606 BA18     		add	r2, r7, r2
 927 0608 1268     		ldr	r2, [r2]
 928 060a 7A64     		str	r2, [r7, #68]
 929 060c 3B64     		str	r3, [r7, #64]
 930 060e 0123     		mov	r3, #1
 931 0610 FB63     		str	r3, [r7, #60]
 932 0612 9223     		mov	r3, #146
 933 0614 5B00     		lsl	r3, r3, #1
 934 0616 FB18     		add	r3, r7, r3
 935 0618 1B68     		ldr	r3, [r3]
 936 061a BB63     		str	r3, [r7, #56]
 937              	.LBB18:
 938              	.LBB19:
6125:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
 939              		.loc 2 6125 0
 940 061c 0023     		mov	r3, #0
 941 061e 7B63     		str	r3, [r7, #52]
6130:.\Include/arm_math.h **** 
 942              		.loc 2 6130 0
 943 0620 3B6D     		ldr	r3, [r7, #80]
 944 0622 1B68     		ldr	r3, [r3]
 945 0624 3B63     		str	r3, [r7, #48]
6132:.\Include/arm_math.h **** 
 946              		.loc 2 6132 0
 947 0626 3B6C     		ldr	r3, [r7, #64]
 948 0628 7A6C     		ldr	r2, [r7, #68]
 949 062a D318     		add	r3, r2, r3
 950 062c FB62     		str	r3, [r7, #44]
6135:.\Include/arm_math.h **** 
 951              		.loc 2 6135 0
 952 062e BB6B     		ldr	r3, [r7, #56]
 953 0630 7B63     		str	r3, [r7, #52]
 954 0632 1EE0     		b	.L22
 955              	.L25:
6140:.\Include/arm_math.h **** 
 956              		.loc 2 6140 0
 957 0634 3B6B     		ldr	r3, [r7, #48]
 958 0636 BA6D     		ldr	r2, [r7, #88]
 959 0638 D318     		add	r3, r2, r3
 960 063a 1A78     		ldrb	r2, [r3]
 961 063c BB6C     		ldr	r3, [r7, #72]
 962 063e 1A70     		strb	r2, [r3]
6143:.\Include/arm_math.h **** 
 963              		.loc 2 6143 0
 964 0640 FB6B     		ldr	r3, [r7, #60]
 965 0642 BA6C     		ldr	r2, [r7, #72]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 134


 966 0644 D318     		add	r3, r2, r3
 967 0646 BB64     		str	r3, [r7, #72]
6145:.\Include/arm_math.h ****       {
 968              		.loc 2 6145 0
 969 0648 FB6A     		ldr	r3, [r7, #44]
 970 064a BA6C     		ldr	r2, [r7, #72]
 971 064c 9A42     		cmp	r2, r3
 972 064e 01D1     		bne	.L23
6147:.\Include/arm_math.h ****       }
 973              		.loc 2 6147 0
 974 0650 7B6C     		ldr	r3, [r7, #68]
 975 0652 BB64     		str	r3, [r7, #72]
 976              	.L23:
6151:.\Include/arm_math.h **** 
 977              		.loc 2 6151 0
 978 0654 3A6B     		ldr	r2, [r7, #48]
 979 0656 FB6C     		ldr	r3, [r7, #76]
 980 0658 D318     		add	r3, r2, r3
 981 065a 3B63     		str	r3, [r7, #48]
6153:.\Include/arm_math.h ****       {
 982              		.loc 2 6153 0
 983 065c 7A6D     		ldr	r2, [r7, #84]
 984 065e 3B6B     		ldr	r3, [r7, #48]
 985 0660 9A42     		cmp	r2, r3
 986 0662 03DC     		bgt	.L24
6155:.\Include/arm_math.h ****       }
 987              		.loc 2 6155 0
 988 0664 3A6B     		ldr	r2, [r7, #48]
 989 0666 7B6D     		ldr	r3, [r7, #84]
 990 0668 D31A     		sub	r3, r2, r3
 991 066a 3B63     		str	r3, [r7, #48]
 992              	.L24:
6159:.\Include/arm_math.h ****     }
 993              		.loc 2 6159 0
 994 066c 7B6B     		ldr	r3, [r7, #52]
 995 066e 013B     		sub	r3, r3, #1
 996 0670 7B63     		str	r3, [r7, #52]
 997              	.L22:
6137:.\Include/arm_math.h ****     {
 998              		.loc 2 6137 0
 999 0672 7B6B     		ldr	r3, [r7, #52]
 1000 0674 002B     		cmp	r3, #0
 1001 0676 DDD1     		bne	.L25
 1002              		.loc 2 6163 0
 1003 0678 3B6D     		ldr	r3, [r7, #80]
 1004 067a 3A6B     		ldr	r2, [r7, #48]
 1005 067c 1A60     		str	r2, [r3]
 1006              	.LBE19:
 1007              	.LBE18:
 429:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 											(int32_t) blockSize, 1, blockSize);
 430:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 431:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Working pointer for the scratch buffer of state values */
 432:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	px = pb;
 1008              		.loc 1 432 0
 1009 067e EC23     		mov	r3, #236
 1010 0680 FB18     		add	r3, r7, r3
 1011 0682 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 135


 1012 0684 8822     		mov	r2, #136
 1013 0686 5200     		lsl	r2, r2, #1
 1014 0688 BA18     		add	r2, r7, r2
 1015 068a 1360     		str	r3, [r2]
 433:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 434:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Working pointer for scratch buffer of output values */
 435:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	pScratchOut = pScr2;
 1016              		.loc 1 435 0
 1017 068c F823     		mov	r3, #248
 1018 068e FB18     		add	r3, r7, r3
 1019 0690 1B68     		ldr	r3, [r3]
 1020 0692 9022     		mov	r2, #144
 1021 0694 5200     		lsl	r2, r2, #1
 1022 0696 BA18     		add	r2, r7, r2
 1023 0698 1360     		str	r3, [r2]
 436:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 437:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	/* Loop over the blockSize */
 438:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	blkCnt = blockSize;
 1024              		.loc 1 438 0
 1025 069a 9223     		mov	r3, #146
 1026 069c 5B00     		lsl	r3, r3, #1
 1027 069e FB18     		add	r3, r7, r3
 1028 06a0 1B68     		ldr	r3, [r3]
 1029 06a2 7A1C     		add	r2, r7, #1
 1030 06a4 FF32     		add	r2, r2, #255
 1031 06a6 1360     		str	r3, [r2]
 439:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 440:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	while (blkCnt > 0u)
 1032              		.loc 1 440 0
 1033 06a8 2CE0     		b	.L26
 1034              	.L27:
 441:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	{
 442:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		/* Perform Multiply-Accumulate */
 443:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		in = *pScratchOut + ((q31_t) * px++ * coeff);
 1035              		.loc 1 443 0
 1036 06aa 9023     		mov	r3, #144
 1037 06ac 5B00     		lsl	r3, r3, #1
 1038 06ae FB18     		add	r3, r7, r3
 1039 06b0 1B68     		ldr	r3, [r3]
 1040 06b2 1A68     		ldr	r2, [r3]
 1041 06b4 8823     		mov	r3, #136
 1042 06b6 5B00     		lsl	r3, r3, #1
 1043 06b8 FB18     		add	r3, r7, r3
 1044 06ba 1B68     		ldr	r3, [r3]
 1045 06bc 591C     		add	r1, r3, #1
 1046 06be 8820     		mov	r0, #136
 1047 06c0 4000     		lsl	r0, r0, #1
 1048 06c2 3818     		add	r0, r7, r0
 1049 06c4 0160     		str	r1, [r0]
 1050 06c6 1B78     		ldrb	r3, [r3]
 1051 06c8 5BB2     		sxtb	r3, r3
 1052 06ca FF21     		mov	r1, #255
 1053 06cc 7918     		add	r1, r7, r1
 1054 06ce 0978     		ldrb	r1, [r1]
 1055 06d0 49B2     		sxtb	r1, r1
 1056 06d2 4B43     		mul	r3, r1
 1057 06d4 D318     		add	r3, r2, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 136


 1058 06d6 E022     		mov	r2, #224
 1059 06d8 BA18     		add	r2, r7, r2
 1060 06da 1360     		str	r3, [r2]
 444:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		*pScratchOut++ = in;
 1061              		.loc 1 444 0
 1062 06dc 9023     		mov	r3, #144
 1063 06de 5B00     		lsl	r3, r3, #1
 1064 06e0 FB18     		add	r3, r7, r3
 1065 06e2 1B68     		ldr	r3, [r3]
 1066 06e4 1A1D     		add	r2, r3, #4
 1067 06e6 9021     		mov	r1, #144
 1068 06e8 4900     		lsl	r1, r1, #1
 1069 06ea 7918     		add	r1, r7, r1
 1070 06ec 0A60     		str	r2, [r1]
 1071 06ee E022     		mov	r2, #224
 1072 06f0 BA18     		add	r2, r7, r2
 1073 06f2 1268     		ldr	r2, [r2]
 1074 06f4 1A60     		str	r2, [r3]
 445:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 446:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		/* Decrement the loop counter */
 447:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 		blkCnt--;
 1075              		.loc 1 447 0
 1076 06f6 7B1C     		add	r3, r7, #1
 1077 06f8 FF33     		add	r3, r3, #255
 1078 06fa 1B68     		ldr	r3, [r3]
 1079 06fc 013B     		sub	r3, r3, #1
 1080 06fe 7A1C     		add	r2, r7, #1
 1081 0700 FF32     		add	r2, r2, #255
 1082 0702 1360     		str	r3, [r2]
 1083              	.L26:
 440:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	{
 1084              		.loc 1 440 0
 1085 0704 7B1C     		add	r3, r7, #1
 1086 0706 FF33     		add	r3, r3, #255
 1087 0708 1B68     		ldr	r3, [r3]
 1088 070a 002B     		cmp	r3, #0
 1089 070c CDD1     		bne	.L27
 448:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 	}
 449:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 450:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* All the output values are in pScratchOut buffer.
 451:Source\FilteringFunctions/arm_fir_sparse_q7.c ****      Convert them into 1.15 format, saturate and store in the destination buffer. */
 452:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   /* Loop over the blockSize. */
 453:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   blkCnt = blockSize;
 1090              		.loc 1 453 0
 1091 070e 9223     		mov	r3, #146
 1092 0710 5B00     		lsl	r3, r3, #1
 1093 0712 FB18     		add	r3, r7, r3
 1094 0714 1B68     		ldr	r3, [r3]
 1095 0716 7A1C     		add	r2, r7, #1
 1096 0718 FF32     		add	r2, r2, #255
 1097 071a 1360     		str	r3, [r2]
 454:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 455:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   while (blkCnt > 0u)
 1098              		.loc 1 455 0
 1099 071c 46E0     		b	.L28
 1100              	.L35:
 456:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 137


 457:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     *pOut++ = (q7_t) __SSAT(*pScr2++ >> 7, 8);
 1101              		.loc 1 457 0
 1102 071e 8623     		mov	r3, #134
 1103 0720 5B00     		lsl	r3, r3, #1
 1104 0722 FB18     		add	r3, r7, r3
 1105 0724 1A68     		ldr	r2, [r3]
 1106 0726 531C     		add	r3, r2, #1
 1107 0728 8621     		mov	r1, #134
 1108 072a 4900     		lsl	r1, r1, #1
 1109 072c 7918     		add	r1, r7, r1
 1110 072e 0B60     		str	r3, [r1]
 1111 0730 F823     		mov	r3, #248
 1112 0732 FB18     		add	r3, r7, r3
 1113 0734 1B68     		ldr	r3, [r3]
 1114 0736 191D     		add	r1, r3, #4
 1115 0738 F820     		mov	r0, #248
 1116 073a 3818     		add	r0, r7, r0
 1117 073c 0160     		str	r1, [r0]
 1118 073e 1B68     		ldr	r3, [r3]
 1119 0740 DB11     		asr	r3, r3, #7
 1120 0742 BB62     		str	r3, [r7, #40]
 1121 0744 0823     		mov	r3, #8
 1122 0746 7B62     		str	r3, [r7, #36]
 1123              	.LBB20:
 1124              	.LBB21:
 699:.\Include/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 1125              		.loc 2 699 0
 1126 0748 0123     		mov	r3, #1
 1127 074a 3B62     		str	r3, [r7, #32]
 700:.\Include/arm_math.h ****     {
 1128              		.loc 2 700 0
 1129 074c 0023     		mov	r3, #0
 1130 074e FB61     		str	r3, [r7, #28]
 1131 0750 05E0     		b	.L29
 1132              	.L30:
 702:.\Include/arm_math.h ****     }
 1133              		.loc 2 702 0
 1134 0752 3B6A     		ldr	r3, [r7, #32]
 1135 0754 5B00     		lsl	r3, r3, #1
 1136 0756 3B62     		str	r3, [r7, #32]
 700:.\Include/arm_math.h ****     {
 1137              		.loc 2 700 0
 1138 0758 FB69     		ldr	r3, [r7, #28]
 1139 075a 0133     		add	r3, r3, #1
 1140 075c FB61     		str	r3, [r7, #28]
 1141              	.L29:
 1142 075e 7B6A     		ldr	r3, [r7, #36]
 1143 0760 013B     		sub	r3, r3, #1
 1144 0762 F969     		ldr	r1, [r7, #28]
 1145 0764 9942     		cmp	r1, r3
 1146 0766 F4D3     		bcc	.L30
 705:.\Include/arm_math.h ****     {
 1147              		.loc 2 705 0
 1148 0768 BB6A     		ldr	r3, [r7, #40]
 1149 076a 002B     		cmp	r3, #0
 1150 076c 09DD     		ble	.L31
 707:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 138


 1151              		.loc 2 707 0
 1152 076e 3B6A     		ldr	r3, [r7, #32]
 1153 0770 013B     		sub	r3, r3, #1
 1154 0772 3B62     		str	r3, [r7, #32]
 709:.\Include/arm_math.h ****       {
 1155              		.loc 2 709 0
 1156 0774 B96A     		ldr	r1, [r7, #40]
 1157 0776 3B6A     		ldr	r3, [r7, #32]
 1158 0778 9942     		cmp	r1, r3
 1159 077a 0CDD     		ble	.L36
 711:.\Include/arm_math.h ****       }
 1160              		.loc 2 711 0
 1161 077c 3B6A     		ldr	r3, [r7, #32]
 1162 077e BB62     		str	r3, [r7, #40]
 1163 0780 0AE0     		b	.L33
 1164              	.L31:
 716:.\Include/arm_math.h **** 
 1165              		.loc 2 716 0
 1166 0782 3B6A     		ldr	r3, [r7, #32]
 1167 0784 5B42     		neg	r3, r3
 1168 0786 BB61     		str	r3, [r7, #24]
 718:.\Include/arm_math.h ****       {
 1169              		.loc 2 718 0
 1170 0788 B96A     		ldr	r1, [r7, #40]
 1171 078a BB69     		ldr	r3, [r7, #24]
 1172 078c 9942     		cmp	r1, r3
 1173 078e 03DA     		bge	.L33
 720:.\Include/arm_math.h ****       }
 1174              		.loc 2 720 0
 1175 0790 BB69     		ldr	r3, [r7, #24]
 1176 0792 BB62     		str	r3, [r7, #40]
 1177 0794 00E0     		b	.L33
 1178              	.L36:
 711:.\Include/arm_math.h ****       }
 1179              		.loc 2 711 0
 1180 0796 C046     		mov	r8, r8
 1181              	.L33:
 723:.\Include/arm_math.h ****   }
 1182              		.loc 2 723 0
 1183 0798 BB6A     		ldr	r3, [r7, #40]
 1184              	.LBE21:
 1185              	.LBE20:
 1186              		.loc 1 457 0
 1187 079a DBB2     		uxtb	r3, r3
 1188 079c 1370     		strb	r3, [r2]
 458:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 459:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     /* Decrement the blockSize loop counter */
 460:Source\FilteringFunctions/arm_fir_sparse_q7.c ****     blkCnt--;
 1189              		.loc 1 460 0
 1190 079e 7B1C     		add	r3, r7, #1
 1191 07a0 FF33     		add	r3, r3, #255
 1192 07a2 1B68     		ldr	r3, [r3]
 1193 07a4 013B     		sub	r3, r3, #1
 1194 07a6 7A1C     		add	r2, r7, #1
 1195 07a8 FF32     		add	r2, r2, #255
 1196 07aa 1360     		str	r3, [r2]
 1197              	.L28:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 139


 455:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   {
 1198              		.loc 1 455 0
 1199 07ac 7B1C     		add	r3, r7, #1
 1200 07ae FF33     		add	r3, r3, #255
 1201 07b0 1B68     		ldr	r3, [r3]
 1202 07b2 002B     		cmp	r3, #0
 1203 07b4 B3D1     		bne	.L35
 461:Source\FilteringFunctions/arm_fir_sparse_q7.c ****   }
 462:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 463:Source\FilteringFunctions/arm_fir_sparse_q7.c **** #endif /*   #if defined (ARM_MATH_DSP) */
 464:Source\FilteringFunctions/arm_fir_sparse_q7.c **** 
 465:Source\FilteringFunctions/arm_fir_sparse_q7.c **** }
 1204              		.loc 1 465 0
 1205 07b6 BD46     		mov	sp, r7
 1206 07b8 46B0     		add	sp, sp, #280
 1207              		@ sp needed
 1208 07ba 80BD     		pop	{r7, pc}
 1209              		.cfi_endproc
 1210              	.LFE82:
 1211              		.size	arm_fir_sparse_q7, .-arm_fir_sparse_q7
 1212              		.text
 1213              	.Letext0:
 1214              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 1215              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 1216              		.section	.debug_info,"",%progbits
 1217              	.Ldebug_info0:
 1218 0000 74060000 		.4byte	0x674
 1219 0004 0400     		.2byte	0x4
 1220 0006 00000000 		.4byte	.Ldebug_abbrev0
 1221 000a 04       		.byte	0x4
 1222 000b 01       		.uleb128 0x1
 1223 000c 3C010000 		.4byte	.LASF58
 1224 0010 01       		.byte	0x1
 1225 0011 00000000 		.4byte	.LASF59
 1226 0015 76020000 		.4byte	.LASF60
 1227 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1228 001d 00000000 		.4byte	0
 1229 0021 00000000 		.4byte	.Ldebug_line0
 1230 0025 02       		.uleb128 0x2
 1231 0026 75000000 		.4byte	.LASF3
 1232 002a 03       		.byte	0x3
 1233 002b 1B       		.byte	0x1b
 1234 002c 30000000 		.4byte	0x30
 1235 0030 03       		.uleb128 0x3
 1236 0031 01       		.byte	0x1
 1237 0032 06       		.byte	0x6
 1238 0033 8C000000 		.4byte	.LASF0
 1239 0037 03       		.uleb128 0x3
 1240 0038 01       		.byte	0x1
 1241 0039 08       		.byte	0x8
 1242 003a 4E020000 		.4byte	.LASF1
 1243 003e 03       		.uleb128 0x3
 1244 003f 02       		.byte	0x2
 1245 0040 05       		.byte	0x5
 1246 0041 63020000 		.4byte	.LASF2
 1247 0045 02       		.uleb128 0x2
 1248 0046 F1020000 		.4byte	.LASF4
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 140


 1249 004a 03       		.byte	0x3
 1250 004b 2B       		.byte	0x2b
 1251 004c 50000000 		.4byte	0x50
 1252 0050 03       		.uleb128 0x3
 1253 0051 02       		.byte	0x2
 1254 0052 07       		.byte	0x7
 1255 0053 CE010000 		.4byte	.LASF5
 1256 0057 02       		.uleb128 0x2
 1257 0058 FC020000 		.4byte	.LASF6
 1258 005c 03       		.byte	0x3
 1259 005d 3F       		.byte	0x3f
 1260 005e 62000000 		.4byte	0x62
 1261 0062 03       		.uleb128 0x3
 1262 0063 04       		.byte	0x4
 1263 0064 05       		.byte	0x5
 1264 0065 AD000000 		.4byte	.LASF7
 1265 0069 02       		.uleb128 0x2
 1266 006a DE000000 		.4byte	.LASF8
 1267 006e 03       		.byte	0x3
 1268 006f 41       		.byte	0x41
 1269 0070 74000000 		.4byte	0x74
 1270 0074 03       		.uleb128 0x3
 1271 0075 04       		.byte	0x4
 1272 0076 07       		.byte	0x7
 1273 0077 2A010000 		.4byte	.LASF9
 1274 007b 03       		.uleb128 0x3
 1275 007c 08       		.byte	0x8
 1276 007d 05       		.byte	0x5
 1277 007e 7E000000 		.4byte	.LASF10
 1278 0082 03       		.uleb128 0x3
 1279 0083 08       		.byte	0x8
 1280 0084 07       		.byte	0x7
 1281 0085 57000000 		.4byte	.LASF11
 1282 0089 04       		.uleb128 0x4
 1283 008a 04       		.byte	0x4
 1284 008b 05       		.byte	0x5
 1285 008c 696E7400 		.ascii	"int\000"
 1286 0090 03       		.uleb128 0x3
 1287 0091 04       		.byte	0x4
 1288 0092 07       		.byte	0x7
 1289 0093 06010000 		.4byte	.LASF12
 1290 0097 02       		.uleb128 0x2
 1291 0098 26030000 		.4byte	.LASF13
 1292 009c 04       		.byte	0x4
 1293 009d 14       		.byte	0x14
 1294 009e 25000000 		.4byte	0x25
 1295 00a2 02       		.uleb128 0x2
 1296 00a3 C2000000 		.4byte	.LASF14
 1297 00a7 04       		.byte	0x4
 1298 00a8 21       		.byte	0x21
 1299 00a9 45000000 		.4byte	0x45
 1300 00ad 02       		.uleb128 0x2
 1301 00ae 46020000 		.4byte	.LASF15
 1302 00b2 04       		.byte	0x4
 1303 00b3 2C       		.byte	0x2c
 1304 00b4 57000000 		.4byte	0x57
 1305 00b8 02       		.uleb128 0x2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 141


 1306 00b9 CA020000 		.4byte	.LASF16
 1307 00bd 04       		.byte	0x4
 1308 00be 2D       		.byte	0x2d
 1309 00bf 69000000 		.4byte	0x69
 1310 00c3 03       		.uleb128 0x3
 1311 00c4 04       		.byte	0x4
 1312 00c5 07       		.byte	0x7
 1313 00c6 F8010000 		.4byte	.LASF17
 1314 00ca 03       		.uleb128 0x3
 1315 00cb 01       		.byte	0x1
 1316 00cc 08       		.byte	0x8
 1317 00cd DA020000 		.4byte	.LASF18
 1318 00d1 03       		.uleb128 0x3
 1319 00d2 08       		.byte	0x8
 1320 00d3 04       		.byte	0x4
 1321 00d4 CB000000 		.4byte	.LASF19
 1322 00d8 03       		.uleb128 0x3
 1323 00d9 04       		.byte	0x4
 1324 00da 04       		.byte	0x4
 1325 00db 23020000 		.4byte	.LASF20
 1326 00df 03       		.uleb128 0x3
 1327 00e0 08       		.byte	0x8
 1328 00e1 04       		.byte	0x4
 1329 00e2 01020000 		.4byte	.LASF21
 1330 00e6 05       		.uleb128 0x5
 1331 00e7 16030000 		.4byte	.LASF22
 1332 00eb 02       		.byte	0x2
 1333 00ec 9101     		.2byte	0x191
 1334 00ee 97000000 		.4byte	0x97
 1335 00f2 05       		.uleb128 0x5
 1336 00f3 C4020000 		.4byte	.LASF23
 1337 00f7 02       		.byte	0x2
 1338 00f8 9B01     		.2byte	0x19b
 1339 00fa AD000000 		.4byte	0xad
 1340 00fe 06       		.uleb128 0x6
 1341 00ff 04       		.byte	0x4
 1342 0100 E6000000 		.4byte	0xe6
 1343 0104 06       		.uleb128 0x6
 1344 0105 04       		.byte	0x4
 1345 0106 F2000000 		.4byte	0xf2
 1346 010a 06       		.uleb128 0x6
 1347 010b 04       		.byte	0x4
 1348 010c A2000000 		.4byte	0xa2
 1349 0110 06       		.uleb128 0x6
 1350 0111 04       		.byte	0x4
 1351 0112 AD000000 		.4byte	0xad
 1352 0116 07       		.uleb128 0x7
 1353 0117 14       		.byte	0x14
 1354 0118 02       		.byte	0x2
 1355 0119 B611     		.2byte	0x11b6
 1356 011b 6E010000 		.4byte	0x16e
 1357 011f 08       		.uleb128 0x8
 1358 0120 BC020000 		.4byte	.LASF24
 1359 0124 02       		.byte	0x2
 1360 0125 B811     		.2byte	0x11b8
 1361 0127 A2000000 		.4byte	0xa2
 1362 012b 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 142


 1363 012c 08       		.uleb128 0x8
 1364 012d 0D020000 		.4byte	.LASF25
 1365 0131 02       		.byte	0x2
 1366 0132 B911     		.2byte	0x11b9
 1367 0134 A2000000 		.4byte	0xa2
 1368 0138 02       		.byte	0x2
 1369 0139 08       		.uleb128 0x8
 1370 013a 5C020000 		.4byte	.LASF26
 1371 013e 02       		.byte	0x2
 1372 013f BA11     		.2byte	0x11ba
 1373 0141 FE000000 		.4byte	0xfe
 1374 0145 04       		.byte	0x4
 1375 0146 08       		.uleb128 0x8
 1376 0147 45030000 		.4byte	.LASF27
 1377 014b 02       		.byte	0x2
 1378 014c BB11     		.2byte	0x11bb
 1379 014e FE000000 		.4byte	0xfe
 1380 0152 08       		.byte	0x8
 1381 0153 08       		.uleb128 0x8
 1382 0154 6D020000 		.4byte	.LASF28
 1383 0158 02       		.byte	0x2
 1384 0159 BC11     		.2byte	0x11bc
 1385 015b A2000000 		.4byte	0xa2
 1386 015f 0C       		.byte	0xc
 1387 0160 08       		.uleb128 0x8
 1388 0161 29020000 		.4byte	.LASF29
 1389 0165 02       		.byte	0x2
 1390 0166 BD11     		.2byte	0x11bd
 1391 0168 10010000 		.4byte	0x110
 1392 016c 10       		.byte	0x10
 1393 016d 00       		.byte	0
 1394 016e 05       		.uleb128 0x5
 1395 016f 35000000 		.4byte	.LASF30
 1396 0173 02       		.byte	0x2
 1397 0174 BE11     		.2byte	0x11be
 1398 0176 16010000 		.4byte	0x116
 1399 017a 09       		.uleb128 0x9
 1400 017b 98000000 		.4byte	.LASF37
 1401 017f 02       		.byte	0x2
 1402 0180 B617     		.2byte	0x17b6
 1403 0182 03       		.byte	0x3
 1404 0183 F0010000 		.4byte	0x1f0
 1405 0187 0A       		.uleb128 0xa
 1406 0188 18020000 		.4byte	.LASF31
 1407 018c 02       		.byte	0x2
 1408 018d B717     		.2byte	0x17b7
 1409 018f FE000000 		.4byte	0xfe
 1410 0193 0B       		.uleb128 0xb
 1411 0194 4C00     		.ascii	"L\000"
 1412 0196 02       		.byte	0x2
 1413 0197 B817     		.2byte	0x17b8
 1414 0199 AD000000 		.4byte	0xad
 1415 019d 0A       		.uleb128 0xa
 1416 019e 33020000 		.4byte	.LASF32
 1417 01a2 02       		.byte	0x2
 1418 01a3 B917     		.2byte	0x17b9
 1419 01a5 0A010000 		.4byte	0x10a
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 143


 1420 01a9 0A       		.uleb128 0xa
 1421 01aa EE010000 		.4byte	.LASF33
 1422 01ae 02       		.byte	0x2
 1423 01af BA17     		.2byte	0x17ba
 1424 01b1 AD000000 		.4byte	0xad
 1425 01b5 0B       		.uleb128 0xb
 1426 01b6 73726300 		.ascii	"src\000"
 1427 01ba 02       		.byte	0x2
 1428 01bb BB17     		.2byte	0x17bb
 1429 01bd F0010000 		.4byte	0x1f0
 1430 01c1 0A       		.uleb128 0xa
 1431 01c2 BB000000 		.4byte	.LASF34
 1432 01c6 02       		.byte	0x2
 1433 01c7 BC17     		.2byte	0x17bc
 1434 01c9 AD000000 		.4byte	0xad
 1435 01cd 0A       		.uleb128 0xa
 1436 01ce 2D030000 		.4byte	.LASF35
 1437 01d2 02       		.byte	0x2
 1438 01d3 BD17     		.2byte	0x17bd
 1439 01d5 B8000000 		.4byte	0xb8
 1440 01d9 0C       		.uleb128 0xc
 1441 01da 6900     		.ascii	"i\000"
 1442 01dc 02       		.byte	0x2
 1443 01dd BF17     		.2byte	0x17bf
 1444 01df B8000000 		.4byte	0xb8
 1445 01e3 0D       		.uleb128 0xd
 1446 01e4 4D030000 		.4byte	.LASF36
 1447 01e8 02       		.byte	0x2
 1448 01e9 C017     		.2byte	0x17c0
 1449 01eb AD000000 		.4byte	0xad
 1450 01ef 00       		.byte	0
 1451 01f0 06       		.uleb128 0x6
 1452 01f1 04       		.byte	0x4
 1453 01f2 F6010000 		.4byte	0x1f6
 1454 01f6 0E       		.uleb128 0xe
 1455 01f7 E6000000 		.4byte	0xe6
 1456 01fb 09       		.uleb128 0x9
 1457 01fc F2000000 		.4byte	.LASF38
 1458 0200 02       		.byte	0x2
 1459 0201 E217     		.2byte	0x17e2
 1460 0203 03       		.byte	0x3
 1461 0204 95020000 		.4byte	0x295
 1462 0208 0A       		.uleb128 0xa
 1463 0209 18020000 		.4byte	.LASF31
 1464 020d 02       		.byte	0x2
 1465 020e E317     		.2byte	0x17e3
 1466 0210 FE000000 		.4byte	0xfe
 1467 0214 0B       		.uleb128 0xb
 1468 0215 4C00     		.ascii	"L\000"
 1469 0217 02       		.byte	0x2
 1470 0218 E417     		.2byte	0x17e4
 1471 021a AD000000 		.4byte	0xad
 1472 021e 0A       		.uleb128 0xa
 1473 021f 1F010000 		.4byte	.LASF39
 1474 0223 02       		.byte	0x2
 1475 0224 E517     		.2byte	0x17e5
 1476 0226 10010000 		.4byte	0x110
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 144


 1477 022a 0A       		.uleb128 0xa
 1478 022b EE010000 		.4byte	.LASF33
 1479 022f 02       		.byte	0x2
 1480 0230 E617     		.2byte	0x17e6
 1481 0232 AD000000 		.4byte	0xad
 1482 0236 0B       		.uleb128 0xb
 1483 0237 64737400 		.ascii	"dst\000"
 1484 023b 02       		.byte	0x2
 1485 023c E717     		.2byte	0x17e7
 1486 023e FE000000 		.4byte	0xfe
 1487 0242 0A       		.uleb128 0xa
 1488 0243 E9000000 		.4byte	.LASF40
 1489 0247 02       		.byte	0x2
 1490 0248 E817     		.2byte	0x17e8
 1491 024a FE000000 		.4byte	0xfe
 1492 024e 0A       		.uleb128 0xa
 1493 024f 1B030000 		.4byte	.LASF41
 1494 0253 02       		.byte	0x2
 1495 0254 E917     		.2byte	0x17e9
 1496 0256 AD000000 		.4byte	0xad
 1497 025a 0A       		.uleb128 0xa
 1498 025b 3F020000 		.4byte	.LASF42
 1499 025f 02       		.byte	0x2
 1500 0260 EA17     		.2byte	0x17ea
 1501 0262 AD000000 		.4byte	0xad
 1502 0266 0A       		.uleb128 0xa
 1503 0267 2D030000 		.4byte	.LASF35
 1504 026b 02       		.byte	0x2
 1505 026c EB17     		.2byte	0x17eb
 1506 026e B8000000 		.4byte	0xb8
 1507 0272 0C       		.uleb128 0xc
 1508 0273 6900     		.ascii	"i\000"
 1509 0275 02       		.byte	0x2
 1510 0276 ED17     		.2byte	0x17ed
 1511 0278 B8000000 		.4byte	0xb8
 1512 027c 0D       		.uleb128 0xd
 1513 027d E1010000 		.4byte	.LASF43
 1514 0281 02       		.byte	0x2
 1515 0282 EE17     		.2byte	0x17ee
 1516 0284 AD000000 		.4byte	0xad
 1517 0288 0D       		.uleb128 0xd
 1518 0289 37030000 		.4byte	.LASF44
 1519 028d 02       		.byte	0x2
 1520 028e EE17     		.2byte	0x17ee
 1521 0290 AD000000 		.4byte	0xad
 1522 0294 00       		.byte	0
 1523 0295 0F       		.uleb128 0xf
 1524 0296 2E000000 		.4byte	.LASF61
 1525 029a 02       		.byte	0x2
 1526 029b B402     		.2byte	0x2b4
 1527 029d F2000000 		.4byte	0xf2
 1528 02a1 03       		.byte	0x3
 1529 02a2 DD020000 		.4byte	0x2dd
 1530 02a6 0B       		.uleb128 0xb
 1531 02a7 7800     		.ascii	"x\000"
 1532 02a9 02       		.byte	0x2
 1533 02aa B502     		.2byte	0x2b5
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 145


 1534 02ac F2000000 		.4byte	0xf2
 1535 02b0 0B       		.uleb128 0xb
 1536 02b1 7900     		.ascii	"y\000"
 1537 02b3 02       		.byte	0x2
 1538 02b4 B602     		.2byte	0x2b6
 1539 02b6 B8000000 		.4byte	0xb8
 1540 02ba 0D       		.uleb128 0xd
 1541 02bb D3020000 		.4byte	.LASF45
 1542 02bf 02       		.byte	0x2
 1543 02c0 B802     		.2byte	0x2b8
 1544 02c2 AD000000 		.4byte	0xad
 1545 02c6 0D       		.uleb128 0xd
 1546 02c7 50000000 		.4byte	.LASF46
 1547 02cb 02       		.byte	0x2
 1548 02cc B802     		.2byte	0x2b8
 1549 02ce AD000000 		.4byte	0xad
 1550 02d2 0C       		.uleb128 0xc
 1551 02d3 6900     		.ascii	"i\000"
 1552 02d5 02       		.byte	0x2
 1553 02d6 B902     		.2byte	0x2b9
 1554 02d8 B8000000 		.4byte	0xb8
 1555 02dc 00       		.byte	0
 1556 02dd 10       		.uleb128 0x10
 1557 02de DF020000 		.4byte	.LASF62
 1558 02e2 01       		.byte	0x1
 1559 02e3 3E       		.byte	0x3e
 1560 02e4 00000000 		.4byte	.LFB82
 1561 02e8 BC070000 		.4byte	.LFE82-.LFB82
 1562 02ec 01       		.uleb128 0x1
 1563 02ed 9C       		.byte	0x9c
 1564 02ee 71060000 		.4byte	0x671
 1565 02f2 11       		.uleb128 0x11
 1566 02f3 5300     		.ascii	"S\000"
 1567 02f5 01       		.byte	0x1
 1568 02f6 3F       		.byte	0x3f
 1569 02f7 71060000 		.4byte	0x671
 1570 02fb 03       		.uleb128 0x3
 1571 02fc 91       		.byte	0x91
 1572 02fd EC7D     		.sleb128 -276
 1573 02ff 12       		.uleb128 0x12
 1574 0300 13010000 		.4byte	.LASF47
 1575 0304 01       		.byte	0x1
 1576 0305 40       		.byte	0x40
 1577 0306 FE000000 		.4byte	0xfe
 1578 030a 03       		.uleb128 0x3
 1579 030b 91       		.byte	0x91
 1580 030c E87D     		.sleb128 -280
 1581 030e 12       		.uleb128 0x12
 1582 030f B6000000 		.4byte	.LASF48
 1583 0313 01       		.byte	0x1
 1584 0314 41       		.byte	0x41
 1585 0315 FE000000 		.4byte	0xfe
 1586 0319 03       		.uleb128 0x3
 1587 031a 91       		.byte	0x91
 1588 031b E47D     		.sleb128 -284
 1589 031d 12       		.uleb128 0x12
 1590 031e 55030000 		.4byte	.LASF49
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 146


 1591 0322 01       		.byte	0x1
 1592 0323 42       		.byte	0x42
 1593 0324 FE000000 		.4byte	0xfe
 1594 0328 03       		.uleb128 0x3
 1595 0329 91       		.byte	0x91
 1596 032a E07D     		.sleb128 -288
 1597 032c 12       		.uleb128 0x12
 1598 032d D2000000 		.4byte	.LASF50
 1599 0331 01       		.byte	0x1
 1600 0332 43       		.byte	0x43
 1601 0333 04010000 		.4byte	0x104
 1602 0337 02       		.uleb128 0x2
 1603 0338 91       		.byte	0x91
 1604 0339 00       		.sleb128 0
 1605 033a 12       		.uleb128 0x12
 1606 033b 2D030000 		.4byte	.LASF35
 1607 033f 01       		.byte	0x1
 1608 0340 44       		.byte	0x44
 1609 0341 B8000000 		.4byte	0xb8
 1610 0345 02       		.uleb128 0x2
 1611 0346 91       		.byte	0x91
 1612 0347 04       		.sleb128 4
 1613 0348 13       		.uleb128 0x13
 1614 0349 5C020000 		.4byte	.LASF26
 1615 034d 01       		.byte	0x1
 1616 034e 47       		.byte	0x47
 1617 034f FE000000 		.4byte	0xfe
 1618 0353 02       		.uleb128 0x2
 1619 0354 91       		.byte	0x91
 1620 0355 54       		.sleb128 -44
 1621 0356 13       		.uleb128 0x13
 1622 0357 45030000 		.4byte	.LASF27
 1623 035b 01       		.byte	0x1
 1624 035c 48       		.byte	0x48
 1625 035d FE000000 		.4byte	0xfe
 1626 0361 02       		.uleb128 0x2
 1627 0362 91       		.byte	0x91
 1628 0363 74       		.sleb128 -12
 1629 0364 14       		.uleb128 0x14
 1630 0365 707800   		.ascii	"px\000"
 1631 0368 01       		.byte	0x1
 1632 0369 49       		.byte	0x49
 1633 036a FE000000 		.4byte	0xfe
 1634 036e 02       		.uleb128 0x2
 1635 036f 91       		.byte	0x91
 1636 0370 70       		.sleb128 -16
 1637 0371 14       		.uleb128 0x14
 1638 0372 707900   		.ascii	"py\000"
 1639 0375 01       		.byte	0x1
 1640 0376 4A       		.byte	0x4a
 1641 0377 FE000000 		.4byte	0xfe
 1642 037b 02       		.uleb128 0x2
 1643 037c 91       		.byte	0x91
 1644 037d 50       		.sleb128 -48
 1645 037e 14       		.uleb128 0x14
 1646 037f 706200   		.ascii	"pb\000"
 1647 0382 01       		.byte	0x1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 147


 1648 0383 4B       		.byte	0x4b
 1649 0384 FE000000 		.4byte	0xfe
 1650 0388 02       		.uleb128 0x2
 1651 0389 91       		.byte	0x91
 1652 038a 4C       		.sleb128 -52
 1653 038b 13       		.uleb128 0x13
 1654 038c E9010000 		.4byte	.LASF51
 1655 0390 01       		.byte	0x1
 1656 0391 4C       		.byte	0x4c
 1657 0392 FE000000 		.4byte	0xfe
 1658 0396 02       		.uleb128 0x2
 1659 0397 91       		.byte	0x91
 1660 0398 6C       		.sleb128 -20
 1661 0399 13       		.uleb128 0x13
 1662 039a 29020000 		.4byte	.LASF29
 1663 039e 01       		.byte	0x1
 1664 039f 4D       		.byte	0x4d
 1665 03a0 10010000 		.4byte	0x110
 1666 03a4 02       		.uleb128 0x2
 1667 03a5 91       		.byte	0x91
 1668 03a6 68       		.sleb128 -24
 1669 03a7 13       		.uleb128 0x13
 1670 03a8 60030000 		.4byte	.LASF52
 1671 03ac 01       		.byte	0x1
 1672 03ad 4E       		.byte	0x4e
 1673 03ae B8000000 		.4byte	0xb8
 1674 03b2 02       		.uleb128 0x2
 1675 03b3 91       		.byte	0x91
 1676 03b4 48       		.sleb128 -56
 1677 03b5 13       		.uleb128 0x13
 1678 03b6 BC020000 		.4byte	.LASF24
 1679 03ba 01       		.byte	0x1
 1680 03bb 4F       		.byte	0x4f
 1681 03bc A2000000 		.4byte	0xa2
 1682 03c0 02       		.uleb128 0x2
 1683 03c1 91       		.byte	0x91
 1684 03c2 46       		.sleb128 -58
 1685 03c3 13       		.uleb128 0x13
 1686 03c4 06030000 		.4byte	.LASF53
 1687 03c8 01       		.byte	0x1
 1688 03c9 50       		.byte	0x50
 1689 03ca AD000000 		.4byte	0xad
 1690 03ce 03       		.uleb128 0x3
 1691 03cf 91       		.byte	0x91
 1692 03d0 F47D     		.sleb128 -268
 1693 03d2 13       		.uleb128 0x13
 1694 03d3 18010000 		.4byte	.LASF54
 1695 03d7 01       		.byte	0x1
 1696 03d8 51       		.byte	0x51
 1697 03d9 B8000000 		.4byte	0xb8
 1698 03dd 02       		.uleb128 0x2
 1699 03de 91       		.byte	0x91
 1700 03df 64       		.sleb128 -28
 1701 03e0 13       		.uleb128 0x13
 1702 03e1 6E000000 		.4byte	.LASF55
 1703 03e5 01       		.byte	0x1
 1704 03e6 51       		.byte	0x51
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 148


 1705 03e7 B8000000 		.4byte	0xb8
 1706 03eb 02       		.uleb128 0x2
 1707 03ec 91       		.byte	0x91
 1708 03ed 60       		.sleb128 -32
 1709 03ee 13       		.uleb128 0x13
 1710 03ef 10030000 		.4byte	.LASF56
 1711 03f3 01       		.byte	0x1
 1712 03f4 52       		.byte	0x52
 1713 03f5 E6000000 		.4byte	0xe6
 1714 03f9 02       		.uleb128 0x2
 1715 03fa 91       		.byte	0x91
 1716 03fb 5F       		.sleb128 -33
 1717 03fc 13       		.uleb128 0x13
 1718 03fd 3F030000 		.4byte	.LASF57
 1719 0401 01       		.byte	0x1
 1720 0402 53       		.byte	0x53
 1721 0403 04010000 		.4byte	0x104
 1722 0407 02       		.uleb128 0x2
 1723 0408 91       		.byte	0x91
 1724 0409 58       		.sleb128 -40
 1725 040a 14       		.uleb128 0x14
 1726 040b 696E00   		.ascii	"in\000"
 1727 040e 01       		.byte	0x1
 1728 040f 54       		.byte	0x54
 1729 0410 F2000000 		.4byte	0xf2
 1730 0414 02       		.uleb128 0x2
 1731 0415 91       		.byte	0x91
 1732 0416 40       		.sleb128 -64
 1733 0417 15       		.uleb128 0x15
 1734 0418 7A010000 		.4byte	0x17a
 1735 041c DE000000 		.4byte	.LBB12
 1736 0420 B0000000 		.4byte	.LBE12-.LBB12
 1737 0424 01       		.byte	0x1
 1738 0425 4001     		.2byte	0x140
 1739 0427 87040000 		.4byte	0x487
 1740 042b 16       		.uleb128 0x16
 1741 042c CD010000 		.4byte	0x1cd
 1742 0430 03       		.uleb128 0x3
 1743 0431 91       		.byte	0x91
 1744 0432 A47F     		.sleb128 -92
 1745 0434 16       		.uleb128 0x16
 1746 0435 C1010000 		.4byte	0x1c1
 1747 0439 03       		.uleb128 0x3
 1748 043a 91       		.byte	0x91
 1749 043b A87F     		.sleb128 -88
 1750 043d 16       		.uleb128 0x16
 1751 043e B5010000 		.4byte	0x1b5
 1752 0442 03       		.uleb128 0x3
 1753 0443 91       		.byte	0x91
 1754 0444 AC7F     		.sleb128 -84
 1755 0446 16       		.uleb128 0x16
 1756 0447 A9010000 		.4byte	0x1a9
 1757 044b 03       		.uleb128 0x3
 1758 044c 91       		.byte	0x91
 1759 044d B07F     		.sleb128 -80
 1760 044f 16       		.uleb128 0x16
 1761 0450 9D010000 		.4byte	0x19d
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 149


 1762 0454 03       		.uleb128 0x3
 1763 0455 91       		.byte	0x91
 1764 0456 B47F     		.sleb128 -76
 1765 0458 16       		.uleb128 0x16
 1766 0459 93010000 		.4byte	0x193
 1767 045d 03       		.uleb128 0x3
 1768 045e 91       		.byte	0x91
 1769 045f B87F     		.sleb128 -72
 1770 0461 16       		.uleb128 0x16
 1771 0462 87010000 		.4byte	0x187
 1772 0466 03       		.uleb128 0x3
 1773 0467 91       		.byte	0x91
 1774 0468 BC7F     		.sleb128 -68
 1775 046a 17       		.uleb128 0x17
 1776 046b DE000000 		.4byte	.LBB13
 1777 046f B0000000 		.4byte	.LBE13-.LBB13
 1778 0473 18       		.uleb128 0x18
 1779 0474 D9010000 		.4byte	0x1d9
 1780 0478 03       		.uleb128 0x3
 1781 0479 91       		.byte	0x91
 1782 047a A07F     		.sleb128 -96
 1783 047c 18       		.uleb128 0x18
 1784 047d E3010000 		.4byte	0x1e3
 1785 0481 03       		.uleb128 0x3
 1786 0482 91       		.byte	0x91
 1787 0483 9C7F     		.sleb128 -100
 1788 0485 00       		.byte	0
 1789 0486 00       		.byte	0
 1790 0487 15       		.uleb128 0x15
 1791 0488 FB010000 		.4byte	0x1fb
 1792 048c 46020000 		.4byte	.LBB14
 1793 0490 DE000000 		.4byte	.LBE14-.LBB14
 1794 0494 01       		.byte	0x1
 1795 0495 5301     		.2byte	0x153
 1796 0497 12050000 		.4byte	0x512
 1797 049b 16       		.uleb128 0x16
 1798 049c 66020000 		.4byte	0x266
 1799 04a0 03       		.uleb128 0x3
 1800 04a1 91       		.byte	0x91
 1801 04a2 F87E     		.sleb128 -136
 1802 04a4 16       		.uleb128 0x16
 1803 04a5 5A020000 		.4byte	0x25a
 1804 04a9 03       		.uleb128 0x3
 1805 04aa 91       		.byte	0x91
 1806 04ab FC7E     		.sleb128 -132
 1807 04ad 16       		.uleb128 0x16
 1808 04ae 4E020000 		.4byte	0x24e
 1809 04b2 03       		.uleb128 0x3
 1810 04b3 91       		.byte	0x91
 1811 04b4 807F     		.sleb128 -128
 1812 04b6 16       		.uleb128 0x16
 1813 04b7 42020000 		.4byte	0x242
 1814 04bb 03       		.uleb128 0x3
 1815 04bc 91       		.byte	0x91
 1816 04bd 847F     		.sleb128 -124
 1817 04bf 16       		.uleb128 0x16
 1818 04c0 36020000 		.4byte	0x236
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 150


 1819 04c4 03       		.uleb128 0x3
 1820 04c5 91       		.byte	0x91
 1821 04c6 887F     		.sleb128 -120
 1822 04c8 16       		.uleb128 0x16
 1823 04c9 2A020000 		.4byte	0x22a
 1824 04cd 03       		.uleb128 0x3
 1825 04ce 91       		.byte	0x91
 1826 04cf 8C7F     		.sleb128 -116
 1827 04d1 16       		.uleb128 0x16
 1828 04d2 1E020000 		.4byte	0x21e
 1829 04d6 03       		.uleb128 0x3
 1830 04d7 91       		.byte	0x91
 1831 04d8 907F     		.sleb128 -112
 1832 04da 16       		.uleb128 0x16
 1833 04db 14020000 		.4byte	0x214
 1834 04df 03       		.uleb128 0x3
 1835 04e0 91       		.byte	0x91
 1836 04e1 947F     		.sleb128 -108
 1837 04e3 16       		.uleb128 0x16
 1838 04e4 08020000 		.4byte	0x208
 1839 04e8 03       		.uleb128 0x3
 1840 04e9 91       		.byte	0x91
 1841 04ea 987F     		.sleb128 -104
 1842 04ec 17       		.uleb128 0x17
 1843 04ed 46020000 		.4byte	.LBB15
 1844 04f1 DE000000 		.4byte	.LBE15-.LBB15
 1845 04f5 18       		.uleb128 0x18
 1846 04f6 72020000 		.4byte	0x272
 1847 04fa 03       		.uleb128 0x3
 1848 04fb 91       		.byte	0x91
 1849 04fc F47E     		.sleb128 -140
 1850 04fe 18       		.uleb128 0x18
 1851 04ff 7C020000 		.4byte	0x27c
 1852 0503 03       		.uleb128 0x3
 1853 0504 91       		.byte	0x91
 1854 0505 F07E     		.sleb128 -144
 1855 0507 18       		.uleb128 0x18
 1856 0508 88020000 		.4byte	0x288
 1857 050c 03       		.uleb128 0x3
 1858 050d 91       		.byte	0x91
 1859 050e EC7E     		.sleb128 -148
 1860 0510 00       		.byte	0
 1861 0511 00       		.byte	0
 1862 0512 15       		.uleb128 0x15
 1863 0513 FB010000 		.4byte	0x1fb
 1864 0517 5A040000 		.4byte	.LBB16
 1865 051b 76000000 		.4byte	.LBE16-.LBB16
 1866 051f 01       		.byte	0x1
 1867 0520 7E01     		.2byte	0x17e
 1868 0522 9D050000 		.4byte	0x59d
 1869 0526 16       		.uleb128 0x16
 1870 0527 66020000 		.4byte	0x266
 1871 052b 03       		.uleb128 0x3
 1872 052c 91       		.byte	0x91
 1873 052d C87E     		.sleb128 -184
 1874 052f 16       		.uleb128 0x16
 1875 0530 5A020000 		.4byte	0x25a
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 151


 1876 0534 03       		.uleb128 0x3
 1877 0535 91       		.byte	0x91
 1878 0536 CC7E     		.sleb128 -180
 1879 0538 16       		.uleb128 0x16
 1880 0539 4E020000 		.4byte	0x24e
 1881 053d 03       		.uleb128 0x3
 1882 053e 91       		.byte	0x91
 1883 053f D07E     		.sleb128 -176
 1884 0541 16       		.uleb128 0x16
 1885 0542 42020000 		.4byte	0x242
 1886 0546 03       		.uleb128 0x3
 1887 0547 91       		.byte	0x91
 1888 0548 D47E     		.sleb128 -172
 1889 054a 16       		.uleb128 0x16
 1890 054b 36020000 		.4byte	0x236
 1891 054f 03       		.uleb128 0x3
 1892 0550 91       		.byte	0x91
 1893 0551 D87E     		.sleb128 -168
 1894 0553 16       		.uleb128 0x16
 1895 0554 2A020000 		.4byte	0x22a
 1896 0558 03       		.uleb128 0x3
 1897 0559 91       		.byte	0x91
 1898 055a DC7E     		.sleb128 -164
 1899 055c 16       		.uleb128 0x16
 1900 055d 1E020000 		.4byte	0x21e
 1901 0561 03       		.uleb128 0x3
 1902 0562 91       		.byte	0x91
 1903 0563 E07E     		.sleb128 -160
 1904 0565 16       		.uleb128 0x16
 1905 0566 14020000 		.4byte	0x214
 1906 056a 03       		.uleb128 0x3
 1907 056b 91       		.byte	0x91
 1908 056c E47E     		.sleb128 -156
 1909 056e 16       		.uleb128 0x16
 1910 056f 08020000 		.4byte	0x208
 1911 0573 03       		.uleb128 0x3
 1912 0574 91       		.byte	0x91
 1913 0575 E87E     		.sleb128 -152
 1914 0577 17       		.uleb128 0x17
 1915 0578 5A040000 		.4byte	.LBB17
 1916 057c 76000000 		.4byte	.LBE17-.LBB17
 1917 0580 18       		.uleb128 0x18
 1918 0581 72020000 		.4byte	0x272
 1919 0585 03       		.uleb128 0x3
 1920 0586 91       		.byte	0x91
 1921 0587 C47E     		.sleb128 -188
 1922 0589 18       		.uleb128 0x18
 1923 058a 7C020000 		.4byte	0x27c
 1924 058e 03       		.uleb128 0x3
 1925 058f 91       		.byte	0x91
 1926 0590 C07E     		.sleb128 -192
 1927 0592 18       		.uleb128 0x18
 1928 0593 88020000 		.4byte	0x288
 1929 0597 03       		.uleb128 0x3
 1930 0598 91       		.byte	0x91
 1931 0599 BC7E     		.sleb128 -196
 1932 059b 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 152


 1933 059c 00       		.byte	0
 1934 059d 15       		.uleb128 0x15
 1935 059e FB010000 		.4byte	0x1fb
 1936 05a2 1C060000 		.4byte	.LBB18
 1937 05a6 62000000 		.4byte	.LBE18-.LBB18
 1938 05aa 01       		.byte	0x1
 1939 05ab AC01     		.2byte	0x1ac
 1940 05ad 28060000 		.4byte	0x628
 1941 05b1 16       		.uleb128 0x16
 1942 05b2 66020000 		.4byte	0x266
 1943 05b6 03       		.uleb128 0x3
 1944 05b7 91       		.byte	0x91
 1945 05b8 987E     		.sleb128 -232
 1946 05ba 16       		.uleb128 0x16
 1947 05bb 5A020000 		.4byte	0x25a
 1948 05bf 03       		.uleb128 0x3
 1949 05c0 91       		.byte	0x91
 1950 05c1 9C7E     		.sleb128 -228
 1951 05c3 16       		.uleb128 0x16
 1952 05c4 4E020000 		.4byte	0x24e
 1953 05c8 03       		.uleb128 0x3
 1954 05c9 91       		.byte	0x91
 1955 05ca A07E     		.sleb128 -224
 1956 05cc 16       		.uleb128 0x16
 1957 05cd 42020000 		.4byte	0x242
 1958 05d1 03       		.uleb128 0x3
 1959 05d2 91       		.byte	0x91
 1960 05d3 A47E     		.sleb128 -220
 1961 05d5 16       		.uleb128 0x16
 1962 05d6 36020000 		.4byte	0x236
 1963 05da 03       		.uleb128 0x3
 1964 05db 91       		.byte	0x91
 1965 05dc A87E     		.sleb128 -216
 1966 05de 16       		.uleb128 0x16
 1967 05df 2A020000 		.4byte	0x22a
 1968 05e3 03       		.uleb128 0x3
 1969 05e4 91       		.byte	0x91
 1970 05e5 AC7E     		.sleb128 -212
 1971 05e7 16       		.uleb128 0x16
 1972 05e8 1E020000 		.4byte	0x21e
 1973 05ec 03       		.uleb128 0x3
 1974 05ed 91       		.byte	0x91
 1975 05ee B07E     		.sleb128 -208
 1976 05f0 16       		.uleb128 0x16
 1977 05f1 14020000 		.4byte	0x214
 1978 05f5 03       		.uleb128 0x3
 1979 05f6 91       		.byte	0x91
 1980 05f7 B47E     		.sleb128 -204
 1981 05f9 16       		.uleb128 0x16
 1982 05fa 08020000 		.4byte	0x208
 1983 05fe 03       		.uleb128 0x3
 1984 05ff 91       		.byte	0x91
 1985 0600 B87E     		.sleb128 -200
 1986 0602 17       		.uleb128 0x17
 1987 0603 1C060000 		.4byte	.LBB19
 1988 0607 62000000 		.4byte	.LBE19-.LBB19
 1989 060b 18       		.uleb128 0x18
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 153


 1990 060c 72020000 		.4byte	0x272
 1991 0610 03       		.uleb128 0x3
 1992 0611 91       		.byte	0x91
 1993 0612 947E     		.sleb128 -236
 1994 0614 18       		.uleb128 0x18
 1995 0615 7C020000 		.4byte	0x27c
 1996 0619 03       		.uleb128 0x3
 1997 061a 91       		.byte	0x91
 1998 061b 907E     		.sleb128 -240
 1999 061d 18       		.uleb128 0x18
 2000 061e 88020000 		.4byte	0x288
 2001 0622 03       		.uleb128 0x3
 2002 0623 91       		.byte	0x91
 2003 0624 8C7E     		.sleb128 -244
 2004 0626 00       		.byte	0
 2005 0627 00       		.byte	0
 2006 0628 19       		.uleb128 0x19
 2007 0629 95020000 		.4byte	0x295
 2008 062d 48070000 		.4byte	.LBB20
 2009 0631 52000000 		.4byte	.LBE20-.LBB20
 2010 0635 01       		.byte	0x1
 2011 0636 C901     		.2byte	0x1c9
 2012 0638 16       		.uleb128 0x16
 2013 0639 B0020000 		.4byte	0x2b0
 2014 063d 03       		.uleb128 0x3
 2015 063e 91       		.byte	0x91
 2016 063f 847E     		.sleb128 -252
 2017 0641 16       		.uleb128 0x16
 2018 0642 A6020000 		.4byte	0x2a6
 2019 0646 03       		.uleb128 0x3
 2020 0647 91       		.byte	0x91
 2021 0648 887E     		.sleb128 -248
 2022 064a 17       		.uleb128 0x17
 2023 064b 48070000 		.4byte	.LBB21
 2024 064f 52000000 		.4byte	.LBE21-.LBB21
 2025 0653 18       		.uleb128 0x18
 2026 0654 BA020000 		.4byte	0x2ba
 2027 0658 03       		.uleb128 0x3
 2028 0659 91       		.byte	0x91
 2029 065a 807E     		.sleb128 -256
 2030 065c 18       		.uleb128 0x18
 2031 065d C6020000 		.4byte	0x2c6
 2032 0661 03       		.uleb128 0x3
 2033 0662 91       		.byte	0x91
 2034 0663 F87D     		.sleb128 -264
 2035 0665 18       		.uleb128 0x18
 2036 0666 D2020000 		.4byte	0x2d2
 2037 066a 03       		.uleb128 0x3
 2038 066b 91       		.byte	0x91
 2039 066c FC7D     		.sleb128 -260
 2040 066e 00       		.byte	0
 2041 066f 00       		.byte	0
 2042 0670 00       		.byte	0
 2043 0671 06       		.uleb128 0x6
 2044 0672 04       		.byte	0x4
 2045 0673 6E010000 		.4byte	0x16e
 2046 0677 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 154


 2047              		.section	.debug_abbrev,"",%progbits
 2048              	.Ldebug_abbrev0:
 2049 0000 01       		.uleb128 0x1
 2050 0001 11       		.uleb128 0x11
 2051 0002 01       		.byte	0x1
 2052 0003 25       		.uleb128 0x25
 2053 0004 0E       		.uleb128 0xe
 2054 0005 13       		.uleb128 0x13
 2055 0006 0B       		.uleb128 0xb
 2056 0007 03       		.uleb128 0x3
 2057 0008 0E       		.uleb128 0xe
 2058 0009 1B       		.uleb128 0x1b
 2059 000a 0E       		.uleb128 0xe
 2060 000b 55       		.uleb128 0x55
 2061 000c 17       		.uleb128 0x17
 2062 000d 11       		.uleb128 0x11
 2063 000e 01       		.uleb128 0x1
 2064 000f 10       		.uleb128 0x10
 2065 0010 17       		.uleb128 0x17
 2066 0011 00       		.byte	0
 2067 0012 00       		.byte	0
 2068 0013 02       		.uleb128 0x2
 2069 0014 16       		.uleb128 0x16
 2070 0015 00       		.byte	0
 2071 0016 03       		.uleb128 0x3
 2072 0017 0E       		.uleb128 0xe
 2073 0018 3A       		.uleb128 0x3a
 2074 0019 0B       		.uleb128 0xb
 2075 001a 3B       		.uleb128 0x3b
 2076 001b 0B       		.uleb128 0xb
 2077 001c 49       		.uleb128 0x49
 2078 001d 13       		.uleb128 0x13
 2079 001e 00       		.byte	0
 2080 001f 00       		.byte	0
 2081 0020 03       		.uleb128 0x3
 2082 0021 24       		.uleb128 0x24
 2083 0022 00       		.byte	0
 2084 0023 0B       		.uleb128 0xb
 2085 0024 0B       		.uleb128 0xb
 2086 0025 3E       		.uleb128 0x3e
 2087 0026 0B       		.uleb128 0xb
 2088 0027 03       		.uleb128 0x3
 2089 0028 0E       		.uleb128 0xe
 2090 0029 00       		.byte	0
 2091 002a 00       		.byte	0
 2092 002b 04       		.uleb128 0x4
 2093 002c 24       		.uleb128 0x24
 2094 002d 00       		.byte	0
 2095 002e 0B       		.uleb128 0xb
 2096 002f 0B       		.uleb128 0xb
 2097 0030 3E       		.uleb128 0x3e
 2098 0031 0B       		.uleb128 0xb
 2099 0032 03       		.uleb128 0x3
 2100 0033 08       		.uleb128 0x8
 2101 0034 00       		.byte	0
 2102 0035 00       		.byte	0
 2103 0036 05       		.uleb128 0x5
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 155


 2104 0037 16       		.uleb128 0x16
 2105 0038 00       		.byte	0
 2106 0039 03       		.uleb128 0x3
 2107 003a 0E       		.uleb128 0xe
 2108 003b 3A       		.uleb128 0x3a
 2109 003c 0B       		.uleb128 0xb
 2110 003d 3B       		.uleb128 0x3b
 2111 003e 05       		.uleb128 0x5
 2112 003f 49       		.uleb128 0x49
 2113 0040 13       		.uleb128 0x13
 2114 0041 00       		.byte	0
 2115 0042 00       		.byte	0
 2116 0043 06       		.uleb128 0x6
 2117 0044 0F       		.uleb128 0xf
 2118 0045 00       		.byte	0
 2119 0046 0B       		.uleb128 0xb
 2120 0047 0B       		.uleb128 0xb
 2121 0048 49       		.uleb128 0x49
 2122 0049 13       		.uleb128 0x13
 2123 004a 00       		.byte	0
 2124 004b 00       		.byte	0
 2125 004c 07       		.uleb128 0x7
 2126 004d 13       		.uleb128 0x13
 2127 004e 01       		.byte	0x1
 2128 004f 0B       		.uleb128 0xb
 2129 0050 0B       		.uleb128 0xb
 2130 0051 3A       		.uleb128 0x3a
 2131 0052 0B       		.uleb128 0xb
 2132 0053 3B       		.uleb128 0x3b
 2133 0054 05       		.uleb128 0x5
 2134 0055 01       		.uleb128 0x1
 2135 0056 13       		.uleb128 0x13
 2136 0057 00       		.byte	0
 2137 0058 00       		.byte	0
 2138 0059 08       		.uleb128 0x8
 2139 005a 0D       		.uleb128 0xd
 2140 005b 00       		.byte	0
 2141 005c 03       		.uleb128 0x3
 2142 005d 0E       		.uleb128 0xe
 2143 005e 3A       		.uleb128 0x3a
 2144 005f 0B       		.uleb128 0xb
 2145 0060 3B       		.uleb128 0x3b
 2146 0061 05       		.uleb128 0x5
 2147 0062 49       		.uleb128 0x49
 2148 0063 13       		.uleb128 0x13
 2149 0064 38       		.uleb128 0x38
 2150 0065 0B       		.uleb128 0xb
 2151 0066 00       		.byte	0
 2152 0067 00       		.byte	0
 2153 0068 09       		.uleb128 0x9
 2154 0069 2E       		.uleb128 0x2e
 2155 006a 01       		.byte	0x1
 2156 006b 03       		.uleb128 0x3
 2157 006c 0E       		.uleb128 0xe
 2158 006d 3A       		.uleb128 0x3a
 2159 006e 0B       		.uleb128 0xb
 2160 006f 3B       		.uleb128 0x3b
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 156


 2161 0070 05       		.uleb128 0x5
 2162 0071 27       		.uleb128 0x27
 2163 0072 19       		.uleb128 0x19
 2164 0073 20       		.uleb128 0x20
 2165 0074 0B       		.uleb128 0xb
 2166 0075 01       		.uleb128 0x1
 2167 0076 13       		.uleb128 0x13
 2168 0077 00       		.byte	0
 2169 0078 00       		.byte	0
 2170 0079 0A       		.uleb128 0xa
 2171 007a 05       		.uleb128 0x5
 2172 007b 00       		.byte	0
 2173 007c 03       		.uleb128 0x3
 2174 007d 0E       		.uleb128 0xe
 2175 007e 3A       		.uleb128 0x3a
 2176 007f 0B       		.uleb128 0xb
 2177 0080 3B       		.uleb128 0x3b
 2178 0081 05       		.uleb128 0x5
 2179 0082 49       		.uleb128 0x49
 2180 0083 13       		.uleb128 0x13
 2181 0084 00       		.byte	0
 2182 0085 00       		.byte	0
 2183 0086 0B       		.uleb128 0xb
 2184 0087 05       		.uleb128 0x5
 2185 0088 00       		.byte	0
 2186 0089 03       		.uleb128 0x3
 2187 008a 08       		.uleb128 0x8
 2188 008b 3A       		.uleb128 0x3a
 2189 008c 0B       		.uleb128 0xb
 2190 008d 3B       		.uleb128 0x3b
 2191 008e 05       		.uleb128 0x5
 2192 008f 49       		.uleb128 0x49
 2193 0090 13       		.uleb128 0x13
 2194 0091 00       		.byte	0
 2195 0092 00       		.byte	0
 2196 0093 0C       		.uleb128 0xc
 2197 0094 34       		.uleb128 0x34
 2198 0095 00       		.byte	0
 2199 0096 03       		.uleb128 0x3
 2200 0097 08       		.uleb128 0x8
 2201 0098 3A       		.uleb128 0x3a
 2202 0099 0B       		.uleb128 0xb
 2203 009a 3B       		.uleb128 0x3b
 2204 009b 05       		.uleb128 0x5
 2205 009c 49       		.uleb128 0x49
 2206 009d 13       		.uleb128 0x13
 2207 009e 00       		.byte	0
 2208 009f 00       		.byte	0
 2209 00a0 0D       		.uleb128 0xd
 2210 00a1 34       		.uleb128 0x34
 2211 00a2 00       		.byte	0
 2212 00a3 03       		.uleb128 0x3
 2213 00a4 0E       		.uleb128 0xe
 2214 00a5 3A       		.uleb128 0x3a
 2215 00a6 0B       		.uleb128 0xb
 2216 00a7 3B       		.uleb128 0x3b
 2217 00a8 05       		.uleb128 0x5
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 157


 2218 00a9 49       		.uleb128 0x49
 2219 00aa 13       		.uleb128 0x13
 2220 00ab 00       		.byte	0
 2221 00ac 00       		.byte	0
 2222 00ad 0E       		.uleb128 0xe
 2223 00ae 26       		.uleb128 0x26
 2224 00af 00       		.byte	0
 2225 00b0 49       		.uleb128 0x49
 2226 00b1 13       		.uleb128 0x13
 2227 00b2 00       		.byte	0
 2228 00b3 00       		.byte	0
 2229 00b4 0F       		.uleb128 0xf
 2230 00b5 2E       		.uleb128 0x2e
 2231 00b6 01       		.byte	0x1
 2232 00b7 03       		.uleb128 0x3
 2233 00b8 0E       		.uleb128 0xe
 2234 00b9 3A       		.uleb128 0x3a
 2235 00ba 0B       		.uleb128 0xb
 2236 00bb 3B       		.uleb128 0x3b
 2237 00bc 05       		.uleb128 0x5
 2238 00bd 27       		.uleb128 0x27
 2239 00be 19       		.uleb128 0x19
 2240 00bf 49       		.uleb128 0x49
 2241 00c0 13       		.uleb128 0x13
 2242 00c1 20       		.uleb128 0x20
 2243 00c2 0B       		.uleb128 0xb
 2244 00c3 01       		.uleb128 0x1
 2245 00c4 13       		.uleb128 0x13
 2246 00c5 00       		.byte	0
 2247 00c6 00       		.byte	0
 2248 00c7 10       		.uleb128 0x10
 2249 00c8 2E       		.uleb128 0x2e
 2250 00c9 01       		.byte	0x1
 2251 00ca 3F       		.uleb128 0x3f
 2252 00cb 19       		.uleb128 0x19
 2253 00cc 03       		.uleb128 0x3
 2254 00cd 0E       		.uleb128 0xe
 2255 00ce 3A       		.uleb128 0x3a
 2256 00cf 0B       		.uleb128 0xb
 2257 00d0 3B       		.uleb128 0x3b
 2258 00d1 0B       		.uleb128 0xb
 2259 00d2 27       		.uleb128 0x27
 2260 00d3 19       		.uleb128 0x19
 2261 00d4 11       		.uleb128 0x11
 2262 00d5 01       		.uleb128 0x1
 2263 00d6 12       		.uleb128 0x12
 2264 00d7 06       		.uleb128 0x6
 2265 00d8 40       		.uleb128 0x40
 2266 00d9 18       		.uleb128 0x18
 2267 00da 9742     		.uleb128 0x2117
 2268 00dc 19       		.uleb128 0x19
 2269 00dd 01       		.uleb128 0x1
 2270 00de 13       		.uleb128 0x13
 2271 00df 00       		.byte	0
 2272 00e0 00       		.byte	0
 2273 00e1 11       		.uleb128 0x11
 2274 00e2 05       		.uleb128 0x5
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 158


 2275 00e3 00       		.byte	0
 2276 00e4 03       		.uleb128 0x3
 2277 00e5 08       		.uleb128 0x8
 2278 00e6 3A       		.uleb128 0x3a
 2279 00e7 0B       		.uleb128 0xb
 2280 00e8 3B       		.uleb128 0x3b
 2281 00e9 0B       		.uleb128 0xb
 2282 00ea 49       		.uleb128 0x49
 2283 00eb 13       		.uleb128 0x13
 2284 00ec 02       		.uleb128 0x2
 2285 00ed 18       		.uleb128 0x18
 2286 00ee 00       		.byte	0
 2287 00ef 00       		.byte	0
 2288 00f0 12       		.uleb128 0x12
 2289 00f1 05       		.uleb128 0x5
 2290 00f2 00       		.byte	0
 2291 00f3 03       		.uleb128 0x3
 2292 00f4 0E       		.uleb128 0xe
 2293 00f5 3A       		.uleb128 0x3a
 2294 00f6 0B       		.uleb128 0xb
 2295 00f7 3B       		.uleb128 0x3b
 2296 00f8 0B       		.uleb128 0xb
 2297 00f9 49       		.uleb128 0x49
 2298 00fa 13       		.uleb128 0x13
 2299 00fb 02       		.uleb128 0x2
 2300 00fc 18       		.uleb128 0x18
 2301 00fd 00       		.byte	0
 2302 00fe 00       		.byte	0
 2303 00ff 13       		.uleb128 0x13
 2304 0100 34       		.uleb128 0x34
 2305 0101 00       		.byte	0
 2306 0102 03       		.uleb128 0x3
 2307 0103 0E       		.uleb128 0xe
 2308 0104 3A       		.uleb128 0x3a
 2309 0105 0B       		.uleb128 0xb
 2310 0106 3B       		.uleb128 0x3b
 2311 0107 0B       		.uleb128 0xb
 2312 0108 49       		.uleb128 0x49
 2313 0109 13       		.uleb128 0x13
 2314 010a 02       		.uleb128 0x2
 2315 010b 18       		.uleb128 0x18
 2316 010c 00       		.byte	0
 2317 010d 00       		.byte	0
 2318 010e 14       		.uleb128 0x14
 2319 010f 34       		.uleb128 0x34
 2320 0110 00       		.byte	0
 2321 0111 03       		.uleb128 0x3
 2322 0112 08       		.uleb128 0x8
 2323 0113 3A       		.uleb128 0x3a
 2324 0114 0B       		.uleb128 0xb
 2325 0115 3B       		.uleb128 0x3b
 2326 0116 0B       		.uleb128 0xb
 2327 0117 49       		.uleb128 0x49
 2328 0118 13       		.uleb128 0x13
 2329 0119 02       		.uleb128 0x2
 2330 011a 18       		.uleb128 0x18
 2331 011b 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 159


 2332 011c 00       		.byte	0
 2333 011d 15       		.uleb128 0x15
 2334 011e 1D       		.uleb128 0x1d
 2335 011f 01       		.byte	0x1
 2336 0120 31       		.uleb128 0x31
 2337 0121 13       		.uleb128 0x13
 2338 0122 11       		.uleb128 0x11
 2339 0123 01       		.uleb128 0x1
 2340 0124 12       		.uleb128 0x12
 2341 0125 06       		.uleb128 0x6
 2342 0126 58       		.uleb128 0x58
 2343 0127 0B       		.uleb128 0xb
 2344 0128 59       		.uleb128 0x59
 2345 0129 05       		.uleb128 0x5
 2346 012a 01       		.uleb128 0x1
 2347 012b 13       		.uleb128 0x13
 2348 012c 00       		.byte	0
 2349 012d 00       		.byte	0
 2350 012e 16       		.uleb128 0x16
 2351 012f 05       		.uleb128 0x5
 2352 0130 00       		.byte	0
 2353 0131 31       		.uleb128 0x31
 2354 0132 13       		.uleb128 0x13
 2355 0133 02       		.uleb128 0x2
 2356 0134 18       		.uleb128 0x18
 2357 0135 00       		.byte	0
 2358 0136 00       		.byte	0
 2359 0137 17       		.uleb128 0x17
 2360 0138 0B       		.uleb128 0xb
 2361 0139 01       		.byte	0x1
 2362 013a 11       		.uleb128 0x11
 2363 013b 01       		.uleb128 0x1
 2364 013c 12       		.uleb128 0x12
 2365 013d 06       		.uleb128 0x6
 2366 013e 00       		.byte	0
 2367 013f 00       		.byte	0
 2368 0140 18       		.uleb128 0x18
 2369 0141 34       		.uleb128 0x34
 2370 0142 00       		.byte	0
 2371 0143 31       		.uleb128 0x31
 2372 0144 13       		.uleb128 0x13
 2373 0145 02       		.uleb128 0x2
 2374 0146 18       		.uleb128 0x18
 2375 0147 00       		.byte	0
 2376 0148 00       		.byte	0
 2377 0149 19       		.uleb128 0x19
 2378 014a 1D       		.uleb128 0x1d
 2379 014b 01       		.byte	0x1
 2380 014c 31       		.uleb128 0x31
 2381 014d 13       		.uleb128 0x13
 2382 014e 11       		.uleb128 0x11
 2383 014f 01       		.uleb128 0x1
 2384 0150 12       		.uleb128 0x12
 2385 0151 06       		.uleb128 0x6
 2386 0152 58       		.uleb128 0x58
 2387 0153 0B       		.uleb128 0xb
 2388 0154 59       		.uleb128 0x59
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 160


 2389 0155 05       		.uleb128 0x5
 2390 0156 00       		.byte	0
 2391 0157 00       		.byte	0
 2392 0158 00       		.byte	0
 2393              		.section	.debug_aranges,"",%progbits
 2394 0000 1C000000 		.4byte	0x1c
 2395 0004 0200     		.2byte	0x2
 2396 0006 00000000 		.4byte	.Ldebug_info0
 2397 000a 04       		.byte	0x4
 2398 000b 00       		.byte	0
 2399 000c 0000     		.2byte	0
 2400 000e 0000     		.2byte	0
 2401 0010 00000000 		.4byte	.LFB82
 2402 0014 BC070000 		.4byte	.LFE82-.LFB82
 2403 0018 00000000 		.4byte	0
 2404 001c 00000000 		.4byte	0
 2405              		.section	.debug_ranges,"",%progbits
 2406              	.Ldebug_ranges0:
 2407 0000 00000000 		.4byte	.LFB82
 2408 0004 BC070000 		.4byte	.LFE82
 2409 0008 00000000 		.4byte	0
 2410 000c 00000000 		.4byte	0
 2411              		.section	.debug_line,"",%progbits
 2412              	.Ldebug_line0:
 2413 0000 55020000 		.section	.debug_str,"MS",%progbits,1
 2413      02005401 
 2413      00000201 
 2413      FB0E0D00 
 2413      01010101 
 2414              	.LASF59:
 2415 0000 536F7572 		.ascii	"Source\\FilteringFunctions\\arm_fir_sparse_q7.c\000"
 2415      63655C46 
 2415      696C7465 
 2415      72696E67 
 2415      46756E63 
 2416              	.LASF61:
 2417 002e 5F5F5353 		.ascii	"__SSAT\000"
 2417      415400
 2418              	.LASF30:
 2419 0035 61726D5F 		.ascii	"arm_fir_sparse_instance_q7\000"
 2419      6669725F 
 2419      73706172 
 2419      73655F69 
 2419      6E737461 
 2420              	.LASF46:
 2421 0050 6E65674D 		.ascii	"negMin\000"
 2421      696E00
 2422              	.LASF11:
 2423 0057 6C6F6E67 		.ascii	"long long unsigned int\000"
 2423      206C6F6E 
 2423      6720756E 
 2423      7369676E 
 2423      65642069 
 2424              	.LASF55:
 2425 006e 626C6B43 		.ascii	"blkCnt\000"
 2425      6E7400
 2426              	.LASF3:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 161


 2427 0075 5F5F696E 		.ascii	"__int8_t\000"
 2427      74385F74 
 2427      00
 2428              	.LASF10:
 2429 007e 6C6F6E67 		.ascii	"long long int\000"
 2429      206C6F6E 
 2429      6720696E 
 2429      7400
 2430              	.LASF0:
 2431 008c 7369676E 		.ascii	"signed char\000"
 2431      65642063 
 2431      68617200 
 2432              	.LASF37:
 2433 0098 61726D5F 		.ascii	"arm_circularWrite_q7\000"
 2433      63697263 
 2433      756C6172 
 2433      57726974 
 2433      655F7137 
 2434              	.LASF7:
 2435 00ad 6C6F6E67 		.ascii	"long int\000"
 2435      20696E74 
 2435      00
 2436              	.LASF48:
 2437 00b6 70447374 		.ascii	"pDst\000"
 2437      00
 2438              	.LASF34:
 2439 00bb 73726349 		.ascii	"srcInc\000"
 2439      6E6300
 2440              	.LASF14:
 2441 00c2 75696E74 		.ascii	"uint16_t\000"
 2441      31365F74 
 2441      00
 2442              	.LASF19:
 2443 00cb 646F7562 		.ascii	"double\000"
 2443      6C6500
 2444              	.LASF50:
 2445 00d2 70536372 		.ascii	"pScratchOut\000"
 2445      61746368 
 2445      4F757400 
 2446              	.LASF8:
 2447 00de 5F5F7569 		.ascii	"__uint32_t\000"
 2447      6E743332 
 2447      5F7400
 2448              	.LASF40:
 2449 00e9 6473745F 		.ascii	"dst_base\000"
 2449      62617365 
 2449      00
 2450              	.LASF38:
 2451 00f2 61726D5F 		.ascii	"arm_circularRead_q7\000"
 2451      63697263 
 2451      756C6172 
 2451      52656164 
 2451      5F713700 
 2452              	.LASF12:
 2453 0106 756E7369 		.ascii	"unsigned int\000"
 2453      676E6564 
 2453      20696E74 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 162


 2453      00
 2454              	.LASF47:
 2455 0113 70537263 		.ascii	"pSrc\000"
 2455      00
 2456              	.LASF54:
 2457 0118 74617043 		.ascii	"tapCnt\000"
 2457      6E7400
 2458              	.LASF39:
 2459 011f 72656164 		.ascii	"readOffset\000"
 2459      4F666673 
 2459      657400
 2460              	.LASF9:
 2461 012a 6C6F6E67 		.ascii	"long unsigned int\000"
 2461      20756E73 
 2461      69676E65 
 2461      6420696E 
 2461      7400
 2462              	.LASF58:
 2463 013c 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 2463      4320342E 
 2463      392E3320 
 2463      32303135 
 2463      30333033 
 2464 016f 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0plus -mthumb -"
 2464      20726576 
 2464      6973696F 
 2464      6E203232 
 2464      31323230 
 2465 01a2 67202D4F 		.ascii	"g -O0 -ffunction-sections -ffat-lto-objects\000"
 2465      30202D66 
 2465      66756E63 
 2465      74696F6E 
 2465      2D736563 
 2466              	.LASF5:
 2467 01ce 73686F72 		.ascii	"short unsigned int\000"
 2467      7420756E 
 2467      7369676E 
 2467      65642069 
 2467      6E7400
 2468              	.LASF43:
 2469 01e1 724F6666 		.ascii	"rOffset\000"
 2469      73657400 
 2470              	.LASF51:
 2471 01e9 704F7574 		.ascii	"pOut\000"
 2471      00
 2472              	.LASF33:
 2473 01ee 62756666 		.ascii	"bufferInc\000"
 2473      6572496E 
 2473      6300
 2474              	.LASF17:
 2475 01f8 73697A65 		.ascii	"sizetype\000"
 2475      74797065 
 2475      00
 2476              	.LASF21:
 2477 0201 6C6F6E67 		.ascii	"long double\000"
 2477      20646F75 
 2477      626C6500 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 163


 2478              	.LASF25:
 2479 020d 73746174 		.ascii	"stateIndex\000"
 2479      65496E64 
 2479      657800
 2480              	.LASF31:
 2481 0218 63697263 		.ascii	"circBuffer\000"
 2481      42756666 
 2481      657200
 2482              	.LASF20:
 2483 0223 666C6F61 		.ascii	"float\000"
 2483      7400
 2484              	.LASF29:
 2485 0229 70546170 		.ascii	"pTapDelay\000"
 2485      44656C61 
 2485      7900
 2486              	.LASF32:
 2487 0233 77726974 		.ascii	"writeOffset\000"
 2487      654F6666 
 2487      73657400 
 2488              	.LASF42:
 2489 023f 64737449 		.ascii	"dstInc\000"
 2489      6E6300
 2490              	.LASF15:
 2491 0246 696E7433 		.ascii	"int32_t\000"
 2491      325F7400 
 2492              	.LASF1:
 2493 024e 756E7369 		.ascii	"unsigned char\000"
 2493      676E6564 
 2493      20636861 
 2493      7200
 2494              	.LASF26:
 2495 025c 70537461 		.ascii	"pState\000"
 2495      746500
 2496              	.LASF2:
 2497 0263 73686F72 		.ascii	"short int\000"
 2497      7420696E 
 2497      7400
 2498              	.LASF28:
 2499 026d 6D617844 		.ascii	"maxDelay\000"
 2499      656C6179 
 2499      00
 2500              	.LASF60:
 2501 0276 433A5C55 		.ascii	"C:\\Users\\fneves\\Documents\\PSoC Creator\\wp_1\\e"
 2501      73657273 
 2501      5C666E65 
 2501      7665735C 
 2501      446F6375 
 2502 02a3 6E67696E 		.ascii	"ngine_speed_sensor.cydsn\000"
 2502      655F7370 
 2502      6565645F 
 2502      73656E73 
 2502      6F722E63 
 2503              	.LASF24:
 2504 02bc 6E756D54 		.ascii	"numTaps\000"
 2504      61707300 
 2505              	.LASF23:
 2506 02c4 7133315F 		.ascii	"q31_t\000"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 164


 2506      7400
 2507              	.LASF16:
 2508 02ca 75696E74 		.ascii	"uint32_t\000"
 2508      33325F74 
 2508      00
 2509              	.LASF45:
 2510 02d3 706F734D 		.ascii	"posMax\000"
 2510      617800
 2511              	.LASF18:
 2512 02da 63686172 		.ascii	"char\000"
 2512      00
 2513              	.LASF62:
 2514 02df 61726D5F 		.ascii	"arm_fir_sparse_q7\000"
 2514      6669725F 
 2514      73706172 
 2514      73655F71 
 2514      3700
 2515              	.LASF4:
 2516 02f1 5F5F7569 		.ascii	"__uint16_t\000"
 2516      6E743136 
 2516      5F7400
 2517              	.LASF6:
 2518 02fc 5F5F696E 		.ascii	"__int32_t\000"
 2518      7433325F 
 2518      7400
 2519              	.LASF53:
 2520 0306 72656164 		.ascii	"readIndex\000"
 2520      496E6465 
 2520      7800
 2521              	.LASF56:
 2522 0310 636F6566 		.ascii	"coeff\000"
 2522      6600
 2523              	.LASF22:
 2524 0316 71375F74 		.ascii	"q7_t\000"
 2524      00
 2525              	.LASF41:
 2526 031b 6473745F 		.ascii	"dst_length\000"
 2526      6C656E67 
 2526      746800
 2527              	.LASF13:
 2528 0326 696E7438 		.ascii	"int8_t\000"
 2528      5F7400
 2529              	.LASF35:
 2530 032d 626C6F63 		.ascii	"blockSize\000"
 2530      6B53697A 
 2530      6500
 2531              	.LASF44:
 2532 0337 6473745F 		.ascii	"dst_end\000"
 2532      656E6400 
 2533              	.LASF57:
 2534 033f 70536372 		.ascii	"pScr2\000"
 2534      3200
 2535              	.LASF27:
 2536 0345 70436F65 		.ascii	"pCoeffs\000"
 2536      66667300 
 2537              	.LASF36:
 2538 034d 774F6666 		.ascii	"wOffset\000"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccJrszxW.s 			page 165


 2538      73657400 
 2539              	.LASF49:
 2540 0355 70536372 		.ascii	"pScratchIn\000"
 2540      61746368 
 2540      496E00
 2541              	.LASF52:
 2542 0360 64656C61 		.ascii	"delaySize\000"
 2542      7953697A 
 2542      6500
 2543              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
