ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 1


   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"arm_rms_f32.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_fmul
  18              		.global	__aeabi_fadd
  19              		.global	__aeabi_ui2f
  20              		.global	__aeabi_fdiv
  21              		.global	__aeabi_fcmpge
  22              		.section	.text.arm_rms_f32,"ax",%progbits
  23              		.align	2
  24              		.global	arm_rms_f32
  25              		.code	16
  26              		.thumb_func
  27              		.type	arm_rms_f32, %function
  28              	arm_rms_f32:
  29              	.LFB82:
  30              		.file 1 "Source\\StatisticsFunctions\\arm_rms_f32.c"
   1:Source\StatisticsFunctions/arm_rms_f32.c **** /* ----------------------------------------------------------------------
   2:Source\StatisticsFunctions/arm_rms_f32.c ****  * Project:      CMSIS DSP Library
   3:Source\StatisticsFunctions/arm_rms_f32.c ****  * Title:        arm_rms_f32.c
   4:Source\StatisticsFunctions/arm_rms_f32.c ****  * Description:  Root mean square value of an array of F32 type
   5:Source\StatisticsFunctions/arm_rms_f32.c ****  *
   6:Source\StatisticsFunctions/arm_rms_f32.c ****  * $Date:        27. January 2017
   7:Source\StatisticsFunctions/arm_rms_f32.c ****  * $Revision:    V.1.5.1
   8:Source\StatisticsFunctions/arm_rms_f32.c ****  *
   9:Source\StatisticsFunctions/arm_rms_f32.c ****  * Target Processor: Cortex-M cores
  10:Source\StatisticsFunctions/arm_rms_f32.c ****  * -------------------------------------------------------------------- */
  11:Source\StatisticsFunctions/arm_rms_f32.c **** /*
  12:Source\StatisticsFunctions/arm_rms_f32.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  14:Source\StatisticsFunctions/arm_rms_f32.c ****  * SPDX-License-Identifier: Apache-2.0
  15:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  16:Source\StatisticsFunctions/arm_rms_f32.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:Source\StatisticsFunctions/arm_rms_f32.c ****  * not use this file except in compliance with the License.
  18:Source\StatisticsFunctions/arm_rms_f32.c ****  * You may obtain a copy of the License at
  19:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  20:Source\StatisticsFunctions/arm_rms_f32.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  22:Source\StatisticsFunctions/arm_rms_f32.c ****  * Unless required by applicable law or agreed to in writing, software
  23:Source\StatisticsFunctions/arm_rms_f32.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:Source\StatisticsFunctions/arm_rms_f32.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:Source\StatisticsFunctions/arm_rms_f32.c ****  * See the License for the specific language governing permissions and
  26:Source\StatisticsFunctions/arm_rms_f32.c ****  * limitations under the License.
  27:Source\StatisticsFunctions/arm_rms_f32.c ****  */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 2


  28:Source\StatisticsFunctions/arm_rms_f32.c **** 
  29:Source\StatisticsFunctions/arm_rms_f32.c **** #include "arm_math.h"
  30:Source\StatisticsFunctions/arm_rms_f32.c **** 
  31:Source\StatisticsFunctions/arm_rms_f32.c **** /**
  32:Source\StatisticsFunctions/arm_rms_f32.c ****  * @ingroup groupStats
  33:Source\StatisticsFunctions/arm_rms_f32.c ****  */
  34:Source\StatisticsFunctions/arm_rms_f32.c **** 
  35:Source\StatisticsFunctions/arm_rms_f32.c **** /**
  36:Source\StatisticsFunctions/arm_rms_f32.c ****  * @defgroup RMS Root mean square (RMS)
  37:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  38:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  39:Source\StatisticsFunctions/arm_rms_f32.c ****  * Calculates the Root Mean Sqaure of the elements in the input vector.
  40:Source\StatisticsFunctions/arm_rms_f32.c ****  * The underlying algorithm is used:
  41:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  42:Source\StatisticsFunctions/arm_rms_f32.c ****  * <pre>
  43:Source\StatisticsFunctions/arm_rms_f32.c ****  * 	Result = sqrt(((pSrc[0] * pSrc[0] + pSrc[1] * pSrc[1] + ... + pSrc[blockSize-1] * pSrc[blockSiz
  44:Source\StatisticsFunctions/arm_rms_f32.c ****  * </pre>
  45:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  46:Source\StatisticsFunctions/arm_rms_f32.c ****  * There are separate functions for floating point, Q31, and Q15 data types.
  47:Source\StatisticsFunctions/arm_rms_f32.c ****  */
  48:Source\StatisticsFunctions/arm_rms_f32.c **** 
  49:Source\StatisticsFunctions/arm_rms_f32.c **** /**
  50:Source\StatisticsFunctions/arm_rms_f32.c ****  * @addtogroup RMS
  51:Source\StatisticsFunctions/arm_rms_f32.c ****  * @{
  52:Source\StatisticsFunctions/arm_rms_f32.c ****  */
  53:Source\StatisticsFunctions/arm_rms_f32.c **** 
  54:Source\StatisticsFunctions/arm_rms_f32.c **** 
  55:Source\StatisticsFunctions/arm_rms_f32.c **** /**
  56:Source\StatisticsFunctions/arm_rms_f32.c ****  * @brief Root Mean Square of the elements of a floating-point vector.
  57:Source\StatisticsFunctions/arm_rms_f32.c ****  * @param[in]       *pSrc points to the input vector
  58:Source\StatisticsFunctions/arm_rms_f32.c ****  * @param[in]       blockSize length of the input vector
  59:Source\StatisticsFunctions/arm_rms_f32.c ****  * @param[out]      *pResult rms value returned here
  60:Source\StatisticsFunctions/arm_rms_f32.c ****  * @return none.
  61:Source\StatisticsFunctions/arm_rms_f32.c ****  *
  62:Source\StatisticsFunctions/arm_rms_f32.c ****  */
  63:Source\StatisticsFunctions/arm_rms_f32.c **** 
  64:Source\StatisticsFunctions/arm_rms_f32.c **** void arm_rms_f32(
  65:Source\StatisticsFunctions/arm_rms_f32.c ****   float32_t * pSrc,
  66:Source\StatisticsFunctions/arm_rms_f32.c ****   uint32_t blockSize,
  67:Source\StatisticsFunctions/arm_rms_f32.c ****   float32_t * pResult)
  68:Source\StatisticsFunctions/arm_rms_f32.c **** {
  31              		.loc 1 68 0
  32              		.cfi_startproc
  33 0000 80B5     		push	{r7, lr}
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 8AB0     		sub	sp, sp, #40
  38              		.cfi_def_cfa_offset 48
  39 0004 00AF     		add	r7, sp, #0
  40              		.cfi_def_cfa_register 7
  41 0006 F860     		str	r0, [r7, #12]
  42 0008 B960     		str	r1, [r7, #8]
  43 000a 7A60     		str	r2, [r7, #4]
  69:Source\StatisticsFunctions/arm_rms_f32.c ****   float32_t sum = 0.0f;                          /* Accumulator */
  44              		.loc 1 69 0
  45 000c 0023     		mov	r3, #0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 3


  46 000e 7B62     		str	r3, [r7, #36]
  70:Source\StatisticsFunctions/arm_rms_f32.c ****   float32_t in;                                  /* Tempoprary variable to store input value */
  71:Source\StatisticsFunctions/arm_rms_f32.c ****   uint32_t blkCnt;                               /* loop counter */
  72:Source\StatisticsFunctions/arm_rms_f32.c **** 
  73:Source\StatisticsFunctions/arm_rms_f32.c **** #if defined (ARM_MATH_DSP)
  74:Source\StatisticsFunctions/arm_rms_f32.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
  75:Source\StatisticsFunctions/arm_rms_f32.c **** 
  76:Source\StatisticsFunctions/arm_rms_f32.c ****   /* loop Unrolling */
  77:Source\StatisticsFunctions/arm_rms_f32.c ****   blkCnt = blockSize >> 2u;
  78:Source\StatisticsFunctions/arm_rms_f32.c **** 
  79:Source\StatisticsFunctions/arm_rms_f32.c ****   /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
  80:Source\StatisticsFunctions/arm_rms_f32.c ****    ** a second loop below computes the remaining 1 to 3 samples. */
  81:Source\StatisticsFunctions/arm_rms_f32.c ****   while (blkCnt > 0u)
  82:Source\StatisticsFunctions/arm_rms_f32.c ****   {
  83:Source\StatisticsFunctions/arm_rms_f32.c ****     /* C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1] */
  84:Source\StatisticsFunctions/arm_rms_f32.c ****     /* Compute sum of the squares and then store the result in a temporary variable, sum  */
  85:Source\StatisticsFunctions/arm_rms_f32.c ****     in = *pSrc++;
  86:Source\StatisticsFunctions/arm_rms_f32.c ****     sum += in * in;
  87:Source\StatisticsFunctions/arm_rms_f32.c ****     in = *pSrc++;
  88:Source\StatisticsFunctions/arm_rms_f32.c ****     sum += in * in;
  89:Source\StatisticsFunctions/arm_rms_f32.c ****     in = *pSrc++;
  90:Source\StatisticsFunctions/arm_rms_f32.c ****     sum += in * in;
  91:Source\StatisticsFunctions/arm_rms_f32.c ****     in = *pSrc++;
  92:Source\StatisticsFunctions/arm_rms_f32.c ****     sum += in * in;
  93:Source\StatisticsFunctions/arm_rms_f32.c **** 
  94:Source\StatisticsFunctions/arm_rms_f32.c ****     /* Decrement the loop counter */
  95:Source\StatisticsFunctions/arm_rms_f32.c ****     blkCnt--;
  96:Source\StatisticsFunctions/arm_rms_f32.c ****   }
  97:Source\StatisticsFunctions/arm_rms_f32.c **** 
  98:Source\StatisticsFunctions/arm_rms_f32.c ****   /* If the blockSize is not a multiple of 4, compute any remaining output samples here.
  99:Source\StatisticsFunctions/arm_rms_f32.c ****    ** No loop unrolling is used. */
 100:Source\StatisticsFunctions/arm_rms_f32.c ****   blkCnt = blockSize % 0x4u;
 101:Source\StatisticsFunctions/arm_rms_f32.c **** 
 102:Source\StatisticsFunctions/arm_rms_f32.c **** #else
 103:Source\StatisticsFunctions/arm_rms_f32.c ****   /* Run the below code for Cortex-M0 */
 104:Source\StatisticsFunctions/arm_rms_f32.c **** 
 105:Source\StatisticsFunctions/arm_rms_f32.c ****   /* Loop over blockSize number of values */
 106:Source\StatisticsFunctions/arm_rms_f32.c ****   blkCnt = blockSize;
  47              		.loc 1 106 0
  48 0010 BB68     		ldr	r3, [r7, #8]
  49 0012 3B62     		str	r3, [r7, #32]
 107:Source\StatisticsFunctions/arm_rms_f32.c **** 
 108:Source\StatisticsFunctions/arm_rms_f32.c **** #endif /* #if defined (ARM_MATH_DSP) */
 109:Source\StatisticsFunctions/arm_rms_f32.c **** 
 110:Source\StatisticsFunctions/arm_rms_f32.c ****   while (blkCnt > 0u)
  50              		.loc 1 110 0
  51 0014 12E0     		b	.L2
  52              	.L3:
 111:Source\StatisticsFunctions/arm_rms_f32.c ****   {
 112:Source\StatisticsFunctions/arm_rms_f32.c ****     /* C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1] */
 113:Source\StatisticsFunctions/arm_rms_f32.c ****     /* Compute sum of the squares and then store the results in a temporary variable, sum  */
 114:Source\StatisticsFunctions/arm_rms_f32.c ****     in = *pSrc++;
  53              		.loc 1 114 0
  54 0016 FB68     		ldr	r3, [r7, #12]
  55 0018 1A1D     		add	r2, r3, #4
  56 001a FA60     		str	r2, [r7, #12]
  57 001c 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 4


  58 001e FB61     		str	r3, [r7, #28]
 115:Source\StatisticsFunctions/arm_rms_f32.c ****     sum += in * in;
  59              		.loc 1 115 0
  60 0020 F869     		ldr	r0, [r7, #28]
  61 0022 F969     		ldr	r1, [r7, #28]
  62 0024 FFF7FEFF 		bl	__aeabi_fmul
  63 0028 031C     		add	r3, r0, #0
  64 002a 786A     		ldr	r0, [r7, #36]
  65 002c 191C     		add	r1, r3, #0
  66 002e FFF7FEFF 		bl	__aeabi_fadd
  67 0032 031C     		add	r3, r0, #0
  68 0034 7B62     		str	r3, [r7, #36]
 116:Source\StatisticsFunctions/arm_rms_f32.c **** 
 117:Source\StatisticsFunctions/arm_rms_f32.c ****     /* Decrement the loop counter */
 118:Source\StatisticsFunctions/arm_rms_f32.c ****     blkCnt--;
  69              		.loc 1 118 0
  70 0036 3B6A     		ldr	r3, [r7, #32]
  71 0038 013B     		sub	r3, r3, #1
  72 003a 3B62     		str	r3, [r7, #32]
  73              	.L2:
 110:Source\StatisticsFunctions/arm_rms_f32.c ****   {
  74              		.loc 1 110 0
  75 003c 3B6A     		ldr	r3, [r7, #32]
  76 003e 002B     		cmp	r3, #0
  77 0040 E9D1     		bne	.L3
 119:Source\StatisticsFunctions/arm_rms_f32.c ****   }
 120:Source\StatisticsFunctions/arm_rms_f32.c **** 
 121:Source\StatisticsFunctions/arm_rms_f32.c ****   /* Compute Rms and store the result in the destination */
 122:Source\StatisticsFunctions/arm_rms_f32.c ****   arm_sqrt_f32(sum / (float32_t) blockSize, pResult);
  78              		.loc 1 122 0
  79 0042 B868     		ldr	r0, [r7, #8]
  80 0044 FFF7FEFF 		bl	__aeabi_ui2f
  81 0048 031C     		add	r3, r0, #0
  82 004a 786A     		ldr	r0, [r7, #36]
  83 004c 191C     		add	r1, r3, #0
  84 004e FFF7FEFF 		bl	__aeabi_fdiv
  85 0052 031C     		add	r3, r0, #0
  86 0054 BB61     		str	r3, [r7, #24]
  87 0056 7B68     		ldr	r3, [r7, #4]
  88 0058 7B61     		str	r3, [r7, #20]
  89              	.LBB4:
  90              	.LBB5:
  91              		.file 2 ".\\Include/arm_math.h"
   1:.\Include/arm_math.h **** /* ----------------------------------------------------------------------
   2:.\Include/arm_math.h ****  * Project:      CMSIS DSP Library
   3:.\Include/arm_math.h ****  * Title:        arm_math.h
   4:.\Include/arm_math.h ****  * Description:  Public header file for CMSIS DSP Library
   5:.\Include/arm_math.h ****  *
   6:.\Include/arm_math.h ****  * $Date:        27. January 2017
   7:.\Include/arm_math.h ****  * $Revision:    V.1.5.1
   8:.\Include/arm_math.h ****  *
   9:.\Include/arm_math.h ****  * Target Processor: Cortex-M cores
  10:.\Include/arm_math.h ****  * -------------------------------------------------------------------- */
  11:.\Include/arm_math.h **** /*
  12:.\Include/arm_math.h ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:.\Include/arm_math.h ****  *
  14:.\Include/arm_math.h ****  * SPDX-License-Identifier: Apache-2.0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 5


  15:.\Include/arm_math.h ****  *
  16:.\Include/arm_math.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:.\Include/arm_math.h ****  * not use this file except in compliance with the License.
  18:.\Include/arm_math.h ****  * You may obtain a copy of the License at
  19:.\Include/arm_math.h ****  *
  20:.\Include/arm_math.h ****  * www.apache.org/licenses/LICENSE-2.0
  21:.\Include/arm_math.h ****  *
  22:.\Include/arm_math.h ****  * Unless required by applicable law or agreed to in writing, software
  23:.\Include/arm_math.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:.\Include/arm_math.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:.\Include/arm_math.h ****  * See the License for the specific language governing permissions and
  26:.\Include/arm_math.h ****  * limitations under the License.
  27:.\Include/arm_math.h ****  */
  28:.\Include/arm_math.h **** 
  29:.\Include/arm_math.h **** /**
  30:.\Include/arm_math.h ****    \mainpage CMSIS DSP Software Library
  31:.\Include/arm_math.h ****    *
  32:.\Include/arm_math.h ****    * Introduction
  33:.\Include/arm_math.h ****    * ------------
  34:.\Include/arm_math.h ****    *
  35:.\Include/arm_math.h ****    * This user manual describes the CMSIS DSP software library,
  36:.\Include/arm_math.h ****    * a suite of common signal processing functions for use on Cortex-M processor based devices.
  37:.\Include/arm_math.h ****    *
  38:.\Include/arm_math.h ****    * The library is divided into a number of functions each covering a specific category:
  39:.\Include/arm_math.h ****    * - Basic math functions
  40:.\Include/arm_math.h ****    * - Fast math functions
  41:.\Include/arm_math.h ****    * - Complex math functions
  42:.\Include/arm_math.h ****    * - Filters
  43:.\Include/arm_math.h ****    * - Matrix functions
  44:.\Include/arm_math.h ****    * - Transforms
  45:.\Include/arm_math.h ****    * - Motor control functions
  46:.\Include/arm_math.h ****    * - Statistical functions
  47:.\Include/arm_math.h ****    * - Support functions
  48:.\Include/arm_math.h ****    * - Interpolation functions
  49:.\Include/arm_math.h ****    *
  50:.\Include/arm_math.h ****    * The library has separate functions for operating on 8-bit integers, 16-bit integers,
  51:.\Include/arm_math.h ****    * 32-bit integer and 32-bit floating-point values.
  52:.\Include/arm_math.h ****    *
  53:.\Include/arm_math.h ****    * Using the Library
  54:.\Include/arm_math.h ****    * ------------
  55:.\Include/arm_math.h ****    *
  56:.\Include/arm_math.h ****    * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> fold
  57:.\Include/arm_math.h ****    * - arm_cortexM7lfdp_math.lib (Cortex-M7, Little endian, Double Precision Floating Point Unit)
  58:.\Include/arm_math.h ****    * - arm_cortexM7bfdp_math.lib (Cortex-M7, Big endian, Double Precision Floating Point Unit)
  59:.\Include/arm_math.h ****    * - arm_cortexM7lfsp_math.lib (Cortex-M7, Little endian, Single Precision Floating Point Unit)
  60:.\Include/arm_math.h ****    * - arm_cortexM7bfsp_math.lib (Cortex-M7, Big endian and Single Precision Floating Point Unit on
  61:.\Include/arm_math.h ****    * - arm_cortexM7l_math.lib (Cortex-M7, Little endian)
  62:.\Include/arm_math.h ****    * - arm_cortexM7b_math.lib (Cortex-M7, Big endian)
  63:.\Include/arm_math.h ****    * - arm_cortexM4lf_math.lib (Cortex-M4, Little endian, Floating Point Unit)
  64:.\Include/arm_math.h ****    * - arm_cortexM4bf_math.lib (Cortex-M4, Big endian, Floating Point Unit)
  65:.\Include/arm_math.h ****    * - arm_cortexM4l_math.lib (Cortex-M4, Little endian)
  66:.\Include/arm_math.h ****    * - arm_cortexM4b_math.lib (Cortex-M4, Big endian)
  67:.\Include/arm_math.h ****    * - arm_cortexM3l_math.lib (Cortex-M3, Little endian)
  68:.\Include/arm_math.h ****    * - arm_cortexM3b_math.lib (Cortex-M3, Big endian)
  69:.\Include/arm_math.h ****    * - arm_cortexM0l_math.lib (Cortex-M0 / Cortex-M0+, Little endian)
  70:.\Include/arm_math.h ****    * - arm_cortexM0b_math.lib (Cortex-M0 / Cortex-M0+, Big endian)
  71:.\Include/arm_math.h ****    * - arm_ARMv8MBLl_math.lib (ARMv8M Baseline, Little endian)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 6


  72:.\Include/arm_math.h ****    * - arm_ARMv8MMLl_math.lib (ARMv8M Mainline, Little endian)
  73:.\Include/arm_math.h ****    * - arm_ARMv8MMLlfsp_math.lib (ARMv8M Mainline, Little endian, Single Precision Floating Point U
  74:.\Include/arm_math.h ****    * - arm_ARMv8MMLld_math.lib (ARMv8M Mainline, Little endian, DSP instructions)
  75:.\Include/arm_math.h ****    * - arm_ARMv8MMLldfsp_math.lib (ARMv8M Mainline, Little endian, DSP instructions, Single Precisi
  76:.\Include/arm_math.h ****    *
  77:.\Include/arm_math.h ****    * The library functions are declared in the public file <code>arm_math.h</code> which is placed 
  78:.\Include/arm_math.h ****    * Simply include this file and link the appropriate library in the application and begin calling
  79:.\Include/arm_math.h ****    * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endi
  80:.\Include/arm_math.h ****    * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
  81:.\Include/arm_math.h ****    * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
  82:.\Include/arm_math.h ****    * For ARMv8M cores define pre processor MACRO ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
  83:.\Include/arm_math.h ****    * Set Pre processor MACRO __DSP_PRESENT if ARMv8M Mainline core supports DSP instructions.
  84:.\Include/arm_math.h ****    * 
  85:.\Include/arm_math.h ****    *
  86:.\Include/arm_math.h ****    * Examples
  87:.\Include/arm_math.h ****    * --------
  88:.\Include/arm_math.h ****    *
  89:.\Include/arm_math.h ****    * The library ships with a number of examples which demonstrate how to use the library functions
  90:.\Include/arm_math.h ****    *
  91:.\Include/arm_math.h ****    * Toolchain Support
  92:.\Include/arm_math.h ****    * ------------
  93:.\Include/arm_math.h ****    *
  94:.\Include/arm_math.h ****    * The library has been developed and tested with MDK-ARM version 5.14.0.0
  95:.\Include/arm_math.h ****    * The library is being tested in GCC and IAR toolchains and updates on this activity will be mad
  96:.\Include/arm_math.h ****    *
  97:.\Include/arm_math.h ****    * Building the Library
  98:.\Include/arm_math.h ****    * ------------
  99:.\Include/arm_math.h ****    *
 100:.\Include/arm_math.h ****    * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in t
 101:.\Include/arm_math.h ****    * - arm_cortexM_math.uvprojx
 102:.\Include/arm_math.h ****    *
 103:.\Include/arm_math.h ****    *
 104:.\Include/arm_math.h ****    * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecti
 105:.\Include/arm_math.h ****    *
 106:.\Include/arm_math.h ****    * Pre-processor Macros
 107:.\Include/arm_math.h ****    * ------------
 108:.\Include/arm_math.h ****    *
 109:.\Include/arm_math.h ****    * Each library project have differant pre-processor macros.
 110:.\Include/arm_math.h ****    *
 111:.\Include/arm_math.h ****    * - UNALIGNED_SUPPORT_DISABLE:
 112:.\Include/arm_math.h ****    *
 113:.\Include/arm_math.h ****    * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory acces
 114:.\Include/arm_math.h ****    *
 115:.\Include/arm_math.h ****    * - ARM_MATH_BIG_ENDIAN:
 116:.\Include/arm_math.h ****    *
 117:.\Include/arm_math.h ****    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default libra
 118:.\Include/arm_math.h ****    *
 119:.\Include/arm_math.h ****    * - ARM_MATH_MATRIX_CHECK:
 120:.\Include/arm_math.h ****    *
 121:.\Include/arm_math.h ****    * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
 122:.\Include/arm_math.h ****    *
 123:.\Include/arm_math.h ****    * - ARM_MATH_ROUNDING:
 124:.\Include/arm_math.h ****    *
 125:.\Include/arm_math.h ****    * Define macro ARM_MATH_ROUNDING for rounding on support functions
 126:.\Include/arm_math.h ****    *
 127:.\Include/arm_math.h ****    * - ARM_MATH_CMx:
 128:.\Include/arm_math.h ****    *
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 7


 129:.\Include/arm_math.h ****    * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for build
 130:.\Include/arm_math.h ****    * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building libra
 131:.\Include/arm_math.h ****    * ARM_MATH_CM7 for building the library on cortex-M7.
 132:.\Include/arm_math.h ****    *
 133:.\Include/arm_math.h ****    * - ARM_MATH_ARMV8MxL:
 134:.\Include/arm_math.h ****    *
 135:.\Include/arm_math.h ****    * Define macro ARM_MATH_ARMV8MBL for building the library on ARMv8M Baseline target, ARM_MATH_AR
 136:.\Include/arm_math.h ****    * on ARMv8M Mainline target.
 137:.\Include/arm_math.h ****    *
 138:.\Include/arm_math.h ****    * - __FPU_PRESENT:
 139:.\Include/arm_math.h ****    *
 140:.\Include/arm_math.h ****    * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro f
 141:.\Include/arm_math.h ****    *
 142:.\Include/arm_math.h ****    * - __DSP_PRESENT:
 143:.\Include/arm_math.h ****    *
 144:.\Include/arm_math.h ****    * Initialize macro __DSP_PRESENT = 1 when ARMv8M Mainline core supports DSP instructions.
 145:.\Include/arm_math.h ****    *
 146:.\Include/arm_math.h ****    * <hr>
 147:.\Include/arm_math.h ****    * CMSIS-DSP in ARM::CMSIS Pack
 148:.\Include/arm_math.h ****    * -----------------------------
 149:.\Include/arm_math.h ****    *
 150:.\Include/arm_math.h ****    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directorie
 151:.\Include/arm_math.h ****    * |File/Folder                   |Content                                                       
 152:.\Include/arm_math.h ****    * |------------------------------|--------------------------------------------------------------
 153:.\Include/arm_math.h ****    * |\b CMSIS\\Documentation\\DSP  | This documentation                                           
 154:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                     
 155:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library funct
 156:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                      
 157:.\Include/arm_math.h ****    *
 158:.\Include/arm_math.h ****    * <hr>
 159:.\Include/arm_math.h ****    * Revision History of CMSIS-DSP
 160:.\Include/arm_math.h ****    * ------------
 161:.\Include/arm_math.h ****    * Please refer to \ref ChangeLog_pg.
 162:.\Include/arm_math.h ****    *
 163:.\Include/arm_math.h ****    * Copyright Notice
 164:.\Include/arm_math.h ****    * ------------
 165:.\Include/arm_math.h ****    *
 166:.\Include/arm_math.h ****    * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
 167:.\Include/arm_math.h ****    */
 168:.\Include/arm_math.h **** 
 169:.\Include/arm_math.h **** 
 170:.\Include/arm_math.h **** /**
 171:.\Include/arm_math.h ****  * @defgroup groupMath Basic Math Functions
 172:.\Include/arm_math.h ****  */
 173:.\Include/arm_math.h **** 
 174:.\Include/arm_math.h **** /**
 175:.\Include/arm_math.h ****  * @defgroup groupFastMath Fast Math Functions
 176:.\Include/arm_math.h ****  * This set of functions provides a fast approximation to sine, cosine, and square root.
 177:.\Include/arm_math.h ****  * As compared to most of the other functions in the CMSIS math library, the fast math functions
 178:.\Include/arm_math.h ****  * operate on individual values and not arrays.
 179:.\Include/arm_math.h ****  * There are separate functions for Q15, Q31, and floating-point data.
 180:.\Include/arm_math.h ****  *
 181:.\Include/arm_math.h ****  */
 182:.\Include/arm_math.h **** 
 183:.\Include/arm_math.h **** /**
 184:.\Include/arm_math.h ****  * @defgroup groupCmplxMath Complex Math Functions
 185:.\Include/arm_math.h ****  * This set of functions operates on complex data vectors.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 8


 186:.\Include/arm_math.h ****  * The data in the complex arrays is stored in an interleaved fashion
 187:.\Include/arm_math.h ****  * (real, imag, real, imag, ...).
 188:.\Include/arm_math.h ****  * In the API functions, the number of samples in a complex array refers
 189:.\Include/arm_math.h ****  * to the number of complex values; the array contains twice this number of
 190:.\Include/arm_math.h ****  * real values.
 191:.\Include/arm_math.h ****  */
 192:.\Include/arm_math.h **** 
 193:.\Include/arm_math.h **** /**
 194:.\Include/arm_math.h ****  * @defgroup groupFilters Filtering Functions
 195:.\Include/arm_math.h ****  */
 196:.\Include/arm_math.h **** 
 197:.\Include/arm_math.h **** /**
 198:.\Include/arm_math.h ****  * @defgroup groupMatrix Matrix Functions
 199:.\Include/arm_math.h ****  *
 200:.\Include/arm_math.h ****  * This set of functions provides basic matrix math operations.
 201:.\Include/arm_math.h ****  * The functions operate on matrix data structures.  For example,
 202:.\Include/arm_math.h ****  * the type
 203:.\Include/arm_math.h ****  * definition for the floating-point matrix structure is shown
 204:.\Include/arm_math.h ****  * below:
 205:.\Include/arm_math.h ****  * <pre>
 206:.\Include/arm_math.h ****  *     typedef struct
 207:.\Include/arm_math.h ****  *     {
 208:.\Include/arm_math.h ****  *       uint16_t numRows;     // number of rows of the matrix.
 209:.\Include/arm_math.h ****  *       uint16_t numCols;     // number of columns of the matrix.
 210:.\Include/arm_math.h ****  *       float32_t *pData;     // points to the data of the matrix.
 211:.\Include/arm_math.h ****  *     } arm_matrix_instance_f32;
 212:.\Include/arm_math.h ****  * </pre>
 213:.\Include/arm_math.h ****  * There are similar definitions for Q15 and Q31 data types.
 214:.\Include/arm_math.h ****  *
 215:.\Include/arm_math.h ****  * The structure specifies the size of the matrix and then points to
 216:.\Include/arm_math.h ****  * an array of data.  The array is of size <code>numRows X numCols</code>
 217:.\Include/arm_math.h ****  * and the values are arranged in row order.  That is, the
 218:.\Include/arm_math.h ****  * matrix element (i, j) is stored at:
 219:.\Include/arm_math.h ****  * <pre>
 220:.\Include/arm_math.h ****  *     pData[i*numCols + j]
 221:.\Include/arm_math.h ****  * </pre>
 222:.\Include/arm_math.h ****  *
 223:.\Include/arm_math.h ****  * \par Init Functions
 224:.\Include/arm_math.h ****  * There is an associated initialization function for each type of matrix
 225:.\Include/arm_math.h ****  * data structure.
 226:.\Include/arm_math.h ****  * The initialization function sets the values of the internal structure fields.
 227:.\Include/arm_math.h ****  * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
 228:.\Include/arm_math.h ****  * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
 229:.\Include/arm_math.h ****  *
 230:.\Include/arm_math.h ****  * \par
 231:.\Include/arm_math.h ****  * Use of the initialization function is optional. However, if initialization function is used
 232:.\Include/arm_math.h ****  * then the instance structure cannot be placed into a const data section.
 233:.\Include/arm_math.h ****  * To place the instance structure in a const data
 234:.\Include/arm_math.h ****  * section, manually initialize the data structure.  For example:
 235:.\Include/arm_math.h ****  * <pre>
 236:.\Include/arm_math.h ****  * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
 237:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
 238:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
 239:.\Include/arm_math.h ****  * </pre>
 240:.\Include/arm_math.h ****  * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
 241:.\Include/arm_math.h ****  * specifies the number of columns, and <code>pData</code> points to the
 242:.\Include/arm_math.h ****  * data array.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 9


 243:.\Include/arm_math.h ****  *
 244:.\Include/arm_math.h ****  * \par Size Checking
 245:.\Include/arm_math.h ****  * By default all of the matrix functions perform size checking on the input and
 246:.\Include/arm_math.h ****  * output matrices.  For example, the matrix addition function verifies that the
 247:.\Include/arm_math.h ****  * two input matrices and the output matrix all have the same number of rows and
 248:.\Include/arm_math.h ****  * columns.  If the size check fails the functions return:
 249:.\Include/arm_math.h ****  * <pre>
 250:.\Include/arm_math.h ****  *     ARM_MATH_SIZE_MISMATCH
 251:.\Include/arm_math.h ****  * </pre>
 252:.\Include/arm_math.h ****  * Otherwise the functions return
 253:.\Include/arm_math.h ****  * <pre>
 254:.\Include/arm_math.h ****  *     ARM_MATH_SUCCESS
 255:.\Include/arm_math.h ****  * </pre>
 256:.\Include/arm_math.h ****  * There is some overhead associated with this matrix size checking.
 257:.\Include/arm_math.h ****  * The matrix size checking is enabled via the \#define
 258:.\Include/arm_math.h ****  * <pre>
 259:.\Include/arm_math.h ****  *     ARM_MATH_MATRIX_CHECK
 260:.\Include/arm_math.h ****  * </pre>
 261:.\Include/arm_math.h ****  * within the library project settings.  By default this macro is defined
 262:.\Include/arm_math.h ****  * and size checking is enabled.  By changing the project settings and
 263:.\Include/arm_math.h ****  * undefining this macro size checking is eliminated and the functions
 264:.\Include/arm_math.h ****  * run a bit faster.  With size checking disabled the functions always
 265:.\Include/arm_math.h ****  * return <code>ARM_MATH_SUCCESS</code>.
 266:.\Include/arm_math.h ****  */
 267:.\Include/arm_math.h **** 
 268:.\Include/arm_math.h **** /**
 269:.\Include/arm_math.h ****  * @defgroup groupTransforms Transform Functions
 270:.\Include/arm_math.h ****  */
 271:.\Include/arm_math.h **** 
 272:.\Include/arm_math.h **** /**
 273:.\Include/arm_math.h ****  * @defgroup groupController Controller Functions
 274:.\Include/arm_math.h ****  */
 275:.\Include/arm_math.h **** 
 276:.\Include/arm_math.h **** /**
 277:.\Include/arm_math.h ****  * @defgroup groupStats Statistics Functions
 278:.\Include/arm_math.h ****  */
 279:.\Include/arm_math.h **** /**
 280:.\Include/arm_math.h ****  * @defgroup groupSupport Support Functions
 281:.\Include/arm_math.h ****  */
 282:.\Include/arm_math.h **** 
 283:.\Include/arm_math.h **** /**
 284:.\Include/arm_math.h ****  * @defgroup groupInterpolation Interpolation Functions
 285:.\Include/arm_math.h ****  * These functions perform 1- and 2-dimensional interpolation of data.
 286:.\Include/arm_math.h ****  * Linear interpolation is used for 1-dimensional data and
 287:.\Include/arm_math.h ****  * bilinear interpolation is used for 2-dimensional data.
 288:.\Include/arm_math.h ****  */
 289:.\Include/arm_math.h **** 
 290:.\Include/arm_math.h **** /**
 291:.\Include/arm_math.h ****  * @defgroup groupExamples Examples
 292:.\Include/arm_math.h ****  */
 293:.\Include/arm_math.h **** #ifndef _ARM_MATH_H
 294:.\Include/arm_math.h **** #define _ARM_MATH_H
 295:.\Include/arm_math.h **** 
 296:.\Include/arm_math.h **** /* ignore some GCC warnings */
 297:.\Include/arm_math.h **** #if defined ( __GNUC__ )
 298:.\Include/arm_math.h **** #pragma GCC diagnostic push
 299:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 10


 300:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wconversion"
 301:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
 302:.\Include/arm_math.h **** #endif
 303:.\Include/arm_math.h **** 
 304:.\Include/arm_math.h **** #define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
 305:.\Include/arm_math.h **** 
 306:.\Include/arm_math.h **** #if defined(ARM_MATH_CM7)
 307:.\Include/arm_math.h ****   #include "core_cm7.h"
 308:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 309:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM4)
 310:.\Include/arm_math.h ****   #include "core_cm4.h"
 311:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 312:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM3)
 313:.\Include/arm_math.h ****   #include "core_cm3.h"
 314:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0)
 315:.\Include/arm_math.h ****   #include "core_cm0.h"
 316:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 317:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0PLUS)
 318:.\Include/arm_math.h ****   #include "core_cm0plus.h"
 319:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 320:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MBL)
 321:.\Include/arm_math.h ****   #include "core_armv8mbl.h"
 322:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 323:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MML)
 324:.\Include/arm_math.h ****   #include "core_armv8mml.h"
 325:.\Include/arm_math.h ****   #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
 326:.\Include/arm_math.h ****     #define ARM_MATH_DSP
 327:.\Include/arm_math.h ****   #endif
 328:.\Include/arm_math.h **** #else
 329:.\Include/arm_math.h ****   #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_
 330:.\Include/arm_math.h **** #endif
 331:.\Include/arm_math.h **** 
 332:.\Include/arm_math.h **** #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 333:.\Include/arm_math.h **** #include "string.h"
 334:.\Include/arm_math.h **** #include "math.h"
 335:.\Include/arm_math.h **** #ifdef   __cplusplus
 336:.\Include/arm_math.h **** extern "C"
 337:.\Include/arm_math.h **** {
 338:.\Include/arm_math.h **** #endif
 339:.\Include/arm_math.h **** 
 340:.\Include/arm_math.h **** 
 341:.\Include/arm_math.h ****   /**
 342:.\Include/arm_math.h ****    * @brief Macros required for reciprocal calculation in Normalized LMS
 343:.\Include/arm_math.h ****    */
 344:.\Include/arm_math.h **** 
 345:.\Include/arm_math.h **** #define DELTA_Q31          (0x100)
 346:.\Include/arm_math.h **** #define DELTA_Q15          0x5
 347:.\Include/arm_math.h **** #define INDEX_MASK         0x0000003F
 348:.\Include/arm_math.h **** #ifndef PI
 349:.\Include/arm_math.h ****   #define PI               3.14159265358979f
 350:.\Include/arm_math.h **** #endif
 351:.\Include/arm_math.h **** 
 352:.\Include/arm_math.h ****   /**
 353:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Fast math approximations
 354:.\Include/arm_math.h ****    */
 355:.\Include/arm_math.h **** 
 356:.\Include/arm_math.h **** #define FAST_MATH_TABLE_SIZE  512
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 11


 357:.\Include/arm_math.h **** #define FAST_MATH_Q31_SHIFT   (32 - 10)
 358:.\Include/arm_math.h **** #define FAST_MATH_Q15_SHIFT   (16 - 10)
 359:.\Include/arm_math.h **** #define CONTROLLER_Q31_SHIFT  (32 - 9)
 360:.\Include/arm_math.h **** #define TABLE_SPACING_Q31     0x400000
 361:.\Include/arm_math.h **** #define TABLE_SPACING_Q15     0x80
 362:.\Include/arm_math.h **** 
 363:.\Include/arm_math.h ****   /**
 364:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Controller functions
 365:.\Include/arm_math.h ****    */
 366:.\Include/arm_math.h ****   /* 1.31(q31) Fixed value of 2/360 */
 367:.\Include/arm_math.h ****   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 368:.\Include/arm_math.h **** #define INPUT_SPACING         0xB60B61
 369:.\Include/arm_math.h **** 
 370:.\Include/arm_math.h ****   /**
 371:.\Include/arm_math.h ****    * @brief Macro for Unaligned Support
 372:.\Include/arm_math.h ****    */
 373:.\Include/arm_math.h **** #ifndef UNALIGNED_SUPPORT_DISABLE
 374:.\Include/arm_math.h ****     #define ALIGN4
 375:.\Include/arm_math.h **** #else
 376:.\Include/arm_math.h ****   #if defined  (__GNUC__)
 377:.\Include/arm_math.h ****     #define ALIGN4 __attribute__((aligned(4)))
 378:.\Include/arm_math.h ****   #else
 379:.\Include/arm_math.h ****     #define ALIGN4 __align(4)
 380:.\Include/arm_math.h ****   #endif
 381:.\Include/arm_math.h **** #endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 382:.\Include/arm_math.h **** 
 383:.\Include/arm_math.h ****   /**
 384:.\Include/arm_math.h ****    * @brief Error status returned by some functions in the library.
 385:.\Include/arm_math.h ****    */
 386:.\Include/arm_math.h **** 
 387:.\Include/arm_math.h ****   typedef enum
 388:.\Include/arm_math.h ****   {
 389:.\Include/arm_math.h ****     ARM_MATH_SUCCESS = 0,                /**< No error */
 390:.\Include/arm_math.h ****     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
 391:.\Include/arm_math.h ****     ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
 392:.\Include/arm_math.h ****     ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation
 393:.\Include/arm_math.h ****     ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
 394:.\Include/arm_math.h ****     ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is 
 395:.\Include/arm_math.h ****     ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
 396:.\Include/arm_math.h ****   } arm_status;
 397:.\Include/arm_math.h **** 
 398:.\Include/arm_math.h ****   /**
 399:.\Include/arm_math.h ****    * @brief 8-bit fractional data type in 1.7 format.
 400:.\Include/arm_math.h ****    */
 401:.\Include/arm_math.h ****   typedef int8_t q7_t;
 402:.\Include/arm_math.h **** 
 403:.\Include/arm_math.h ****   /**
 404:.\Include/arm_math.h ****    * @brief 16-bit fractional data type in 1.15 format.
 405:.\Include/arm_math.h ****    */
 406:.\Include/arm_math.h ****   typedef int16_t q15_t;
 407:.\Include/arm_math.h **** 
 408:.\Include/arm_math.h ****   /**
 409:.\Include/arm_math.h ****    * @brief 32-bit fractional data type in 1.31 format.
 410:.\Include/arm_math.h ****    */
 411:.\Include/arm_math.h ****   typedef int32_t q31_t;
 412:.\Include/arm_math.h **** 
 413:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 12


 414:.\Include/arm_math.h ****    * @brief 64-bit fractional data type in 1.63 format.
 415:.\Include/arm_math.h ****    */
 416:.\Include/arm_math.h ****   typedef int64_t q63_t;
 417:.\Include/arm_math.h **** 
 418:.\Include/arm_math.h ****   /**
 419:.\Include/arm_math.h ****    * @brief 32-bit floating-point type definition.
 420:.\Include/arm_math.h ****    */
 421:.\Include/arm_math.h ****   typedef float float32_t;
 422:.\Include/arm_math.h **** 
 423:.\Include/arm_math.h ****   /**
 424:.\Include/arm_math.h ****    * @brief 64-bit floating-point type definition.
 425:.\Include/arm_math.h ****    */
 426:.\Include/arm_math.h ****   typedef double float64_t;
 427:.\Include/arm_math.h **** 
 428:.\Include/arm_math.h ****   /**
 429:.\Include/arm_math.h ****    * @brief definition to read/write two 16 bit values.
 430:.\Include/arm_math.h ****    */
 431:.\Include/arm_math.h **** #if   defined ( __CC_ARM )
 432:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 433:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 434:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 435:.\Include/arm_math.h **** 
 436:.\Include/arm_math.h **** #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 437:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 438:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 439:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 440:.\Include/arm_math.h **** 
 441:.\Include/arm_math.h **** #elif defined ( __GNUC__ )
 442:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 443:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 444:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 445:.\Include/arm_math.h **** 
 446:.\Include/arm_math.h **** #elif defined ( __ICCARM__ )
 447:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 448:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 449:.\Include/arm_math.h ****   #define CMSIS_INLINE
 450:.\Include/arm_math.h **** 
 451:.\Include/arm_math.h **** #elif defined ( __TI_ARM__ )
 452:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 453:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 454:.\Include/arm_math.h ****   #define CMSIS_INLINE
 455:.\Include/arm_math.h **** 
 456:.\Include/arm_math.h **** #elif defined ( __CSMC__ )
 457:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 458:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 459:.\Include/arm_math.h ****   #define CMSIS_INLINE
 460:.\Include/arm_math.h **** 
 461:.\Include/arm_math.h **** #elif defined ( __TASKING__ )
 462:.\Include/arm_math.h ****   #define __SIMD32_TYPE __unaligned int32_t
 463:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 464:.\Include/arm_math.h ****   #define CMSIS_INLINE
 465:.\Include/arm_math.h **** 
 466:.\Include/arm_math.h **** #else
 467:.\Include/arm_math.h ****   #error Unknown compiler
 468:.\Include/arm_math.h **** #endif
 469:.\Include/arm_math.h **** 
 470:.\Include/arm_math.h **** #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 13


 471:.\Include/arm_math.h **** #define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
 472:.\Include/arm_math.h **** #define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
 473:.\Include/arm_math.h **** #define __SIMD64(addr)        (*(int64_t **) & (addr))
 474:.\Include/arm_math.h **** 
 475:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 476:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 477:.\Include/arm_math.h ****   /**
 478:.\Include/arm_math.h ****    * @brief definition to pack two 16 bit values.
 479:.\Include/arm_math.h ****    */
 480:.\Include/arm_math.h **** #define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
 481:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
 482:.\Include/arm_math.h **** #define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
 483:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
 484:.\Include/arm_math.h **** 
 485:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 486:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
 487:.\Include/arm_math.h **** 
 488:.\Include/arm_math.h ****    /**
 489:.\Include/arm_math.h ****    * @brief definition to pack four 8 bit values.
 490:.\Include/arm_math.h ****    */
 491:.\Include/arm_math.h **** #ifndef ARM_MATH_BIG_ENDIAN
 492:.\Include/arm_math.h **** 
 493:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
 494:.\Include/arm_math.h ****                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
 495:.\Include/arm_math.h ****                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
 496:.\Include/arm_math.h ****                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 497:.\Include/arm_math.h **** #else
 498:.\Include/arm_math.h **** 
 499:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
 500:.\Include/arm_math.h ****                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
 501:.\Include/arm_math.h ****                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
 502:.\Include/arm_math.h ****                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 503:.\Include/arm_math.h **** 
 504:.\Include/arm_math.h **** #endif
 505:.\Include/arm_math.h **** 
 506:.\Include/arm_math.h **** 
 507:.\Include/arm_math.h ****   /**
 508:.\Include/arm_math.h ****    * @brief Clips Q63 to Q31 values.
 509:.\Include/arm_math.h ****    */
 510:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
 511:.\Include/arm_math.h ****   q63_t x)
 512:.\Include/arm_math.h ****   {
 513:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 514:.\Include/arm_math.h ****       ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
 515:.\Include/arm_math.h ****   }
 516:.\Include/arm_math.h **** 
 517:.\Include/arm_math.h ****   /**
 518:.\Include/arm_math.h ****    * @brief Clips Q63 to Q15 values.
 519:.\Include/arm_math.h ****    */
 520:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
 521:.\Include/arm_math.h ****   q63_t x)
 522:.\Include/arm_math.h ****   {
 523:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 524:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
 525:.\Include/arm_math.h ****   }
 526:.\Include/arm_math.h **** 
 527:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 14


 528:.\Include/arm_math.h ****    * @brief Clips Q31 to Q7 values.
 529:.\Include/arm_math.h ****    */
 530:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
 531:.\Include/arm_math.h ****   q31_t x)
 532:.\Include/arm_math.h ****   {
 533:.\Include/arm_math.h ****     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
 534:.\Include/arm_math.h ****       ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
 535:.\Include/arm_math.h ****   }
 536:.\Include/arm_math.h **** 
 537:.\Include/arm_math.h ****   /**
 538:.\Include/arm_math.h ****    * @brief Clips Q31 to Q15 values.
 539:.\Include/arm_math.h ****    */
 540:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
 541:.\Include/arm_math.h ****   q31_t x)
 542:.\Include/arm_math.h ****   {
 543:.\Include/arm_math.h ****     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
 544:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
 545:.\Include/arm_math.h ****   }
 546:.\Include/arm_math.h **** 
 547:.\Include/arm_math.h ****   /**
 548:.\Include/arm_math.h ****    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
 549:.\Include/arm_math.h ****    */
 550:.\Include/arm_math.h **** 
 551:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
 552:.\Include/arm_math.h ****   q63_t x,
 553:.\Include/arm_math.h ****   q31_t y)
 554:.\Include/arm_math.h ****   {
 555:.\Include/arm_math.h ****     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
 556:.\Include/arm_math.h ****             (((q63_t) (x >> 32) * y)));
 557:.\Include/arm_math.h ****   }
 558:.\Include/arm_math.h **** 
 559:.\Include/arm_math.h **** /*
 560:.\Include/arm_math.h ****   #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
 561:.\Include/arm_math.h ****   #define __CLZ __clz
 562:.\Include/arm_math.h ****   #endif
 563:.\Include/arm_math.h ****  */
 564:.\Include/arm_math.h **** /* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
 565:.\Include/arm_math.h **** #if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
 566:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 567:.\Include/arm_math.h ****   q31_t data);
 568:.\Include/arm_math.h **** 
 569:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 570:.\Include/arm_math.h ****   q31_t data)
 571:.\Include/arm_math.h ****   {
 572:.\Include/arm_math.h ****     uint32_t count = 0;
 573:.\Include/arm_math.h ****     uint32_t mask = 0x80000000;
 574:.\Include/arm_math.h **** 
 575:.\Include/arm_math.h ****     while ((data & mask) == 0)
 576:.\Include/arm_math.h ****     {
 577:.\Include/arm_math.h ****       count += 1u;
 578:.\Include/arm_math.h ****       mask = mask >> 1u;
 579:.\Include/arm_math.h ****     }
 580:.\Include/arm_math.h **** 
 581:.\Include/arm_math.h ****     return (count);
 582:.\Include/arm_math.h ****   }
 583:.\Include/arm_math.h **** #endif
 584:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 15


 585:.\Include/arm_math.h ****   /**
 586:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
 587:.\Include/arm_math.h ****    */
 588:.\Include/arm_math.h **** 
 589:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
 590:.\Include/arm_math.h ****   q31_t in,
 591:.\Include/arm_math.h ****   q31_t * dst,
 592:.\Include/arm_math.h ****   q31_t * pRecipTable)
 593:.\Include/arm_math.h ****   {
 594:.\Include/arm_math.h ****     q31_t out;
 595:.\Include/arm_math.h ****     uint32_t tempVal;
 596:.\Include/arm_math.h ****     uint32_t index, i;
 597:.\Include/arm_math.h ****     uint32_t signBits;
 598:.\Include/arm_math.h **** 
 599:.\Include/arm_math.h ****     if (in > 0)
 600:.\Include/arm_math.h ****     {
 601:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ( in) - 1));
 602:.\Include/arm_math.h ****     }
 603:.\Include/arm_math.h ****     else
 604:.\Include/arm_math.h ****     {
 605:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ(-in) - 1));
 606:.\Include/arm_math.h ****     }
 607:.\Include/arm_math.h **** 
 608:.\Include/arm_math.h ****     /* Convert input sample to 1.31 format */
 609:.\Include/arm_math.h ****     in = (in << signBits);
 610:.\Include/arm_math.h **** 
 611:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 612:.\Include/arm_math.h ****     index = (uint32_t)(in >> 24);
 613:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 614:.\Include/arm_math.h **** 
 615:.\Include/arm_math.h ****     /* 1.31 with exp 1 */
 616:.\Include/arm_math.h ****     out = pRecipTable[index];
 617:.\Include/arm_math.h **** 
 618:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 619:.\Include/arm_math.h ****     /* running approximation for two iterations */
 620:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 621:.\Include/arm_math.h ****     {
 622:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q63_t) in * out) >> 31);
 623:.\Include/arm_math.h ****       tempVal = 0x7FFFFFFFu - tempVal;
 624:.\Include/arm_math.h ****       /*      1.31 with exp 1 */
 625:.\Include/arm_math.h ****       /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
 626:.\Include/arm_math.h ****       out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
 627:.\Include/arm_math.h ****     }
 628:.\Include/arm_math.h **** 
 629:.\Include/arm_math.h ****     /* write output */
 630:.\Include/arm_math.h ****     *dst = out;
 631:.\Include/arm_math.h **** 
 632:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 633:.\Include/arm_math.h ****     return (signBits + 1u);
 634:.\Include/arm_math.h ****   }
 635:.\Include/arm_math.h **** 
 636:.\Include/arm_math.h **** 
 637:.\Include/arm_math.h ****   /**
 638:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
 639:.\Include/arm_math.h ****    */
 640:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
 641:.\Include/arm_math.h ****   q15_t in,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 16


 642:.\Include/arm_math.h ****   q15_t * dst,
 643:.\Include/arm_math.h ****   q15_t * pRecipTable)
 644:.\Include/arm_math.h ****   {
 645:.\Include/arm_math.h ****     q15_t out = 0;
 646:.\Include/arm_math.h ****     uint32_t tempVal = 0;
 647:.\Include/arm_math.h ****     uint32_t index = 0, i = 0;
 648:.\Include/arm_math.h ****     uint32_t signBits = 0;
 649:.\Include/arm_math.h **** 
 650:.\Include/arm_math.h ****     if (in > 0)
 651:.\Include/arm_math.h ****     {
 652:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ( in) - 17));
 653:.\Include/arm_math.h ****     }
 654:.\Include/arm_math.h ****     else
 655:.\Include/arm_math.h ****     {
 656:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ(-in) - 17));
 657:.\Include/arm_math.h ****     }
 658:.\Include/arm_math.h **** 
 659:.\Include/arm_math.h ****     /* Convert input sample to 1.15 format */
 660:.\Include/arm_math.h ****     in = (in << signBits);
 661:.\Include/arm_math.h **** 
 662:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 663:.\Include/arm_math.h ****     index = (uint32_t)(in >>  8);
 664:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 665:.\Include/arm_math.h **** 
 666:.\Include/arm_math.h ****     /*      1.15 with exp 1  */
 667:.\Include/arm_math.h ****     out = pRecipTable[index];
 668:.\Include/arm_math.h **** 
 669:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 670:.\Include/arm_math.h ****     /* running approximation for two iterations */
 671:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 672:.\Include/arm_math.h ****     {
 673:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q31_t) in * out) >> 15);
 674:.\Include/arm_math.h ****       tempVal = 0x7FFFu - tempVal;
 675:.\Include/arm_math.h ****       /*      1.15 with exp 1 */
 676:.\Include/arm_math.h ****       out = (q15_t) (((q31_t) out * tempVal) >> 14);
 677:.\Include/arm_math.h ****       /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
 678:.\Include/arm_math.h ****     }
 679:.\Include/arm_math.h **** 
 680:.\Include/arm_math.h ****     /* write output */
 681:.\Include/arm_math.h ****     *dst = out;
 682:.\Include/arm_math.h **** 
 683:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 684:.\Include/arm_math.h ****     return (signBits + 1);
 685:.\Include/arm_math.h ****   }
 686:.\Include/arm_math.h **** 
 687:.\Include/arm_math.h **** 
 688:.\Include/arm_math.h ****   /*
 689:.\Include/arm_math.h ****    * @brief C custom defined intrinisic function for only M0 processors
 690:.\Include/arm_math.h ****    */
 691:.\Include/arm_math.h **** #if defined(ARM_MATH_CM0_FAMILY)
 692:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t __SSAT(
 693:.\Include/arm_math.h ****   q31_t x,
 694:.\Include/arm_math.h ****   uint32_t y)
 695:.\Include/arm_math.h ****   {
 696:.\Include/arm_math.h ****     int32_t posMax, negMin;
 697:.\Include/arm_math.h ****     uint32_t i;
 698:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 17


 699:.\Include/arm_math.h ****     posMax = 1;
 700:.\Include/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 701:.\Include/arm_math.h ****     {
 702:.\Include/arm_math.h ****       posMax = posMax * 2;
 703:.\Include/arm_math.h ****     }
 704:.\Include/arm_math.h **** 
 705:.\Include/arm_math.h ****     if (x > 0)
 706:.\Include/arm_math.h ****     {
 707:.\Include/arm_math.h ****       posMax = (posMax - 1);
 708:.\Include/arm_math.h **** 
 709:.\Include/arm_math.h ****       if (x > posMax)
 710:.\Include/arm_math.h ****       {
 711:.\Include/arm_math.h ****         x = posMax;
 712:.\Include/arm_math.h ****       }
 713:.\Include/arm_math.h ****     }
 714:.\Include/arm_math.h ****     else
 715:.\Include/arm_math.h ****     {
 716:.\Include/arm_math.h ****       negMin = -posMax;
 717:.\Include/arm_math.h **** 
 718:.\Include/arm_math.h ****       if (x < negMin)
 719:.\Include/arm_math.h ****       {
 720:.\Include/arm_math.h ****         x = negMin;
 721:.\Include/arm_math.h ****       }
 722:.\Include/arm_math.h ****     }
 723:.\Include/arm_math.h ****     return (x);
 724:.\Include/arm_math.h ****   }
 725:.\Include/arm_math.h **** #endif /* end of ARM_MATH_CM0_FAMILY */
 726:.\Include/arm_math.h **** 
 727:.\Include/arm_math.h **** 
 728:.\Include/arm_math.h ****   /*
 729:.\Include/arm_math.h ****    * @brief C custom defined intrinsic function for M3 and M0 processors
 730:.\Include/arm_math.h ****    */
 731:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 732:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 733:.\Include/arm_math.h **** 
 734:.\Include/arm_math.h ****   /*
 735:.\Include/arm_math.h ****    * @brief C custom defined QADD8 for M3 and M0 processors
 736:.\Include/arm_math.h ****    */
 737:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
 738:.\Include/arm_math.h ****   uint32_t x,
 739:.\Include/arm_math.h ****   uint32_t y)
 740:.\Include/arm_math.h ****   {
 741:.\Include/arm_math.h ****     q31_t r, s, t, u;
 742:.\Include/arm_math.h **** 
 743:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 744:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 745:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 746:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 747:.\Include/arm_math.h **** 
 748:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 749:.\Include/arm_math.h ****   }
 750:.\Include/arm_math.h **** 
 751:.\Include/arm_math.h **** 
 752:.\Include/arm_math.h ****   /*
 753:.\Include/arm_math.h ****    * @brief C custom defined QSUB8 for M3 and M0 processors
 754:.\Include/arm_math.h ****    */
 755:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 18


 756:.\Include/arm_math.h ****   uint32_t x,
 757:.\Include/arm_math.h ****   uint32_t y)
 758:.\Include/arm_math.h ****   {
 759:.\Include/arm_math.h ****     q31_t r, s, t, u;
 760:.\Include/arm_math.h **** 
 761:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 762:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 763:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 764:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 765:.\Include/arm_math.h **** 
 766:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 767:.\Include/arm_math.h ****   }
 768:.\Include/arm_math.h **** 
 769:.\Include/arm_math.h **** 
 770:.\Include/arm_math.h ****   /*
 771:.\Include/arm_math.h ****    * @brief C custom defined QADD16 for M3 and M0 processors
 772:.\Include/arm_math.h ****    */
 773:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
 774:.\Include/arm_math.h ****   uint32_t x,
 775:.\Include/arm_math.h ****   uint32_t y)
 776:.\Include/arm_math.h ****   {
 777:.\Include/arm_math.h **** /*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass
 778:.\Include/arm_math.h ****     q31_t r = 0, s = 0;
 779:.\Include/arm_math.h **** 
 780:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 781:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 782:.\Include/arm_math.h **** 
 783:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 784:.\Include/arm_math.h ****   }
 785:.\Include/arm_math.h **** 
 786:.\Include/arm_math.h **** 
 787:.\Include/arm_math.h ****   /*
 788:.\Include/arm_math.h ****    * @brief C custom defined SHADD16 for M3 and M0 processors
 789:.\Include/arm_math.h ****    */
 790:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
 791:.\Include/arm_math.h ****   uint32_t x,
 792:.\Include/arm_math.h ****   uint32_t y)
 793:.\Include/arm_math.h ****   {
 794:.\Include/arm_math.h ****     q31_t r, s;
 795:.\Include/arm_math.h **** 
 796:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 797:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 798:.\Include/arm_math.h **** 
 799:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 800:.\Include/arm_math.h ****   }
 801:.\Include/arm_math.h **** 
 802:.\Include/arm_math.h **** 
 803:.\Include/arm_math.h ****   /*
 804:.\Include/arm_math.h ****    * @brief C custom defined QSUB16 for M3 and M0 processors
 805:.\Include/arm_math.h ****    */
 806:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
 807:.\Include/arm_math.h ****   uint32_t x,
 808:.\Include/arm_math.h ****   uint32_t y)
 809:.\Include/arm_math.h ****   {
 810:.\Include/arm_math.h ****     q31_t r, s;
 811:.\Include/arm_math.h **** 
 812:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 19


 813:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 814:.\Include/arm_math.h **** 
 815:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 816:.\Include/arm_math.h ****   }
 817:.\Include/arm_math.h **** 
 818:.\Include/arm_math.h **** 
 819:.\Include/arm_math.h ****   /*
 820:.\Include/arm_math.h ****    * @brief C custom defined SHSUB16 for M3 and M0 processors
 821:.\Include/arm_math.h ****    */
 822:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
 823:.\Include/arm_math.h ****   uint32_t x,
 824:.\Include/arm_math.h ****   uint32_t y)
 825:.\Include/arm_math.h ****   {
 826:.\Include/arm_math.h ****     q31_t r, s;
 827:.\Include/arm_math.h **** 
 828:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 829:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 830:.\Include/arm_math.h **** 
 831:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 832:.\Include/arm_math.h ****   }
 833:.\Include/arm_math.h **** 
 834:.\Include/arm_math.h **** 
 835:.\Include/arm_math.h ****   /*
 836:.\Include/arm_math.h ****    * @brief C custom defined QASX for M3 and M0 processors
 837:.\Include/arm_math.h ****    */
 838:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
 839:.\Include/arm_math.h ****   uint32_t x,
 840:.\Include/arm_math.h ****   uint32_t y)
 841:.\Include/arm_math.h ****   {
 842:.\Include/arm_math.h ****     q31_t r, s;
 843:.\Include/arm_math.h **** 
 844:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 845:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 846:.\Include/arm_math.h **** 
 847:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 848:.\Include/arm_math.h ****   }
 849:.\Include/arm_math.h **** 
 850:.\Include/arm_math.h **** 
 851:.\Include/arm_math.h ****   /*
 852:.\Include/arm_math.h ****    * @brief C custom defined SHASX for M3 and M0 processors
 853:.\Include/arm_math.h ****    */
 854:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
 855:.\Include/arm_math.h ****   uint32_t x,
 856:.\Include/arm_math.h ****   uint32_t y)
 857:.\Include/arm_math.h ****   {
 858:.\Include/arm_math.h ****     q31_t r, s;
 859:.\Include/arm_math.h **** 
 860:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 861:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 862:.\Include/arm_math.h **** 
 863:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 864:.\Include/arm_math.h ****   }
 865:.\Include/arm_math.h **** 
 866:.\Include/arm_math.h **** 
 867:.\Include/arm_math.h ****   /*
 868:.\Include/arm_math.h ****    * @brief C custom defined QSAX for M3 and M0 processors
 869:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 20


 870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
 871:.\Include/arm_math.h ****   uint32_t x,
 872:.\Include/arm_math.h ****   uint32_t y)
 873:.\Include/arm_math.h ****   {
 874:.\Include/arm_math.h ****     q31_t r, s;
 875:.\Include/arm_math.h **** 
 876:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 877:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 878:.\Include/arm_math.h **** 
 879:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 880:.\Include/arm_math.h ****   }
 881:.\Include/arm_math.h **** 
 882:.\Include/arm_math.h **** 
 883:.\Include/arm_math.h ****   /*
 884:.\Include/arm_math.h ****    * @brief C custom defined SHSAX for M3 and M0 processors
 885:.\Include/arm_math.h ****    */
 886:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
 887:.\Include/arm_math.h ****   uint32_t x,
 888:.\Include/arm_math.h ****   uint32_t y)
 889:.\Include/arm_math.h ****   {
 890:.\Include/arm_math.h ****     q31_t r, s;
 891:.\Include/arm_math.h **** 
 892:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 893:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 894:.\Include/arm_math.h **** 
 895:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 896:.\Include/arm_math.h ****   }
 897:.\Include/arm_math.h **** 
 898:.\Include/arm_math.h **** 
 899:.\Include/arm_math.h ****   /*
 900:.\Include/arm_math.h ****    * @brief C custom defined SMUSDX for M3 and M0 processors
 901:.\Include/arm_math.h ****    */
 902:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
 903:.\Include/arm_math.h ****   uint32_t x,
 904:.\Include/arm_math.h ****   uint32_t y)
 905:.\Include/arm_math.h ****   {
 906:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 907:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 908:.\Include/arm_math.h ****   }
 909:.\Include/arm_math.h **** 
 910:.\Include/arm_math.h ****   /*
 911:.\Include/arm_math.h ****    * @brief C custom defined SMUADX for M3 and M0 processors
 912:.\Include/arm_math.h ****    */
 913:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
 914:.\Include/arm_math.h ****   uint32_t x,
 915:.\Include/arm_math.h ****   uint32_t y)
 916:.\Include/arm_math.h ****   {
 917:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 918:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 919:.\Include/arm_math.h ****   }
 920:.\Include/arm_math.h **** 
 921:.\Include/arm_math.h **** 
 922:.\Include/arm_math.h ****   /*
 923:.\Include/arm_math.h ****    * @brief C custom defined QADD for M3 and M0 processors
 924:.\Include/arm_math.h ****    */
 925:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
 926:.\Include/arm_math.h ****   int32_t x,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 21


 927:.\Include/arm_math.h ****   int32_t y)
 928:.\Include/arm_math.h ****   {
 929:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
 930:.\Include/arm_math.h ****   }
 931:.\Include/arm_math.h **** 
 932:.\Include/arm_math.h **** 
 933:.\Include/arm_math.h ****   /*
 934:.\Include/arm_math.h ****    * @brief C custom defined QSUB for M3 and M0 processors
 935:.\Include/arm_math.h ****    */
 936:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
 937:.\Include/arm_math.h ****   int32_t x,
 938:.\Include/arm_math.h ****   int32_t y)
 939:.\Include/arm_math.h ****   {
 940:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
 941:.\Include/arm_math.h ****   }
 942:.\Include/arm_math.h **** 
 943:.\Include/arm_math.h **** 
 944:.\Include/arm_math.h ****   /*
 945:.\Include/arm_math.h ****    * @brief C custom defined SMLAD for M3 and M0 processors
 946:.\Include/arm_math.h ****    */
 947:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
 948:.\Include/arm_math.h ****   uint32_t x,
 949:.\Include/arm_math.h ****   uint32_t y,
 950:.\Include/arm_math.h ****   uint32_t sum)
 951:.\Include/arm_math.h ****   {
 952:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 953:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 954:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 955:.\Include/arm_math.h ****   }
 956:.\Include/arm_math.h **** 
 957:.\Include/arm_math.h **** 
 958:.\Include/arm_math.h ****   /*
 959:.\Include/arm_math.h ****    * @brief C custom defined SMLADX for M3 and M0 processors
 960:.\Include/arm_math.h ****    */
 961:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
 962:.\Include/arm_math.h ****   uint32_t x,
 963:.\Include/arm_math.h ****   uint32_t y,
 964:.\Include/arm_math.h ****   uint32_t sum)
 965:.\Include/arm_math.h ****   {
 966:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 967:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 968:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 969:.\Include/arm_math.h ****   }
 970:.\Include/arm_math.h **** 
 971:.\Include/arm_math.h **** 
 972:.\Include/arm_math.h ****   /*
 973:.\Include/arm_math.h ****    * @brief C custom defined SMLSDX for M3 and M0 processors
 974:.\Include/arm_math.h ****    */
 975:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
 976:.\Include/arm_math.h ****   uint32_t x,
 977:.\Include/arm_math.h ****   uint32_t y,
 978:.\Include/arm_math.h ****   uint32_t sum)
 979:.\Include/arm_math.h ****   {
 980:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 981:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 982:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 983:.\Include/arm_math.h ****   }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 22


 984:.\Include/arm_math.h **** 
 985:.\Include/arm_math.h **** 
 986:.\Include/arm_math.h ****   /*
 987:.\Include/arm_math.h ****    * @brief C custom defined SMLALD for M3 and M0 processors
 988:.\Include/arm_math.h ****    */
 989:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
 990:.\Include/arm_math.h ****   uint32_t x,
 991:.\Include/arm_math.h ****   uint32_t y,
 992:.\Include/arm_math.h ****   uint64_t sum)
 993:.\Include/arm_math.h ****   {
 994:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
 995:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 996:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 997:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 998:.\Include/arm_math.h ****   }
 999:.\Include/arm_math.h **** 
1000:.\Include/arm_math.h **** 
1001:.\Include/arm_math.h ****   /*
1002:.\Include/arm_math.h ****    * @brief C custom defined SMLALDX for M3 and M0 processors
1003:.\Include/arm_math.h ****    */
1004:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
1005:.\Include/arm_math.h ****   uint32_t x,
1006:.\Include/arm_math.h ****   uint32_t y,
1007:.\Include/arm_math.h ****   uint64_t sum)
1008:.\Include/arm_math.h ****   {
1009:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
1010:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
1011:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
1012:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
1013:.\Include/arm_math.h ****   }
1014:.\Include/arm_math.h **** 
1015:.\Include/arm_math.h **** 
1016:.\Include/arm_math.h ****   /*
1017:.\Include/arm_math.h ****    * @brief C custom defined SMUAD for M3 and M0 processors
1018:.\Include/arm_math.h ****    */
1019:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
1020:.\Include/arm_math.h ****   uint32_t x,
1021:.\Include/arm_math.h ****   uint32_t y)
1022:.\Include/arm_math.h ****   {
1023:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
1024:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1025:.\Include/arm_math.h ****   }
1026:.\Include/arm_math.h **** 
1027:.\Include/arm_math.h **** 
1028:.\Include/arm_math.h ****   /*
1029:.\Include/arm_math.h ****    * @brief C custom defined SMUSD for M3 and M0 processors
1030:.\Include/arm_math.h ****    */
1031:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
1032:.\Include/arm_math.h ****   uint32_t x,
1033:.\Include/arm_math.h ****   uint32_t y)
1034:.\Include/arm_math.h ****   {
1035:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
1036:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1037:.\Include/arm_math.h ****   }
1038:.\Include/arm_math.h **** 
1039:.\Include/arm_math.h **** 
1040:.\Include/arm_math.h ****   /*
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 23


1041:.\Include/arm_math.h ****    * @brief C custom defined SXTB16 for M3 and M0 processors
1042:.\Include/arm_math.h ****    */
1043:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
1044:.\Include/arm_math.h ****   uint32_t x)
1045:.\Include/arm_math.h ****   {
1046:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
1047:.\Include/arm_math.h ****                        ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
1048:.\Include/arm_math.h ****   }
1049:.\Include/arm_math.h **** 
1050:.\Include/arm_math.h ****   /*
1051:.\Include/arm_math.h ****    * @brief C custom defined SMMLA for M3 and M0 processors
1052:.\Include/arm_math.h ****    */
1053:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
1054:.\Include/arm_math.h ****   int32_t x,
1055:.\Include/arm_math.h ****   int32_t y,
1056:.\Include/arm_math.h ****   int32_t sum)
1057:.\Include/arm_math.h ****   {
1058:.\Include/arm_math.h ****     return (sum + (int32_t) (((int64_t) x * y) >> 32));
1059:.\Include/arm_math.h ****   }
1060:.\Include/arm_math.h **** 
1061:.\Include/arm_math.h **** #if 0
1062:.\Include/arm_math.h ****   /*
1063:.\Include/arm_math.h ****    * @brief C custom defined PKHBT for unavailable DSP extension
1064:.\Include/arm_math.h ****    */
1065:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHBT(
1066:.\Include/arm_math.h ****   uint32_t x,
1067:.\Include/arm_math.h ****   uint32_t y,
1068:.\Include/arm_math.h ****   uint32_t leftshift)
1069:.\Include/arm_math.h ****   {
1070:.\Include/arm_math.h ****     return ( ((x             ) & 0x0000FFFFUL) |
1071:.\Include/arm_math.h ****              ((y << leftshift) & 0xFFFF0000UL)  );
1072:.\Include/arm_math.h ****   }
1073:.\Include/arm_math.h **** 
1074:.\Include/arm_math.h ****   /*
1075:.\Include/arm_math.h ****    * @brief C custom defined PKHTB for unavailable DSP extension
1076:.\Include/arm_math.h ****    */
1077:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHTB(
1078:.\Include/arm_math.h ****   uint32_t x,
1079:.\Include/arm_math.h ****   uint32_t y,
1080:.\Include/arm_math.h ****   uint32_t rightshift)
1081:.\Include/arm_math.h ****   {
1082:.\Include/arm_math.h ****     return ( ((x              ) & 0xFFFF0000UL) |
1083:.\Include/arm_math.h ****              ((y >> rightshift) & 0x0000FFFFUL)  );
1084:.\Include/arm_math.h ****   }
1085:.\Include/arm_math.h **** #endif
1086:.\Include/arm_math.h **** 
1087:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
1088:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
1089:.\Include/arm_math.h **** 
1090:.\Include/arm_math.h **** 
1091:.\Include/arm_math.h ****   /**
1092:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 FIR filter.
1093:.\Include/arm_math.h ****    */
1094:.\Include/arm_math.h ****   typedef struct
1095:.\Include/arm_math.h ****   {
1096:.\Include/arm_math.h ****     uint16_t numTaps;        /**< number of filter coefficients in the filter. */
1097:.\Include/arm_math.h ****     q7_t *pState;            /**< points to the state variable array. The array is of length numTap
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 24


1098:.\Include/arm_math.h ****     q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*
1099:.\Include/arm_math.h ****   } arm_fir_instance_q7;
1100:.\Include/arm_math.h **** 
1101:.\Include/arm_math.h ****   /**
1102:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR filter.
1103:.\Include/arm_math.h ****    */
1104:.\Include/arm_math.h ****   typedef struct
1105:.\Include/arm_math.h ****   {
1106:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1107:.\Include/arm_math.h ****     q15_t *pState;            /**< points to the state variable array. The array is of length numTa
1108:.\Include/arm_math.h ****     q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1109:.\Include/arm_math.h ****   } arm_fir_instance_q15;
1110:.\Include/arm_math.h **** 
1111:.\Include/arm_math.h ****   /**
1112:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR filter.
1113:.\Include/arm_math.h ****    */
1114:.\Include/arm_math.h ****   typedef struct
1115:.\Include/arm_math.h ****   {
1116:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1117:.\Include/arm_math.h ****     q31_t *pState;            /**< points to the state variable array. The array is of length numTa
1118:.\Include/arm_math.h ****     q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1119:.\Include/arm_math.h ****   } arm_fir_instance_q31;
1120:.\Include/arm_math.h **** 
1121:.\Include/arm_math.h ****   /**
1122:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR filter.
1123:.\Include/arm_math.h ****    */
1124:.\Include/arm_math.h ****   typedef struct
1125:.\Include/arm_math.h ****   {
1126:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of filter coefficients in the filter. */
1127:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
1128:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
1129:.\Include/arm_math.h ****   } arm_fir_instance_f32;
1130:.\Include/arm_math.h **** 
1131:.\Include/arm_math.h **** 
1132:.\Include/arm_math.h ****   /**
1133:.\Include/arm_math.h ****    * @brief Processing function for the Q7 FIR filter.
1134:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
1135:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1136:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1137:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1138:.\Include/arm_math.h ****    */
1139:.\Include/arm_math.h ****   void arm_fir_q7(
1140:.\Include/arm_math.h ****   const arm_fir_instance_q7 * S,
1141:.\Include/arm_math.h ****   q7_t * pSrc,
1142:.\Include/arm_math.h ****   q7_t * pDst,
1143:.\Include/arm_math.h ****   uint32_t blockSize);
1144:.\Include/arm_math.h **** 
1145:.\Include/arm_math.h **** 
1146:.\Include/arm_math.h ****   /**
1147:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 FIR filter.
1148:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 FIR structure.
1149:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1150:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1151:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1152:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed.
1153:.\Include/arm_math.h ****    */
1154:.\Include/arm_math.h ****   void arm_fir_init_q7(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 25


1155:.\Include/arm_math.h ****   arm_fir_instance_q7 * S,
1156:.\Include/arm_math.h ****   uint16_t numTaps,
1157:.\Include/arm_math.h ****   q7_t * pCoeffs,
1158:.\Include/arm_math.h ****   q7_t * pState,
1159:.\Include/arm_math.h ****   uint32_t blockSize);
1160:.\Include/arm_math.h **** 
1161:.\Include/arm_math.h **** 
1162:.\Include/arm_math.h ****   /**
1163:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR filter.
1164:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR structure.
1165:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1166:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1167:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1168:.\Include/arm_math.h ****    */
1169:.\Include/arm_math.h ****   void arm_fir_q15(
1170:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1171:.\Include/arm_math.h ****   q15_t * pSrc,
1172:.\Include/arm_math.h ****   q15_t * pDst,
1173:.\Include/arm_math.h ****   uint32_t blockSize);
1174:.\Include/arm_math.h **** 
1175:.\Include/arm_math.h **** 
1176:.\Include/arm_math.h ****   /**
1177:.\Include/arm_math.h ****    * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
1178:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
1179:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1180:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1181:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1182:.\Include/arm_math.h ****    */
1183:.\Include/arm_math.h ****   void arm_fir_fast_q15(
1184:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1185:.\Include/arm_math.h ****   q15_t * pSrc,
1186:.\Include/arm_math.h ****   q15_t * pDst,
1187:.\Include/arm_math.h ****   uint32_t blockSize);
1188:.\Include/arm_math.h **** 
1189:.\Include/arm_math.h **** 
1190:.\Include/arm_math.h ****   /**
1191:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR filter.
1192:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
1193:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greate
1194:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1195:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1196:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1197:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARG
1198:.\Include/arm_math.h ****    * <code>numTaps</code> is not a supported value.
1199:.\Include/arm_math.h ****    */
1200:.\Include/arm_math.h ****   arm_status arm_fir_init_q15(
1201:.\Include/arm_math.h ****   arm_fir_instance_q15 * S,
1202:.\Include/arm_math.h ****   uint16_t numTaps,
1203:.\Include/arm_math.h ****   q15_t * pCoeffs,
1204:.\Include/arm_math.h ****   q15_t * pState,
1205:.\Include/arm_math.h ****   uint32_t blockSize);
1206:.\Include/arm_math.h **** 
1207:.\Include/arm_math.h **** 
1208:.\Include/arm_math.h ****   /**
1209:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR filter.
1210:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR filter structure.
1211:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 26


1212:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1213:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1214:.\Include/arm_math.h ****    */
1215:.\Include/arm_math.h ****   void arm_fir_q31(
1216:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1217:.\Include/arm_math.h ****   q31_t * pSrc,
1218:.\Include/arm_math.h ****   q31_t * pDst,
1219:.\Include/arm_math.h ****   uint32_t blockSize);
1220:.\Include/arm_math.h **** 
1221:.\Include/arm_math.h **** 
1222:.\Include/arm_math.h ****   /**
1223:.\Include/arm_math.h ****    * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
1224:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR structure.
1225:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1226:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1227:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1228:.\Include/arm_math.h ****    */
1229:.\Include/arm_math.h ****   void arm_fir_fast_q31(
1230:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1231:.\Include/arm_math.h ****   q31_t * pSrc,
1232:.\Include/arm_math.h ****   q31_t * pDst,
1233:.\Include/arm_math.h ****   uint32_t blockSize);
1234:.\Include/arm_math.h **** 
1235:.\Include/arm_math.h **** 
1236:.\Include/arm_math.h ****   /**
1237:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR filter.
1238:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR structure.
1239:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1240:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1241:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1242:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1243:.\Include/arm_math.h ****    */
1244:.\Include/arm_math.h ****   void arm_fir_init_q31(
1245:.\Include/arm_math.h ****   arm_fir_instance_q31 * S,
1246:.\Include/arm_math.h ****   uint16_t numTaps,
1247:.\Include/arm_math.h ****   q31_t * pCoeffs,
1248:.\Include/arm_math.h ****   q31_t * pState,
1249:.\Include/arm_math.h ****   uint32_t blockSize);
1250:.\Include/arm_math.h **** 
1251:.\Include/arm_math.h **** 
1252:.\Include/arm_math.h ****   /**
1253:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR filter.
1254:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR structure.
1255:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1256:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1257:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1258:.\Include/arm_math.h ****    */
1259:.\Include/arm_math.h ****   void arm_fir_f32(
1260:.\Include/arm_math.h ****   const arm_fir_instance_f32 * S,
1261:.\Include/arm_math.h ****   float32_t * pSrc,
1262:.\Include/arm_math.h ****   float32_t * pDst,
1263:.\Include/arm_math.h ****   uint32_t blockSize);
1264:.\Include/arm_math.h **** 
1265:.\Include/arm_math.h **** 
1266:.\Include/arm_math.h ****   /**
1267:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR filter.
1268:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 27


1269:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1270:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1271:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1272:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1273:.\Include/arm_math.h ****    */
1274:.\Include/arm_math.h ****   void arm_fir_init_f32(
1275:.\Include/arm_math.h ****   arm_fir_instance_f32 * S,
1276:.\Include/arm_math.h ****   uint16_t numTaps,
1277:.\Include/arm_math.h ****   float32_t * pCoeffs,
1278:.\Include/arm_math.h ****   float32_t * pState,
1279:.\Include/arm_math.h ****   uint32_t blockSize);
1280:.\Include/arm_math.h **** 
1281:.\Include/arm_math.h **** 
1282:.\Include/arm_math.h ****   /**
1283:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 Biquad cascade filter.
1284:.\Include/arm_math.h ****    */
1285:.\Include/arm_math.h ****   typedef struct
1286:.\Include/arm_math.h ****   {
1287:.\Include/arm_math.h ****     int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*num
1288:.\Include/arm_math.h ****     q15_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1289:.\Include/arm_math.h ****     q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1290:.\Include/arm_math.h ****     int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
1291:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q15;
1292:.\Include/arm_math.h **** 
1293:.\Include/arm_math.h ****   /**
1294:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 Biquad cascade filter.
1295:.\Include/arm_math.h ****    */
1296:.\Include/arm_math.h ****   typedef struct
1297:.\Include/arm_math.h ****   {
1298:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1299:.\Include/arm_math.h ****     q31_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1300:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1301:.\Include/arm_math.h ****     uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
1302:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q31;
1303:.\Include/arm_math.h **** 
1304:.\Include/arm_math.h ****   /**
1305:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Biquad cascade filter.
1306:.\Include/arm_math.h ****    */
1307:.\Include/arm_math.h ****   typedef struct
1308:.\Include/arm_math.h ****   {
1309:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1310:.\Include/arm_math.h ****     float32_t *pState;       /**< Points to the array of state coefficients.  The array is of lengt
1311:.\Include/arm_math.h ****     float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*nu
1312:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_f32;
1313:.\Include/arm_math.h **** 
1314:.\Include/arm_math.h **** 
1315:.\Include/arm_math.h ****   /**
1316:.\Include/arm_math.h ****    * @brief Processing function for the Q15 Biquad cascade filter.
1317:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1318:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1319:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1320:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1321:.\Include/arm_math.h ****    */
1322:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q15(
1323:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1324:.\Include/arm_math.h ****   q15_t * pSrc,
1325:.\Include/arm_math.h ****   q15_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 28


1326:.\Include/arm_math.h ****   uint32_t blockSize);
1327:.\Include/arm_math.h **** 
1328:.\Include/arm_math.h **** 
1329:.\Include/arm_math.h ****   /**
1330:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 Biquad cascade filter.
1331:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
1332:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1333:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1334:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1335:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1336:.\Include/arm_math.h ****    */
1337:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q15(
1338:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q15 * S,
1339:.\Include/arm_math.h ****   uint8_t numStages,
1340:.\Include/arm_math.h ****   q15_t * pCoeffs,
1341:.\Include/arm_math.h ****   q15_t * pState,
1342:.\Include/arm_math.h ****   int8_t postShift);
1343:.\Include/arm_math.h **** 
1344:.\Include/arm_math.h **** 
1345:.\Include/arm_math.h ****   /**
1346:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-
1347:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1348:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1349:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1350:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1351:.\Include/arm_math.h ****    */
1352:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q15(
1353:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1354:.\Include/arm_math.h ****   q15_t * pSrc,
1355:.\Include/arm_math.h ****   q15_t * pDst,
1356:.\Include/arm_math.h ****   uint32_t blockSize);
1357:.\Include/arm_math.h **** 
1358:.\Include/arm_math.h **** 
1359:.\Include/arm_math.h ****   /**
1360:.\Include/arm_math.h ****    * @brief Processing function for the Q31 Biquad cascade filter
1361:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1362:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1363:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1364:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1365:.\Include/arm_math.h ****    */
1366:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q31(
1367:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1368:.\Include/arm_math.h ****   q31_t * pSrc,
1369:.\Include/arm_math.h ****   q31_t * pDst,
1370:.\Include/arm_math.h ****   uint32_t blockSize);
1371:.\Include/arm_math.h **** 
1372:.\Include/arm_math.h **** 
1373:.\Include/arm_math.h ****   /**
1374:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-
1375:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1376:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1377:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1378:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1379:.\Include/arm_math.h ****    */
1380:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q31(
1381:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1382:.\Include/arm_math.h ****   q31_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 29


1383:.\Include/arm_math.h ****   q31_t * pDst,
1384:.\Include/arm_math.h ****   uint32_t blockSize);
1385:.\Include/arm_math.h **** 
1386:.\Include/arm_math.h **** 
1387:.\Include/arm_math.h ****   /**
1388:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 Biquad cascade filter.
1389:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
1390:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1391:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1392:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1393:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1394:.\Include/arm_math.h ****    */
1395:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q31(
1396:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q31 * S,
1397:.\Include/arm_math.h ****   uint8_t numStages,
1398:.\Include/arm_math.h ****   q31_t * pCoeffs,
1399:.\Include/arm_math.h ****   q31_t * pState,
1400:.\Include/arm_math.h ****   int8_t postShift);
1401:.\Include/arm_math.h **** 
1402:.\Include/arm_math.h **** 
1403:.\Include/arm_math.h ****   /**
1404:.\Include/arm_math.h ****    * @brief Processing function for the floating-point Biquad cascade filter.
1405:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
1406:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1407:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1408:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1409:.\Include/arm_math.h ****    */
1410:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_f32(
1411:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_f32 * S,
1412:.\Include/arm_math.h ****   float32_t * pSrc,
1413:.\Include/arm_math.h ****   float32_t * pDst,
1414:.\Include/arm_math.h ****   uint32_t blockSize);
1415:.\Include/arm_math.h **** 
1416:.\Include/arm_math.h **** 
1417:.\Include/arm_math.h ****   /**
1418:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point Biquad cascade filter.
1419:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure
1420:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1421:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1422:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1423:.\Include/arm_math.h ****    */
1424:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_f32(
1425:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_f32 * S,
1426:.\Include/arm_math.h ****   uint8_t numStages,
1427:.\Include/arm_math.h ****   float32_t * pCoeffs,
1428:.\Include/arm_math.h ****   float32_t * pState);
1429:.\Include/arm_math.h **** 
1430:.\Include/arm_math.h **** 
1431:.\Include/arm_math.h ****   /**
1432:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1433:.\Include/arm_math.h ****    */
1434:.\Include/arm_math.h ****   typedef struct
1435:.\Include/arm_math.h ****   {
1436:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1437:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1438:.\Include/arm_math.h ****     float32_t *pData;     /**< points to the data of the matrix. */
1439:.\Include/arm_math.h ****   } arm_matrix_instance_f32;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 30


1440:.\Include/arm_math.h **** 
1441:.\Include/arm_math.h **** 
1442:.\Include/arm_math.h ****   /**
1443:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1444:.\Include/arm_math.h ****    */
1445:.\Include/arm_math.h ****   typedef struct
1446:.\Include/arm_math.h ****   {
1447:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1448:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1449:.\Include/arm_math.h ****     float64_t *pData;     /**< points to the data of the matrix. */
1450:.\Include/arm_math.h ****   } arm_matrix_instance_f64;
1451:.\Include/arm_math.h **** 
1452:.\Include/arm_math.h ****   /**
1453:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 matrix structure.
1454:.\Include/arm_math.h ****    */
1455:.\Include/arm_math.h ****   typedef struct
1456:.\Include/arm_math.h ****   {
1457:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1458:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1459:.\Include/arm_math.h ****     q15_t *pData;         /**< points to the data of the matrix. */
1460:.\Include/arm_math.h ****   } arm_matrix_instance_q15;
1461:.\Include/arm_math.h **** 
1462:.\Include/arm_math.h ****   /**
1463:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 matrix structure.
1464:.\Include/arm_math.h ****    */
1465:.\Include/arm_math.h ****   typedef struct
1466:.\Include/arm_math.h ****   {
1467:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1468:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1469:.\Include/arm_math.h ****     q31_t *pData;         /**< points to the data of the matrix. */
1470:.\Include/arm_math.h ****   } arm_matrix_instance_q31;
1471:.\Include/arm_math.h **** 
1472:.\Include/arm_math.h **** 
1473:.\Include/arm_math.h ****   /**
1474:.\Include/arm_math.h ****    * @brief Floating-point matrix addition.
1475:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1476:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1477:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1478:.\Include/arm_math.h ****    * @return     The function returns either
1479:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1480:.\Include/arm_math.h ****    */
1481:.\Include/arm_math.h ****   arm_status arm_mat_add_f32(
1482:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1483:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1484:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1485:.\Include/arm_math.h **** 
1486:.\Include/arm_math.h **** 
1487:.\Include/arm_math.h ****   /**
1488:.\Include/arm_math.h ****    * @brief Q15 matrix addition.
1489:.\Include/arm_math.h ****    * @param[in]   pSrcA  points to the first input matrix structure
1490:.\Include/arm_math.h ****    * @param[in]   pSrcB  points to the second input matrix structure
1491:.\Include/arm_math.h ****    * @param[out]  pDst   points to output matrix structure
1492:.\Include/arm_math.h ****    * @return     The function returns either
1493:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1494:.\Include/arm_math.h ****    */
1495:.\Include/arm_math.h ****   arm_status arm_mat_add_q15(
1496:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 31


1497:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1498:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1499:.\Include/arm_math.h **** 
1500:.\Include/arm_math.h **** 
1501:.\Include/arm_math.h ****   /**
1502:.\Include/arm_math.h ****    * @brief Q31 matrix addition.
1503:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1504:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1505:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1506:.\Include/arm_math.h ****    * @return     The function returns either
1507:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1508:.\Include/arm_math.h ****    */
1509:.\Include/arm_math.h ****   arm_status arm_mat_add_q31(
1510:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1511:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1512:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1513:.\Include/arm_math.h **** 
1514:.\Include/arm_math.h **** 
1515:.\Include/arm_math.h ****   /**
1516:.\Include/arm_math.h ****    * @brief Floating-point, complex, matrix multiplication.
1517:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1518:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1519:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1520:.\Include/arm_math.h ****    * @return     The function returns either
1521:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1522:.\Include/arm_math.h ****    */
1523:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_f32(
1524:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1525:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1526:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1527:.\Include/arm_math.h **** 
1528:.\Include/arm_math.h **** 
1529:.\Include/arm_math.h ****   /**
1530:.\Include/arm_math.h ****    * @brief Q15, complex,  matrix multiplication.
1531:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1532:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1533:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1534:.\Include/arm_math.h ****    * @return     The function returns either
1535:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1536:.\Include/arm_math.h ****    */
1537:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q15(
1538:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1539:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1540:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1541:.\Include/arm_math.h ****   q15_t * pScratch);
1542:.\Include/arm_math.h **** 
1543:.\Include/arm_math.h **** 
1544:.\Include/arm_math.h ****   /**
1545:.\Include/arm_math.h ****    * @brief Q31, complex, matrix multiplication.
1546:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1547:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1548:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1549:.\Include/arm_math.h ****    * @return     The function returns either
1550:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1551:.\Include/arm_math.h ****    */
1552:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q31(
1553:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 32


1554:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1555:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1556:.\Include/arm_math.h **** 
1557:.\Include/arm_math.h **** 
1558:.\Include/arm_math.h ****   /**
1559:.\Include/arm_math.h ****    * @brief Floating-point matrix transpose.
1560:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1561:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1562:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1563:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1564:.\Include/arm_math.h ****    */
1565:.\Include/arm_math.h ****   arm_status arm_mat_trans_f32(
1566:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1567:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1568:.\Include/arm_math.h **** 
1569:.\Include/arm_math.h **** 
1570:.\Include/arm_math.h ****   /**
1571:.\Include/arm_math.h ****    * @brief Q15 matrix transpose.
1572:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1573:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1574:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1575:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1576:.\Include/arm_math.h ****    */
1577:.\Include/arm_math.h ****   arm_status arm_mat_trans_q15(
1578:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1579:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1580:.\Include/arm_math.h **** 
1581:.\Include/arm_math.h **** 
1582:.\Include/arm_math.h ****   /**
1583:.\Include/arm_math.h ****    * @brief Q31 matrix transpose.
1584:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1585:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1586:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1587:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1588:.\Include/arm_math.h ****    */
1589:.\Include/arm_math.h ****   arm_status arm_mat_trans_q31(
1590:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1591:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1592:.\Include/arm_math.h **** 
1593:.\Include/arm_math.h **** 
1594:.\Include/arm_math.h ****   /**
1595:.\Include/arm_math.h ****    * @brief Floating-point matrix multiplication
1596:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1597:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1598:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1599:.\Include/arm_math.h ****    * @return     The function returns either
1600:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1601:.\Include/arm_math.h ****    */
1602:.\Include/arm_math.h ****   arm_status arm_mat_mult_f32(
1603:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1604:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1605:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1606:.\Include/arm_math.h **** 
1607:.\Include/arm_math.h **** 
1608:.\Include/arm_math.h ****   /**
1609:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication
1610:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 33


1611:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1612:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1613:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1614:.\Include/arm_math.h ****    * @return     The function returns either
1615:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1616:.\Include/arm_math.h ****    */
1617:.\Include/arm_math.h ****   arm_status arm_mat_mult_q15(
1618:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1619:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1620:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1621:.\Include/arm_math.h ****   q15_t * pState);
1622:.\Include/arm_math.h **** 
1623:.\Include/arm_math.h **** 
1624:.\Include/arm_math.h ****   /**
1625:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1626:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1627:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1628:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1629:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1630:.\Include/arm_math.h ****    * @return     The function returns either
1631:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1632:.\Include/arm_math.h ****    */
1633:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q15(
1634:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1635:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1636:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1637:.\Include/arm_math.h ****   q15_t * pState);
1638:.\Include/arm_math.h **** 
1639:.\Include/arm_math.h **** 
1640:.\Include/arm_math.h ****   /**
1641:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication
1642:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1643:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1644:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1645:.\Include/arm_math.h ****    * @return     The function returns either
1646:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1647:.\Include/arm_math.h ****    */
1648:.\Include/arm_math.h ****   arm_status arm_mat_mult_q31(
1649:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1650:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1651:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1652:.\Include/arm_math.h **** 
1653:.\Include/arm_math.h **** 
1654:.\Include/arm_math.h ****   /**
1655:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1656:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1657:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1658:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1659:.\Include/arm_math.h ****    * @return     The function returns either
1660:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1661:.\Include/arm_math.h ****    */
1662:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q31(
1663:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1664:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1665:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1666:.\Include/arm_math.h **** 
1667:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 34


1668:.\Include/arm_math.h ****   /**
1669:.\Include/arm_math.h ****    * @brief Floating-point matrix subtraction
1670:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1671:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1672:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1673:.\Include/arm_math.h ****    * @return     The function returns either
1674:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1675:.\Include/arm_math.h ****    */
1676:.\Include/arm_math.h ****   arm_status arm_mat_sub_f32(
1677:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1678:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1679:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1680:.\Include/arm_math.h **** 
1681:.\Include/arm_math.h **** 
1682:.\Include/arm_math.h ****   /**
1683:.\Include/arm_math.h ****    * @brief Q15 matrix subtraction
1684:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1685:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1686:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1687:.\Include/arm_math.h ****    * @return     The function returns either
1688:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1689:.\Include/arm_math.h ****    */
1690:.\Include/arm_math.h ****   arm_status arm_mat_sub_q15(
1691:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1692:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1693:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1694:.\Include/arm_math.h **** 
1695:.\Include/arm_math.h **** 
1696:.\Include/arm_math.h ****   /**
1697:.\Include/arm_math.h ****    * @brief Q31 matrix subtraction
1698:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1699:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1700:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1701:.\Include/arm_math.h ****    * @return     The function returns either
1702:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1703:.\Include/arm_math.h ****    */
1704:.\Include/arm_math.h ****   arm_status arm_mat_sub_q31(
1705:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1706:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1707:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1708:.\Include/arm_math.h **** 
1709:.\Include/arm_math.h **** 
1710:.\Include/arm_math.h ****   /**
1711:.\Include/arm_math.h ****    * @brief Floating-point matrix scaling.
1712:.\Include/arm_math.h ****    * @param[in]  pSrc   points to the input matrix
1713:.\Include/arm_math.h ****    * @param[in]  scale  scale factor
1714:.\Include/arm_math.h ****    * @param[out] pDst   points to the output matrix
1715:.\Include/arm_math.h ****    * @return     The function returns either
1716:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1717:.\Include/arm_math.h ****    */
1718:.\Include/arm_math.h ****   arm_status arm_mat_scale_f32(
1719:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1720:.\Include/arm_math.h ****   float32_t scale,
1721:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1722:.\Include/arm_math.h **** 
1723:.\Include/arm_math.h **** 
1724:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 35


1725:.\Include/arm_math.h ****    * @brief Q15 matrix scaling.
1726:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1727:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1728:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1729:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix
1730:.\Include/arm_math.h ****    * @return     The function returns either
1731:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1732:.\Include/arm_math.h ****    */
1733:.\Include/arm_math.h ****   arm_status arm_mat_scale_q15(
1734:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1735:.\Include/arm_math.h ****   q15_t scaleFract,
1736:.\Include/arm_math.h ****   int32_t shift,
1737:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1738:.\Include/arm_math.h **** 
1739:.\Include/arm_math.h **** 
1740:.\Include/arm_math.h ****   /**
1741:.\Include/arm_math.h ****    * @brief Q31 matrix scaling.
1742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1743:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1744:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1745:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix structure
1746:.\Include/arm_math.h ****    * @return     The function returns either
1747:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1748:.\Include/arm_math.h ****    */
1749:.\Include/arm_math.h ****   arm_status arm_mat_scale_q31(
1750:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1751:.\Include/arm_math.h ****   q31_t scaleFract,
1752:.\Include/arm_math.h ****   int32_t shift,
1753:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1754:.\Include/arm_math.h **** 
1755:.\Include/arm_math.h **** 
1756:.\Include/arm_math.h ****   /**
1757:.\Include/arm_math.h ****    * @brief  Q31 matrix initialization.
1758:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1759:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1760:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1761:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1762:.\Include/arm_math.h ****    */
1763:.\Include/arm_math.h ****   void arm_mat_init_q31(
1764:.\Include/arm_math.h ****   arm_matrix_instance_q31 * S,
1765:.\Include/arm_math.h ****   uint16_t nRows,
1766:.\Include/arm_math.h ****   uint16_t nColumns,
1767:.\Include/arm_math.h ****   q31_t * pData);
1768:.\Include/arm_math.h **** 
1769:.\Include/arm_math.h **** 
1770:.\Include/arm_math.h ****   /**
1771:.\Include/arm_math.h ****    * @brief  Q15 matrix initialization.
1772:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1773:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1774:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1775:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1776:.\Include/arm_math.h ****    */
1777:.\Include/arm_math.h ****   void arm_mat_init_q15(
1778:.\Include/arm_math.h ****   arm_matrix_instance_q15 * S,
1779:.\Include/arm_math.h ****   uint16_t nRows,
1780:.\Include/arm_math.h ****   uint16_t nColumns,
1781:.\Include/arm_math.h ****   q15_t * pData);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 36


1782:.\Include/arm_math.h **** 
1783:.\Include/arm_math.h **** 
1784:.\Include/arm_math.h ****   /**
1785:.\Include/arm_math.h ****    * @brief  Floating-point matrix initialization.
1786:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1787:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1788:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1789:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1790:.\Include/arm_math.h ****    */
1791:.\Include/arm_math.h ****   void arm_mat_init_f32(
1792:.\Include/arm_math.h ****   arm_matrix_instance_f32 * S,
1793:.\Include/arm_math.h ****   uint16_t nRows,
1794:.\Include/arm_math.h ****   uint16_t nColumns,
1795:.\Include/arm_math.h ****   float32_t * pData);
1796:.\Include/arm_math.h **** 
1797:.\Include/arm_math.h **** 
1798:.\Include/arm_math.h **** 
1799:.\Include/arm_math.h ****   /**
1800:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 PID Control.
1801:.\Include/arm_math.h ****    */
1802:.\Include/arm_math.h ****   typedef struct
1803:.\Include/arm_math.h ****   {
1804:.\Include/arm_math.h ****     q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
1805:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
1806:.\Include/arm_math.h ****     q15_t A1;
1807:.\Include/arm_math.h ****     q15_t A2;
1808:.\Include/arm_math.h **** #else
1809:.\Include/arm_math.h ****     q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
1810:.\Include/arm_math.h **** #endif
1811:.\Include/arm_math.h ****     q15_t state[3];     /**< The state array of length 3. */
1812:.\Include/arm_math.h ****     q15_t Kp;           /**< The proportional gain. */
1813:.\Include/arm_math.h ****     q15_t Ki;           /**< The integral gain. */
1814:.\Include/arm_math.h ****     q15_t Kd;           /**< The derivative gain. */
1815:.\Include/arm_math.h ****   } arm_pid_instance_q15;
1816:.\Include/arm_math.h **** 
1817:.\Include/arm_math.h ****   /**
1818:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 PID Control.
1819:.\Include/arm_math.h ****    */
1820:.\Include/arm_math.h ****   typedef struct
1821:.\Include/arm_math.h ****   {
1822:.\Include/arm_math.h ****     q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
1823:.\Include/arm_math.h ****     q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
1824:.\Include/arm_math.h ****     q31_t A2;            /**< The derived gain, A2 = Kd . */
1825:.\Include/arm_math.h ****     q31_t state[3];      /**< The state array of length 3. */
1826:.\Include/arm_math.h ****     q31_t Kp;            /**< The proportional gain. */
1827:.\Include/arm_math.h ****     q31_t Ki;            /**< The integral gain. */
1828:.\Include/arm_math.h ****     q31_t Kd;            /**< The derivative gain. */
1829:.\Include/arm_math.h ****   } arm_pid_instance_q31;
1830:.\Include/arm_math.h **** 
1831:.\Include/arm_math.h ****   /**
1832:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point PID Control.
1833:.\Include/arm_math.h ****    */
1834:.\Include/arm_math.h ****   typedef struct
1835:.\Include/arm_math.h ****   {
1836:.\Include/arm_math.h ****     float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
1837:.\Include/arm_math.h ****     float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
1838:.\Include/arm_math.h ****     float32_t A2;          /**< The derived gain, A2 = Kd . */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 37


1839:.\Include/arm_math.h ****     float32_t state[3];    /**< The state array of length 3. */
1840:.\Include/arm_math.h ****     float32_t Kp;          /**< The proportional gain. */
1841:.\Include/arm_math.h ****     float32_t Ki;          /**< The integral gain. */
1842:.\Include/arm_math.h ****     float32_t Kd;          /**< The derivative gain. */
1843:.\Include/arm_math.h ****   } arm_pid_instance_f32;
1844:.\Include/arm_math.h **** 
1845:.\Include/arm_math.h **** 
1846:.\Include/arm_math.h **** 
1847:.\Include/arm_math.h ****   /**
1848:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point PID Control.
1849:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the PID structure.
1850:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1851:.\Include/arm_math.h ****    */
1852:.\Include/arm_math.h ****   void arm_pid_init_f32(
1853:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
1854:.\Include/arm_math.h ****   int32_t resetStateFlag);
1855:.\Include/arm_math.h **** 
1856:.\Include/arm_math.h **** 
1857:.\Include/arm_math.h ****   /**
1858:.\Include/arm_math.h ****    * @brief  Reset function for the floating-point PID Control.
1859:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point PID Control structure
1860:.\Include/arm_math.h ****    */
1861:.\Include/arm_math.h ****   void arm_pid_reset_f32(
1862:.\Include/arm_math.h ****   arm_pid_instance_f32 * S);
1863:.\Include/arm_math.h **** 
1864:.\Include/arm_math.h **** 
1865:.\Include/arm_math.h ****   /**
1866:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 PID Control.
1867:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1868:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1869:.\Include/arm_math.h ****    */
1870:.\Include/arm_math.h ****   void arm_pid_init_q31(
1871:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
1872:.\Include/arm_math.h ****   int32_t resetStateFlag);
1873:.\Include/arm_math.h **** 
1874:.\Include/arm_math.h **** 
1875:.\Include/arm_math.h ****   /**
1876:.\Include/arm_math.h ****    * @brief  Reset function for the Q31 PID Control.
1877:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q31 PID Control structure
1878:.\Include/arm_math.h ****    */
1879:.\Include/arm_math.h **** 
1880:.\Include/arm_math.h ****   void arm_pid_reset_q31(
1881:.\Include/arm_math.h ****   arm_pid_instance_q31 * S);
1882:.\Include/arm_math.h **** 
1883:.\Include/arm_math.h **** 
1884:.\Include/arm_math.h ****   /**
1885:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 PID Control.
1886:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1887:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1888:.\Include/arm_math.h ****    */
1889:.\Include/arm_math.h ****   void arm_pid_init_q15(
1890:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
1891:.\Include/arm_math.h ****   int32_t resetStateFlag);
1892:.\Include/arm_math.h **** 
1893:.\Include/arm_math.h **** 
1894:.\Include/arm_math.h ****   /**
1895:.\Include/arm_math.h ****    * @brief  Reset function for the Q15 PID Control.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 38


1896:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the q15 PID Control structure
1897:.\Include/arm_math.h ****    */
1898:.\Include/arm_math.h ****   void arm_pid_reset_q15(
1899:.\Include/arm_math.h ****   arm_pid_instance_q15 * S);
1900:.\Include/arm_math.h **** 
1901:.\Include/arm_math.h **** 
1902:.\Include/arm_math.h ****   /**
1903:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Linear Interpolate function.
1904:.\Include/arm_math.h ****    */
1905:.\Include/arm_math.h ****   typedef struct
1906:.\Include/arm_math.h ****   {
1907:.\Include/arm_math.h ****     uint32_t nValues;           /**< nValues */
1908:.\Include/arm_math.h ****     float32_t x1;               /**< x1 */
1909:.\Include/arm_math.h ****     float32_t xSpacing;         /**< xSpacing */
1910:.\Include/arm_math.h ****     float32_t *pYData;          /**< pointer to the table of Y values */
1911:.\Include/arm_math.h ****   } arm_linear_interp_instance_f32;
1912:.\Include/arm_math.h **** 
1913:.\Include/arm_math.h ****   /**
1914:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point bilinear interpolation function.
1915:.\Include/arm_math.h ****    */
1916:.\Include/arm_math.h ****   typedef struct
1917:.\Include/arm_math.h ****   {
1918:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1919:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1920:.\Include/arm_math.h ****     float32_t *pData;   /**< points to the data table. */
1921:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_f32;
1922:.\Include/arm_math.h **** 
1923:.\Include/arm_math.h ****    /**
1924:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 bilinear interpolation function.
1925:.\Include/arm_math.h ****    */
1926:.\Include/arm_math.h ****   typedef struct
1927:.\Include/arm_math.h ****   {
1928:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1929:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1930:.\Include/arm_math.h ****     q31_t *pData;       /**< points to the data table. */
1931:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q31;
1932:.\Include/arm_math.h **** 
1933:.\Include/arm_math.h ****    /**
1934:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1935:.\Include/arm_math.h ****    */
1936:.\Include/arm_math.h ****   typedef struct
1937:.\Include/arm_math.h ****   {
1938:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1939:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1940:.\Include/arm_math.h ****     q15_t *pData;       /**< points to the data table. */
1941:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q15;
1942:.\Include/arm_math.h **** 
1943:.\Include/arm_math.h ****    /**
1944:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1945:.\Include/arm_math.h ****    */
1946:.\Include/arm_math.h ****   typedef struct
1947:.\Include/arm_math.h ****   {
1948:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1949:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1950:.\Include/arm_math.h ****     q7_t *pData;        /**< points to the data table. */
1951:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q7;
1952:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 39


1953:.\Include/arm_math.h **** 
1954:.\Include/arm_math.h ****   /**
1955:.\Include/arm_math.h ****    * @brief Q7 vector multiplication.
1956:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1957:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1958:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1959:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1960:.\Include/arm_math.h ****    */
1961:.\Include/arm_math.h ****   void arm_mult_q7(
1962:.\Include/arm_math.h ****   q7_t * pSrcA,
1963:.\Include/arm_math.h ****   q7_t * pSrcB,
1964:.\Include/arm_math.h ****   q7_t * pDst,
1965:.\Include/arm_math.h ****   uint32_t blockSize);
1966:.\Include/arm_math.h **** 
1967:.\Include/arm_math.h **** 
1968:.\Include/arm_math.h ****   /**
1969:.\Include/arm_math.h ****    * @brief Q15 vector multiplication.
1970:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1971:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1972:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1973:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1974:.\Include/arm_math.h ****    */
1975:.\Include/arm_math.h ****   void arm_mult_q15(
1976:.\Include/arm_math.h ****   q15_t * pSrcA,
1977:.\Include/arm_math.h ****   q15_t * pSrcB,
1978:.\Include/arm_math.h ****   q15_t * pDst,
1979:.\Include/arm_math.h ****   uint32_t blockSize);
1980:.\Include/arm_math.h **** 
1981:.\Include/arm_math.h **** 
1982:.\Include/arm_math.h ****   /**
1983:.\Include/arm_math.h ****    * @brief Q31 vector multiplication.
1984:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1985:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1986:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1987:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1988:.\Include/arm_math.h ****    */
1989:.\Include/arm_math.h ****   void arm_mult_q31(
1990:.\Include/arm_math.h ****   q31_t * pSrcA,
1991:.\Include/arm_math.h ****   q31_t * pSrcB,
1992:.\Include/arm_math.h ****   q31_t * pDst,
1993:.\Include/arm_math.h ****   uint32_t blockSize);
1994:.\Include/arm_math.h **** 
1995:.\Include/arm_math.h **** 
1996:.\Include/arm_math.h ****   /**
1997:.\Include/arm_math.h ****    * @brief Floating-point vector multiplication.
1998:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1999:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2000:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2001:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2002:.\Include/arm_math.h ****    */
2003:.\Include/arm_math.h ****   void arm_mult_f32(
2004:.\Include/arm_math.h ****   float32_t * pSrcA,
2005:.\Include/arm_math.h ****   float32_t * pSrcB,
2006:.\Include/arm_math.h ****   float32_t * pDst,
2007:.\Include/arm_math.h ****   uint32_t blockSize);
2008:.\Include/arm_math.h **** 
2009:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 40


2010:.\Include/arm_math.h ****   /**
2011:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2012:.\Include/arm_math.h ****    */
2013:.\Include/arm_math.h ****   typedef struct
2014:.\Include/arm_math.h ****   {
2015:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2016:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2017:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2018:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
2019:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2020:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2021:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2022:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q15;
2023:.\Include/arm_math.h **** 
2024:.\Include/arm_math.h **** /* Deprecated */
2025:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q15(
2026:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q15 * S,
2027:.\Include/arm_math.h ****   uint16_t fftLen,
2028:.\Include/arm_math.h ****   uint8_t ifftFlag,
2029:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2030:.\Include/arm_math.h **** 
2031:.\Include/arm_math.h **** /* Deprecated */
2032:.\Include/arm_math.h ****   void arm_cfft_radix2_q15(
2033:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q15 * S,
2034:.\Include/arm_math.h ****   q15_t * pSrc);
2035:.\Include/arm_math.h **** 
2036:.\Include/arm_math.h **** 
2037:.\Include/arm_math.h ****   /**
2038:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2039:.\Include/arm_math.h ****    */
2040:.\Include/arm_math.h ****   typedef struct
2041:.\Include/arm_math.h ****   {
2042:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2043:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2044:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2045:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
2046:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2047:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2048:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2049:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q15;
2050:.\Include/arm_math.h **** 
2051:.\Include/arm_math.h **** /* Deprecated */
2052:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q15(
2053:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S,
2054:.\Include/arm_math.h ****   uint16_t fftLen,
2055:.\Include/arm_math.h ****   uint8_t ifftFlag,
2056:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2057:.\Include/arm_math.h **** 
2058:.\Include/arm_math.h **** /* Deprecated */
2059:.\Include/arm_math.h ****   void arm_cfft_radix4_q15(
2060:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q15 * S,
2061:.\Include/arm_math.h ****   q15_t * pSrc);
2062:.\Include/arm_math.h **** 
2063:.\Include/arm_math.h ****   /**
2064:.\Include/arm_math.h ****    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
2065:.\Include/arm_math.h ****    */
2066:.\Include/arm_math.h ****   typedef struct
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 41


2067:.\Include/arm_math.h ****   {
2068:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2069:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2070:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2071:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
2072:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2073:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2074:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2075:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q31;
2076:.\Include/arm_math.h **** 
2077:.\Include/arm_math.h **** /* Deprecated */
2078:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q31(
2079:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q31 * S,
2080:.\Include/arm_math.h ****   uint16_t fftLen,
2081:.\Include/arm_math.h ****   uint8_t ifftFlag,
2082:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2083:.\Include/arm_math.h **** 
2084:.\Include/arm_math.h **** /* Deprecated */
2085:.\Include/arm_math.h ****   void arm_cfft_radix2_q31(
2086:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q31 * S,
2087:.\Include/arm_math.h ****   q31_t * pSrc);
2088:.\Include/arm_math.h **** 
2089:.\Include/arm_math.h ****   /**
2090:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 CFFT/CIFFT function.
2091:.\Include/arm_math.h ****    */
2092:.\Include/arm_math.h ****   typedef struct
2093:.\Include/arm_math.h ****   {
2094:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2095:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2096:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2097:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
2098:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2099:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2100:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2101:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q31;
2102:.\Include/arm_math.h **** 
2103:.\Include/arm_math.h **** /* Deprecated */
2104:.\Include/arm_math.h ****   void arm_cfft_radix4_q31(
2105:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q31 * S,
2106:.\Include/arm_math.h ****   q31_t * pSrc);
2107:.\Include/arm_math.h **** 
2108:.\Include/arm_math.h **** /* Deprecated */
2109:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q31(
2110:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S,
2111:.\Include/arm_math.h ****   uint16_t fftLen,
2112:.\Include/arm_math.h ****   uint8_t ifftFlag,
2113:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2114:.\Include/arm_math.h **** 
2115:.\Include/arm_math.h ****   /**
2116:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2117:.\Include/arm_math.h ****    */
2118:.\Include/arm_math.h ****   typedef struct
2119:.\Include/arm_math.h ****   {
2120:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2121:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2122:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2123:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 42


2124:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2125:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2126:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2127:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2128:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_f32;
2129:.\Include/arm_math.h **** 
2130:.\Include/arm_math.h **** /* Deprecated */
2131:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_f32(
2132:.\Include/arm_math.h ****   arm_cfft_radix2_instance_f32 * S,
2133:.\Include/arm_math.h ****   uint16_t fftLen,
2134:.\Include/arm_math.h ****   uint8_t ifftFlag,
2135:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2136:.\Include/arm_math.h **** 
2137:.\Include/arm_math.h **** /* Deprecated */
2138:.\Include/arm_math.h ****   void arm_cfft_radix2_f32(
2139:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_f32 * S,
2140:.\Include/arm_math.h ****   float32_t * pSrc);
2141:.\Include/arm_math.h **** 
2142:.\Include/arm_math.h ****   /**
2143:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2144:.\Include/arm_math.h ****    */
2145:.\Include/arm_math.h ****   typedef struct
2146:.\Include/arm_math.h ****   {
2147:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2148:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2149:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2150:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2151:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2152:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2153:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2154:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2155:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_f32;
2156:.\Include/arm_math.h **** 
2157:.\Include/arm_math.h **** /* Deprecated */
2158:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_f32(
2159:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S,
2160:.\Include/arm_math.h ****   uint16_t fftLen,
2161:.\Include/arm_math.h ****   uint8_t ifftFlag,
2162:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2163:.\Include/arm_math.h **** 
2164:.\Include/arm_math.h **** /* Deprecated */
2165:.\Include/arm_math.h ****   void arm_cfft_radix4_f32(
2166:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_f32 * S,
2167:.\Include/arm_math.h ****   float32_t * pSrc);
2168:.\Include/arm_math.h **** 
2169:.\Include/arm_math.h ****   /**
2170:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2171:.\Include/arm_math.h ****    */
2172:.\Include/arm_math.h ****   typedef struct
2173:.\Include/arm_math.h ****   {
2174:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2175:.\Include/arm_math.h ****     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
2176:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2177:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2178:.\Include/arm_math.h ****   } arm_cfft_instance_q15;
2179:.\Include/arm_math.h **** 
2180:.\Include/arm_math.h **** void arm_cfft_q15(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 43


2181:.\Include/arm_math.h ****     const arm_cfft_instance_q15 * S,
2182:.\Include/arm_math.h ****     q15_t * p1,
2183:.\Include/arm_math.h ****     uint8_t ifftFlag,
2184:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2185:.\Include/arm_math.h **** 
2186:.\Include/arm_math.h ****   /**
2187:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2188:.\Include/arm_math.h ****    */
2189:.\Include/arm_math.h ****   typedef struct
2190:.\Include/arm_math.h ****   {
2191:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2192:.\Include/arm_math.h ****     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
2193:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2194:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2195:.\Include/arm_math.h ****   } arm_cfft_instance_q31;
2196:.\Include/arm_math.h **** 
2197:.\Include/arm_math.h **** void arm_cfft_q31(
2198:.\Include/arm_math.h ****     const arm_cfft_instance_q31 * S,
2199:.\Include/arm_math.h ****     q31_t * p1,
2200:.\Include/arm_math.h ****     uint8_t ifftFlag,
2201:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2202:.\Include/arm_math.h **** 
2203:.\Include/arm_math.h ****   /**
2204:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2205:.\Include/arm_math.h ****    */
2206:.\Include/arm_math.h ****   typedef struct
2207:.\Include/arm_math.h ****   {
2208:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2209:.\Include/arm_math.h ****     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
2210:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2211:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2212:.\Include/arm_math.h ****   } arm_cfft_instance_f32;
2213:.\Include/arm_math.h **** 
2214:.\Include/arm_math.h ****   void arm_cfft_f32(
2215:.\Include/arm_math.h ****   const arm_cfft_instance_f32 * S,
2216:.\Include/arm_math.h ****   float32_t * p1,
2217:.\Include/arm_math.h ****   uint8_t ifftFlag,
2218:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2219:.\Include/arm_math.h **** 
2220:.\Include/arm_math.h ****   /**
2221:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 RFFT/RIFFT function.
2222:.\Include/arm_math.h ****    */
2223:.\Include/arm_math.h ****   typedef struct
2224:.\Include/arm_math.h ****   {
2225:.\Include/arm_math.h ****     uint32_t fftLenReal;                      /**< length of the real FFT. */
2226:.\Include/arm_math.h ****     uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inver
2227:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disable
2228:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports diffe
2229:.\Include/arm_math.h ****     q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
2230:.\Include/arm_math.h ****     q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
2231:.\Include/arm_math.h ****     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
2232:.\Include/arm_math.h ****   } arm_rfft_instance_q15;
2233:.\Include/arm_math.h **** 
2234:.\Include/arm_math.h ****   arm_status arm_rfft_init_q15(
2235:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S,
2236:.\Include/arm_math.h ****   uint32_t fftLenReal,
2237:.\Include/arm_math.h ****   uint32_t ifftFlagR,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 44


2238:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2239:.\Include/arm_math.h **** 
2240:.\Include/arm_math.h ****   void arm_rfft_q15(
2241:.\Include/arm_math.h ****   const arm_rfft_instance_q15 * S,
2242:.\Include/arm_math.h ****   q15_t * pSrc,
2243:.\Include/arm_math.h ****   q15_t * pDst);
2244:.\Include/arm_math.h **** 
2245:.\Include/arm_math.h ****   /**
2246:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 RFFT/RIFFT function.
2247:.\Include/arm_math.h ****    */
2248:.\Include/arm_math.h ****   typedef struct
2249:.\Include/arm_math.h ****   {
2250:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2251:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2252:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2253:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports dif
2254:.\Include/arm_math.h ****     q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
2255:.\Include/arm_math.h ****     q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
2256:.\Include/arm_math.h ****     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
2257:.\Include/arm_math.h ****   } arm_rfft_instance_q31;
2258:.\Include/arm_math.h **** 
2259:.\Include/arm_math.h ****   arm_status arm_rfft_init_q31(
2260:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S,
2261:.\Include/arm_math.h ****   uint32_t fftLenReal,
2262:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2263:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2264:.\Include/arm_math.h **** 
2265:.\Include/arm_math.h ****   void arm_rfft_q31(
2266:.\Include/arm_math.h ****   const arm_rfft_instance_q31 * S,
2267:.\Include/arm_math.h ****   q31_t * pSrc,
2268:.\Include/arm_math.h ****   q31_t * pDst);
2269:.\Include/arm_math.h **** 
2270:.\Include/arm_math.h ****   /**
2271:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2272:.\Include/arm_math.h ****    */
2273:.\Include/arm_math.h ****   typedef struct
2274:.\Include/arm_math.h ****   {
2275:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2276:.\Include/arm_math.h ****     uint16_t fftLenBy2;                         /**< length of the complex FFT. */
2277:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2278:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2279:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports
2280:.\Include/arm_math.h ****     float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
2281:.\Include/arm_math.h ****     float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
2282:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
2283:.\Include/arm_math.h ****   } arm_rfft_instance_f32;
2284:.\Include/arm_math.h **** 
2285:.\Include/arm_math.h ****   arm_status arm_rfft_init_f32(
2286:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S,
2287:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2288:.\Include/arm_math.h ****   uint32_t fftLenReal,
2289:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2290:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2291:.\Include/arm_math.h **** 
2292:.\Include/arm_math.h ****   void arm_rfft_f32(
2293:.\Include/arm_math.h ****   const arm_rfft_instance_f32 * S,
2294:.\Include/arm_math.h ****   float32_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 45


2295:.\Include/arm_math.h ****   float32_t * pDst);
2296:.\Include/arm_math.h **** 
2297:.\Include/arm_math.h ****   /**
2298:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2299:.\Include/arm_math.h ****    */
2300:.\Include/arm_math.h **** typedef struct
2301:.\Include/arm_math.h ****   {
2302:.\Include/arm_math.h ****     arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
2303:.\Include/arm_math.h ****     uint16_t fftLenRFFT;             /**< length of the real sequence */
2304:.\Include/arm_math.h ****     float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
2305:.\Include/arm_math.h ****   } arm_rfft_fast_instance_f32 ;
2306:.\Include/arm_math.h **** 
2307:.\Include/arm_math.h **** arm_status arm_rfft_fast_init_f32 (
2308:.\Include/arm_math.h ****    arm_rfft_fast_instance_f32 * S,
2309:.\Include/arm_math.h ****    uint16_t fftLen);
2310:.\Include/arm_math.h **** 
2311:.\Include/arm_math.h **** void arm_rfft_fast_f32(
2312:.\Include/arm_math.h ****   arm_rfft_fast_instance_f32 * S,
2313:.\Include/arm_math.h ****   float32_t * p, float32_t * pOut,
2314:.\Include/arm_math.h ****   uint8_t ifftFlag);
2315:.\Include/arm_math.h **** 
2316:.\Include/arm_math.h ****   /**
2317:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
2318:.\Include/arm_math.h ****    */
2319:.\Include/arm_math.h ****   typedef struct
2320:.\Include/arm_math.h ****   {
2321:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2322:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2323:.\Include/arm_math.h ****     float32_t normalize;                 /**< normalizing factor. */
2324:.\Include/arm_math.h ****     float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
2325:.\Include/arm_math.h ****     float32_t *pCosFactor;               /**< points to the cosFactor table. */
2326:.\Include/arm_math.h ****     arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
2327:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
2328:.\Include/arm_math.h ****   } arm_dct4_instance_f32;
2329:.\Include/arm_math.h **** 
2330:.\Include/arm_math.h **** 
2331:.\Include/arm_math.h ****   /**
2332:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point DCT4/IDCT4.
2333:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
2334:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
2335:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
2336:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2337:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2338:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2339:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2340:.\Include/arm_math.h ****    */
2341:.\Include/arm_math.h ****   arm_status arm_dct4_init_f32(
2342:.\Include/arm_math.h ****   arm_dct4_instance_f32 * S,
2343:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S_RFFT,
2344:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2345:.\Include/arm_math.h ****   uint16_t N,
2346:.\Include/arm_math.h ****   uint16_t Nby2,
2347:.\Include/arm_math.h ****   float32_t normalize);
2348:.\Include/arm_math.h **** 
2349:.\Include/arm_math.h **** 
2350:.\Include/arm_math.h ****   /**
2351:.\Include/arm_math.h ****    * @brief Processing function for the floating-point DCT4/IDCT4.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 46


2352:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure
2353:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2354:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2355:.\Include/arm_math.h ****    */
2356:.\Include/arm_math.h ****   void arm_dct4_f32(
2357:.\Include/arm_math.h ****   const arm_dct4_instance_f32 * S,
2358:.\Include/arm_math.h ****   float32_t * pState,
2359:.\Include/arm_math.h ****   float32_t * pInlineBuffer);
2360:.\Include/arm_math.h **** 
2361:.\Include/arm_math.h **** 
2362:.\Include/arm_math.h ****   /**
2363:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 DCT4/IDCT4 function.
2364:.\Include/arm_math.h ****    */
2365:.\Include/arm_math.h ****   typedef struct
2366:.\Include/arm_math.h ****   {
2367:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2368:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2369:.\Include/arm_math.h ****     q31_t normalize;                     /**< normalizing factor. */
2370:.\Include/arm_math.h ****     q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
2371:.\Include/arm_math.h ****     q31_t *pCosFactor;                   /**< points to the cosFactor table. */
2372:.\Include/arm_math.h ****     arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
2373:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
2374:.\Include/arm_math.h ****   } arm_dct4_instance_q31;
2375:.\Include/arm_math.h **** 
2376:.\Include/arm_math.h **** 
2377:.\Include/arm_math.h ****   /**
2378:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 DCT4/IDCT4.
2379:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
2380:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
2381:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
2382:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2383:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2384:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2385:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2386:.\Include/arm_math.h ****    */
2387:.\Include/arm_math.h ****   arm_status arm_dct4_init_q31(
2388:.\Include/arm_math.h ****   arm_dct4_instance_q31 * S,
2389:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S_RFFT,
2390:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S_CFFT,
2391:.\Include/arm_math.h ****   uint16_t N,
2392:.\Include/arm_math.h ****   uint16_t Nby2,
2393:.\Include/arm_math.h ****   q31_t normalize);
2394:.\Include/arm_math.h **** 
2395:.\Include/arm_math.h **** 
2396:.\Include/arm_math.h ****   /**
2397:.\Include/arm_math.h ****    * @brief Processing function for the Q31 DCT4/IDCT4.
2398:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q31 DCT4 structure.
2399:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2400:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2401:.\Include/arm_math.h ****    */
2402:.\Include/arm_math.h ****   void arm_dct4_q31(
2403:.\Include/arm_math.h ****   const arm_dct4_instance_q31 * S,
2404:.\Include/arm_math.h ****   q31_t * pState,
2405:.\Include/arm_math.h ****   q31_t * pInlineBuffer);
2406:.\Include/arm_math.h **** 
2407:.\Include/arm_math.h **** 
2408:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 47


2409:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 DCT4/IDCT4 function.
2410:.\Include/arm_math.h ****    */
2411:.\Include/arm_math.h ****   typedef struct
2412:.\Include/arm_math.h ****   {
2413:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2414:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2415:.\Include/arm_math.h ****     q15_t normalize;                     /**< normalizing factor. */
2416:.\Include/arm_math.h ****     q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
2417:.\Include/arm_math.h ****     q15_t *pCosFactor;                   /**< points to the cosFactor table. */
2418:.\Include/arm_math.h ****     arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
2419:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
2420:.\Include/arm_math.h ****   } arm_dct4_instance_q15;
2421:.\Include/arm_math.h **** 
2422:.\Include/arm_math.h **** 
2423:.\Include/arm_math.h ****   /**
2424:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 DCT4/IDCT4.
2425:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
2426:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
2427:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
2428:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2429:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2430:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2431:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2432:.\Include/arm_math.h ****    */
2433:.\Include/arm_math.h ****   arm_status arm_dct4_init_q15(
2434:.\Include/arm_math.h ****   arm_dct4_instance_q15 * S,
2435:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S_RFFT,
2436:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S_CFFT,
2437:.\Include/arm_math.h ****   uint16_t N,
2438:.\Include/arm_math.h ****   uint16_t Nby2,
2439:.\Include/arm_math.h ****   q15_t normalize);
2440:.\Include/arm_math.h **** 
2441:.\Include/arm_math.h **** 
2442:.\Include/arm_math.h ****   /**
2443:.\Include/arm_math.h ****    * @brief Processing function for the Q15 DCT4/IDCT4.
2444:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q15 DCT4 structure.
2445:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2446:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2447:.\Include/arm_math.h ****    */
2448:.\Include/arm_math.h ****   void arm_dct4_q15(
2449:.\Include/arm_math.h ****   const arm_dct4_instance_q15 * S,
2450:.\Include/arm_math.h ****   q15_t * pState,
2451:.\Include/arm_math.h ****   q15_t * pInlineBuffer);
2452:.\Include/arm_math.h **** 
2453:.\Include/arm_math.h **** 
2454:.\Include/arm_math.h ****   /**
2455:.\Include/arm_math.h ****    * @brief Floating-point vector addition.
2456:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2457:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2458:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2459:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2460:.\Include/arm_math.h ****    */
2461:.\Include/arm_math.h ****   void arm_add_f32(
2462:.\Include/arm_math.h ****   float32_t * pSrcA,
2463:.\Include/arm_math.h ****   float32_t * pSrcB,
2464:.\Include/arm_math.h ****   float32_t * pDst,
2465:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 48


2466:.\Include/arm_math.h **** 
2467:.\Include/arm_math.h **** 
2468:.\Include/arm_math.h ****   /**
2469:.\Include/arm_math.h ****    * @brief Q7 vector addition.
2470:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2471:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2472:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2473:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2474:.\Include/arm_math.h ****    */
2475:.\Include/arm_math.h ****   void arm_add_q7(
2476:.\Include/arm_math.h ****   q7_t * pSrcA,
2477:.\Include/arm_math.h ****   q7_t * pSrcB,
2478:.\Include/arm_math.h ****   q7_t * pDst,
2479:.\Include/arm_math.h ****   uint32_t blockSize);
2480:.\Include/arm_math.h **** 
2481:.\Include/arm_math.h **** 
2482:.\Include/arm_math.h ****   /**
2483:.\Include/arm_math.h ****    * @brief Q15 vector addition.
2484:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2485:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2486:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2487:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2488:.\Include/arm_math.h ****    */
2489:.\Include/arm_math.h ****   void arm_add_q15(
2490:.\Include/arm_math.h ****   q15_t * pSrcA,
2491:.\Include/arm_math.h ****   q15_t * pSrcB,
2492:.\Include/arm_math.h ****   q15_t * pDst,
2493:.\Include/arm_math.h ****   uint32_t blockSize);
2494:.\Include/arm_math.h **** 
2495:.\Include/arm_math.h **** 
2496:.\Include/arm_math.h ****   /**
2497:.\Include/arm_math.h ****    * @brief Q31 vector addition.
2498:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2499:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2500:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2501:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2502:.\Include/arm_math.h ****    */
2503:.\Include/arm_math.h ****   void arm_add_q31(
2504:.\Include/arm_math.h ****   q31_t * pSrcA,
2505:.\Include/arm_math.h ****   q31_t * pSrcB,
2506:.\Include/arm_math.h ****   q31_t * pDst,
2507:.\Include/arm_math.h ****   uint32_t blockSize);
2508:.\Include/arm_math.h **** 
2509:.\Include/arm_math.h **** 
2510:.\Include/arm_math.h ****   /**
2511:.\Include/arm_math.h ****    * @brief Floating-point vector subtraction.
2512:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2513:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2514:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2515:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2516:.\Include/arm_math.h ****    */
2517:.\Include/arm_math.h ****   void arm_sub_f32(
2518:.\Include/arm_math.h ****   float32_t * pSrcA,
2519:.\Include/arm_math.h ****   float32_t * pSrcB,
2520:.\Include/arm_math.h ****   float32_t * pDst,
2521:.\Include/arm_math.h ****   uint32_t blockSize);
2522:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 49


2523:.\Include/arm_math.h **** 
2524:.\Include/arm_math.h ****   /**
2525:.\Include/arm_math.h ****    * @brief Q7 vector subtraction.
2526:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2527:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2528:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2529:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2530:.\Include/arm_math.h ****    */
2531:.\Include/arm_math.h ****   void arm_sub_q7(
2532:.\Include/arm_math.h ****   q7_t * pSrcA,
2533:.\Include/arm_math.h ****   q7_t * pSrcB,
2534:.\Include/arm_math.h ****   q7_t * pDst,
2535:.\Include/arm_math.h ****   uint32_t blockSize);
2536:.\Include/arm_math.h **** 
2537:.\Include/arm_math.h **** 
2538:.\Include/arm_math.h ****   /**
2539:.\Include/arm_math.h ****    * @brief Q15 vector subtraction.
2540:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2541:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2542:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2543:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2544:.\Include/arm_math.h ****    */
2545:.\Include/arm_math.h ****   void arm_sub_q15(
2546:.\Include/arm_math.h ****   q15_t * pSrcA,
2547:.\Include/arm_math.h ****   q15_t * pSrcB,
2548:.\Include/arm_math.h ****   q15_t * pDst,
2549:.\Include/arm_math.h ****   uint32_t blockSize);
2550:.\Include/arm_math.h **** 
2551:.\Include/arm_math.h **** 
2552:.\Include/arm_math.h ****   /**
2553:.\Include/arm_math.h ****    * @brief Q31 vector subtraction.
2554:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2555:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2556:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2557:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2558:.\Include/arm_math.h ****    */
2559:.\Include/arm_math.h ****   void arm_sub_q31(
2560:.\Include/arm_math.h ****   q31_t * pSrcA,
2561:.\Include/arm_math.h ****   q31_t * pSrcB,
2562:.\Include/arm_math.h ****   q31_t * pDst,
2563:.\Include/arm_math.h ****   uint32_t blockSize);
2564:.\Include/arm_math.h **** 
2565:.\Include/arm_math.h **** 
2566:.\Include/arm_math.h ****   /**
2567:.\Include/arm_math.h ****    * @brief Multiplies a floating-point vector by a scalar.
2568:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2569:.\Include/arm_math.h ****    * @param[in]  scale      scale factor to be applied
2570:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2571:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2572:.\Include/arm_math.h ****    */
2573:.\Include/arm_math.h ****   void arm_scale_f32(
2574:.\Include/arm_math.h ****   float32_t * pSrc,
2575:.\Include/arm_math.h ****   float32_t scale,
2576:.\Include/arm_math.h ****   float32_t * pDst,
2577:.\Include/arm_math.h ****   uint32_t blockSize);
2578:.\Include/arm_math.h **** 
2579:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 50


2580:.\Include/arm_math.h ****   /**
2581:.\Include/arm_math.h ****    * @brief Multiplies a Q7 vector by a scalar.
2582:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2583:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2584:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2585:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2586:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2587:.\Include/arm_math.h ****    */
2588:.\Include/arm_math.h ****   void arm_scale_q7(
2589:.\Include/arm_math.h ****   q7_t * pSrc,
2590:.\Include/arm_math.h ****   q7_t scaleFract,
2591:.\Include/arm_math.h ****   int8_t shift,
2592:.\Include/arm_math.h ****   q7_t * pDst,
2593:.\Include/arm_math.h ****   uint32_t blockSize);
2594:.\Include/arm_math.h **** 
2595:.\Include/arm_math.h **** 
2596:.\Include/arm_math.h ****   /**
2597:.\Include/arm_math.h ****    * @brief Multiplies a Q15 vector by a scalar.
2598:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2599:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2600:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2601:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2602:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2603:.\Include/arm_math.h ****    */
2604:.\Include/arm_math.h ****   void arm_scale_q15(
2605:.\Include/arm_math.h ****   q15_t * pSrc,
2606:.\Include/arm_math.h ****   q15_t scaleFract,
2607:.\Include/arm_math.h ****   int8_t shift,
2608:.\Include/arm_math.h ****   q15_t * pDst,
2609:.\Include/arm_math.h ****   uint32_t blockSize);
2610:.\Include/arm_math.h **** 
2611:.\Include/arm_math.h **** 
2612:.\Include/arm_math.h ****   /**
2613:.\Include/arm_math.h ****    * @brief Multiplies a Q31 vector by a scalar.
2614:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2615:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2616:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2617:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2618:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2619:.\Include/arm_math.h ****    */
2620:.\Include/arm_math.h ****   void arm_scale_q31(
2621:.\Include/arm_math.h ****   q31_t * pSrc,
2622:.\Include/arm_math.h ****   q31_t scaleFract,
2623:.\Include/arm_math.h ****   int8_t shift,
2624:.\Include/arm_math.h ****   q31_t * pDst,
2625:.\Include/arm_math.h ****   uint32_t blockSize);
2626:.\Include/arm_math.h **** 
2627:.\Include/arm_math.h **** 
2628:.\Include/arm_math.h ****   /**
2629:.\Include/arm_math.h ****    * @brief Q7 vector absolute value.
2630:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2631:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2632:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2633:.\Include/arm_math.h ****    */
2634:.\Include/arm_math.h ****   void arm_abs_q7(
2635:.\Include/arm_math.h ****   q7_t * pSrc,
2636:.\Include/arm_math.h ****   q7_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 51


2637:.\Include/arm_math.h ****   uint32_t blockSize);
2638:.\Include/arm_math.h **** 
2639:.\Include/arm_math.h **** 
2640:.\Include/arm_math.h ****   /**
2641:.\Include/arm_math.h ****    * @brief Floating-point vector absolute value.
2642:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2643:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2644:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2645:.\Include/arm_math.h ****    */
2646:.\Include/arm_math.h ****   void arm_abs_f32(
2647:.\Include/arm_math.h ****   float32_t * pSrc,
2648:.\Include/arm_math.h ****   float32_t * pDst,
2649:.\Include/arm_math.h ****   uint32_t blockSize);
2650:.\Include/arm_math.h **** 
2651:.\Include/arm_math.h **** 
2652:.\Include/arm_math.h ****   /**
2653:.\Include/arm_math.h ****    * @brief Q15 vector absolute value.
2654:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2655:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2656:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2657:.\Include/arm_math.h ****    */
2658:.\Include/arm_math.h ****   void arm_abs_q15(
2659:.\Include/arm_math.h ****   q15_t * pSrc,
2660:.\Include/arm_math.h ****   q15_t * pDst,
2661:.\Include/arm_math.h ****   uint32_t blockSize);
2662:.\Include/arm_math.h **** 
2663:.\Include/arm_math.h **** 
2664:.\Include/arm_math.h ****   /**
2665:.\Include/arm_math.h ****    * @brief Q31 vector absolute value.
2666:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2667:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2668:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2669:.\Include/arm_math.h ****    */
2670:.\Include/arm_math.h ****   void arm_abs_q31(
2671:.\Include/arm_math.h ****   q31_t * pSrc,
2672:.\Include/arm_math.h ****   q31_t * pDst,
2673:.\Include/arm_math.h ****   uint32_t blockSize);
2674:.\Include/arm_math.h **** 
2675:.\Include/arm_math.h **** 
2676:.\Include/arm_math.h ****   /**
2677:.\Include/arm_math.h ****    * @brief Dot product of floating-point vectors.
2678:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2679:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2680:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2681:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2682:.\Include/arm_math.h ****    */
2683:.\Include/arm_math.h ****   void arm_dot_prod_f32(
2684:.\Include/arm_math.h ****   float32_t * pSrcA,
2685:.\Include/arm_math.h ****   float32_t * pSrcB,
2686:.\Include/arm_math.h ****   uint32_t blockSize,
2687:.\Include/arm_math.h ****   float32_t * result);
2688:.\Include/arm_math.h **** 
2689:.\Include/arm_math.h **** 
2690:.\Include/arm_math.h ****   /**
2691:.\Include/arm_math.h ****    * @brief Dot product of Q7 vectors.
2692:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2693:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 52


2694:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2695:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2696:.\Include/arm_math.h ****    */
2697:.\Include/arm_math.h ****   void arm_dot_prod_q7(
2698:.\Include/arm_math.h ****   q7_t * pSrcA,
2699:.\Include/arm_math.h ****   q7_t * pSrcB,
2700:.\Include/arm_math.h ****   uint32_t blockSize,
2701:.\Include/arm_math.h ****   q31_t * result);
2702:.\Include/arm_math.h **** 
2703:.\Include/arm_math.h **** 
2704:.\Include/arm_math.h ****   /**
2705:.\Include/arm_math.h ****    * @brief Dot product of Q15 vectors.
2706:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2707:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2708:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2709:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2710:.\Include/arm_math.h ****    */
2711:.\Include/arm_math.h ****   void arm_dot_prod_q15(
2712:.\Include/arm_math.h ****   q15_t * pSrcA,
2713:.\Include/arm_math.h ****   q15_t * pSrcB,
2714:.\Include/arm_math.h ****   uint32_t blockSize,
2715:.\Include/arm_math.h ****   q63_t * result);
2716:.\Include/arm_math.h **** 
2717:.\Include/arm_math.h **** 
2718:.\Include/arm_math.h ****   /**
2719:.\Include/arm_math.h ****    * @brief Dot product of Q31 vectors.
2720:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2721:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2722:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2723:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2724:.\Include/arm_math.h ****    */
2725:.\Include/arm_math.h ****   void arm_dot_prod_q31(
2726:.\Include/arm_math.h ****   q31_t * pSrcA,
2727:.\Include/arm_math.h ****   q31_t * pSrcB,
2728:.\Include/arm_math.h ****   uint32_t blockSize,
2729:.\Include/arm_math.h ****   q63_t * result);
2730:.\Include/arm_math.h **** 
2731:.\Include/arm_math.h **** 
2732:.\Include/arm_math.h ****   /**
2733:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q7 vector a specified number of bits.
2734:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2735:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2736:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2737:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2738:.\Include/arm_math.h ****    */
2739:.\Include/arm_math.h ****   void arm_shift_q7(
2740:.\Include/arm_math.h ****   q7_t * pSrc,
2741:.\Include/arm_math.h ****   int8_t shiftBits,
2742:.\Include/arm_math.h ****   q7_t * pDst,
2743:.\Include/arm_math.h ****   uint32_t blockSize);
2744:.\Include/arm_math.h **** 
2745:.\Include/arm_math.h **** 
2746:.\Include/arm_math.h ****   /**
2747:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q15 vector a specified number of bits.
2748:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2749:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2750:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 53


2751:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2752:.\Include/arm_math.h ****    */
2753:.\Include/arm_math.h ****   void arm_shift_q15(
2754:.\Include/arm_math.h ****   q15_t * pSrc,
2755:.\Include/arm_math.h ****   int8_t shiftBits,
2756:.\Include/arm_math.h ****   q15_t * pDst,
2757:.\Include/arm_math.h ****   uint32_t blockSize);
2758:.\Include/arm_math.h **** 
2759:.\Include/arm_math.h **** 
2760:.\Include/arm_math.h ****   /**
2761:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q31 vector a specified number of bits.
2762:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2763:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2764:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2765:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2766:.\Include/arm_math.h ****    */
2767:.\Include/arm_math.h ****   void arm_shift_q31(
2768:.\Include/arm_math.h ****   q31_t * pSrc,
2769:.\Include/arm_math.h ****   int8_t shiftBits,
2770:.\Include/arm_math.h ****   q31_t * pDst,
2771:.\Include/arm_math.h ****   uint32_t blockSize);
2772:.\Include/arm_math.h **** 
2773:.\Include/arm_math.h **** 
2774:.\Include/arm_math.h ****   /**
2775:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a floating-point vector.
2776:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2777:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2778:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2779:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2780:.\Include/arm_math.h ****    */
2781:.\Include/arm_math.h ****   void arm_offset_f32(
2782:.\Include/arm_math.h ****   float32_t * pSrc,
2783:.\Include/arm_math.h ****   float32_t offset,
2784:.\Include/arm_math.h ****   float32_t * pDst,
2785:.\Include/arm_math.h ****   uint32_t blockSize);
2786:.\Include/arm_math.h **** 
2787:.\Include/arm_math.h **** 
2788:.\Include/arm_math.h ****   /**
2789:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q7 vector.
2790:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2791:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2792:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2793:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2794:.\Include/arm_math.h ****    */
2795:.\Include/arm_math.h ****   void arm_offset_q7(
2796:.\Include/arm_math.h ****   q7_t * pSrc,
2797:.\Include/arm_math.h ****   q7_t offset,
2798:.\Include/arm_math.h ****   q7_t * pDst,
2799:.\Include/arm_math.h ****   uint32_t blockSize);
2800:.\Include/arm_math.h **** 
2801:.\Include/arm_math.h **** 
2802:.\Include/arm_math.h ****   /**
2803:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q15 vector.
2804:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2805:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2806:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2807:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 54


2808:.\Include/arm_math.h ****    */
2809:.\Include/arm_math.h ****   void arm_offset_q15(
2810:.\Include/arm_math.h ****   q15_t * pSrc,
2811:.\Include/arm_math.h ****   q15_t offset,
2812:.\Include/arm_math.h ****   q15_t * pDst,
2813:.\Include/arm_math.h ****   uint32_t blockSize);
2814:.\Include/arm_math.h **** 
2815:.\Include/arm_math.h **** 
2816:.\Include/arm_math.h ****   /**
2817:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q31 vector.
2818:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2819:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2820:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2821:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2822:.\Include/arm_math.h ****    */
2823:.\Include/arm_math.h ****   void arm_offset_q31(
2824:.\Include/arm_math.h ****   q31_t * pSrc,
2825:.\Include/arm_math.h ****   q31_t offset,
2826:.\Include/arm_math.h ****   q31_t * pDst,
2827:.\Include/arm_math.h ****   uint32_t blockSize);
2828:.\Include/arm_math.h **** 
2829:.\Include/arm_math.h **** 
2830:.\Include/arm_math.h ****   /**
2831:.\Include/arm_math.h ****    * @brief  Negates the elements of a floating-point vector.
2832:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2833:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2834:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2835:.\Include/arm_math.h ****    */
2836:.\Include/arm_math.h ****   void arm_negate_f32(
2837:.\Include/arm_math.h ****   float32_t * pSrc,
2838:.\Include/arm_math.h ****   float32_t * pDst,
2839:.\Include/arm_math.h ****   uint32_t blockSize);
2840:.\Include/arm_math.h **** 
2841:.\Include/arm_math.h **** 
2842:.\Include/arm_math.h ****   /**
2843:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q7 vector.
2844:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2845:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2846:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2847:.\Include/arm_math.h ****    */
2848:.\Include/arm_math.h ****   void arm_negate_q7(
2849:.\Include/arm_math.h ****   q7_t * pSrc,
2850:.\Include/arm_math.h ****   q7_t * pDst,
2851:.\Include/arm_math.h ****   uint32_t blockSize);
2852:.\Include/arm_math.h **** 
2853:.\Include/arm_math.h **** 
2854:.\Include/arm_math.h ****   /**
2855:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q15 vector.
2856:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2857:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2858:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2859:.\Include/arm_math.h ****    */
2860:.\Include/arm_math.h ****   void arm_negate_q15(
2861:.\Include/arm_math.h ****   q15_t * pSrc,
2862:.\Include/arm_math.h ****   q15_t * pDst,
2863:.\Include/arm_math.h ****   uint32_t blockSize);
2864:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 55


2865:.\Include/arm_math.h **** 
2866:.\Include/arm_math.h ****   /**
2867:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q31 vector.
2868:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2869:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2870:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2871:.\Include/arm_math.h ****    */
2872:.\Include/arm_math.h ****   void arm_negate_q31(
2873:.\Include/arm_math.h ****   q31_t * pSrc,
2874:.\Include/arm_math.h ****   q31_t * pDst,
2875:.\Include/arm_math.h ****   uint32_t blockSize);
2876:.\Include/arm_math.h **** 
2877:.\Include/arm_math.h **** 
2878:.\Include/arm_math.h ****   /**
2879:.\Include/arm_math.h ****    * @brief  Copies the elements of a floating-point vector.
2880:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2881:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2882:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2883:.\Include/arm_math.h ****    */
2884:.\Include/arm_math.h ****   void arm_copy_f32(
2885:.\Include/arm_math.h ****   float32_t * pSrc,
2886:.\Include/arm_math.h ****   float32_t * pDst,
2887:.\Include/arm_math.h ****   uint32_t blockSize);
2888:.\Include/arm_math.h **** 
2889:.\Include/arm_math.h **** 
2890:.\Include/arm_math.h ****   /**
2891:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q7 vector.
2892:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2893:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2894:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2895:.\Include/arm_math.h ****    */
2896:.\Include/arm_math.h ****   void arm_copy_q7(
2897:.\Include/arm_math.h ****   q7_t * pSrc,
2898:.\Include/arm_math.h ****   q7_t * pDst,
2899:.\Include/arm_math.h ****   uint32_t blockSize);
2900:.\Include/arm_math.h **** 
2901:.\Include/arm_math.h **** 
2902:.\Include/arm_math.h ****   /**
2903:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q15 vector.
2904:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2905:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2906:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2907:.\Include/arm_math.h ****    */
2908:.\Include/arm_math.h ****   void arm_copy_q15(
2909:.\Include/arm_math.h ****   q15_t * pSrc,
2910:.\Include/arm_math.h ****   q15_t * pDst,
2911:.\Include/arm_math.h ****   uint32_t blockSize);
2912:.\Include/arm_math.h **** 
2913:.\Include/arm_math.h **** 
2914:.\Include/arm_math.h ****   /**
2915:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q31 vector.
2916:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2917:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2918:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2919:.\Include/arm_math.h ****    */
2920:.\Include/arm_math.h ****   void arm_copy_q31(
2921:.\Include/arm_math.h ****   q31_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 56


2922:.\Include/arm_math.h ****   q31_t * pDst,
2923:.\Include/arm_math.h ****   uint32_t blockSize);
2924:.\Include/arm_math.h **** 
2925:.\Include/arm_math.h **** 
2926:.\Include/arm_math.h ****   /**
2927:.\Include/arm_math.h ****    * @brief  Fills a constant value into a floating-point vector.
2928:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2929:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2930:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2931:.\Include/arm_math.h ****    */
2932:.\Include/arm_math.h ****   void arm_fill_f32(
2933:.\Include/arm_math.h ****   float32_t value,
2934:.\Include/arm_math.h ****   float32_t * pDst,
2935:.\Include/arm_math.h ****   uint32_t blockSize);
2936:.\Include/arm_math.h **** 
2937:.\Include/arm_math.h **** 
2938:.\Include/arm_math.h ****   /**
2939:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q7 vector.
2940:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2941:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2942:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2943:.\Include/arm_math.h ****    */
2944:.\Include/arm_math.h ****   void arm_fill_q7(
2945:.\Include/arm_math.h ****   q7_t value,
2946:.\Include/arm_math.h ****   q7_t * pDst,
2947:.\Include/arm_math.h ****   uint32_t blockSize);
2948:.\Include/arm_math.h **** 
2949:.\Include/arm_math.h **** 
2950:.\Include/arm_math.h ****   /**
2951:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q15 vector.
2952:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2953:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2954:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2955:.\Include/arm_math.h ****    */
2956:.\Include/arm_math.h ****   void arm_fill_q15(
2957:.\Include/arm_math.h ****   q15_t value,
2958:.\Include/arm_math.h ****   q15_t * pDst,
2959:.\Include/arm_math.h ****   uint32_t blockSize);
2960:.\Include/arm_math.h **** 
2961:.\Include/arm_math.h **** 
2962:.\Include/arm_math.h ****   /**
2963:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q31 vector.
2964:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2965:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2966:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2967:.\Include/arm_math.h ****    */
2968:.\Include/arm_math.h ****   void arm_fill_q31(
2969:.\Include/arm_math.h ****   q31_t value,
2970:.\Include/arm_math.h ****   q31_t * pDst,
2971:.\Include/arm_math.h ****   uint32_t blockSize);
2972:.\Include/arm_math.h **** 
2973:.\Include/arm_math.h **** 
2974:.\Include/arm_math.h **** /**
2975:.\Include/arm_math.h ****  * @brief Convolution of floating-point sequences.
2976:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2977:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2978:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 57


2979:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2980:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2981:.\Include/arm_math.h ****  */
2982:.\Include/arm_math.h ****   void arm_conv_f32(
2983:.\Include/arm_math.h ****   float32_t * pSrcA,
2984:.\Include/arm_math.h ****   uint32_t srcALen,
2985:.\Include/arm_math.h ****   float32_t * pSrcB,
2986:.\Include/arm_math.h ****   uint32_t srcBLen,
2987:.\Include/arm_math.h ****   float32_t * pDst);
2988:.\Include/arm_math.h **** 
2989:.\Include/arm_math.h **** 
2990:.\Include/arm_math.h ****   /**
2991:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences.
2992:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2993:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2994:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2995:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2996:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2997:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2998:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2999:.\Include/arm_math.h ****    */
3000:.\Include/arm_math.h ****   void arm_conv_opt_q15(
3001:.\Include/arm_math.h ****   q15_t * pSrcA,
3002:.\Include/arm_math.h ****   uint32_t srcALen,
3003:.\Include/arm_math.h ****   q15_t * pSrcB,
3004:.\Include/arm_math.h ****   uint32_t srcBLen,
3005:.\Include/arm_math.h ****   q15_t * pDst,
3006:.\Include/arm_math.h ****   q15_t * pScratch1,
3007:.\Include/arm_math.h ****   q15_t * pScratch2);
3008:.\Include/arm_math.h **** 
3009:.\Include/arm_math.h **** 
3010:.\Include/arm_math.h **** /**
3011:.\Include/arm_math.h ****  * @brief Convolution of Q15 sequences.
3012:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
3013:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
3014:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
3015:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
3016:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
3017:.\Include/arm_math.h ****  */
3018:.\Include/arm_math.h ****   void arm_conv_q15(
3019:.\Include/arm_math.h ****   q15_t * pSrcA,
3020:.\Include/arm_math.h ****   uint32_t srcALen,
3021:.\Include/arm_math.h ****   q15_t * pSrcB,
3022:.\Include/arm_math.h ****   uint32_t srcBLen,
3023:.\Include/arm_math.h ****   q15_t * pDst);
3024:.\Include/arm_math.h **** 
3025:.\Include/arm_math.h **** 
3026:.\Include/arm_math.h ****   /**
3027:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3028:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3029:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3030:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3031:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3032:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3033:.\Include/arm_math.h ****    */
3034:.\Include/arm_math.h ****   void arm_conv_fast_q15(
3035:.\Include/arm_math.h ****           q15_t * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 58


3036:.\Include/arm_math.h ****           uint32_t srcALen,
3037:.\Include/arm_math.h ****           q15_t * pSrcB,
3038:.\Include/arm_math.h ****           uint32_t srcBLen,
3039:.\Include/arm_math.h ****           q15_t * pDst);
3040:.\Include/arm_math.h **** 
3041:.\Include/arm_math.h **** 
3042:.\Include/arm_math.h ****   /**
3043:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3044:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3045:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3046:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3047:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3048:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3049:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
3050:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
3051:.\Include/arm_math.h ****    */
3052:.\Include/arm_math.h ****   void arm_conv_fast_opt_q15(
3053:.\Include/arm_math.h ****   q15_t * pSrcA,
3054:.\Include/arm_math.h ****   uint32_t srcALen,
3055:.\Include/arm_math.h ****   q15_t * pSrcB,
3056:.\Include/arm_math.h ****   uint32_t srcBLen,
3057:.\Include/arm_math.h ****   q15_t * pDst,
3058:.\Include/arm_math.h ****   q15_t * pScratch1,
3059:.\Include/arm_math.h ****   q15_t * pScratch2);
3060:.\Include/arm_math.h **** 
3061:.\Include/arm_math.h **** 
3062:.\Include/arm_math.h ****   /**
3063:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences.
3064:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3065:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3066:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3067:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3068:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3069:.\Include/arm_math.h ****    */
3070:.\Include/arm_math.h ****   void arm_conv_q31(
3071:.\Include/arm_math.h ****   q31_t * pSrcA,
3072:.\Include/arm_math.h ****   uint32_t srcALen,
3073:.\Include/arm_math.h ****   q31_t * pSrcB,
3074:.\Include/arm_math.h ****   uint32_t srcBLen,
3075:.\Include/arm_math.h ****   q31_t * pDst);
3076:.\Include/arm_math.h **** 
3077:.\Include/arm_math.h **** 
3078:.\Include/arm_math.h ****   /**
3079:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3080:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3081:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3082:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3083:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3084:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3085:.\Include/arm_math.h ****    */
3086:.\Include/arm_math.h ****   void arm_conv_fast_q31(
3087:.\Include/arm_math.h ****   q31_t * pSrcA,
3088:.\Include/arm_math.h ****   uint32_t srcALen,
3089:.\Include/arm_math.h ****   q31_t * pSrcB,
3090:.\Include/arm_math.h ****   uint32_t srcBLen,
3091:.\Include/arm_math.h ****   q31_t * pDst);
3092:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 59


3093:.\Include/arm_math.h **** 
3094:.\Include/arm_math.h ****     /**
3095:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3096:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3097:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3098:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3099:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3100:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3101:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
3102:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
3103:.\Include/arm_math.h ****    */
3104:.\Include/arm_math.h ****   void arm_conv_opt_q7(
3105:.\Include/arm_math.h ****   q7_t * pSrcA,
3106:.\Include/arm_math.h ****   uint32_t srcALen,
3107:.\Include/arm_math.h ****   q7_t * pSrcB,
3108:.\Include/arm_math.h ****   uint32_t srcBLen,
3109:.\Include/arm_math.h ****   q7_t * pDst,
3110:.\Include/arm_math.h ****   q15_t * pScratch1,
3111:.\Include/arm_math.h ****   q15_t * pScratch2);
3112:.\Include/arm_math.h **** 
3113:.\Include/arm_math.h **** 
3114:.\Include/arm_math.h ****   /**
3115:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3116:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3117:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3118:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3119:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3120:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3121:.\Include/arm_math.h ****    */
3122:.\Include/arm_math.h ****   void arm_conv_q7(
3123:.\Include/arm_math.h ****   q7_t * pSrcA,
3124:.\Include/arm_math.h ****   uint32_t srcALen,
3125:.\Include/arm_math.h ****   q7_t * pSrcB,
3126:.\Include/arm_math.h ****   uint32_t srcBLen,
3127:.\Include/arm_math.h ****   q7_t * pDst);
3128:.\Include/arm_math.h **** 
3129:.\Include/arm_math.h **** 
3130:.\Include/arm_math.h ****   /**
3131:.\Include/arm_math.h ****    * @brief Partial convolution of floating-point sequences.
3132:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3133:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3134:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3135:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3136:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3137:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3138:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3139:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3140:.\Include/arm_math.h ****    */
3141:.\Include/arm_math.h ****   arm_status arm_conv_partial_f32(
3142:.\Include/arm_math.h ****   float32_t * pSrcA,
3143:.\Include/arm_math.h ****   uint32_t srcALen,
3144:.\Include/arm_math.h ****   float32_t * pSrcB,
3145:.\Include/arm_math.h ****   uint32_t srcBLen,
3146:.\Include/arm_math.h ****   float32_t * pDst,
3147:.\Include/arm_math.h ****   uint32_t firstIndex,
3148:.\Include/arm_math.h ****   uint32_t numPoints);
3149:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 60


3150:.\Include/arm_math.h **** 
3151:.\Include/arm_math.h ****   /**
3152:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3153:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3154:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3155:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3156:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3157:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3158:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3159:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3160:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3161:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3162:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3163:.\Include/arm_math.h ****    */
3164:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q15(
3165:.\Include/arm_math.h ****   q15_t * pSrcA,
3166:.\Include/arm_math.h ****   uint32_t srcALen,
3167:.\Include/arm_math.h ****   q15_t * pSrcB,
3168:.\Include/arm_math.h ****   uint32_t srcBLen,
3169:.\Include/arm_math.h ****   q15_t * pDst,
3170:.\Include/arm_math.h ****   uint32_t firstIndex,
3171:.\Include/arm_math.h ****   uint32_t numPoints,
3172:.\Include/arm_math.h ****   q15_t * pScratch1,
3173:.\Include/arm_math.h ****   q15_t * pScratch2);
3174:.\Include/arm_math.h **** 
3175:.\Include/arm_math.h **** 
3176:.\Include/arm_math.h ****   /**
3177:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3178:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3179:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3180:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3181:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3182:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3183:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3184:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3185:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3186:.\Include/arm_math.h ****    */
3187:.\Include/arm_math.h ****   arm_status arm_conv_partial_q15(
3188:.\Include/arm_math.h ****   q15_t * pSrcA,
3189:.\Include/arm_math.h ****   uint32_t srcALen,
3190:.\Include/arm_math.h ****   q15_t * pSrcB,
3191:.\Include/arm_math.h ****   uint32_t srcBLen,
3192:.\Include/arm_math.h ****   q15_t * pDst,
3193:.\Include/arm_math.h ****   uint32_t firstIndex,
3194:.\Include/arm_math.h ****   uint32_t numPoints);
3195:.\Include/arm_math.h **** 
3196:.\Include/arm_math.h **** 
3197:.\Include/arm_math.h ****   /**
3198:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3199:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3200:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3201:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3202:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3203:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3204:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3205:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3206:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 61


3207:.\Include/arm_math.h ****    */
3208:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q15(
3209:.\Include/arm_math.h ****   q15_t * pSrcA,
3210:.\Include/arm_math.h ****   uint32_t srcALen,
3211:.\Include/arm_math.h ****   q15_t * pSrcB,
3212:.\Include/arm_math.h ****   uint32_t srcBLen,
3213:.\Include/arm_math.h ****   q15_t * pDst,
3214:.\Include/arm_math.h ****   uint32_t firstIndex,
3215:.\Include/arm_math.h ****   uint32_t numPoints);
3216:.\Include/arm_math.h **** 
3217:.\Include/arm_math.h **** 
3218:.\Include/arm_math.h ****   /**
3219:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3220:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3221:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3222:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3223:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3224:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3225:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3226:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3227:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3228:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3229:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3230:.\Include/arm_math.h ****    */
3231:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_opt_q15(
3232:.\Include/arm_math.h ****   q15_t * pSrcA,
3233:.\Include/arm_math.h ****   uint32_t srcALen,
3234:.\Include/arm_math.h ****   q15_t * pSrcB,
3235:.\Include/arm_math.h ****   uint32_t srcBLen,
3236:.\Include/arm_math.h ****   q15_t * pDst,
3237:.\Include/arm_math.h ****   uint32_t firstIndex,
3238:.\Include/arm_math.h ****   uint32_t numPoints,
3239:.\Include/arm_math.h ****   q15_t * pScratch1,
3240:.\Include/arm_math.h ****   q15_t * pScratch2);
3241:.\Include/arm_math.h **** 
3242:.\Include/arm_math.h **** 
3243:.\Include/arm_math.h ****   /**
3244:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences.
3245:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3246:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3247:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3248:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3249:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3250:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3251:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3252:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3253:.\Include/arm_math.h ****    */
3254:.\Include/arm_math.h ****   arm_status arm_conv_partial_q31(
3255:.\Include/arm_math.h ****   q31_t * pSrcA,
3256:.\Include/arm_math.h ****   uint32_t srcALen,
3257:.\Include/arm_math.h ****   q31_t * pSrcB,
3258:.\Include/arm_math.h ****   uint32_t srcBLen,
3259:.\Include/arm_math.h ****   q31_t * pDst,
3260:.\Include/arm_math.h ****   uint32_t firstIndex,
3261:.\Include/arm_math.h ****   uint32_t numPoints);
3262:.\Include/arm_math.h **** 
3263:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 62


3264:.\Include/arm_math.h ****   /**
3265:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3266:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3267:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3268:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3269:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3270:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3271:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3272:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3273:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3274:.\Include/arm_math.h ****    */
3275:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q31(
3276:.\Include/arm_math.h ****   q31_t * pSrcA,
3277:.\Include/arm_math.h ****   uint32_t srcALen,
3278:.\Include/arm_math.h ****   q31_t * pSrcB,
3279:.\Include/arm_math.h ****   uint32_t srcBLen,
3280:.\Include/arm_math.h ****   q31_t * pDst,
3281:.\Include/arm_math.h ****   uint32_t firstIndex,
3282:.\Include/arm_math.h ****   uint32_t numPoints);
3283:.\Include/arm_math.h **** 
3284:.\Include/arm_math.h **** 
3285:.\Include/arm_math.h ****   /**
3286:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences
3287:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3288:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3289:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3290:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3291:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3292:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3293:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3294:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) 
3295:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)
3296:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3297:.\Include/arm_math.h ****    */
3298:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q7(
3299:.\Include/arm_math.h ****   q7_t * pSrcA,
3300:.\Include/arm_math.h ****   uint32_t srcALen,
3301:.\Include/arm_math.h ****   q7_t * pSrcB,
3302:.\Include/arm_math.h ****   uint32_t srcBLen,
3303:.\Include/arm_math.h ****   q7_t * pDst,
3304:.\Include/arm_math.h ****   uint32_t firstIndex,
3305:.\Include/arm_math.h ****   uint32_t numPoints,
3306:.\Include/arm_math.h ****   q15_t * pScratch1,
3307:.\Include/arm_math.h ****   q15_t * pScratch2);
3308:.\Include/arm_math.h **** 
3309:.\Include/arm_math.h **** 
3310:.\Include/arm_math.h **** /**
3311:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences.
3312:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3313:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3314:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3315:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3316:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3317:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3318:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3319:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3320:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 63


3321:.\Include/arm_math.h ****   arm_status arm_conv_partial_q7(
3322:.\Include/arm_math.h ****   q7_t * pSrcA,
3323:.\Include/arm_math.h ****   uint32_t srcALen,
3324:.\Include/arm_math.h ****   q7_t * pSrcB,
3325:.\Include/arm_math.h ****   uint32_t srcBLen,
3326:.\Include/arm_math.h ****   q7_t * pDst,
3327:.\Include/arm_math.h ****   uint32_t firstIndex,
3328:.\Include/arm_math.h ****   uint32_t numPoints);
3329:.\Include/arm_math.h **** 
3330:.\Include/arm_math.h **** 
3331:.\Include/arm_math.h ****   /**
3332:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR decimator.
3333:.\Include/arm_math.h ****    */
3334:.\Include/arm_math.h ****   typedef struct
3335:.\Include/arm_math.h ****   {
3336:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3337:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3338:.\Include/arm_math.h ****     q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3339:.\Include/arm_math.h ****     q15_t *pState;              /**< points to the state variable array. The array is of length num
3340:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q15;
3341:.\Include/arm_math.h **** 
3342:.\Include/arm_math.h ****   /**
3343:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR decimator.
3344:.\Include/arm_math.h ****    */
3345:.\Include/arm_math.h ****   typedef struct
3346:.\Include/arm_math.h ****   {
3347:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3348:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3349:.\Include/arm_math.h ****     q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3350:.\Include/arm_math.h ****     q31_t *pState;              /**< points to the state variable array. The array is of length num
3351:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q31;
3352:.\Include/arm_math.h **** 
3353:.\Include/arm_math.h ****   /**
3354:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR decimator.
3355:.\Include/arm_math.h ****    */
3356:.\Include/arm_math.h ****   typedef struct
3357:.\Include/arm_math.h ****   {
3358:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3359:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3360:.\Include/arm_math.h ****     float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTap
3361:.\Include/arm_math.h ****     float32_t *pState;          /**< points to the state variable array. The array is of length num
3362:.\Include/arm_math.h ****   } arm_fir_decimate_instance_f32;
3363:.\Include/arm_math.h **** 
3364:.\Include/arm_math.h **** 
3365:.\Include/arm_math.h ****   /**
3366:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR decimator.
3367:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
3368:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3369:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3370:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3371:.\Include/arm_math.h ****    */
3372:.\Include/arm_math.h ****   void arm_fir_decimate_f32(
3373:.\Include/arm_math.h ****   const arm_fir_decimate_instance_f32 * S,
3374:.\Include/arm_math.h ****   float32_t * pSrc,
3375:.\Include/arm_math.h ****   float32_t * pDst,
3376:.\Include/arm_math.h ****   uint32_t blockSize);
3377:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 64


3378:.\Include/arm_math.h **** 
3379:.\Include/arm_math.h ****   /**
3380:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR decimator.
3381:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
3382:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3383:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3384:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3385:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3386:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3387:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3388:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3389:.\Include/arm_math.h ****    */
3390:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_f32(
3391:.\Include/arm_math.h ****   arm_fir_decimate_instance_f32 * S,
3392:.\Include/arm_math.h ****   uint16_t numTaps,
3393:.\Include/arm_math.h ****   uint8_t M,
3394:.\Include/arm_math.h ****   float32_t * pCoeffs,
3395:.\Include/arm_math.h ****   float32_t * pState,
3396:.\Include/arm_math.h ****   uint32_t blockSize);
3397:.\Include/arm_math.h **** 
3398:.\Include/arm_math.h **** 
3399:.\Include/arm_math.h ****   /**
3400:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator.
3401:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3402:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3403:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3404:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3405:.\Include/arm_math.h ****    */
3406:.\Include/arm_math.h ****   void arm_fir_decimate_q15(
3407:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3408:.\Include/arm_math.h ****   q15_t * pSrc,
3409:.\Include/arm_math.h ****   q15_t * pDst,
3410:.\Include/arm_math.h ****   uint32_t blockSize);
3411:.\Include/arm_math.h **** 
3412:.\Include/arm_math.h **** 
3413:.\Include/arm_math.h ****   /**
3414:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3415:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3416:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3417:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3418:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3419:.\Include/arm_math.h ****    */
3420:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q15(
3421:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3422:.\Include/arm_math.h ****   q15_t * pSrc,
3423:.\Include/arm_math.h ****   q15_t * pDst,
3424:.\Include/arm_math.h ****   uint32_t blockSize);
3425:.\Include/arm_math.h **** 
3426:.\Include/arm_math.h **** 
3427:.\Include/arm_math.h ****   /**
3428:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR decimator.
3429:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
3430:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3431:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3432:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3433:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3434:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 65


3435:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3436:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3437:.\Include/arm_math.h ****    */
3438:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q15(
3439:.\Include/arm_math.h ****   arm_fir_decimate_instance_q15 * S,
3440:.\Include/arm_math.h ****   uint16_t numTaps,
3441:.\Include/arm_math.h ****   uint8_t M,
3442:.\Include/arm_math.h ****   q15_t * pCoeffs,
3443:.\Include/arm_math.h ****   q15_t * pState,
3444:.\Include/arm_math.h ****   uint32_t blockSize);
3445:.\Include/arm_math.h **** 
3446:.\Include/arm_math.h **** 
3447:.\Include/arm_math.h ****   /**
3448:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator.
3449:.\Include/arm_math.h ****    * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
3450:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the block of input data.
3451:.\Include/arm_math.h ****    * @param[out] pDst  points to the block of output data
3452:.\Include/arm_math.h ****    * @param[in] blockSize number of input samples to process per call.
3453:.\Include/arm_math.h ****    */
3454:.\Include/arm_math.h ****   void arm_fir_decimate_q31(
3455:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q31 * S,
3456:.\Include/arm_math.h ****   q31_t * pSrc,
3457:.\Include/arm_math.h ****   q31_t * pDst,
3458:.\Include/arm_math.h ****   uint32_t blockSize);
3459:.\Include/arm_math.h **** 
3460:.\Include/arm_math.h ****   /**
3461:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3462:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
3463:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3464:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3465:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3466:.\Include/arm_math.h ****    */
3467:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q31(
3468:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3469:.\Include/arm_math.h ****   q31_t * pSrc,
3470:.\Include/arm_math.h ****   q31_t * pDst,
3471:.\Include/arm_math.h ****   uint32_t blockSize);
3472:.\Include/arm_math.h **** 
3473:.\Include/arm_math.h **** 
3474:.\Include/arm_math.h ****   /**
3475:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR decimator.
3476:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
3477:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3478:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3479:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3480:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3481:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3482:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3483:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3484:.\Include/arm_math.h ****    */
3485:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q31(
3486:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3487:.\Include/arm_math.h ****   uint16_t numTaps,
3488:.\Include/arm_math.h ****   uint8_t M,
3489:.\Include/arm_math.h ****   q31_t * pCoeffs,
3490:.\Include/arm_math.h ****   q31_t * pState,
3491:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 66


3492:.\Include/arm_math.h **** 
3493:.\Include/arm_math.h **** 
3494:.\Include/arm_math.h ****   /**
3495:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR interpolator.
3496:.\Include/arm_math.h ****    */
3497:.\Include/arm_math.h ****   typedef struct
3498:.\Include/arm_math.h ****   {
3499:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3500:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3501:.\Include/arm_math.h ****     q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3502:.\Include/arm_math.h ****     q15_t *pState;                  /**< points to the state variable array. The array is of length
3503:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q15;
3504:.\Include/arm_math.h **** 
3505:.\Include/arm_math.h ****   /**
3506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR interpolator.
3507:.\Include/arm_math.h ****    */
3508:.\Include/arm_math.h ****   typedef struct
3509:.\Include/arm_math.h ****   {
3510:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3511:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3512:.\Include/arm_math.h ****     q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3513:.\Include/arm_math.h ****     q31_t *pState;                  /**< points to the state variable array. The array is of length
3514:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q31;
3515:.\Include/arm_math.h **** 
3516:.\Include/arm_math.h ****   /**
3517:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR interpolator.
3518:.\Include/arm_math.h ****    */
3519:.\Include/arm_math.h ****   typedef struct
3520:.\Include/arm_math.h ****   {
3521:.\Include/arm_math.h ****     uint8_t L;                     /**< upsample factor. */
3522:.\Include/arm_math.h ****     uint16_t phaseLength;          /**< length of each polyphase filter component. */
3523:.\Include/arm_math.h ****     float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*p
3524:.\Include/arm_math.h ****     float32_t *pState;             /**< points to the state variable array. The array is of length 
3525:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_f32;
3526:.\Include/arm_math.h **** 
3527:.\Include/arm_math.h **** 
3528:.\Include/arm_math.h ****   /**
3529:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR interpolator.
3530:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3531:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3532:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3533:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3534:.\Include/arm_math.h ****    */
3535:.\Include/arm_math.h ****   void arm_fir_interpolate_q15(
3536:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q15 * S,
3537:.\Include/arm_math.h ****   q15_t * pSrc,
3538:.\Include/arm_math.h ****   q15_t * pDst,
3539:.\Include/arm_math.h ****   uint32_t blockSize);
3540:.\Include/arm_math.h **** 
3541:.\Include/arm_math.h **** 
3542:.\Include/arm_math.h ****   /**
3543:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR interpolator.
3544:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
3545:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3546:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3547:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3548:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 67


3549:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3550:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3551:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3552:.\Include/arm_math.h ****    */
3553:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q15(
3554:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q15 * S,
3555:.\Include/arm_math.h ****   uint8_t L,
3556:.\Include/arm_math.h ****   uint16_t numTaps,
3557:.\Include/arm_math.h ****   q15_t * pCoeffs,
3558:.\Include/arm_math.h ****   q15_t * pState,
3559:.\Include/arm_math.h ****   uint32_t blockSize);
3560:.\Include/arm_math.h **** 
3561:.\Include/arm_math.h **** 
3562:.\Include/arm_math.h ****   /**
3563:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR interpolator.
3564:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3565:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3566:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3567:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3568:.\Include/arm_math.h ****    */
3569:.\Include/arm_math.h ****   void arm_fir_interpolate_q31(
3570:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q31 * S,
3571:.\Include/arm_math.h ****   q31_t * pSrc,
3572:.\Include/arm_math.h ****   q31_t * pDst,
3573:.\Include/arm_math.h ****   uint32_t blockSize);
3574:.\Include/arm_math.h **** 
3575:.\Include/arm_math.h **** 
3576:.\Include/arm_math.h ****   /**
3577:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR interpolator.
3578:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
3579:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3580:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3581:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3582:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3583:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3584:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3585:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3586:.\Include/arm_math.h ****    */
3587:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q31(
3588:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q31 * S,
3589:.\Include/arm_math.h ****   uint8_t L,
3590:.\Include/arm_math.h ****   uint16_t numTaps,
3591:.\Include/arm_math.h ****   q31_t * pCoeffs,
3592:.\Include/arm_math.h ****   q31_t * pState,
3593:.\Include/arm_math.h ****   uint32_t blockSize);
3594:.\Include/arm_math.h **** 
3595:.\Include/arm_math.h **** 
3596:.\Include/arm_math.h ****   /**
3597:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR interpolator.
3598:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
3599:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3600:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3601:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3602:.\Include/arm_math.h ****    */
3603:.\Include/arm_math.h ****   void arm_fir_interpolate_f32(
3604:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_f32 * S,
3605:.\Include/arm_math.h ****   float32_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 68


3606:.\Include/arm_math.h ****   float32_t * pDst,
3607:.\Include/arm_math.h ****   uint32_t blockSize);
3608:.\Include/arm_math.h **** 
3609:.\Include/arm_math.h **** 
3610:.\Include/arm_math.h ****   /**
3611:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR interpolator.
3612:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR interpolator structu
3613:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3614:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3615:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3616:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3617:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3618:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3619:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3620:.\Include/arm_math.h ****    */
3621:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_f32(
3622:.\Include/arm_math.h ****   arm_fir_interpolate_instance_f32 * S,
3623:.\Include/arm_math.h ****   uint8_t L,
3624:.\Include/arm_math.h ****   uint16_t numTaps,
3625:.\Include/arm_math.h ****   float32_t * pCoeffs,
3626:.\Include/arm_math.h ****   float32_t * pState,
3627:.\Include/arm_math.h ****   uint32_t blockSize);
3628:.\Include/arm_math.h **** 
3629:.\Include/arm_math.h **** 
3630:.\Include/arm_math.h ****   /**
3631:.\Include/arm_math.h ****    * @brief Instance structure for the high precision Q31 Biquad cascade filter.
3632:.\Include/arm_math.h ****    */
3633:.\Include/arm_math.h ****   typedef struct
3634:.\Include/arm_math.h ****   {
3635:.\Include/arm_math.h ****     uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*num
3636:.\Include/arm_math.h ****     q63_t *pState;           /**< points to the array of state coefficients.  The array is of lengt
3637:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*nu
3638:.\Include/arm_math.h ****     uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
3639:.\Include/arm_math.h ****   } arm_biquad_cas_df1_32x64_ins_q31;
3640:.\Include/arm_math.h **** 
3641:.\Include/arm_math.h **** 
3642:.\Include/arm_math.h ****   /**
3643:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter s
3644:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3645:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3646:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3647:.\Include/arm_math.h ****    */
3648:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_q31(
3649:.\Include/arm_math.h ****   const arm_biquad_cas_df1_32x64_ins_q31 * S,
3650:.\Include/arm_math.h ****   q31_t * pSrc,
3651:.\Include/arm_math.h ****   q31_t * pDst,
3652:.\Include/arm_math.h ****   uint32_t blockSize);
3653:.\Include/arm_math.h **** 
3654:.\Include/arm_math.h **** 
3655:.\Include/arm_math.h ****   /**
3656:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filte
3657:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3658:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3659:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3660:.\Include/arm_math.h ****    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficie
3661:.\Include/arm_math.h ****    */
3662:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_init_q31(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 69


3663:.\Include/arm_math.h ****   arm_biquad_cas_df1_32x64_ins_q31 * S,
3664:.\Include/arm_math.h ****   uint8_t numStages,
3665:.\Include/arm_math.h ****   q31_t * pCoeffs,
3666:.\Include/arm_math.h ****   q63_t * pState,
3667:.\Include/arm_math.h ****   uint8_t postShift);
3668:.\Include/arm_math.h **** 
3669:.\Include/arm_math.h **** 
3670:.\Include/arm_math.h ****   /**
3671:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3672:.\Include/arm_math.h ****    */
3673:.\Include/arm_math.h ****   typedef struct
3674:.\Include/arm_math.h ****   {
3675:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3676:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3677:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3678:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f32;
3679:.\Include/arm_math.h **** 
3680:.\Include/arm_math.h ****   /**
3681:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3682:.\Include/arm_math.h ****    */
3683:.\Include/arm_math.h ****   typedef struct
3684:.\Include/arm_math.h ****   {
3685:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3686:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3687:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3688:.\Include/arm_math.h ****   } arm_biquad_cascade_stereo_df2T_instance_f32;
3689:.\Include/arm_math.h **** 
3690:.\Include/arm_math.h ****   /**
3691:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3692:.\Include/arm_math.h ****    */
3693:.\Include/arm_math.h ****   typedef struct
3694:.\Include/arm_math.h ****   {
3695:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3696:.\Include/arm_math.h ****     float64_t *pState;         /**< points to the array of state coefficients.  The array is of len
3697:.\Include/arm_math.h ****     float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3698:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f64;
3699:.\Include/arm_math.h **** 
3700:.\Include/arm_math.h **** 
3701:.\Include/arm_math.h ****   /**
3702:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3703:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3704:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3705:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3706:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3707:.\Include/arm_math.h ****    */
3708:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f32(
3709:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f32 * S,
3710:.\Include/arm_math.h ****   float32_t * pSrc,
3711:.\Include/arm_math.h ****   float32_t * pDst,
3712:.\Include/arm_math.h ****   uint32_t blockSize);
3713:.\Include/arm_math.h **** 
3714:.\Include/arm_math.h **** 
3715:.\Include/arm_math.h ****   /**
3716:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3717:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3718:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3719:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 70


3720:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3721:.\Include/arm_math.h ****    */
3722:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_f32(
3723:.\Include/arm_math.h ****   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3724:.\Include/arm_math.h ****   float32_t * pSrc,
3725:.\Include/arm_math.h ****   float32_t * pDst,
3726:.\Include/arm_math.h ****   uint32_t blockSize);
3727:.\Include/arm_math.h **** 
3728:.\Include/arm_math.h **** 
3729:.\Include/arm_math.h ****   /**
3730:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3731:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3732:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3733:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3734:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3735:.\Include/arm_math.h ****    */
3736:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f64(
3737:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f64 * S,
3738:.\Include/arm_math.h ****   float64_t * pSrc,
3739:.\Include/arm_math.h ****   float64_t * pDst,
3740:.\Include/arm_math.h ****   uint32_t blockSize);
3741:.\Include/arm_math.h **** 
3742:.\Include/arm_math.h **** 
3743:.\Include/arm_math.h ****   /**
3744:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3745:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3746:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3747:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3748:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3749:.\Include/arm_math.h ****    */
3750:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f32(
3751:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f32 * S,
3752:.\Include/arm_math.h ****   uint8_t numStages,
3753:.\Include/arm_math.h ****   float32_t * pCoeffs,
3754:.\Include/arm_math.h ****   float32_t * pState);
3755:.\Include/arm_math.h **** 
3756:.\Include/arm_math.h **** 
3757:.\Include/arm_math.h ****   /**
3758:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3759:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3760:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3761:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3762:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3763:.\Include/arm_math.h ****    */
3764:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_init_f32(
3765:.\Include/arm_math.h ****   arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3766:.\Include/arm_math.h ****   uint8_t numStages,
3767:.\Include/arm_math.h ****   float32_t * pCoeffs,
3768:.\Include/arm_math.h ****   float32_t * pState);
3769:.\Include/arm_math.h **** 
3770:.\Include/arm_math.h **** 
3771:.\Include/arm_math.h ****   /**
3772:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3773:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3774:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3775:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3776:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 71


3777:.\Include/arm_math.h ****    */
3778:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f64(
3779:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f64 * S,
3780:.\Include/arm_math.h ****   uint8_t numStages,
3781:.\Include/arm_math.h ****   float64_t * pCoeffs,
3782:.\Include/arm_math.h ****   float64_t * pState);
3783:.\Include/arm_math.h **** 
3784:.\Include/arm_math.h **** 
3785:.\Include/arm_math.h ****   /**
3786:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR lattice filter.
3787:.\Include/arm_math.h ****    */
3788:.\Include/arm_math.h ****   typedef struct
3789:.\Include/arm_math.h ****   {
3790:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3791:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3792:.\Include/arm_math.h ****     q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3793:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q15;
3794:.\Include/arm_math.h **** 
3795:.\Include/arm_math.h ****   /**
3796:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR lattice filter.
3797:.\Include/arm_math.h ****    */
3798:.\Include/arm_math.h ****   typedef struct
3799:.\Include/arm_math.h ****   {
3800:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3801:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3802:.\Include/arm_math.h ****     q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3803:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q31;
3804:.\Include/arm_math.h **** 
3805:.\Include/arm_math.h ****   /**
3806:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR lattice filter.
3807:.\Include/arm_math.h ****    */
3808:.\Include/arm_math.h ****   typedef struct
3809:.\Include/arm_math.h ****   {
3810:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3811:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3812:.\Include/arm_math.h ****     float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of leng
3813:.\Include/arm_math.h ****   } arm_fir_lattice_instance_f32;
3814:.\Include/arm_math.h **** 
3815:.\Include/arm_math.h **** 
3816:.\Include/arm_math.h ****   /**
3817:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 FIR lattice filter.
3818:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 FIR lattice structure.
3819:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3820:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3821:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages.
3822:.\Include/arm_math.h ****    */
3823:.\Include/arm_math.h ****   void arm_fir_lattice_init_q15(
3824:.\Include/arm_math.h ****   arm_fir_lattice_instance_q15 * S,
3825:.\Include/arm_math.h ****   uint16_t numStages,
3826:.\Include/arm_math.h ****   q15_t * pCoeffs,
3827:.\Include/arm_math.h ****   q15_t * pState);
3828:.\Include/arm_math.h **** 
3829:.\Include/arm_math.h **** 
3830:.\Include/arm_math.h ****   /**
3831:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR lattice filter.
3832:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
3833:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 72


3834:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3835:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3836:.\Include/arm_math.h ****    */
3837:.\Include/arm_math.h ****   void arm_fir_lattice_q15(
3838:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q15 * S,
3839:.\Include/arm_math.h ****   q15_t * pSrc,
3840:.\Include/arm_math.h ****   q15_t * pDst,
3841:.\Include/arm_math.h ****   uint32_t blockSize);
3842:.\Include/arm_math.h **** 
3843:.\Include/arm_math.h **** 
3844:.\Include/arm_math.h ****   /**
3845:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 FIR lattice filter.
3846:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 FIR lattice structure.
3847:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3848:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3849:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.   The array is of length numStages.
3850:.\Include/arm_math.h ****    */
3851:.\Include/arm_math.h ****   void arm_fir_lattice_init_q31(
3852:.\Include/arm_math.h ****   arm_fir_lattice_instance_q31 * S,
3853:.\Include/arm_math.h ****   uint16_t numStages,
3854:.\Include/arm_math.h ****   q31_t * pCoeffs,
3855:.\Include/arm_math.h ****   q31_t * pState);
3856:.\Include/arm_math.h **** 
3857:.\Include/arm_math.h **** 
3858:.\Include/arm_math.h ****   /**
3859:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR lattice filter.
3860:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
3861:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3862:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3863:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3864:.\Include/arm_math.h ****    */
3865:.\Include/arm_math.h ****   void arm_fir_lattice_q31(
3866:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q31 * S,
3867:.\Include/arm_math.h ****   q31_t * pSrc,
3868:.\Include/arm_math.h ****   q31_t * pDst,
3869:.\Include/arm_math.h ****   uint32_t blockSize);
3870:.\Include/arm_math.h **** 
3871:.\Include/arm_math.h **** 
3872:.\Include/arm_math.h **** /**
3873:.\Include/arm_math.h ****  * @brief Initialization function for the floating-point FIR lattice filter.
3874:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the floating-point FIR lattice structure.
3875:.\Include/arm_math.h ****  * @param[in] numStages  number of filter stages.
3876:.\Include/arm_math.h ****  * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3877:.\Include/arm_math.h ****  * @param[in] pState     points to the state buffer.  The array is of length numStages.
3878:.\Include/arm_math.h ****  */
3879:.\Include/arm_math.h ****   void arm_fir_lattice_init_f32(
3880:.\Include/arm_math.h ****   arm_fir_lattice_instance_f32 * S,
3881:.\Include/arm_math.h ****   uint16_t numStages,
3882:.\Include/arm_math.h ****   float32_t * pCoeffs,
3883:.\Include/arm_math.h ****   float32_t * pState);
3884:.\Include/arm_math.h **** 
3885:.\Include/arm_math.h **** 
3886:.\Include/arm_math.h ****   /**
3887:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR lattice filter.
3888:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
3889:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3890:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 73


3891:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3892:.\Include/arm_math.h ****    */
3893:.\Include/arm_math.h ****   void arm_fir_lattice_f32(
3894:.\Include/arm_math.h ****   const arm_fir_lattice_instance_f32 * S,
3895:.\Include/arm_math.h ****   float32_t * pSrc,
3896:.\Include/arm_math.h ****   float32_t * pDst,
3897:.\Include/arm_math.h ****   uint32_t blockSize);
3898:.\Include/arm_math.h **** 
3899:.\Include/arm_math.h **** 
3900:.\Include/arm_math.h ****   /**
3901:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 IIR lattice filter.
3902:.\Include/arm_math.h ****    */
3903:.\Include/arm_math.h ****   typedef struct
3904:.\Include/arm_math.h ****   {
3905:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3906:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3907:.\Include/arm_math.h ****     q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3908:.\Include/arm_math.h ****     q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3909:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q15;
3910:.\Include/arm_math.h **** 
3911:.\Include/arm_math.h ****   /**
3912:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 IIR lattice filter.
3913:.\Include/arm_math.h ****    */
3914:.\Include/arm_math.h ****   typedef struct
3915:.\Include/arm_math.h ****   {
3916:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3917:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3918:.\Include/arm_math.h ****     q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3919:.\Include/arm_math.h ****     q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3920:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q31;
3921:.\Include/arm_math.h **** 
3922:.\Include/arm_math.h ****   /**
3923:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point IIR lattice filter.
3924:.\Include/arm_math.h ****    */
3925:.\Include/arm_math.h ****   typedef struct
3926:.\Include/arm_math.h ****   {
3927:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3928:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3929:.\Include/arm_math.h ****     float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array
3930:.\Include/arm_math.h ****     float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is 
3931:.\Include/arm_math.h ****   } arm_iir_lattice_instance_f32;
3932:.\Include/arm_math.h **** 
3933:.\Include/arm_math.h **** 
3934:.\Include/arm_math.h ****   /**
3935:.\Include/arm_math.h ****    * @brief Processing function for the floating-point IIR lattice filter.
3936:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
3937:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3938:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3939:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3940:.\Include/arm_math.h ****    */
3941:.\Include/arm_math.h ****   void arm_iir_lattice_f32(
3942:.\Include/arm_math.h ****   const arm_iir_lattice_instance_f32 * S,
3943:.\Include/arm_math.h ****   float32_t * pSrc,
3944:.\Include/arm_math.h ****   float32_t * pDst,
3945:.\Include/arm_math.h ****   uint32_t blockSize);
3946:.\Include/arm_math.h **** 
3947:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 74


3948:.\Include/arm_math.h ****   /**
3949:.\Include/arm_math.h ****    * @brief Initialization function for the floating-point IIR lattice filter.
3950:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point IIR lattice structure.
3951:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3952:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3953:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3954:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-
3955:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3956:.\Include/arm_math.h ****    */
3957:.\Include/arm_math.h ****   void arm_iir_lattice_init_f32(
3958:.\Include/arm_math.h ****   arm_iir_lattice_instance_f32 * S,
3959:.\Include/arm_math.h ****   uint16_t numStages,
3960:.\Include/arm_math.h ****   float32_t * pkCoeffs,
3961:.\Include/arm_math.h ****   float32_t * pvCoeffs,
3962:.\Include/arm_math.h ****   float32_t * pState,
3963:.\Include/arm_math.h ****   uint32_t blockSize);
3964:.\Include/arm_math.h **** 
3965:.\Include/arm_math.h **** 
3966:.\Include/arm_math.h ****   /**
3967:.\Include/arm_math.h ****    * @brief Processing function for the Q31 IIR lattice filter.
3968:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
3969:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3970:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3971:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3972:.\Include/arm_math.h ****    */
3973:.\Include/arm_math.h ****   void arm_iir_lattice_q31(
3974:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q31 * S,
3975:.\Include/arm_math.h ****   q31_t * pSrc,
3976:.\Include/arm_math.h ****   q31_t * pDst,
3977:.\Include/arm_math.h ****   uint32_t blockSize);
3978:.\Include/arm_math.h **** 
3979:.\Include/arm_math.h **** 
3980:.\Include/arm_math.h ****   /**
3981:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 IIR lattice filter.
3982:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 IIR lattice structure.
3983:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3984:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3985:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3986:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
3987:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3988:.\Include/arm_math.h ****    */
3989:.\Include/arm_math.h ****   void arm_iir_lattice_init_q31(
3990:.\Include/arm_math.h ****   arm_iir_lattice_instance_q31 * S,
3991:.\Include/arm_math.h ****   uint16_t numStages,
3992:.\Include/arm_math.h ****   q31_t * pkCoeffs,
3993:.\Include/arm_math.h ****   q31_t * pvCoeffs,
3994:.\Include/arm_math.h ****   q31_t * pState,
3995:.\Include/arm_math.h ****   uint32_t blockSize);
3996:.\Include/arm_math.h **** 
3997:.\Include/arm_math.h **** 
3998:.\Include/arm_math.h ****   /**
3999:.\Include/arm_math.h ****    * @brief Processing function for the Q15 IIR lattice filter.
4000:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
4001:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4002:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
4003:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4004:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 75


4005:.\Include/arm_math.h ****   void arm_iir_lattice_q15(
4006:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q15 * S,
4007:.\Include/arm_math.h ****   q15_t * pSrc,
4008:.\Include/arm_math.h ****   q15_t * pDst,
4009:.\Include/arm_math.h ****   uint32_t blockSize);
4010:.\Include/arm_math.h **** 
4011:.\Include/arm_math.h **** 
4012:.\Include/arm_math.h **** /**
4013:.\Include/arm_math.h ****  * @brief Initialization function for the Q15 IIR lattice filter.
4014:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
4015:.\Include/arm_math.h ****  * @param[in] numStages  number of stages in the filter.
4016:.\Include/arm_math.h ****  * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages
4017:.\Include/arm_math.h ****  * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
4018:.\Include/arm_math.h ****  * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
4019:.\Include/arm_math.h ****  * @param[in] blockSize  number of samples to process per call.
4020:.\Include/arm_math.h ****  */
4021:.\Include/arm_math.h ****   void arm_iir_lattice_init_q15(
4022:.\Include/arm_math.h ****   arm_iir_lattice_instance_q15 * S,
4023:.\Include/arm_math.h ****   uint16_t numStages,
4024:.\Include/arm_math.h ****   q15_t * pkCoeffs,
4025:.\Include/arm_math.h ****   q15_t * pvCoeffs,
4026:.\Include/arm_math.h ****   q15_t * pState,
4027:.\Include/arm_math.h ****   uint32_t blockSize);
4028:.\Include/arm_math.h **** 
4029:.\Include/arm_math.h **** 
4030:.\Include/arm_math.h ****   /**
4031:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point LMS filter.
4032:.\Include/arm_math.h ****    */
4033:.\Include/arm_math.h ****   typedef struct
4034:.\Include/arm_math.h ****   {
4035:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4036:.\Include/arm_math.h ****     float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+bl
4037:.\Include/arm_math.h ****     float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
4038:.\Include/arm_math.h ****     float32_t mu;        /**< step size that controls filter coefficient updates. */
4039:.\Include/arm_math.h ****   } arm_lms_instance_f32;
4040:.\Include/arm_math.h **** 
4041:.\Include/arm_math.h **** 
4042:.\Include/arm_math.h ****   /**
4043:.\Include/arm_math.h ****    * @brief Processing function for floating-point LMS filter.
4044:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point LMS filter structure.
4045:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4046:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4047:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4048:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4049:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4050:.\Include/arm_math.h ****    */
4051:.\Include/arm_math.h ****   void arm_lms_f32(
4052:.\Include/arm_math.h ****   const arm_lms_instance_f32 * S,
4053:.\Include/arm_math.h ****   float32_t * pSrc,
4054:.\Include/arm_math.h ****   float32_t * pRef,
4055:.\Include/arm_math.h ****   float32_t * pOut,
4056:.\Include/arm_math.h ****   float32_t * pErr,
4057:.\Include/arm_math.h ****   uint32_t blockSize);
4058:.\Include/arm_math.h **** 
4059:.\Include/arm_math.h **** 
4060:.\Include/arm_math.h ****   /**
4061:.\Include/arm_math.h ****    * @brief Initialization function for floating-point LMS filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 76


4062:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4063:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4064:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4065:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4066:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4067:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4068:.\Include/arm_math.h ****    */
4069:.\Include/arm_math.h ****   void arm_lms_init_f32(
4070:.\Include/arm_math.h ****   arm_lms_instance_f32 * S,
4071:.\Include/arm_math.h ****   uint16_t numTaps,
4072:.\Include/arm_math.h ****   float32_t * pCoeffs,
4073:.\Include/arm_math.h ****   float32_t * pState,
4074:.\Include/arm_math.h ****   float32_t mu,
4075:.\Include/arm_math.h ****   uint32_t blockSize);
4076:.\Include/arm_math.h **** 
4077:.\Include/arm_math.h **** 
4078:.\Include/arm_math.h ****   /**
4079:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 LMS filter.
4080:.\Include/arm_math.h ****    */
4081:.\Include/arm_math.h ****   typedef struct
4082:.\Include/arm_math.h ****   {
4083:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4084:.\Include/arm_math.h ****     q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4085:.\Include/arm_math.h ****     q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4086:.\Include/arm_math.h ****     q15_t mu;            /**< step size that controls filter coefficient updates. */
4087:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4088:.\Include/arm_math.h ****   } arm_lms_instance_q15;
4089:.\Include/arm_math.h **** 
4090:.\Include/arm_math.h **** 
4091:.\Include/arm_math.h ****   /**
4092:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 LMS filter.
4093:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 LMS filter structure.
4094:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4095:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4096:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.
4097:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4098:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4099:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4100:.\Include/arm_math.h ****    */
4101:.\Include/arm_math.h ****   void arm_lms_init_q15(
4102:.\Include/arm_math.h ****   arm_lms_instance_q15 * S,
4103:.\Include/arm_math.h ****   uint16_t numTaps,
4104:.\Include/arm_math.h ****   q15_t * pCoeffs,
4105:.\Include/arm_math.h ****   q15_t * pState,
4106:.\Include/arm_math.h ****   q15_t mu,
4107:.\Include/arm_math.h ****   uint32_t blockSize,
4108:.\Include/arm_math.h ****   uint32_t postShift);
4109:.\Include/arm_math.h **** 
4110:.\Include/arm_math.h **** 
4111:.\Include/arm_math.h ****   /**
4112:.\Include/arm_math.h ****    * @brief Processing function for Q15 LMS filter.
4113:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4114:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4115:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4116:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4117:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4118:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 77


4119:.\Include/arm_math.h ****    */
4120:.\Include/arm_math.h ****   void arm_lms_q15(
4121:.\Include/arm_math.h ****   const arm_lms_instance_q15 * S,
4122:.\Include/arm_math.h ****   q15_t * pSrc,
4123:.\Include/arm_math.h ****   q15_t * pRef,
4124:.\Include/arm_math.h ****   q15_t * pOut,
4125:.\Include/arm_math.h ****   q15_t * pErr,
4126:.\Include/arm_math.h ****   uint32_t blockSize);
4127:.\Include/arm_math.h **** 
4128:.\Include/arm_math.h **** 
4129:.\Include/arm_math.h ****   /**
4130:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 LMS filter.
4131:.\Include/arm_math.h ****    */
4132:.\Include/arm_math.h ****   typedef struct
4133:.\Include/arm_math.h ****   {
4134:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4135:.\Include/arm_math.h ****     q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4136:.\Include/arm_math.h ****     q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4137:.\Include/arm_math.h ****     q31_t mu;            /**< step size that controls filter coefficient updates. */
4138:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4139:.\Include/arm_math.h ****   } arm_lms_instance_q31;
4140:.\Include/arm_math.h **** 
4141:.\Include/arm_math.h **** 
4142:.\Include/arm_math.h ****   /**
4143:.\Include/arm_math.h ****    * @brief Processing function for Q31 LMS filter.
4144:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4145:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4146:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4147:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4148:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4149:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4150:.\Include/arm_math.h ****    */
4151:.\Include/arm_math.h ****   void arm_lms_q31(
4152:.\Include/arm_math.h ****   const arm_lms_instance_q31 * S,
4153:.\Include/arm_math.h ****   q31_t * pSrc,
4154:.\Include/arm_math.h ****   q31_t * pRef,
4155:.\Include/arm_math.h ****   q31_t * pOut,
4156:.\Include/arm_math.h ****   q31_t * pErr,
4157:.\Include/arm_math.h ****   uint32_t blockSize);
4158:.\Include/arm_math.h **** 
4159:.\Include/arm_math.h **** 
4160:.\Include/arm_math.h ****   /**
4161:.\Include/arm_math.h ****    * @brief Initialization function for Q31 LMS filter.
4162:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 LMS filter structure.
4163:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4164:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4165:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4166:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4167:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4168:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4169:.\Include/arm_math.h ****    */
4170:.\Include/arm_math.h ****   void arm_lms_init_q31(
4171:.\Include/arm_math.h ****   arm_lms_instance_q31 * S,
4172:.\Include/arm_math.h ****   uint16_t numTaps,
4173:.\Include/arm_math.h ****   q31_t * pCoeffs,
4174:.\Include/arm_math.h ****   q31_t * pState,
4175:.\Include/arm_math.h ****   q31_t mu,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 78


4176:.\Include/arm_math.h ****   uint32_t blockSize,
4177:.\Include/arm_math.h ****   uint32_t postShift);
4178:.\Include/arm_math.h **** 
4179:.\Include/arm_math.h **** 
4180:.\Include/arm_math.h ****   /**
4181:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point normalized LMS filter.
4182:.\Include/arm_math.h ****    */
4183:.\Include/arm_math.h ****   typedef struct
4184:.\Include/arm_math.h ****   {
4185:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4186:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
4187:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
4188:.\Include/arm_math.h ****     float32_t mu;         /**< step size that control filter coefficient updates. */
4189:.\Include/arm_math.h ****     float32_t energy;     /**< saves previous frame energy. */
4190:.\Include/arm_math.h ****     float32_t x0;         /**< saves previous input sample. */
4191:.\Include/arm_math.h ****   } arm_lms_norm_instance_f32;
4192:.\Include/arm_math.h **** 
4193:.\Include/arm_math.h **** 
4194:.\Include/arm_math.h ****   /**
4195:.\Include/arm_math.h ****    * @brief Processing function for floating-point normalized LMS filter.
4196:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point normalized LMS filter struc
4197:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4198:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4199:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4200:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4201:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4202:.\Include/arm_math.h ****    */
4203:.\Include/arm_math.h ****   void arm_lms_norm_f32(
4204:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4205:.\Include/arm_math.h ****   float32_t * pSrc,
4206:.\Include/arm_math.h ****   float32_t * pRef,
4207:.\Include/arm_math.h ****   float32_t * pOut,
4208:.\Include/arm_math.h ****   float32_t * pErr,
4209:.\Include/arm_math.h ****   uint32_t blockSize);
4210:.\Include/arm_math.h **** 
4211:.\Include/arm_math.h **** 
4212:.\Include/arm_math.h ****   /**
4213:.\Include/arm_math.h ****    * @brief Initialization function for floating-point normalized LMS filter.
4214:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4215:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4216:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4217:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4218:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4219:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4220:.\Include/arm_math.h ****    */
4221:.\Include/arm_math.h ****   void arm_lms_norm_init_f32(
4222:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4223:.\Include/arm_math.h ****   uint16_t numTaps,
4224:.\Include/arm_math.h ****   float32_t * pCoeffs,
4225:.\Include/arm_math.h ****   float32_t * pState,
4226:.\Include/arm_math.h ****   float32_t mu,
4227:.\Include/arm_math.h ****   uint32_t blockSize);
4228:.\Include/arm_math.h **** 
4229:.\Include/arm_math.h **** 
4230:.\Include/arm_math.h ****   /**
4231:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 normalized LMS filter.
4232:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 79


4233:.\Include/arm_math.h ****   typedef struct
4234:.\Include/arm_math.h ****   {
4235:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4236:.\Include/arm_math.h ****     q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4237:.\Include/arm_math.h ****     q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4238:.\Include/arm_math.h ****     q31_t mu;             /**< step size that controls filter coefficient updates. */
4239:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4240:.\Include/arm_math.h ****     q31_t *recipTable;    /**< points to the reciprocal initial value table. */
4241:.\Include/arm_math.h ****     q31_t energy;         /**< saves previous frame energy. */
4242:.\Include/arm_math.h ****     q31_t x0;             /**< saves previous input sample. */
4243:.\Include/arm_math.h ****   } arm_lms_norm_instance_q31;
4244:.\Include/arm_math.h **** 
4245:.\Include/arm_math.h **** 
4246:.\Include/arm_math.h ****   /**
4247:.\Include/arm_math.h ****    * @brief Processing function for Q31 normalized LMS filter.
4248:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
4249:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4250:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4251:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4252:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4253:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4254:.\Include/arm_math.h ****    */
4255:.\Include/arm_math.h ****   void arm_lms_norm_q31(
4256:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4257:.\Include/arm_math.h ****   q31_t * pSrc,
4258:.\Include/arm_math.h ****   q31_t * pRef,
4259:.\Include/arm_math.h ****   q31_t * pOut,
4260:.\Include/arm_math.h ****   q31_t * pErr,
4261:.\Include/arm_math.h ****   uint32_t blockSize);
4262:.\Include/arm_math.h **** 
4263:.\Include/arm_math.h **** 
4264:.\Include/arm_math.h ****   /**
4265:.\Include/arm_math.h ****    * @brief Initialization function for Q31 normalized LMS filter.
4266:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
4267:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4268:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4269:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4270:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4271:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4272:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4273:.\Include/arm_math.h ****    */
4274:.\Include/arm_math.h ****   void arm_lms_norm_init_q31(
4275:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4276:.\Include/arm_math.h ****   uint16_t numTaps,
4277:.\Include/arm_math.h ****   q31_t * pCoeffs,
4278:.\Include/arm_math.h ****   q31_t * pState,
4279:.\Include/arm_math.h ****   q31_t mu,
4280:.\Include/arm_math.h ****   uint32_t blockSize,
4281:.\Include/arm_math.h ****   uint8_t postShift);
4282:.\Include/arm_math.h **** 
4283:.\Include/arm_math.h **** 
4284:.\Include/arm_math.h ****   /**
4285:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 normalized LMS filter.
4286:.\Include/arm_math.h ****    */
4287:.\Include/arm_math.h ****   typedef struct
4288:.\Include/arm_math.h ****   {
4289:.\Include/arm_math.h ****     uint16_t numTaps;     /**< Number of coefficients in the filter. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 80


4290:.\Include/arm_math.h ****     q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4291:.\Include/arm_math.h ****     q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4292:.\Include/arm_math.h ****     q15_t mu;             /**< step size that controls filter coefficient updates. */
4293:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4294:.\Include/arm_math.h ****     q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
4295:.\Include/arm_math.h ****     q15_t energy;         /**< saves previous frame energy. */
4296:.\Include/arm_math.h ****     q15_t x0;             /**< saves previous input sample. */
4297:.\Include/arm_math.h ****   } arm_lms_norm_instance_q15;
4298:.\Include/arm_math.h **** 
4299:.\Include/arm_math.h **** 
4300:.\Include/arm_math.h ****   /**
4301:.\Include/arm_math.h ****    * @brief Processing function for Q15 normalized LMS filter.
4302:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
4303:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4304:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4305:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4306:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4307:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4308:.\Include/arm_math.h ****    */
4309:.\Include/arm_math.h ****   void arm_lms_norm_q15(
4310:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4311:.\Include/arm_math.h ****   q15_t * pSrc,
4312:.\Include/arm_math.h ****   q15_t * pRef,
4313:.\Include/arm_math.h ****   q15_t * pOut,
4314:.\Include/arm_math.h ****   q15_t * pErr,
4315:.\Include/arm_math.h ****   uint32_t blockSize);
4316:.\Include/arm_math.h **** 
4317:.\Include/arm_math.h **** 
4318:.\Include/arm_math.h ****   /**
4319:.\Include/arm_math.h ****    * @brief Initialization function for Q15 normalized LMS filter.
4320:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
4321:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4322:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4323:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4324:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4325:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4326:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4327:.\Include/arm_math.h ****    */
4328:.\Include/arm_math.h ****   void arm_lms_norm_init_q15(
4329:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4330:.\Include/arm_math.h ****   uint16_t numTaps,
4331:.\Include/arm_math.h ****   q15_t * pCoeffs,
4332:.\Include/arm_math.h ****   q15_t * pState,
4333:.\Include/arm_math.h ****   q15_t mu,
4334:.\Include/arm_math.h ****   uint32_t blockSize,
4335:.\Include/arm_math.h ****   uint8_t postShift);
4336:.\Include/arm_math.h **** 
4337:.\Include/arm_math.h **** 
4338:.\Include/arm_math.h ****   /**
4339:.\Include/arm_math.h ****    * @brief Correlation of floating-point sequences.
4340:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4341:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4342:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4343:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4344:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4345:.\Include/arm_math.h ****    */
4346:.\Include/arm_math.h ****   void arm_correlate_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 81


4347:.\Include/arm_math.h ****   float32_t * pSrcA,
4348:.\Include/arm_math.h ****   uint32_t srcALen,
4349:.\Include/arm_math.h ****   float32_t * pSrcB,
4350:.\Include/arm_math.h ****   uint32_t srcBLen,
4351:.\Include/arm_math.h ****   float32_t * pDst);
4352:.\Include/arm_math.h **** 
4353:.\Include/arm_math.h **** 
4354:.\Include/arm_math.h ****    /**
4355:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences
4356:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4357:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4358:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4359:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4360:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4361:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4362:.\Include/arm_math.h ****    */
4363:.\Include/arm_math.h ****   void arm_correlate_opt_q15(
4364:.\Include/arm_math.h ****   q15_t * pSrcA,
4365:.\Include/arm_math.h ****   uint32_t srcALen,
4366:.\Include/arm_math.h ****   q15_t * pSrcB,
4367:.\Include/arm_math.h ****   uint32_t srcBLen,
4368:.\Include/arm_math.h ****   q15_t * pDst,
4369:.\Include/arm_math.h ****   q15_t * pScratch);
4370:.\Include/arm_math.h **** 
4371:.\Include/arm_math.h **** 
4372:.\Include/arm_math.h ****   /**
4373:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences.
4374:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4375:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4376:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4377:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4378:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4379:.\Include/arm_math.h ****    */
4380:.\Include/arm_math.h **** 
4381:.\Include/arm_math.h ****   void arm_correlate_q15(
4382:.\Include/arm_math.h ****   q15_t * pSrcA,
4383:.\Include/arm_math.h ****   uint32_t srcALen,
4384:.\Include/arm_math.h ****   q15_t * pSrcB,
4385:.\Include/arm_math.h ****   uint32_t srcBLen,
4386:.\Include/arm_math.h ****   q15_t * pDst);
4387:.\Include/arm_math.h **** 
4388:.\Include/arm_math.h **** 
4389:.\Include/arm_math.h ****   /**
4390:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4391:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4392:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4393:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4394:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4395:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4396:.\Include/arm_math.h ****    */
4397:.\Include/arm_math.h **** 
4398:.\Include/arm_math.h ****   void arm_correlate_fast_q15(
4399:.\Include/arm_math.h ****   q15_t * pSrcA,
4400:.\Include/arm_math.h ****   uint32_t srcALen,
4401:.\Include/arm_math.h ****   q15_t * pSrcB,
4402:.\Include/arm_math.h ****   uint32_t srcBLen,
4403:.\Include/arm_math.h ****   q15_t * pDst);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 82


4404:.\Include/arm_math.h **** 
4405:.\Include/arm_math.h **** 
4406:.\Include/arm_math.h ****   /**
4407:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4408:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4409:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4410:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4411:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4412:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4413:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4414:.\Include/arm_math.h ****    */
4415:.\Include/arm_math.h ****   void arm_correlate_fast_opt_q15(
4416:.\Include/arm_math.h ****   q15_t * pSrcA,
4417:.\Include/arm_math.h ****   uint32_t srcALen,
4418:.\Include/arm_math.h ****   q15_t * pSrcB,
4419:.\Include/arm_math.h ****   uint32_t srcBLen,
4420:.\Include/arm_math.h ****   q15_t * pDst,
4421:.\Include/arm_math.h ****   q15_t * pScratch);
4422:.\Include/arm_math.h **** 
4423:.\Include/arm_math.h **** 
4424:.\Include/arm_math.h ****   /**
4425:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences.
4426:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4427:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4428:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4429:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4430:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4431:.\Include/arm_math.h ****    */
4432:.\Include/arm_math.h ****   void arm_correlate_q31(
4433:.\Include/arm_math.h ****   q31_t * pSrcA,
4434:.\Include/arm_math.h ****   uint32_t srcALen,
4435:.\Include/arm_math.h ****   q31_t * pSrcB,
4436:.\Include/arm_math.h ****   uint32_t srcBLen,
4437:.\Include/arm_math.h ****   q31_t * pDst);
4438:.\Include/arm_math.h **** 
4439:.\Include/arm_math.h **** 
4440:.\Include/arm_math.h ****   /**
4441:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
4442:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4443:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4444:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4445:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4446:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4447:.\Include/arm_math.h ****    */
4448:.\Include/arm_math.h ****   void arm_correlate_fast_q31(
4449:.\Include/arm_math.h ****   q31_t * pSrcA,
4450:.\Include/arm_math.h ****   uint32_t srcALen,
4451:.\Include/arm_math.h ****   q31_t * pSrcB,
4452:.\Include/arm_math.h ****   uint32_t srcBLen,
4453:.\Include/arm_math.h ****   q31_t * pDst);
4454:.\Include/arm_math.h **** 
4455:.\Include/arm_math.h **** 
4456:.\Include/arm_math.h ****  /**
4457:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4458:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
4459:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
4460:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 83


4461:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
4462:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 
4463:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
4464:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
4465:.\Include/arm_math.h ****    */
4466:.\Include/arm_math.h ****   void arm_correlate_opt_q7(
4467:.\Include/arm_math.h ****   q7_t * pSrcA,
4468:.\Include/arm_math.h ****   uint32_t srcALen,
4469:.\Include/arm_math.h ****   q7_t * pSrcB,
4470:.\Include/arm_math.h ****   uint32_t srcBLen,
4471:.\Include/arm_math.h ****   q7_t * pDst,
4472:.\Include/arm_math.h ****   q15_t * pScratch1,
4473:.\Include/arm_math.h ****   q15_t * pScratch2);
4474:.\Include/arm_math.h **** 
4475:.\Include/arm_math.h **** 
4476:.\Include/arm_math.h ****   /**
4477:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4478:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4479:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4480:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4481:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4482:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4483:.\Include/arm_math.h ****    */
4484:.\Include/arm_math.h ****   void arm_correlate_q7(
4485:.\Include/arm_math.h ****   q7_t * pSrcA,
4486:.\Include/arm_math.h ****   uint32_t srcALen,
4487:.\Include/arm_math.h ****   q7_t * pSrcB,
4488:.\Include/arm_math.h ****   uint32_t srcBLen,
4489:.\Include/arm_math.h ****   q7_t * pDst);
4490:.\Include/arm_math.h **** 
4491:.\Include/arm_math.h **** 
4492:.\Include/arm_math.h ****   /**
4493:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point sparse FIR filter.
4494:.\Include/arm_math.h ****    */
4495:.\Include/arm_math.h ****   typedef struct
4496:.\Include/arm_math.h ****   {
4497:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4498:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4499:.\Include/arm_math.h ****     float32_t *pState;            /**< points to the state buffer array. The array is of length max
4500:.\Include/arm_math.h ****     float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numT
4501:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4502:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4503:.\Include/arm_math.h ****   } arm_fir_sparse_instance_f32;
4504:.\Include/arm_math.h **** 
4505:.\Include/arm_math.h ****   /**
4506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 sparse FIR filter.
4507:.\Include/arm_math.h ****    */
4508:.\Include/arm_math.h ****   typedef struct
4509:.\Include/arm_math.h ****   {
4510:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4511:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4512:.\Include/arm_math.h ****     q31_t *pState;                /**< points to the state buffer array. The array is of length max
4513:.\Include/arm_math.h ****     q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4514:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4515:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4516:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q31;
4517:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 84


4518:.\Include/arm_math.h ****   /**
4519:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 sparse FIR filter.
4520:.\Include/arm_math.h ****    */
4521:.\Include/arm_math.h ****   typedef struct
4522:.\Include/arm_math.h ****   {
4523:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4524:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4525:.\Include/arm_math.h ****     q15_t *pState;                /**< points to the state buffer array. The array is of length max
4526:.\Include/arm_math.h ****     q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4527:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4528:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4529:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q15;
4530:.\Include/arm_math.h **** 
4531:.\Include/arm_math.h ****   /**
4532:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 sparse FIR filter.
4533:.\Include/arm_math.h ****    */
4534:.\Include/arm_math.h ****   typedef struct
4535:.\Include/arm_math.h ****   {
4536:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4537:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4538:.\Include/arm_math.h ****     q7_t *pState;                 /**< points to the state buffer array. The array is of length max
4539:.\Include/arm_math.h ****     q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numT
4540:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4541:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4542:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q7;
4543:.\Include/arm_math.h **** 
4544:.\Include/arm_math.h **** 
4545:.\Include/arm_math.h ****   /**
4546:.\Include/arm_math.h ****    * @brief Processing function for the floating-point sparse FIR filter.
4547:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
4548:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4549:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4550:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4551:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4552:.\Include/arm_math.h ****    */
4553:.\Include/arm_math.h ****   void arm_fir_sparse_f32(
4554:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4555:.\Include/arm_math.h ****   float32_t * pSrc,
4556:.\Include/arm_math.h ****   float32_t * pDst,
4557:.\Include/arm_math.h ****   float32_t * pScratchIn,
4558:.\Include/arm_math.h ****   uint32_t blockSize);
4559:.\Include/arm_math.h **** 
4560:.\Include/arm_math.h **** 
4561:.\Include/arm_math.h ****   /**
4562:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point sparse FIR filter.
4563:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
4564:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4565:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4566:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4567:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4568:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4569:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4570:.\Include/arm_math.h ****    */
4571:.\Include/arm_math.h ****   void arm_fir_sparse_init_f32(
4572:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4573:.\Include/arm_math.h ****   uint16_t numTaps,
4574:.\Include/arm_math.h ****   float32_t * pCoeffs,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 85


4575:.\Include/arm_math.h ****   float32_t * pState,
4576:.\Include/arm_math.h ****   int32_t * pTapDelay,
4577:.\Include/arm_math.h ****   uint16_t maxDelay,
4578:.\Include/arm_math.h ****   uint32_t blockSize);
4579:.\Include/arm_math.h **** 
4580:.\Include/arm_math.h **** 
4581:.\Include/arm_math.h ****   /**
4582:.\Include/arm_math.h ****    * @brief Processing function for the Q31 sparse FIR filter.
4583:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
4584:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4585:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4586:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4587:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4588:.\Include/arm_math.h ****    */
4589:.\Include/arm_math.h ****   void arm_fir_sparse_q31(
4590:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4591:.\Include/arm_math.h ****   q31_t * pSrc,
4592:.\Include/arm_math.h ****   q31_t * pDst,
4593:.\Include/arm_math.h ****   q31_t * pScratchIn,
4594:.\Include/arm_math.h ****   uint32_t blockSize);
4595:.\Include/arm_math.h **** 
4596:.\Include/arm_math.h **** 
4597:.\Include/arm_math.h ****   /**
4598:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 sparse FIR filter.
4599:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
4600:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4601:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4602:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4603:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4604:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4605:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4606:.\Include/arm_math.h ****    */
4607:.\Include/arm_math.h ****   void arm_fir_sparse_init_q31(
4608:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4609:.\Include/arm_math.h ****   uint16_t numTaps,
4610:.\Include/arm_math.h ****   q31_t * pCoeffs,
4611:.\Include/arm_math.h ****   q31_t * pState,
4612:.\Include/arm_math.h ****   int32_t * pTapDelay,
4613:.\Include/arm_math.h ****   uint16_t maxDelay,
4614:.\Include/arm_math.h ****   uint32_t blockSize);
4615:.\Include/arm_math.h **** 
4616:.\Include/arm_math.h **** 
4617:.\Include/arm_math.h ****   /**
4618:.\Include/arm_math.h ****    * @brief Processing function for the Q15 sparse FIR filter.
4619:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
4620:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4621:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4622:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4623:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4624:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4625:.\Include/arm_math.h ****    */
4626:.\Include/arm_math.h ****   void arm_fir_sparse_q15(
4627:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4628:.\Include/arm_math.h ****   q15_t * pSrc,
4629:.\Include/arm_math.h ****   q15_t * pDst,
4630:.\Include/arm_math.h ****   q15_t * pScratchIn,
4631:.\Include/arm_math.h ****   q31_t * pScratchOut,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 86


4632:.\Include/arm_math.h ****   uint32_t blockSize);
4633:.\Include/arm_math.h **** 
4634:.\Include/arm_math.h **** 
4635:.\Include/arm_math.h ****   /**
4636:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 sparse FIR filter.
4637:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
4638:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4639:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4640:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4641:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4642:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4643:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4644:.\Include/arm_math.h ****    */
4645:.\Include/arm_math.h ****   void arm_fir_sparse_init_q15(
4646:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4647:.\Include/arm_math.h ****   uint16_t numTaps,
4648:.\Include/arm_math.h ****   q15_t * pCoeffs,
4649:.\Include/arm_math.h ****   q15_t * pState,
4650:.\Include/arm_math.h ****   int32_t * pTapDelay,
4651:.\Include/arm_math.h ****   uint16_t maxDelay,
4652:.\Include/arm_math.h ****   uint32_t blockSize);
4653:.\Include/arm_math.h **** 
4654:.\Include/arm_math.h **** 
4655:.\Include/arm_math.h ****   /**
4656:.\Include/arm_math.h ****    * @brief Processing function for the Q7 sparse FIR filter.
4657:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
4658:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4659:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4660:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4661:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4662:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4663:.\Include/arm_math.h ****    */
4664:.\Include/arm_math.h ****   void arm_fir_sparse_q7(
4665:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4666:.\Include/arm_math.h ****   q7_t * pSrc,
4667:.\Include/arm_math.h ****   q7_t * pDst,
4668:.\Include/arm_math.h ****   q7_t * pScratchIn,
4669:.\Include/arm_math.h ****   q31_t * pScratchOut,
4670:.\Include/arm_math.h ****   uint32_t blockSize);
4671:.\Include/arm_math.h **** 
4672:.\Include/arm_math.h **** 
4673:.\Include/arm_math.h ****   /**
4674:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 sparse FIR filter.
4675:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
4676:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4677:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4678:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4679:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4680:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4681:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4682:.\Include/arm_math.h ****    */
4683:.\Include/arm_math.h ****   void arm_fir_sparse_init_q7(
4684:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4685:.\Include/arm_math.h ****   uint16_t numTaps,
4686:.\Include/arm_math.h ****   q7_t * pCoeffs,
4687:.\Include/arm_math.h ****   q7_t * pState,
4688:.\Include/arm_math.h ****   int32_t * pTapDelay,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 87


4689:.\Include/arm_math.h ****   uint16_t maxDelay,
4690:.\Include/arm_math.h ****   uint32_t blockSize);
4691:.\Include/arm_math.h **** 
4692:.\Include/arm_math.h **** 
4693:.\Include/arm_math.h ****   /**
4694:.\Include/arm_math.h ****    * @brief  Floating-point sin_cos function.
4695:.\Include/arm_math.h ****    * @param[in]  theta   input value in degrees
4696:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4697:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cos output.
4698:.\Include/arm_math.h ****    */
4699:.\Include/arm_math.h ****   void arm_sin_cos_f32(
4700:.\Include/arm_math.h ****   float32_t theta,
4701:.\Include/arm_math.h ****   float32_t * pSinVal,
4702:.\Include/arm_math.h ****   float32_t * pCosVal);
4703:.\Include/arm_math.h **** 
4704:.\Include/arm_math.h **** 
4705:.\Include/arm_math.h ****   /**
4706:.\Include/arm_math.h ****    * @brief  Q31 sin_cos function.
4707:.\Include/arm_math.h ****    * @param[in]  theta    scaled input value in degrees
4708:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4709:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cosine output.
4710:.\Include/arm_math.h ****    */
4711:.\Include/arm_math.h ****   void arm_sin_cos_q31(
4712:.\Include/arm_math.h ****   q31_t theta,
4713:.\Include/arm_math.h ****   q31_t * pSinVal,
4714:.\Include/arm_math.h ****   q31_t * pCosVal);
4715:.\Include/arm_math.h **** 
4716:.\Include/arm_math.h **** 
4717:.\Include/arm_math.h ****   /**
4718:.\Include/arm_math.h ****    * @brief  Floating-point complex conjugate.
4719:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4720:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4721:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4722:.\Include/arm_math.h ****    */
4723:.\Include/arm_math.h ****   void arm_cmplx_conj_f32(
4724:.\Include/arm_math.h ****   float32_t * pSrc,
4725:.\Include/arm_math.h ****   float32_t * pDst,
4726:.\Include/arm_math.h ****   uint32_t numSamples);
4727:.\Include/arm_math.h **** 
4728:.\Include/arm_math.h ****   /**
4729:.\Include/arm_math.h ****    * @brief  Q31 complex conjugate.
4730:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4731:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4732:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4733:.\Include/arm_math.h ****    */
4734:.\Include/arm_math.h ****   void arm_cmplx_conj_q31(
4735:.\Include/arm_math.h ****   q31_t * pSrc,
4736:.\Include/arm_math.h ****   q31_t * pDst,
4737:.\Include/arm_math.h ****   uint32_t numSamples);
4738:.\Include/arm_math.h **** 
4739:.\Include/arm_math.h **** 
4740:.\Include/arm_math.h ****   /**
4741:.\Include/arm_math.h ****    * @brief  Q15 complex conjugate.
4742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4743:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4744:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4745:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 88


4746:.\Include/arm_math.h ****   void arm_cmplx_conj_q15(
4747:.\Include/arm_math.h ****   q15_t * pSrc,
4748:.\Include/arm_math.h ****   q15_t * pDst,
4749:.\Include/arm_math.h ****   uint32_t numSamples);
4750:.\Include/arm_math.h **** 
4751:.\Include/arm_math.h **** 
4752:.\Include/arm_math.h ****   /**
4753:.\Include/arm_math.h ****    * @brief  Floating-point complex magnitude squared
4754:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4755:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4756:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4757:.\Include/arm_math.h ****    */
4758:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_f32(
4759:.\Include/arm_math.h ****   float32_t * pSrc,
4760:.\Include/arm_math.h ****   float32_t * pDst,
4761:.\Include/arm_math.h ****   uint32_t numSamples);
4762:.\Include/arm_math.h **** 
4763:.\Include/arm_math.h **** 
4764:.\Include/arm_math.h ****   /**
4765:.\Include/arm_math.h ****    * @brief  Q31 complex magnitude squared
4766:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4767:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4768:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4769:.\Include/arm_math.h ****    */
4770:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q31(
4771:.\Include/arm_math.h ****   q31_t * pSrc,
4772:.\Include/arm_math.h ****   q31_t * pDst,
4773:.\Include/arm_math.h ****   uint32_t numSamples);
4774:.\Include/arm_math.h **** 
4775:.\Include/arm_math.h **** 
4776:.\Include/arm_math.h ****   /**
4777:.\Include/arm_math.h ****    * @brief  Q15 complex magnitude squared
4778:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4779:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4780:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4781:.\Include/arm_math.h ****    */
4782:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q15(
4783:.\Include/arm_math.h ****   q15_t * pSrc,
4784:.\Include/arm_math.h ****   q15_t * pDst,
4785:.\Include/arm_math.h ****   uint32_t numSamples);
4786:.\Include/arm_math.h **** 
4787:.\Include/arm_math.h **** 
4788:.\Include/arm_math.h ****  /**
4789:.\Include/arm_math.h ****    * @ingroup groupController
4790:.\Include/arm_math.h ****    */
4791:.\Include/arm_math.h **** 
4792:.\Include/arm_math.h ****   /**
4793:.\Include/arm_math.h ****    * @defgroup PID PID Motor Control
4794:.\Include/arm_math.h ****    *
4795:.\Include/arm_math.h ****    * A Proportional Integral Derivative (PID) controller is a generic feedback control
4796:.\Include/arm_math.h ****    * loop mechanism widely used in industrial control systems.
4797:.\Include/arm_math.h ****    * A PID controller is the most commonly used type of feedback controller.
4798:.\Include/arm_math.h ****    *
4799:.\Include/arm_math.h ****    * This set of functions implements (PID) controllers
4800:.\Include/arm_math.h ****    * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
4801:.\Include/arm_math.h ****    * of data and each call to the function returns a single processed value.
4802:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 89


4803:.\Include/arm_math.h ****    * is the input sample value. The functions return the output value.
4804:.\Include/arm_math.h ****    *
4805:.\Include/arm_math.h ****    * \par Algorithm:
4806:.\Include/arm_math.h ****    * <pre>
4807:.\Include/arm_math.h ****    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
4808:.\Include/arm_math.h ****    *    A0 = Kp + Ki + Kd
4809:.\Include/arm_math.h ****    *    A1 = (-Kp ) - (2 * Kd )
4810:.\Include/arm_math.h ****    *    A2 = Kd  </pre>
4811:.\Include/arm_math.h ****    *
4812:.\Include/arm_math.h ****    * \par
4813:.\Include/arm_math.h ****    * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative const
4814:.\Include/arm_math.h ****    *
4815:.\Include/arm_math.h ****    * \par
4816:.\Include/arm_math.h ****    * \image html PID.gif "Proportional Integral Derivative Controller"
4817:.\Include/arm_math.h ****    *
4818:.\Include/arm_math.h ****    * \par
4819:.\Include/arm_math.h ****    * The PID controller calculates an "error" value as the difference between
4820:.\Include/arm_math.h ****    * the measured output and the reference input.
4821:.\Include/arm_math.h ****    * The controller attempts to minimize the error by adjusting the process control inputs.
4822:.\Include/arm_math.h ****    * The proportional value determines the reaction to the current error,
4823:.\Include/arm_math.h ****    * the integral value determines the reaction based on the sum of recent errors,
4824:.\Include/arm_math.h ****    * and the derivative value determines the reaction based on the rate at which the error has been
4825:.\Include/arm_math.h ****    *
4826:.\Include/arm_math.h ****    * \par Instance Structure
4827:.\Include/arm_math.h ****    * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instan
4828:.\Include/arm_math.h ****    * A separate instance structure must be defined for each PID Controller.
4829:.\Include/arm_math.h ****    * There are separate instance structure declarations for each of the 3 supported data types.
4830:.\Include/arm_math.h ****    *
4831:.\Include/arm_math.h ****    * \par Reset Functions
4832:.\Include/arm_math.h ****    * There is also an associated reset function for each data type which clears the state array.
4833:.\Include/arm_math.h ****    *
4834:.\Include/arm_math.h ****    * \par Initialization Functions
4835:.\Include/arm_math.h ****    * There is also an associated initialization function for each data type.
4836:.\Include/arm_math.h ****    * The initialization function performs the following operations:
4837:.\Include/arm_math.h ****    * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
4838:.\Include/arm_math.h ****    * - Zeros out the values in the state buffer.
4839:.\Include/arm_math.h ****    *
4840:.\Include/arm_math.h ****    * \par
4841:.\Include/arm_math.h ****    * Instance structure cannot be placed into a const data section and it is recommended to use the
4842:.\Include/arm_math.h ****    *
4843:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
4844:.\Include/arm_math.h ****    * Care must be taken when using the fixed-point versions of the PID Controller functions.
4845:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used in each function m
4846:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4847:.\Include/arm_math.h ****    */
4848:.\Include/arm_math.h **** 
4849:.\Include/arm_math.h ****   /**
4850:.\Include/arm_math.h ****    * @addtogroup PID
4851:.\Include/arm_math.h ****    * @{
4852:.\Include/arm_math.h ****    */
4853:.\Include/arm_math.h **** 
4854:.\Include/arm_math.h ****   /**
4855:.\Include/arm_math.h ****    * @brief  Process function for the floating-point PID Control.
4856:.\Include/arm_math.h ****    * @param[in,out] S   is an instance of the floating-point PID Control structure
4857:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4858:.\Include/arm_math.h ****    * @return out processed output sample.
4859:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 90


4860:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_pid_f32(
4861:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
4862:.\Include/arm_math.h ****   float32_t in)
4863:.\Include/arm_math.h ****   {
4864:.\Include/arm_math.h ****     float32_t out;
4865:.\Include/arm_math.h **** 
4866:.\Include/arm_math.h ****     /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
4867:.\Include/arm_math.h ****     out = (S->A0 * in) +
4868:.\Include/arm_math.h ****       (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
4869:.\Include/arm_math.h **** 
4870:.\Include/arm_math.h ****     /* Update state */
4871:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4872:.\Include/arm_math.h ****     S->state[0] = in;
4873:.\Include/arm_math.h ****     S->state[2] = out;
4874:.\Include/arm_math.h **** 
4875:.\Include/arm_math.h ****     /* return to application */
4876:.\Include/arm_math.h ****     return (out);
4877:.\Include/arm_math.h **** 
4878:.\Include/arm_math.h ****   }
4879:.\Include/arm_math.h **** 
4880:.\Include/arm_math.h ****   /**
4881:.\Include/arm_math.h ****    * @brief  Process function for the Q31 PID Control.
4882:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the Q31 PID Control structure
4883:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4884:.\Include/arm_math.h ****    * @return out processed output sample.
4885:.\Include/arm_math.h ****    *
4886:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4887:.\Include/arm_math.h ****    * \par
4888:.\Include/arm_math.h ****    * The function is implemented using an internal 64-bit accumulator.
4889:.\Include/arm_math.h ****    * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplicat
4890:.\Include/arm_math.h ****    * Thus, if the accumulator result overflows it wraps around rather than clip.
4891:.\Include/arm_math.h ****    * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there
4892:.\Include/arm_math.h ****    * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format
4893:.\Include/arm_math.h ****    */
4894:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_pid_q31(
4895:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
4896:.\Include/arm_math.h ****   q31_t in)
4897:.\Include/arm_math.h ****   {
4898:.\Include/arm_math.h ****     q63_t acc;
4899:.\Include/arm_math.h ****     q31_t out;
4900:.\Include/arm_math.h **** 
4901:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4902:.\Include/arm_math.h ****     acc = (q63_t) S->A0 * in;
4903:.\Include/arm_math.h **** 
4904:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] */
4905:.\Include/arm_math.h ****     acc += (q63_t) S->A1 * S->state[0];
4906:.\Include/arm_math.h **** 
4907:.\Include/arm_math.h ****     /* acc += A2 * x[n-2]  */
4908:.\Include/arm_math.h ****     acc += (q63_t) S->A2 * S->state[1];
4909:.\Include/arm_math.h **** 
4910:.\Include/arm_math.h ****     /* convert output to 1.31 format to add y[n-1] */
4911:.\Include/arm_math.h ****     out = (q31_t) (acc >> 31u);
4912:.\Include/arm_math.h **** 
4913:.\Include/arm_math.h ****     /* out += y[n-1] */
4914:.\Include/arm_math.h ****     out += S->state[2];
4915:.\Include/arm_math.h **** 
4916:.\Include/arm_math.h ****     /* Update state */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 91


4917:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4918:.\Include/arm_math.h ****     S->state[0] = in;
4919:.\Include/arm_math.h ****     S->state[2] = out;
4920:.\Include/arm_math.h **** 
4921:.\Include/arm_math.h ****     /* return to application */
4922:.\Include/arm_math.h ****     return (out);
4923:.\Include/arm_math.h ****   }
4924:.\Include/arm_math.h **** 
4925:.\Include/arm_math.h **** 
4926:.\Include/arm_math.h ****   /**
4927:.\Include/arm_math.h ****    * @brief  Process function for the Q15 PID Control.
4928:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q15 PID Control structure
4929:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4930:.\Include/arm_math.h ****    * @return out processed output sample.
4931:.\Include/arm_math.h ****    *
4932:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4933:.\Include/arm_math.h ****    * \par
4934:.\Include/arm_math.h ****    * The function is implemented using a 64-bit internal accumulator.
4935:.\Include/arm_math.h ****    * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30
4936:.\Include/arm_math.h ****    * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
4937:.\Include/arm_math.h ****    * There is no risk of internal overflow with this approach and the full precision of intermediat
4938:.\Include/arm_math.h ****    * After all additions have been performed, the accumulator is truncated to 34.15 format by disca
4939:.\Include/arm_math.h ****    * Lastly, the accumulator is saturated to yield a result in 1.15 format.
4940:.\Include/arm_math.h ****    */
4941:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_pid_q15(
4942:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
4943:.\Include/arm_math.h ****   q15_t in)
4944:.\Include/arm_math.h ****   {
4945:.\Include/arm_math.h ****     q63_t acc;
4946:.\Include/arm_math.h ****     q15_t out;
4947:.\Include/arm_math.h **** 
4948:.\Include/arm_math.h **** #if defined (ARM_MATH_DSP)
4949:.\Include/arm_math.h ****     __SIMD32_TYPE *vstate;
4950:.\Include/arm_math.h **** 
4951:.\Include/arm_math.h ****     /* Implementation of PID controller */
4952:.\Include/arm_math.h **** 
4953:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4954:.\Include/arm_math.h ****     acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
4955:.\Include/arm_math.h **** 
4956:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4957:.\Include/arm_math.h ****     vstate = __SIMD32_CONST(S->state);
4958:.\Include/arm_math.h ****     acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
4959:.\Include/arm_math.h **** #else
4960:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4961:.\Include/arm_math.h ****     acc = ((q31_t) S->A0) * in;
4962:.\Include/arm_math.h **** 
4963:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4964:.\Include/arm_math.h ****     acc += (q31_t) S->A1 * S->state[0];
4965:.\Include/arm_math.h ****     acc += (q31_t) S->A2 * S->state[1];
4966:.\Include/arm_math.h **** #endif
4967:.\Include/arm_math.h **** 
4968:.\Include/arm_math.h ****     /* acc += y[n-1] */
4969:.\Include/arm_math.h ****     acc += (q31_t) S->state[2] << 15;
4970:.\Include/arm_math.h **** 
4971:.\Include/arm_math.h ****     /* saturate the output */
4972:.\Include/arm_math.h ****     out = (q15_t) (__SSAT((acc >> 15), 16));
4973:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 92


4974:.\Include/arm_math.h ****     /* Update state */
4975:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4976:.\Include/arm_math.h ****     S->state[0] = in;
4977:.\Include/arm_math.h ****     S->state[2] = out;
4978:.\Include/arm_math.h **** 
4979:.\Include/arm_math.h ****     /* return to application */
4980:.\Include/arm_math.h ****     return (out);
4981:.\Include/arm_math.h ****   }
4982:.\Include/arm_math.h **** 
4983:.\Include/arm_math.h ****   /**
4984:.\Include/arm_math.h ****    * @} end of PID group
4985:.\Include/arm_math.h ****    */
4986:.\Include/arm_math.h **** 
4987:.\Include/arm_math.h **** 
4988:.\Include/arm_math.h ****   /**
4989:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
4990:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4991:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4992:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4993:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4994:.\Include/arm_math.h ****    */
4995:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f32(
4996:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * src,
4997:.\Include/arm_math.h ****   arm_matrix_instance_f32 * dst);
4998:.\Include/arm_math.h **** 
4999:.\Include/arm_math.h **** 
5000:.\Include/arm_math.h ****   /**
5001:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
5002:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
5003:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
5004:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
5005:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
5006:.\Include/arm_math.h ****    */
5007:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f64(
5008:.\Include/arm_math.h ****   const arm_matrix_instance_f64 * src,
5009:.\Include/arm_math.h ****   arm_matrix_instance_f64 * dst);
5010:.\Include/arm_math.h **** 
5011:.\Include/arm_math.h **** 
5012:.\Include/arm_math.h **** 
5013:.\Include/arm_math.h ****   /**
5014:.\Include/arm_math.h ****    * @ingroup groupController
5015:.\Include/arm_math.h ****    */
5016:.\Include/arm_math.h **** 
5017:.\Include/arm_math.h ****   /**
5018:.\Include/arm_math.h ****    * @defgroup clarke Vector Clarke Transform
5019:.\Include/arm_math.h ****    * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time i
5020:.\Include/arm_math.h ****    * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calcula
5021:.\Include/arm_math.h ****    * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
5022:.\Include/arm_math.h ****    * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
5023:.\Include/arm_math.h ****    * \image html clarke.gif Stator current space vector and its components in (a,b).
5024:.\Include/arm_math.h ****    * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code
5025:.\Include/arm_math.h ****    * can be calculated using only <code>Ia</code> and <code>Ib</code>.
5026:.\Include/arm_math.h ****    *
5027:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5028:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5029:.\Include/arm_math.h ****    * \par Algorithm
5030:.\Include/arm_math.h ****    * \image html clarkeFormula.gif
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 93


5031:.\Include/arm_math.h ****    * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
5032:.\Include/arm_math.h ****    * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
5033:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5034:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5035:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5036:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5037:.\Include/arm_math.h ****    */
5038:.\Include/arm_math.h **** 
5039:.\Include/arm_math.h ****   /**
5040:.\Include/arm_math.h ****    * @addtogroup clarke
5041:.\Include/arm_math.h ****    * @{
5042:.\Include/arm_math.h ****    */
5043:.\Include/arm_math.h **** 
5044:.\Include/arm_math.h ****   /**
5045:.\Include/arm_math.h ****    *
5046:.\Include/arm_math.h ****    * @brief  Floating-point Clarke transform
5047:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5048:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5049:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5050:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5051:.\Include/arm_math.h ****    */
5052:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_f32(
5053:.\Include/arm_math.h ****   float32_t Ia,
5054:.\Include/arm_math.h ****   float32_t Ib,
5055:.\Include/arm_math.h ****   float32_t * pIalpha,
5056:.\Include/arm_math.h ****   float32_t * pIbeta)
5057:.\Include/arm_math.h ****   {
5058:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Ia */
5059:.\Include/arm_math.h ****     *pIalpha = Ia;
5060:.\Include/arm_math.h **** 
5061:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
5062:.\Include/arm_math.h ****     *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
5063:.\Include/arm_math.h ****   }
5064:.\Include/arm_math.h **** 
5065:.\Include/arm_math.h **** 
5066:.\Include/arm_math.h ****   /**
5067:.\Include/arm_math.h ****    * @brief  Clarke transform for Q31 version
5068:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5069:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5070:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5071:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5072:.\Include/arm_math.h ****    *
5073:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5074:.\Include/arm_math.h ****    * \par
5075:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5076:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5077:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5078:.\Include/arm_math.h ****    */
5079:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_q31(
5080:.\Include/arm_math.h ****   q31_t Ia,
5081:.\Include/arm_math.h ****   q31_t Ib,
5082:.\Include/arm_math.h ****   q31_t * pIalpha,
5083:.\Include/arm_math.h ****   q31_t * pIbeta)
5084:.\Include/arm_math.h ****   {
5085:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5086:.\Include/arm_math.h **** 
5087:.\Include/arm_math.h ****     /* Calculating pIalpha from Ia by equation pIalpha = Ia */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 94


5088:.\Include/arm_math.h ****     *pIalpha = Ia;
5089:.\Include/arm_math.h **** 
5090:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
5091:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
5092:.\Include/arm_math.h **** 
5093:.\Include/arm_math.h ****     /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
5094:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
5095:.\Include/arm_math.h **** 
5096:.\Include/arm_math.h ****     /* pIbeta is calculated by adding the intermediate products */
5097:.\Include/arm_math.h ****     *pIbeta = __QADD(product1, product2);
5098:.\Include/arm_math.h ****   }
5099:.\Include/arm_math.h **** 
5100:.\Include/arm_math.h ****   /**
5101:.\Include/arm_math.h ****    * @} end of clarke group
5102:.\Include/arm_math.h ****    */
5103:.\Include/arm_math.h **** 
5104:.\Include/arm_math.h ****   /**
5105:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q31 vector.
5106:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5107:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5108:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5109:.\Include/arm_math.h ****    */
5110:.\Include/arm_math.h ****   void arm_q7_to_q31(
5111:.\Include/arm_math.h ****   q7_t * pSrc,
5112:.\Include/arm_math.h ****   q31_t * pDst,
5113:.\Include/arm_math.h ****   uint32_t blockSize);
5114:.\Include/arm_math.h **** 
5115:.\Include/arm_math.h **** 
5116:.\Include/arm_math.h **** 
5117:.\Include/arm_math.h ****   /**
5118:.\Include/arm_math.h ****    * @ingroup groupController
5119:.\Include/arm_math.h ****    */
5120:.\Include/arm_math.h **** 
5121:.\Include/arm_math.h ****   /**
5122:.\Include/arm_math.h ****    * @defgroup inv_clarke Vector Inverse Clarke Transform
5123:.\Include/arm_math.h ****    * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous 
5124:.\Include/arm_math.h ****    *
5125:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5126:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5127:.\Include/arm_math.h ****    * \par Algorithm
5128:.\Include/arm_math.h ****    * \image html clarkeInvFormula.gif
5129:.\Include/arm_math.h ****    * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
5130:.\Include/arm_math.h ****    * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
5131:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5132:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5133:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5134:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5135:.\Include/arm_math.h ****    */
5136:.\Include/arm_math.h **** 
5137:.\Include/arm_math.h ****   /**
5138:.\Include/arm_math.h ****    * @addtogroup inv_clarke
5139:.\Include/arm_math.h ****    * @{
5140:.\Include/arm_math.h ****    */
5141:.\Include/arm_math.h **** 
5142:.\Include/arm_math.h ****    /**
5143:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Clarke transform
5144:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 95


5145:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5146:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5147:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5148:.\Include/arm_math.h ****    */
5149:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_f32(
5150:.\Include/arm_math.h ****   float32_t Ialpha,
5151:.\Include/arm_math.h ****   float32_t Ibeta,
5152:.\Include/arm_math.h ****   float32_t * pIa,
5153:.\Include/arm_math.h ****   float32_t * pIb)
5154:.\Include/arm_math.h ****   {
5155:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5156:.\Include/arm_math.h ****     *pIa = Ialpha;
5157:.\Include/arm_math.h **** 
5158:.\Include/arm_math.h ****     /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibet
5159:.\Include/arm_math.h ****     *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
5160:.\Include/arm_math.h ****   }
5161:.\Include/arm_math.h **** 
5162:.\Include/arm_math.h **** 
5163:.\Include/arm_math.h ****   /**
5164:.\Include/arm_math.h ****    * @brief  Inverse Clarke transform for Q31 version
5165:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5166:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5167:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5168:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5169:.\Include/arm_math.h ****    *
5170:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5171:.\Include/arm_math.h ****    * \par
5172:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5173:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5174:.\Include/arm_math.h ****    * There is saturation on the subtraction, hence there is no risk of overflow.
5175:.\Include/arm_math.h ****    */
5176:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_q31(
5177:.\Include/arm_math.h ****   q31_t Ialpha,
5178:.\Include/arm_math.h ****   q31_t Ibeta,
5179:.\Include/arm_math.h ****   q31_t * pIa,
5180:.\Include/arm_math.h ****   q31_t * pIb)
5181:.\Include/arm_math.h ****   {
5182:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5183:.\Include/arm_math.h **** 
5184:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5185:.\Include/arm_math.h ****     *pIa = Ialpha;
5186:.\Include/arm_math.h **** 
5187:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
5188:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
5189:.\Include/arm_math.h **** 
5190:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
5191:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
5192:.\Include/arm_math.h **** 
5193:.\Include/arm_math.h ****     /* pIb is calculated by subtracting the products */
5194:.\Include/arm_math.h ****     *pIb = __QSUB(product2, product1);
5195:.\Include/arm_math.h ****   }
5196:.\Include/arm_math.h **** 
5197:.\Include/arm_math.h ****   /**
5198:.\Include/arm_math.h ****    * @} end of inv_clarke group
5199:.\Include/arm_math.h ****    */
5200:.\Include/arm_math.h **** 
5201:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 96


5202:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q15 vector.
5203:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5204:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5205:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5206:.\Include/arm_math.h ****    */
5207:.\Include/arm_math.h ****   void arm_q7_to_q15(
5208:.\Include/arm_math.h ****   q7_t * pSrc,
5209:.\Include/arm_math.h ****   q15_t * pDst,
5210:.\Include/arm_math.h ****   uint32_t blockSize);
5211:.\Include/arm_math.h **** 
5212:.\Include/arm_math.h **** 
5213:.\Include/arm_math.h **** 
5214:.\Include/arm_math.h ****   /**
5215:.\Include/arm_math.h ****    * @ingroup groupController
5216:.\Include/arm_math.h ****    */
5217:.\Include/arm_math.h **** 
5218:.\Include/arm_math.h ****   /**
5219:.\Include/arm_math.h ****    * @defgroup park Vector Park Transform
5220:.\Include/arm_math.h ****    *
5221:.\Include/arm_math.h ****    * Forward Park transform converts the input two-coordinate vector to flux and torque components.
5222:.\Include/arm_math.h ****    * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and th
5223:.\Include/arm_math.h ****    * from the stationary to the moving reference frame and control the spatial relationship between
5224:.\Include/arm_math.h ****    * the stator vector current and rotor flux vector.
5225:.\Include/arm_math.h ****    * If we consider the d axis aligned with the rotor flux, the diagram below shows the
5226:.\Include/arm_math.h ****    * current vector and the relationship from the two reference frames:
5227:.\Include/arm_math.h ****    * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q ro
5228:.\Include/arm_math.h ****    *
5229:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5230:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5231:.\Include/arm_math.h ****    * \par Algorithm
5232:.\Include/arm_math.h ****    * \image html parkFormula.gif
5233:.\Include/arm_math.h ****    * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
5234:.\Include/arm_math.h ****    * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and 
5235:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5236:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5237:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5238:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5239:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5240:.\Include/arm_math.h ****    */
5241:.\Include/arm_math.h **** 
5242:.\Include/arm_math.h ****   /**
5243:.\Include/arm_math.h ****    * @addtogroup park
5244:.\Include/arm_math.h ****    * @{
5245:.\Include/arm_math.h ****    */
5246:.\Include/arm_math.h **** 
5247:.\Include/arm_math.h ****   /**
5248:.\Include/arm_math.h ****    * @brief Floating-point Park transform
5249:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5250:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5251:.\Include/arm_math.h ****    * @param[out] pId     points to output   rotor reference frame d
5252:.\Include/arm_math.h ****    * @param[out] pIq     points to output   rotor reference frame q
5253:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5254:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5255:.\Include/arm_math.h ****    *
5256:.\Include/arm_math.h ****    * The function implements the forward Park transform.
5257:.\Include/arm_math.h ****    *
5258:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 97


5259:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_f32(
5260:.\Include/arm_math.h ****   float32_t Ialpha,
5261:.\Include/arm_math.h ****   float32_t Ibeta,
5262:.\Include/arm_math.h ****   float32_t * pId,
5263:.\Include/arm_math.h ****   float32_t * pIq,
5264:.\Include/arm_math.h ****   float32_t sinVal,
5265:.\Include/arm_math.h ****   float32_t cosVal)
5266:.\Include/arm_math.h ****   {
5267:.\Include/arm_math.h ****     /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
5268:.\Include/arm_math.h ****     *pId = Ialpha * cosVal + Ibeta * sinVal;
5269:.\Include/arm_math.h **** 
5270:.\Include/arm_math.h ****     /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
5271:.\Include/arm_math.h ****     *pIq = -Ialpha * sinVal + Ibeta * cosVal;
5272:.\Include/arm_math.h ****   }
5273:.\Include/arm_math.h **** 
5274:.\Include/arm_math.h **** 
5275:.\Include/arm_math.h ****   /**
5276:.\Include/arm_math.h ****    * @brief  Park transform for Q31 version
5277:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5278:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5279:.\Include/arm_math.h ****    * @param[out] pId     points to output rotor reference frame d
5280:.\Include/arm_math.h ****    * @param[out] pIq     points to output rotor reference frame q
5281:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5282:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5283:.\Include/arm_math.h ****    *
5284:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5285:.\Include/arm_math.h ****    * \par
5286:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5287:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5288:.\Include/arm_math.h ****    * There is saturation on the addition and subtraction, hence there is no risk of overflow.
5289:.\Include/arm_math.h ****    */
5290:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_q31(
5291:.\Include/arm_math.h ****   q31_t Ialpha,
5292:.\Include/arm_math.h ****   q31_t Ibeta,
5293:.\Include/arm_math.h ****   q31_t * pId,
5294:.\Include/arm_math.h ****   q31_t * pIq,
5295:.\Include/arm_math.h ****   q31_t sinVal,
5296:.\Include/arm_math.h ****   q31_t cosVal)
5297:.\Include/arm_math.h ****   {
5298:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5299:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5300:.\Include/arm_math.h **** 
5301:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * cosVal) */
5302:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
5303:.\Include/arm_math.h **** 
5304:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * sinVal) */
5305:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
5306:.\Include/arm_math.h **** 
5307:.\Include/arm_math.h **** 
5308:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * sinVal) */
5309:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
5310:.\Include/arm_math.h **** 
5311:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * cosVal) */
5312:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
5313:.\Include/arm_math.h **** 
5314:.\Include/arm_math.h ****     /* Calculate pId by adding the two intermediate products 1 and 2 */
5315:.\Include/arm_math.h ****     *pId = __QADD(product1, product2);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 98


5316:.\Include/arm_math.h **** 
5317:.\Include/arm_math.h ****     /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
5318:.\Include/arm_math.h ****     *pIq = __QSUB(product4, product3);
5319:.\Include/arm_math.h ****   }
5320:.\Include/arm_math.h **** 
5321:.\Include/arm_math.h ****   /**
5322:.\Include/arm_math.h ****    * @} end of park group
5323:.\Include/arm_math.h ****    */
5324:.\Include/arm_math.h **** 
5325:.\Include/arm_math.h ****   /**
5326:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to floating-point vector.
5327:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5328:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5329:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5330:.\Include/arm_math.h ****    */
5331:.\Include/arm_math.h ****   void arm_q7_to_float(
5332:.\Include/arm_math.h ****   q7_t * pSrc,
5333:.\Include/arm_math.h ****   float32_t * pDst,
5334:.\Include/arm_math.h ****   uint32_t blockSize);
5335:.\Include/arm_math.h **** 
5336:.\Include/arm_math.h **** 
5337:.\Include/arm_math.h ****   /**
5338:.\Include/arm_math.h ****    * @ingroup groupController
5339:.\Include/arm_math.h ****    */
5340:.\Include/arm_math.h **** 
5341:.\Include/arm_math.h ****   /**
5342:.\Include/arm_math.h ****    * @defgroup inv_park Vector Inverse Park transform
5343:.\Include/arm_math.h ****    * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
5344:.\Include/arm_math.h ****    *
5345:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5346:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5347:.\Include/arm_math.h ****    * \par Algorithm
5348:.\Include/arm_math.h ****    * \image html parkInvFormula.gif
5349:.\Include/arm_math.h ****    * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
5350:.\Include/arm_math.h ****    * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <c
5351:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5352:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5353:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5354:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5355:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5356:.\Include/arm_math.h ****    */
5357:.\Include/arm_math.h **** 
5358:.\Include/arm_math.h ****   /**
5359:.\Include/arm_math.h ****    * @addtogroup inv_park
5360:.\Include/arm_math.h ****    * @{
5361:.\Include/arm_math.h ****    */
5362:.\Include/arm_math.h **** 
5363:.\Include/arm_math.h ****    /**
5364:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Park transform
5365:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5366:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5367:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5368:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5369:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5370:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5371:.\Include/arm_math.h ****    */
5372:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 99


5373:.\Include/arm_math.h ****   float32_t Id,
5374:.\Include/arm_math.h ****   float32_t Iq,
5375:.\Include/arm_math.h ****   float32_t * pIalpha,
5376:.\Include/arm_math.h ****   float32_t * pIbeta,
5377:.\Include/arm_math.h ****   float32_t sinVal,
5378:.\Include/arm_math.h ****   float32_t cosVal)
5379:.\Include/arm_math.h ****   {
5380:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
5381:.\Include/arm_math.h ****     *pIalpha = Id * cosVal - Iq * sinVal;
5382:.\Include/arm_math.h **** 
5383:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
5384:.\Include/arm_math.h ****     *pIbeta = Id * sinVal + Iq * cosVal;
5385:.\Include/arm_math.h ****   }
5386:.\Include/arm_math.h **** 
5387:.\Include/arm_math.h **** 
5388:.\Include/arm_math.h ****   /**
5389:.\Include/arm_math.h ****    * @brief  Inverse Park transform for   Q31 version
5390:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5391:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5392:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5393:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5394:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5395:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5396:.\Include/arm_math.h ****    *
5397:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5398:.\Include/arm_math.h ****    * \par
5399:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5400:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5401:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5402:.\Include/arm_math.h ****    */
5403:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_q31(
5404:.\Include/arm_math.h ****   q31_t Id,
5405:.\Include/arm_math.h ****   q31_t Iq,
5406:.\Include/arm_math.h ****   q31_t * pIalpha,
5407:.\Include/arm_math.h ****   q31_t * pIbeta,
5408:.\Include/arm_math.h ****   q31_t sinVal,
5409:.\Include/arm_math.h ****   q31_t cosVal)
5410:.\Include/arm_math.h ****   {
5411:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5412:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5413:.\Include/arm_math.h **** 
5414:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * cosVal) */
5415:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
5416:.\Include/arm_math.h **** 
5417:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * sinVal) */
5418:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
5419:.\Include/arm_math.h **** 
5420:.\Include/arm_math.h **** 
5421:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * sinVal) */
5422:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
5423:.\Include/arm_math.h **** 
5424:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * cosVal) */
5425:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
5426:.\Include/arm_math.h **** 
5427:.\Include/arm_math.h ****     /* Calculate pIalpha by using the two intermediate products 1 and 2 */
5428:.\Include/arm_math.h ****     *pIalpha = __QSUB(product1, product2);
5429:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 100


5430:.\Include/arm_math.h ****     /* Calculate pIbeta by using the two intermediate products 3 and 4 */
5431:.\Include/arm_math.h ****     *pIbeta = __QADD(product4, product3);
5432:.\Include/arm_math.h ****   }
5433:.\Include/arm_math.h **** 
5434:.\Include/arm_math.h ****   /**
5435:.\Include/arm_math.h ****    * @} end of Inverse park group
5436:.\Include/arm_math.h ****    */
5437:.\Include/arm_math.h **** 
5438:.\Include/arm_math.h **** 
5439:.\Include/arm_math.h ****   /**
5440:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q31 vector to floating-point vector.
5441:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5442:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5443:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5444:.\Include/arm_math.h ****    */
5445:.\Include/arm_math.h ****   void arm_q31_to_float(
5446:.\Include/arm_math.h ****   q31_t * pSrc,
5447:.\Include/arm_math.h ****   float32_t * pDst,
5448:.\Include/arm_math.h ****   uint32_t blockSize);
5449:.\Include/arm_math.h **** 
5450:.\Include/arm_math.h ****   /**
5451:.\Include/arm_math.h ****    * @ingroup groupInterpolation
5452:.\Include/arm_math.h ****    */
5453:.\Include/arm_math.h **** 
5454:.\Include/arm_math.h ****   /**
5455:.\Include/arm_math.h ****    * @defgroup LinearInterpolate Linear Interpolation
5456:.\Include/arm_math.h ****    *
5457:.\Include/arm_math.h ****    * Linear interpolation is a method of curve fitting using linear polynomials.
5458:.\Include/arm_math.h ****    * Linear interpolation works by effectively drawing a straight line between two neighboring samp
5459:.\Include/arm_math.h ****    *
5460:.\Include/arm_math.h ****    * \par
5461:.\Include/arm_math.h ****    * \image html LinearInterp.gif "Linear interpolation"
5462:.\Include/arm_math.h ****    *
5463:.\Include/arm_math.h ****    * \par
5464:.\Include/arm_math.h ****    * A  Linear Interpolate function calculates an output value(y), for the input(x)
5465:.\Include/arm_math.h ****    * using linear interpolation of the input values x0, x1( nearest input values) and the output va
5466:.\Include/arm_math.h ****    *
5467:.\Include/arm_math.h ****    * \par Algorithm:
5468:.\Include/arm_math.h ****    * <pre>
5469:.\Include/arm_math.h ****    *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
5470:.\Include/arm_math.h ****    *       where x0, x1 are nearest values of input x
5471:.\Include/arm_math.h ****    *             y0, y1 are nearest values to output y
5472:.\Include/arm_math.h ****    * </pre>
5473:.\Include/arm_math.h ****    *
5474:.\Include/arm_math.h ****    * \par
5475:.\Include/arm_math.h ****    * This set of functions implements Linear interpolation process
5476:.\Include/arm_math.h ****    * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
5477:.\Include/arm_math.h ****    * sample of data and each call to the function returns a single processed value.
5478:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the Linear Interpolate function data structure.
5479:.\Include/arm_math.h ****    * <code>x</code> is the input sample value. The functions returns the output value.
5480:.\Include/arm_math.h ****    *
5481:.\Include/arm_math.h ****    * \par
5482:.\Include/arm_math.h ****    * if x is outside of the table boundary, Linear interpolation returns first value of the table
5483:.\Include/arm_math.h ****    * if x is below input range and returns last value of table if x is above range.
5484:.\Include/arm_math.h ****    */
5485:.\Include/arm_math.h **** 
5486:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 101


5487:.\Include/arm_math.h ****    * @addtogroup LinearInterpolate
5488:.\Include/arm_math.h ****    * @{
5489:.\Include/arm_math.h ****    */
5490:.\Include/arm_math.h **** 
5491:.\Include/arm_math.h ****   /**
5492:.\Include/arm_math.h ****    * @brief  Process function for the floating-point Linear Interpolation Function.
5493:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
5494:.\Include/arm_math.h ****    * @param[in]     x  input sample to process
5495:.\Include/arm_math.h ****    * @return y processed output sample.
5496:.\Include/arm_math.h ****    *
5497:.\Include/arm_math.h ****    */
5498:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_linear_interp_f32(
5499:.\Include/arm_math.h ****   arm_linear_interp_instance_f32 * S,
5500:.\Include/arm_math.h ****   float32_t x)
5501:.\Include/arm_math.h ****   {
5502:.\Include/arm_math.h ****     float32_t y;
5503:.\Include/arm_math.h ****     float32_t x0, x1;                            /* Nearest input values */
5504:.\Include/arm_math.h ****     float32_t y0, y1;                            /* Nearest output values */
5505:.\Include/arm_math.h ****     float32_t xSpacing = S->xSpacing;            /* spacing between input values */
5506:.\Include/arm_math.h ****     int32_t i;                                   /* Index variable */
5507:.\Include/arm_math.h ****     float32_t *pYData = S->pYData;               /* pointer to output table */
5508:.\Include/arm_math.h **** 
5509:.\Include/arm_math.h ****     /* Calculation of index */
5510:.\Include/arm_math.h ****     i = (int32_t) ((x - S->x1) / xSpacing);
5511:.\Include/arm_math.h **** 
5512:.\Include/arm_math.h ****     if (i < 0)
5513:.\Include/arm_math.h ****     {
5514:.\Include/arm_math.h ****       /* Iniatilize output for below specified range as least output value of table */
5515:.\Include/arm_math.h ****       y = pYData[0];
5516:.\Include/arm_math.h ****     }
5517:.\Include/arm_math.h ****     else if ((uint32_t)i >= S->nValues)
5518:.\Include/arm_math.h ****     {
5519:.\Include/arm_math.h ****       /* Iniatilize output for above specified range as last output value of table */
5520:.\Include/arm_math.h ****       y = pYData[S->nValues - 1];
5521:.\Include/arm_math.h ****     }
5522:.\Include/arm_math.h ****     else
5523:.\Include/arm_math.h ****     {
5524:.\Include/arm_math.h ****       /* Calculation of nearest input values */
5525:.\Include/arm_math.h ****       x0 = S->x1 +  i      * xSpacing;
5526:.\Include/arm_math.h ****       x1 = S->x1 + (i + 1) * xSpacing;
5527:.\Include/arm_math.h **** 
5528:.\Include/arm_math.h ****       /* Read of nearest output values */
5529:.\Include/arm_math.h ****       y0 = pYData[i];
5530:.\Include/arm_math.h ****       y1 = pYData[i + 1];
5531:.\Include/arm_math.h **** 
5532:.\Include/arm_math.h ****       /* Calculation of output */
5533:.\Include/arm_math.h ****       y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
5534:.\Include/arm_math.h **** 
5535:.\Include/arm_math.h ****     }
5536:.\Include/arm_math.h **** 
5537:.\Include/arm_math.h ****     /* returns output value */
5538:.\Include/arm_math.h ****     return (y);
5539:.\Include/arm_math.h ****   }
5540:.\Include/arm_math.h **** 
5541:.\Include/arm_math.h **** 
5542:.\Include/arm_math.h ****    /**
5543:.\Include/arm_math.h ****    *
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 102


5544:.\Include/arm_math.h ****    * @brief  Process function for the Q31 Linear Interpolation Function.
5545:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q31 Linear Interpolation table
5546:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5547:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5548:.\Include/arm_math.h ****    * @return y processed output sample.
5549:.\Include/arm_math.h ****    *
5550:.\Include/arm_math.h ****    * \par
5551:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5552:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5553:.\Include/arm_math.h ****    *
5554:.\Include/arm_math.h ****    */
5555:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_linear_interp_q31(
5556:.\Include/arm_math.h ****   q31_t * pYData,
5557:.\Include/arm_math.h ****   q31_t x,
5558:.\Include/arm_math.h ****   uint32_t nValues)
5559:.\Include/arm_math.h ****   {
5560:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5561:.\Include/arm_math.h ****     q31_t y0, y1;                                /* Nearest output values */
5562:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5563:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5564:.\Include/arm_math.h **** 
5565:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5566:.\Include/arm_math.h ****     /* 12 bits for the table index */
5567:.\Include/arm_math.h ****     /* Index value calculation */
5568:.\Include/arm_math.h ****     index = ((x & (q31_t)0xFFF00000) >> 20);
5569:.\Include/arm_math.h **** 
5570:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5571:.\Include/arm_math.h ****     {
5572:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5573:.\Include/arm_math.h ****     }
5574:.\Include/arm_math.h ****     else if (index < 0)
5575:.\Include/arm_math.h ****     {
5576:.\Include/arm_math.h ****       return (pYData[0]);
5577:.\Include/arm_math.h ****     }
5578:.\Include/arm_math.h ****     else
5579:.\Include/arm_math.h ****     {
5580:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5581:.\Include/arm_math.h ****       /* shift left by 11 to keep fract in 1.31 format */
5582:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF) << 11;
5583:.\Include/arm_math.h **** 
5584:.\Include/arm_math.h ****       /* Read two nearest output values from the index in 1.31(q31) format */
5585:.\Include/arm_math.h ****       y0 = pYData[index];
5586:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5587:.\Include/arm_math.h **** 
5588:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 2.30 format */
5589:.\Include/arm_math.h ****       y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
5590:.\Include/arm_math.h **** 
5591:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
5592:.\Include/arm_math.h ****       y += ((q31_t) (((q63_t) y1 * fract) >> 32));
5593:.\Include/arm_math.h **** 
5594:.\Include/arm_math.h ****       /* Convert y to 1.31 format */
5595:.\Include/arm_math.h ****       return (y << 1u);
5596:.\Include/arm_math.h ****     }
5597:.\Include/arm_math.h ****   }
5598:.\Include/arm_math.h **** 
5599:.\Include/arm_math.h **** 
5600:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 103


5601:.\Include/arm_math.h ****    *
5602:.\Include/arm_math.h ****    * @brief  Process function for the Q15 Linear Interpolation Function.
5603:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q15 Linear Interpolation table
5604:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5605:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5606:.\Include/arm_math.h ****    * @return y processed output sample.
5607:.\Include/arm_math.h ****    *
5608:.\Include/arm_math.h ****    * \par
5609:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5610:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5611:.\Include/arm_math.h ****    *
5612:.\Include/arm_math.h ****    */
5613:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_linear_interp_q15(
5614:.\Include/arm_math.h ****   q15_t * pYData,
5615:.\Include/arm_math.h ****   q31_t x,
5616:.\Include/arm_math.h ****   uint32_t nValues)
5617:.\Include/arm_math.h ****   {
5618:.\Include/arm_math.h ****     q63_t y;                                     /* output */
5619:.\Include/arm_math.h ****     q15_t y0, y1;                                /* Nearest output values */
5620:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5621:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5622:.\Include/arm_math.h **** 
5623:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5624:.\Include/arm_math.h ****     /* 12 bits for the table index */
5625:.\Include/arm_math.h ****     /* Index value calculation */
5626:.\Include/arm_math.h ****     index = ((x & (int32_t)0xFFF00000) >> 20);
5627:.\Include/arm_math.h **** 
5628:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5629:.\Include/arm_math.h ****     {
5630:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5631:.\Include/arm_math.h ****     }
5632:.\Include/arm_math.h ****     else if (index < 0)
5633:.\Include/arm_math.h ****     {
5634:.\Include/arm_math.h ****       return (pYData[0]);
5635:.\Include/arm_math.h ****     }
5636:.\Include/arm_math.h ****     else
5637:.\Include/arm_math.h ****     {
5638:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5639:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5640:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5641:.\Include/arm_math.h **** 
5642:.\Include/arm_math.h ****       /* Read two nearest output values from the index */
5643:.\Include/arm_math.h ****       y0 = pYData[index];
5644:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5645:.\Include/arm_math.h **** 
5646:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 13.35 format */
5647:.\Include/arm_math.h ****       y = ((q63_t) y0 * (0xFFFFF - fract));
5648:.\Include/arm_math.h **** 
5649:.\Include/arm_math.h ****       /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
5650:.\Include/arm_math.h ****       y += ((q63_t) y1 * (fract));
5651:.\Include/arm_math.h **** 
5652:.\Include/arm_math.h ****       /* convert y to 1.15 format */
5653:.\Include/arm_math.h ****       return (q15_t) (y >> 20);
5654:.\Include/arm_math.h ****     }
5655:.\Include/arm_math.h ****   }
5656:.\Include/arm_math.h **** 
5657:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 104


5658:.\Include/arm_math.h ****   /**
5659:.\Include/arm_math.h ****    *
5660:.\Include/arm_math.h ****    * @brief  Process function for the Q7 Linear Interpolation Function.
5661:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q7 Linear Interpolation table
5662:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5663:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5664:.\Include/arm_math.h ****    * @return y processed output sample.
5665:.\Include/arm_math.h ****    *
5666:.\Include/arm_math.h ****    * \par
5667:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5668:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5669:.\Include/arm_math.h ****    */
5670:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t arm_linear_interp_q7(
5671:.\Include/arm_math.h ****   q7_t * pYData,
5672:.\Include/arm_math.h ****   q31_t x,
5673:.\Include/arm_math.h ****   uint32_t nValues)
5674:.\Include/arm_math.h ****   {
5675:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5676:.\Include/arm_math.h ****     q7_t y0, y1;                                 /* Nearest output values */
5677:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5678:.\Include/arm_math.h ****     uint32_t index;                              /* Index to read nearest output values */
5679:.\Include/arm_math.h **** 
5680:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5681:.\Include/arm_math.h ****     /* 12 bits for the table index */
5682:.\Include/arm_math.h ****     /* Index value calculation */
5683:.\Include/arm_math.h ****     if (x < 0)
5684:.\Include/arm_math.h ****     {
5685:.\Include/arm_math.h ****       return (pYData[0]);
5686:.\Include/arm_math.h ****     }
5687:.\Include/arm_math.h ****     index = (x >> 20) & 0xfff;
5688:.\Include/arm_math.h **** 
5689:.\Include/arm_math.h ****     if (index >= (nValues - 1))
5690:.\Include/arm_math.h ****     {
5691:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5692:.\Include/arm_math.h ****     }
5693:.\Include/arm_math.h ****     else
5694:.\Include/arm_math.h ****     {
5695:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5696:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5697:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5698:.\Include/arm_math.h **** 
5699:.\Include/arm_math.h ****       /* Read two nearest output values from the index and are in 1.7(q7) format */
5700:.\Include/arm_math.h ****       y0 = pYData[index];
5701:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5702:.\Include/arm_math.h **** 
5703:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
5704:.\Include/arm_math.h ****       y = ((y0 * (0xFFFFF - fract)));
5705:.\Include/arm_math.h **** 
5706:.\Include/arm_math.h ****       /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
5707:.\Include/arm_math.h ****       y += (y1 * fract);
5708:.\Include/arm_math.h **** 
5709:.\Include/arm_math.h ****       /* convert y to 1.7(q7) format */
5710:.\Include/arm_math.h ****       return (q7_t) (y >> 20);
5711:.\Include/arm_math.h ****      }
5712:.\Include/arm_math.h ****   }
5713:.\Include/arm_math.h **** 
5714:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 105


5715:.\Include/arm_math.h ****    * @} end of LinearInterpolate group
5716:.\Include/arm_math.h ****    */
5717:.\Include/arm_math.h **** 
5718:.\Include/arm_math.h ****   /**
5719:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for floating-point data.
5720:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5721:.\Include/arm_math.h ****    * @return  sin(x).
5722:.\Include/arm_math.h ****    */
5723:.\Include/arm_math.h ****   float32_t arm_sin_f32(
5724:.\Include/arm_math.h ****   float32_t x);
5725:.\Include/arm_math.h **** 
5726:.\Include/arm_math.h **** 
5727:.\Include/arm_math.h ****   /**
5728:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q31 data.
5729:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5730:.\Include/arm_math.h ****    * @return  sin(x).
5731:.\Include/arm_math.h ****    */
5732:.\Include/arm_math.h ****   q31_t arm_sin_q31(
5733:.\Include/arm_math.h ****   q31_t x);
5734:.\Include/arm_math.h **** 
5735:.\Include/arm_math.h **** 
5736:.\Include/arm_math.h ****   /**
5737:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q15 data.
5738:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5739:.\Include/arm_math.h ****    * @return  sin(x).
5740:.\Include/arm_math.h ****    */
5741:.\Include/arm_math.h ****   q15_t arm_sin_q15(
5742:.\Include/arm_math.h ****   q15_t x);
5743:.\Include/arm_math.h **** 
5744:.\Include/arm_math.h **** 
5745:.\Include/arm_math.h ****   /**
5746:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
5747:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5748:.\Include/arm_math.h ****    * @return  cos(x).
5749:.\Include/arm_math.h ****    */
5750:.\Include/arm_math.h ****   float32_t arm_cos_f32(
5751:.\Include/arm_math.h ****   float32_t x);
5752:.\Include/arm_math.h **** 
5753:.\Include/arm_math.h **** 
5754:.\Include/arm_math.h ****   /**
5755:.\Include/arm_math.h ****    * @brief Fast approximation to the trigonometric cosine function for Q31 data.
5756:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5757:.\Include/arm_math.h ****    * @return  cos(x).
5758:.\Include/arm_math.h ****    */
5759:.\Include/arm_math.h ****   q31_t arm_cos_q31(
5760:.\Include/arm_math.h ****   q31_t x);
5761:.\Include/arm_math.h **** 
5762:.\Include/arm_math.h **** 
5763:.\Include/arm_math.h ****   /**
5764:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
5765:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5766:.\Include/arm_math.h ****    * @return  cos(x).
5767:.\Include/arm_math.h ****    */
5768:.\Include/arm_math.h ****   q15_t arm_cos_q15(
5769:.\Include/arm_math.h ****   q15_t x);
5770:.\Include/arm_math.h **** 
5771:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 106


5772:.\Include/arm_math.h ****   /**
5773:.\Include/arm_math.h ****    * @ingroup groupFastMath
5774:.\Include/arm_math.h ****    */
5775:.\Include/arm_math.h **** 
5776:.\Include/arm_math.h **** 
5777:.\Include/arm_math.h ****   /**
5778:.\Include/arm_math.h ****    * @defgroup SQRT Square Root
5779:.\Include/arm_math.h ****    *
5780:.\Include/arm_math.h ****    * Computes the square root of a number.
5781:.\Include/arm_math.h ****    * There are separate functions for Q15, Q31, and floating-point data types.
5782:.\Include/arm_math.h ****    * The square root function is computed using the Newton-Raphson algorithm.
5783:.\Include/arm_math.h ****    * This is an iterative algorithm of the form:
5784:.\Include/arm_math.h ****    * <pre>
5785:.\Include/arm_math.h ****    *      x1 = x0 - f(x0)/f'(x0)
5786:.\Include/arm_math.h ****    * </pre>
5787:.\Include/arm_math.h ****    * where <code>x1</code> is the current estimate,
5788:.\Include/arm_math.h ****    * <code>x0</code> is the previous estimate, and
5789:.\Include/arm_math.h ****    * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
5790:.\Include/arm_math.h ****    * For the square root function, the algorithm reduces to:
5791:.\Include/arm_math.h ****    * <pre>
5792:.\Include/arm_math.h ****    *     x0 = in/2                         [initial guess]
5793:.\Include/arm_math.h ****    *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
5794:.\Include/arm_math.h ****    * </pre>
5795:.\Include/arm_math.h ****    */
5796:.\Include/arm_math.h **** 
5797:.\Include/arm_math.h **** 
5798:.\Include/arm_math.h ****   /**
5799:.\Include/arm_math.h ****    * @addtogroup SQRT
5800:.\Include/arm_math.h ****    * @{
5801:.\Include/arm_math.h ****    */
5802:.\Include/arm_math.h **** 
5803:.\Include/arm_math.h ****   /**
5804:.\Include/arm_math.h ****    * @brief  Floating-point square root function.
5805:.\Include/arm_math.h ****    * @param[in]  in    input value.
5806:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5807:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5808:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5809:.\Include/arm_math.h ****    */
5810:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
5811:.\Include/arm_math.h ****   float32_t in,
5812:.\Include/arm_math.h ****   float32_t * pOut)
5813:.\Include/arm_math.h ****   {
5814:.\Include/arm_math.h ****     if (in >= 0.0f)
  92              		.loc 2 5814 0
  93 005a B869     		ldr	r0, [r7, #24]
  94 005c 0021     		mov	r1, #0
  95 005e FFF7FEFF 		bl	__aeabi_fcmpge
  96 0062 031E     		sub	r3, r0, #0
  97 0064 07D0     		beq	.L8
5815:.\Include/arm_math.h ****     {
5816:.\Include/arm_math.h **** 
5817:.\Include/arm_math.h **** #if   (__FPU_USED == 1) && defined ( __CC_ARM   )
5818:.\Include/arm_math.h ****       *pOut = __sqrtf(in);
5819:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
5820:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5821:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined(__GNUC__)
5822:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 107


5823:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
5824:.\Include/arm_math.h ****       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
5825:.\Include/arm_math.h **** #else
5826:.\Include/arm_math.h ****       *pOut = sqrtf(in);
  98              		.loc 2 5826 0
  99 0066 BB69     		ldr	r3, [r7, #24]
 100 0068 181C     		add	r0, r3, #0
 101 006a FFF7FEFF 		bl	sqrtf
 102 006e 021C     		add	r2, r0, #0
 103 0070 7B69     		ldr	r3, [r7, #20]
 104 0072 1A60     		str	r2, [r3]
 105 0074 02E0     		b	.L6
 106              	.L8:
5827:.\Include/arm_math.h **** #endif
5828:.\Include/arm_math.h **** 
5829:.\Include/arm_math.h ****       return (ARM_MATH_SUCCESS);
5830:.\Include/arm_math.h ****     }
5831:.\Include/arm_math.h ****     else
5832:.\Include/arm_math.h ****     {
5833:.\Include/arm_math.h ****       *pOut = 0.0f;
 107              		.loc 2 5833 0
 108 0076 7B69     		ldr	r3, [r7, #20]
 109 0078 0022     		mov	r2, #0
 110 007a 1A60     		str	r2, [r3]
 111              	.L6:
 112              	.LBE5:
 113              	.LBE4:
 123:Source\StatisticsFunctions/arm_rms_f32.c **** }
 114              		.loc 1 123 0
 115 007c BD46     		mov	sp, r7
 116 007e 0AB0     		add	sp, sp, #40
 117              		@ sp needed
 118 0080 80BD     		pop	{r7, pc}
 119              		.cfi_endproc
 120              	.LFE82:
 121              		.size	arm_rms_f32, .-arm_rms_f32
 122 0082 C046     		.text
 123              	.Letext0:
 124              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 125              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 126              		.section	.debug_info,"",%progbits
 127              	.Ldebug_info0:
 128 0000 A1010000 		.4byte	0x1a1
 129 0004 0400     		.2byte	0x4
 130 0006 00000000 		.4byte	.Ldebug_abbrev0
 131 000a 04       		.byte	0x4
 132 000b 01       		.uleb128 0x1
 133 000c 47010000 		.4byte	.LASF30
 134 0010 01       		.byte	0x1
 135 0011 76020000 		.4byte	.LASF31
 136 0015 29000000 		.4byte	.LASF32
 137 0019 00000000 		.4byte	.Ldebug_ranges0+0
 138 001d 00000000 		.4byte	0
 139 0021 00000000 		.4byte	.Ldebug_line0
 140 0025 02       		.uleb128 0x2
 141 0026 01       		.byte	0x1
 142 0027 06       		.byte	0x6
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 108


 143 0028 5A020000 		.4byte	.LASF0
 144 002c 02       		.uleb128 0x2
 145 002d 01       		.byte	0x1
 146 002e 08       		.byte	0x8
 147 002f 97000000 		.4byte	.LASF1
 148 0033 02       		.uleb128 0x2
 149 0034 02       		.byte	0x2
 150 0035 05       		.byte	0x5
 151 0036 32020000 		.4byte	.LASF2
 152 003a 02       		.uleb128 0x2
 153 003b 02       		.byte	0x2
 154 003c 07       		.byte	0x7
 155 003d BE000000 		.4byte	.LASF3
 156 0041 02       		.uleb128 0x2
 157 0042 04       		.byte	0x4
 158 0043 05       		.byte	0x5
 159 0044 45020000 		.4byte	.LASF4
 160 0048 03       		.uleb128 0x3
 161 0049 00010000 		.4byte	.LASF9
 162 004d 03       		.byte	0x3
 163 004e 41       		.byte	0x41
 164 004f 53000000 		.4byte	0x53
 165 0053 02       		.uleb128 0x2
 166 0054 04       		.byte	0x4
 167 0055 07       		.byte	0x7
 168 0056 AC000000 		.4byte	.LASF5
 169 005a 02       		.uleb128 0x2
 170 005b 08       		.byte	0x8
 171 005c 05       		.byte	0x5
 172 005d F4010000 		.4byte	.LASF6
 173 0061 02       		.uleb128 0x2
 174 0062 08       		.byte	0x8
 175 0063 07       		.byte	0x7
 176 0064 30010000 		.4byte	.LASF7
 177 0068 04       		.uleb128 0x4
 178 0069 04       		.byte	0x4
 179 006a 05       		.byte	0x5
 180 006b 696E7400 		.ascii	"int\000"
 181 006f 02       		.uleb128 0x2
 182 0070 04       		.byte	0x4
 183 0071 07       		.byte	0x7
 184 0072 23010000 		.4byte	.LASF8
 185 0076 03       		.uleb128 0x3
 186 0077 3C020000 		.4byte	.LASF10
 187 007b 04       		.byte	0x4
 188 007c 2D       		.byte	0x2d
 189 007d 48000000 		.4byte	0x48
 190 0081 02       		.uleb128 0x2
 191 0082 04       		.byte	0x4
 192 0083 07       		.byte	0x7
 193 0084 EB010000 		.4byte	.LASF11
 194 0088 02       		.uleb128 0x2
 195 0089 01       		.byte	0x1
 196 008a 08       		.byte	0x8
 197 008b 0C020000 		.4byte	.LASF12
 198 008f 02       		.uleb128 0x2
 199 0090 08       		.byte	0x8
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 109


 200 0091 04       		.byte	0x4
 201 0092 EF000000 		.4byte	.LASF13
 202 0096 02       		.uleb128 0x2
 203 0097 04       		.byte	0x4
 204 0098 04       		.byte	0x4
 205 0099 16000000 		.4byte	.LASF14
 206 009d 02       		.uleb128 0x2
 207 009e 08       		.byte	0x8
 208 009f 04       		.byte	0x4
 209 00a0 4E020000 		.4byte	.LASF15
 210 00a4 05       		.uleb128 0x5
 211 00a5 01       		.byte	0x1
 212 00a6 02       		.byte	0x2
 213 00a7 8401     		.2byte	0x184
 214 00a9 D8000000 		.4byte	0xd8
 215 00ad 06       		.uleb128 0x6
 216 00ae 21020000 		.4byte	.LASF16
 217 00b2 00       		.sleb128 0
 218 00b3 06       		.uleb128 0x6
 219 00b4 0B010000 		.4byte	.LASF17
 220 00b8 7F       		.sleb128 -1
 221 00b9 06       		.uleb128 0x6
 222 00ba 00000000 		.4byte	.LASF18
 223 00be 7E       		.sleb128 -2
 224 00bf 06       		.uleb128 0x6
 225 00c0 7B000000 		.4byte	.LASF19
 226 00c4 7D       		.sleb128 -3
 227 00c5 06       		.uleb128 0x6
 228 00c6 11020000 		.4byte	.LASF20
 229 00ca 7C       		.sleb128 -4
 230 00cb 06       		.uleb128 0x6
 231 00cc D9010000 		.4byte	.LASF21
 232 00d0 7B       		.sleb128 -5
 233 00d1 06       		.uleb128 0x6
 234 00d2 D1000000 		.4byte	.LASF22
 235 00d6 7A       		.sleb128 -6
 236 00d7 00       		.byte	0
 237 00d8 07       		.uleb128 0x7
 238 00d9 6B020000 		.4byte	.LASF23
 239 00dd 02       		.byte	0x2
 240 00de 8C01     		.2byte	0x18c
 241 00e0 A4000000 		.4byte	0xa4
 242 00e4 07       		.uleb128 0x7
 243 00e5 F6000000 		.4byte	.LASF24
 244 00e9 02       		.byte	0x2
 245 00ea A501     		.2byte	0x1a5
 246 00ec 96000000 		.4byte	0x96
 247 00f0 08       		.uleb128 0x8
 248 00f1 04       		.byte	0x4
 249 00f2 E4000000 		.4byte	0xe4
 250 00f6 09       		.uleb128 0x9
 251 00f7 1C000000 		.4byte	.LASF33
 252 00fb 02       		.byte	0x2
 253 00fc B216     		.2byte	0x16b2
 254 00fe D8000000 		.4byte	0xd8
 255 0102 03       		.byte	0x3
 256 0103 1F010000 		.4byte	0x11f
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 110


 257 0107 0A       		.uleb128 0xa
 258 0108 696E00   		.ascii	"in\000"
 259 010b 02       		.byte	0x2
 260 010c B316     		.2byte	0x16b3
 261 010e E4000000 		.4byte	0xe4
 262 0112 0B       		.uleb128 0xb
 263 0113 92000000 		.4byte	.LASF25
 264 0117 02       		.byte	0x2
 265 0118 B416     		.2byte	0x16b4
 266 011a F0000000 		.4byte	0xf0
 267 011e 00       		.byte	0
 268 011f 0C       		.uleb128 0xc
 269 0120 6F000000 		.4byte	.LASF34
 270 0124 01       		.byte	0x1
 271 0125 40       		.byte	0x40
 272 0126 00000000 		.4byte	.LFB82
 273 012a 82000000 		.4byte	.LFE82-.LFB82
 274 012e 01       		.uleb128 0x1
 275 012f 9C       		.byte	0x9c
 276 0130 0D       		.uleb128 0xd
 277 0131 66020000 		.4byte	.LASF26
 278 0135 01       		.byte	0x1
 279 0136 41       		.byte	0x41
 280 0137 F0000000 		.4byte	0xf0
 281 013b 02       		.uleb128 0x2
 282 013c 91       		.byte	0x91
 283 013d 5C       		.sleb128 -36
 284 013e 0D       		.uleb128 0xd
 285 013f 02020000 		.4byte	.LASF27
 286 0143 01       		.byte	0x1
 287 0144 42       		.byte	0x42
 288 0145 76000000 		.4byte	0x76
 289 0149 02       		.uleb128 0x2
 290 014a 91       		.byte	0x91
 291 014b 58       		.sleb128 -40
 292 014c 0D       		.uleb128 0xd
 293 014d E7000000 		.4byte	.LASF28
 294 0151 01       		.byte	0x1
 295 0152 43       		.byte	0x43
 296 0153 F0000000 		.4byte	0xf0
 297 0157 02       		.uleb128 0x2
 298 0158 91       		.byte	0x91
 299 0159 54       		.sleb128 -44
 300 015a 0E       		.uleb128 0xe
 301 015b 73756D00 		.ascii	"sum\000"
 302 015f 01       		.byte	0x1
 303 0160 45       		.byte	0x45
 304 0161 E4000000 		.4byte	0xe4
 305 0165 02       		.uleb128 0x2
 306 0166 91       		.byte	0x91
 307 0167 74       		.sleb128 -12
 308 0168 0E       		.uleb128 0xe
 309 0169 696E00   		.ascii	"in\000"
 310 016c 01       		.byte	0x1
 311 016d 46       		.byte	0x46
 312 016e E4000000 		.4byte	0xe4
 313 0172 02       		.uleb128 0x2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 111


 314 0173 91       		.byte	0x91
 315 0174 6C       		.sleb128 -20
 316 0175 0F       		.uleb128 0xf
 317 0176 A5000000 		.4byte	.LASF29
 318 017a 01       		.byte	0x1
 319 017b 47       		.byte	0x47
 320 017c 76000000 		.4byte	0x76
 321 0180 02       		.uleb128 0x2
 322 0181 91       		.byte	0x91
 323 0182 70       		.sleb128 -16
 324 0183 10       		.uleb128 0x10
 325 0184 F6000000 		.4byte	0xf6
 326 0188 5A000000 		.4byte	.LBB4
 327 018c 22000000 		.4byte	.LBE4-.LBB4
 328 0190 01       		.byte	0x1
 329 0191 7A       		.byte	0x7a
 330 0192 11       		.uleb128 0x11
 331 0193 12010000 		.4byte	0x112
 332 0197 02       		.uleb128 0x2
 333 0198 91       		.byte	0x91
 334 0199 64       		.sleb128 -28
 335 019a 11       		.uleb128 0x11
 336 019b 07010000 		.4byte	0x107
 337 019f 02       		.uleb128 0x2
 338 01a0 91       		.byte	0x91
 339 01a1 68       		.sleb128 -24
 340 01a2 00       		.byte	0
 341 01a3 00       		.byte	0
 342 01a4 00       		.byte	0
 343              		.section	.debug_abbrev,"",%progbits
 344              	.Ldebug_abbrev0:
 345 0000 01       		.uleb128 0x1
 346 0001 11       		.uleb128 0x11
 347 0002 01       		.byte	0x1
 348 0003 25       		.uleb128 0x25
 349 0004 0E       		.uleb128 0xe
 350 0005 13       		.uleb128 0x13
 351 0006 0B       		.uleb128 0xb
 352 0007 03       		.uleb128 0x3
 353 0008 0E       		.uleb128 0xe
 354 0009 1B       		.uleb128 0x1b
 355 000a 0E       		.uleb128 0xe
 356 000b 55       		.uleb128 0x55
 357 000c 17       		.uleb128 0x17
 358 000d 11       		.uleb128 0x11
 359 000e 01       		.uleb128 0x1
 360 000f 10       		.uleb128 0x10
 361 0010 17       		.uleb128 0x17
 362 0011 00       		.byte	0
 363 0012 00       		.byte	0
 364 0013 02       		.uleb128 0x2
 365 0014 24       		.uleb128 0x24
 366 0015 00       		.byte	0
 367 0016 0B       		.uleb128 0xb
 368 0017 0B       		.uleb128 0xb
 369 0018 3E       		.uleb128 0x3e
 370 0019 0B       		.uleb128 0xb
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 112


 371 001a 03       		.uleb128 0x3
 372 001b 0E       		.uleb128 0xe
 373 001c 00       		.byte	0
 374 001d 00       		.byte	0
 375 001e 03       		.uleb128 0x3
 376 001f 16       		.uleb128 0x16
 377 0020 00       		.byte	0
 378 0021 03       		.uleb128 0x3
 379 0022 0E       		.uleb128 0xe
 380 0023 3A       		.uleb128 0x3a
 381 0024 0B       		.uleb128 0xb
 382 0025 3B       		.uleb128 0x3b
 383 0026 0B       		.uleb128 0xb
 384 0027 49       		.uleb128 0x49
 385 0028 13       		.uleb128 0x13
 386 0029 00       		.byte	0
 387 002a 00       		.byte	0
 388 002b 04       		.uleb128 0x4
 389 002c 24       		.uleb128 0x24
 390 002d 00       		.byte	0
 391 002e 0B       		.uleb128 0xb
 392 002f 0B       		.uleb128 0xb
 393 0030 3E       		.uleb128 0x3e
 394 0031 0B       		.uleb128 0xb
 395 0032 03       		.uleb128 0x3
 396 0033 08       		.uleb128 0x8
 397 0034 00       		.byte	0
 398 0035 00       		.byte	0
 399 0036 05       		.uleb128 0x5
 400 0037 04       		.uleb128 0x4
 401 0038 01       		.byte	0x1
 402 0039 0B       		.uleb128 0xb
 403 003a 0B       		.uleb128 0xb
 404 003b 3A       		.uleb128 0x3a
 405 003c 0B       		.uleb128 0xb
 406 003d 3B       		.uleb128 0x3b
 407 003e 05       		.uleb128 0x5
 408 003f 01       		.uleb128 0x1
 409 0040 13       		.uleb128 0x13
 410 0041 00       		.byte	0
 411 0042 00       		.byte	0
 412 0043 06       		.uleb128 0x6
 413 0044 28       		.uleb128 0x28
 414 0045 00       		.byte	0
 415 0046 03       		.uleb128 0x3
 416 0047 0E       		.uleb128 0xe
 417 0048 1C       		.uleb128 0x1c
 418 0049 0D       		.uleb128 0xd
 419 004a 00       		.byte	0
 420 004b 00       		.byte	0
 421 004c 07       		.uleb128 0x7
 422 004d 16       		.uleb128 0x16
 423 004e 00       		.byte	0
 424 004f 03       		.uleb128 0x3
 425 0050 0E       		.uleb128 0xe
 426 0051 3A       		.uleb128 0x3a
 427 0052 0B       		.uleb128 0xb
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 113


 428 0053 3B       		.uleb128 0x3b
 429 0054 05       		.uleb128 0x5
 430 0055 49       		.uleb128 0x49
 431 0056 13       		.uleb128 0x13
 432 0057 00       		.byte	0
 433 0058 00       		.byte	0
 434 0059 08       		.uleb128 0x8
 435 005a 0F       		.uleb128 0xf
 436 005b 00       		.byte	0
 437 005c 0B       		.uleb128 0xb
 438 005d 0B       		.uleb128 0xb
 439 005e 49       		.uleb128 0x49
 440 005f 13       		.uleb128 0x13
 441 0060 00       		.byte	0
 442 0061 00       		.byte	0
 443 0062 09       		.uleb128 0x9
 444 0063 2E       		.uleb128 0x2e
 445 0064 01       		.byte	0x1
 446 0065 03       		.uleb128 0x3
 447 0066 0E       		.uleb128 0xe
 448 0067 3A       		.uleb128 0x3a
 449 0068 0B       		.uleb128 0xb
 450 0069 3B       		.uleb128 0x3b
 451 006a 05       		.uleb128 0x5
 452 006b 27       		.uleb128 0x27
 453 006c 19       		.uleb128 0x19
 454 006d 49       		.uleb128 0x49
 455 006e 13       		.uleb128 0x13
 456 006f 20       		.uleb128 0x20
 457 0070 0B       		.uleb128 0xb
 458 0071 01       		.uleb128 0x1
 459 0072 13       		.uleb128 0x13
 460 0073 00       		.byte	0
 461 0074 00       		.byte	0
 462 0075 0A       		.uleb128 0xa
 463 0076 05       		.uleb128 0x5
 464 0077 00       		.byte	0
 465 0078 03       		.uleb128 0x3
 466 0079 08       		.uleb128 0x8
 467 007a 3A       		.uleb128 0x3a
 468 007b 0B       		.uleb128 0xb
 469 007c 3B       		.uleb128 0x3b
 470 007d 05       		.uleb128 0x5
 471 007e 49       		.uleb128 0x49
 472 007f 13       		.uleb128 0x13
 473 0080 00       		.byte	0
 474 0081 00       		.byte	0
 475 0082 0B       		.uleb128 0xb
 476 0083 05       		.uleb128 0x5
 477 0084 00       		.byte	0
 478 0085 03       		.uleb128 0x3
 479 0086 0E       		.uleb128 0xe
 480 0087 3A       		.uleb128 0x3a
 481 0088 0B       		.uleb128 0xb
 482 0089 3B       		.uleb128 0x3b
 483 008a 05       		.uleb128 0x5
 484 008b 49       		.uleb128 0x49
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 114


 485 008c 13       		.uleb128 0x13
 486 008d 00       		.byte	0
 487 008e 00       		.byte	0
 488 008f 0C       		.uleb128 0xc
 489 0090 2E       		.uleb128 0x2e
 490 0091 01       		.byte	0x1
 491 0092 3F       		.uleb128 0x3f
 492 0093 19       		.uleb128 0x19
 493 0094 03       		.uleb128 0x3
 494 0095 0E       		.uleb128 0xe
 495 0096 3A       		.uleb128 0x3a
 496 0097 0B       		.uleb128 0xb
 497 0098 3B       		.uleb128 0x3b
 498 0099 0B       		.uleb128 0xb
 499 009a 27       		.uleb128 0x27
 500 009b 19       		.uleb128 0x19
 501 009c 11       		.uleb128 0x11
 502 009d 01       		.uleb128 0x1
 503 009e 12       		.uleb128 0x12
 504 009f 06       		.uleb128 0x6
 505 00a0 40       		.uleb128 0x40
 506 00a1 18       		.uleb128 0x18
 507 00a2 9642     		.uleb128 0x2116
 508 00a4 19       		.uleb128 0x19
 509 00a5 00       		.byte	0
 510 00a6 00       		.byte	0
 511 00a7 0D       		.uleb128 0xd
 512 00a8 05       		.uleb128 0x5
 513 00a9 00       		.byte	0
 514 00aa 03       		.uleb128 0x3
 515 00ab 0E       		.uleb128 0xe
 516 00ac 3A       		.uleb128 0x3a
 517 00ad 0B       		.uleb128 0xb
 518 00ae 3B       		.uleb128 0x3b
 519 00af 0B       		.uleb128 0xb
 520 00b0 49       		.uleb128 0x49
 521 00b1 13       		.uleb128 0x13
 522 00b2 02       		.uleb128 0x2
 523 00b3 18       		.uleb128 0x18
 524 00b4 00       		.byte	0
 525 00b5 00       		.byte	0
 526 00b6 0E       		.uleb128 0xe
 527 00b7 34       		.uleb128 0x34
 528 00b8 00       		.byte	0
 529 00b9 03       		.uleb128 0x3
 530 00ba 08       		.uleb128 0x8
 531 00bb 3A       		.uleb128 0x3a
 532 00bc 0B       		.uleb128 0xb
 533 00bd 3B       		.uleb128 0x3b
 534 00be 0B       		.uleb128 0xb
 535 00bf 49       		.uleb128 0x49
 536 00c0 13       		.uleb128 0x13
 537 00c1 02       		.uleb128 0x2
 538 00c2 18       		.uleb128 0x18
 539 00c3 00       		.byte	0
 540 00c4 00       		.byte	0
 541 00c5 0F       		.uleb128 0xf
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 115


 542 00c6 34       		.uleb128 0x34
 543 00c7 00       		.byte	0
 544 00c8 03       		.uleb128 0x3
 545 00c9 0E       		.uleb128 0xe
 546 00ca 3A       		.uleb128 0x3a
 547 00cb 0B       		.uleb128 0xb
 548 00cc 3B       		.uleb128 0x3b
 549 00cd 0B       		.uleb128 0xb
 550 00ce 49       		.uleb128 0x49
 551 00cf 13       		.uleb128 0x13
 552 00d0 02       		.uleb128 0x2
 553 00d1 18       		.uleb128 0x18
 554 00d2 00       		.byte	0
 555 00d3 00       		.byte	0
 556 00d4 10       		.uleb128 0x10
 557 00d5 1D       		.uleb128 0x1d
 558 00d6 01       		.byte	0x1
 559 00d7 31       		.uleb128 0x31
 560 00d8 13       		.uleb128 0x13
 561 00d9 11       		.uleb128 0x11
 562 00da 01       		.uleb128 0x1
 563 00db 12       		.uleb128 0x12
 564 00dc 06       		.uleb128 0x6
 565 00dd 58       		.uleb128 0x58
 566 00de 0B       		.uleb128 0xb
 567 00df 59       		.uleb128 0x59
 568 00e0 0B       		.uleb128 0xb
 569 00e1 00       		.byte	0
 570 00e2 00       		.byte	0
 571 00e3 11       		.uleb128 0x11
 572 00e4 05       		.uleb128 0x5
 573 00e5 00       		.byte	0
 574 00e6 31       		.uleb128 0x31
 575 00e7 13       		.uleb128 0x13
 576 00e8 02       		.uleb128 0x2
 577 00e9 18       		.uleb128 0x18
 578 00ea 00       		.byte	0
 579 00eb 00       		.byte	0
 580 00ec 00       		.byte	0
 581              		.section	.debug_aranges,"",%progbits
 582 0000 1C000000 		.4byte	0x1c
 583 0004 0200     		.2byte	0x2
 584 0006 00000000 		.4byte	.Ldebug_info0
 585 000a 04       		.byte	0x4
 586 000b 00       		.byte	0
 587 000c 0000     		.2byte	0
 588 000e 0000     		.2byte	0
 589 0010 00000000 		.4byte	.LFB82
 590 0014 82000000 		.4byte	.LFE82-.LFB82
 591 0018 00000000 		.4byte	0
 592 001c 00000000 		.4byte	0
 593              		.section	.debug_ranges,"",%progbits
 594              	.Ldebug_ranges0:
 595 0000 00000000 		.4byte	.LFB82
 596 0004 82000000 		.4byte	.LFE82
 597 0008 00000000 		.4byte	0
 598 000c 00000000 		.4byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 116


 599              		.section	.debug_line,"",%progbits
 600              	.Ldebug_line0:
 601 0000 83010000 		.section	.debug_str,"MS",%progbits,1
 601      02004F01 
 601      00000201 
 601      FB0E0D00 
 601      01010101 
 602              	.LASF18:
 603 0000 41524D5F 		.ascii	"ARM_MATH_LENGTH_ERROR\000"
 603      4D415448 
 603      5F4C454E 
 603      4754485F 
 603      4552524F 
 604              	.LASF14:
 605 0016 666C6F61 		.ascii	"float\000"
 605      7400
 606              	.LASF33:
 607 001c 61726D5F 		.ascii	"arm_sqrt_f32\000"
 607      73717274 
 607      5F663332 
 607      00
 608              	.LASF32:
 609 0029 433A5C55 		.ascii	"C:\\Users\\fneves\\Documents\\PSoC Creator\\wp_1\\e"
 609      73657273 
 609      5C666E65 
 609      7665735C 
 609      446F6375 
 610 0056 6E67696E 		.ascii	"ngine_speed_sensor.cydsn\000"
 610      655F7370 
 610      6565645F 
 610      73656E73 
 610      6F722E63 
 611              	.LASF34:
 612 006f 61726D5F 		.ascii	"arm_rms_f32\000"
 612      726D735F 
 612      66333200 
 613              	.LASF19:
 614 007b 41524D5F 		.ascii	"ARM_MATH_SIZE_MISMATCH\000"
 614      4D415448 
 614      5F53495A 
 614      455F4D49 
 614      534D4154 
 615              	.LASF25:
 616 0092 704F7574 		.ascii	"pOut\000"
 616      00
 617              	.LASF1:
 618 0097 756E7369 		.ascii	"unsigned char\000"
 618      676E6564 
 618      20636861 
 618      7200
 619              	.LASF29:
 620 00a5 626C6B43 		.ascii	"blkCnt\000"
 620      6E7400
 621              	.LASF5:
 622 00ac 6C6F6E67 		.ascii	"long unsigned int\000"
 622      20756E73 
 622      69676E65 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 117


 622      6420696E 
 622      7400
 623              	.LASF3:
 624 00be 73686F72 		.ascii	"short unsigned int\000"
 624      7420756E 
 624      7369676E 
 624      65642069 
 624      6E7400
 625              	.LASF22:
 626 00d1 41524D5F 		.ascii	"ARM_MATH_TEST_FAILURE\000"
 626      4D415448 
 626      5F544553 
 626      545F4641 
 626      494C5552 
 627              	.LASF28:
 628 00e7 70526573 		.ascii	"pResult\000"
 628      756C7400 
 629              	.LASF13:
 630 00ef 646F7562 		.ascii	"double\000"
 630      6C6500
 631              	.LASF24:
 632 00f6 666C6F61 		.ascii	"float32_t\000"
 632      7433325F 
 632      7400
 633              	.LASF9:
 634 0100 5F5F7569 		.ascii	"__uint32_t\000"
 634      6E743332 
 634      5F7400
 635              	.LASF17:
 636 010b 41524D5F 		.ascii	"ARM_MATH_ARGUMENT_ERROR\000"
 636      4D415448 
 636      5F415247 
 636      554D454E 
 636      545F4552 
 637              	.LASF8:
 638 0123 756E7369 		.ascii	"unsigned int\000"
 638      676E6564 
 638      20696E74 
 638      00
 639              	.LASF7:
 640 0130 6C6F6E67 		.ascii	"long long unsigned int\000"
 640      206C6F6E 
 640      6720756E 
 640      7369676E 
 640      65642069 
 641              	.LASF30:
 642 0147 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 642      4320342E 
 642      392E3320 
 642      32303135 
 642      30333033 
 643 017a 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0plus -mthumb -"
 643      20726576 
 643      6973696F 
 643      6E203232 
 643      31323230 
 644 01ad 67202D4F 		.ascii	"g -O0 -ffunction-sections -ffat-lto-objects\000"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 118


 644      30202D66 
 644      66756E63 
 644      74696F6E 
 644      2D736563 
 645              	.LASF21:
 646 01d9 41524D5F 		.ascii	"ARM_MATH_SINGULAR\000"
 646      4D415448 
 646      5F53494E 
 646      47554C41 
 646      5200
 647              	.LASF11:
 648 01eb 73697A65 		.ascii	"sizetype\000"
 648      74797065 
 648      00
 649              	.LASF6:
 650 01f4 6C6F6E67 		.ascii	"long long int\000"
 650      206C6F6E 
 650      6720696E 
 650      7400
 651              	.LASF27:
 652 0202 626C6F63 		.ascii	"blockSize\000"
 652      6B53697A 
 652      6500
 653              	.LASF12:
 654 020c 63686172 		.ascii	"char\000"
 654      00
 655              	.LASF20:
 656 0211 41524D5F 		.ascii	"ARM_MATH_NANINF\000"
 656      4D415448 
 656      5F4E414E 
 656      494E4600 
 657              	.LASF16:
 658 0221 41524D5F 		.ascii	"ARM_MATH_SUCCESS\000"
 658      4D415448 
 658      5F535543 
 658      43455353 
 658      00
 659              	.LASF2:
 660 0232 73686F72 		.ascii	"short int\000"
 660      7420696E 
 660      7400
 661              	.LASF10:
 662 023c 75696E74 		.ascii	"uint32_t\000"
 662      33325F74 
 662      00
 663              	.LASF4:
 664 0245 6C6F6E67 		.ascii	"long int\000"
 664      20696E74 
 664      00
 665              	.LASF15:
 666 024e 6C6F6E67 		.ascii	"long double\000"
 666      20646F75 
 666      626C6500 
 667              	.LASF0:
 668 025a 7369676E 		.ascii	"signed char\000"
 668      65642063 
 668      68617200 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccH0qCMz.s 			page 119


 669              	.LASF26:
 670 0266 70537263 		.ascii	"pSrc\000"
 670      00
 671              	.LASF23:
 672 026b 61726D5F 		.ascii	"arm_status\000"
 672      73746174 
 672      757300
 673              	.LASF31:
 674 0276 536F7572 		.ascii	"Source\\StatisticsFunctions\\arm_rms_f32.c\000"
 674      63655C53 
 674      74617469 
 674      73746963 
 674      7346756E 
 675              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
