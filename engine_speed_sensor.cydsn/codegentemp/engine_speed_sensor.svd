<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
  <name>CY8C4A45LQI_483</name>
  <version>0.1</version>
  <description>PSoC Analog Coprocessor</description>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC Registers</description>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller control register</description>
          <addressOffset>0x101000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Global DMAC enable</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>DMA controller is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>DMA controller is enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS</name>
          <description>DMA controller status register</description>
          <addressOffset>0x101010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Specifies the index of the currently active data transfer. This value increases from '0' to the DATA_NR field specified of the currently active descriptor control word.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_ADDR</name>
              <description>Specifies the channel number of the currently active channel. For example, if channel 7 is active, DMAC_STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'.</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the data transfer engine.</description>
              <lsb>24</lsb>
              <msb>26</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>Idle state when the DMA is not active.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_DESCR</name>
                  <description>The DMA is loading the descriptor to the DMA transfer engine.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_SRC</name>
                  <description>The DMA is getting the value from the source location.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DST</name>
                  <description>The DMA is storing the value at the destination location.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DESCR</name>
                  <description>The DMA is updating the descriptors after completion of transfer.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_TRIG_DEACT</name>
                  <description>The DMA is waiting for the level sensitive trigger to deactivate.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_ERROR</name>
                  <description>There was an error during the transaction and the DMA is writing the error code to the channel status register.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Specifies the priority of the currently active channel.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Specifies whether the PING descriptor ('0') or PONG descriptor ('1') of the channel is currently in use.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Specifies if there is a currently active (pending) channel in the data transfer engine.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>No currently active channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>Currently active channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_SRC_ADDR</name>
          <description>Source address currently being used by the DMA controller</description>
          <addressOffset>0x101014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The source address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_DST_ADDR</name>
          <description>Destination address currently being used by the DMA controller</description>
          <addressOffset>0x101018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The destination address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_CH_ACT</name>
          <description>Channel activation status</description>
          <addressOffset>0x10101C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Channel activation status. Bit i is associated to channel i. Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL0</name>
          <description>DMA channel 0 control register</description>
          <addressOffset>0x101080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL1</name>
          <description>DMA channel 1 control register</description>
          <addressOffset>0x101084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL2</name>
          <description>DMA channel 2 control register</description>
          <addressOffset>0x101088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL3</name>
          <description>DMA channel 3 control register</description>
          <addressOffset>0x10108C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL4</name>
          <description>DMA channel 4 control register</description>
          <addressOffset>0x101090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL5</name>
          <description>DMA channel 5 control register</description>
          <addressOffset>0x101094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL6</name>
          <description>DMA channel 6 control register</description>
          <addressOffset>0x101098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL7</name>
          <description>DMA channel 7 control register</description>
          <addressOffset>0x10109C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x1017F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x1017F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x1017F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x1017FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Bitwise AND between the interrupt reguest (INTR) and mask (INTR_MASK) registers.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 0</description>
          <addressOffset>0x101800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 0</description>
          <addressOffset>0x101804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_CTL</name>
          <description>Descriptor 0 control register for channel 0</description>
          <addressOffset>0x101808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 0</description>
          <addressOffset>0x10180C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 0</description>
          <addressOffset>0x101810</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 0</description>
          <addressOffset>0x101814</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 0</description>
          <addressOffset>0x101818</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 0</description>
          <addressOffset>0x10181C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 1</description>
          <addressOffset>0x101820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 1</description>
          <addressOffset>0x101824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_CTL</name>
          <description>Descriptor 0 control register for channel 1</description>
          <addressOffset>0x101828</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 1</description>
          <addressOffset>0x10182C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 1</description>
          <addressOffset>0x101830</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 1</description>
          <addressOffset>0x101834</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 1</description>
          <addressOffset>0x101838</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 1</description>
          <addressOffset>0x10183C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 2</description>
          <addressOffset>0x101840</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 2</description>
          <addressOffset>0x101844</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_CTL</name>
          <description>Descriptor 0 control register for channel 2</description>
          <addressOffset>0x101848</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 2</description>
          <addressOffset>0x10184C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 2</description>
          <addressOffset>0x101850</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 2</description>
          <addressOffset>0x101854</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 2</description>
          <addressOffset>0x101858</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 2</description>
          <addressOffset>0x10185C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 3</description>
          <addressOffset>0x101860</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 3</description>
          <addressOffset>0x101864</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_CTL</name>
          <description>Descriptor 0 control register for channel 3</description>
          <addressOffset>0x101868</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 3</description>
          <addressOffset>0x10186C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 3</description>
          <addressOffset>0x101870</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 3</description>
          <addressOffset>0x101874</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 3</description>
          <addressOffset>0x101878</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 3</description>
          <addressOffset>0x10187C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 4</description>
          <addressOffset>0x101880</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 4</description>
          <addressOffset>0x101884</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_CTL</name>
          <description>Descriptor 0 control register for channel 4</description>
          <addressOffset>0x101888</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 4</description>
          <addressOffset>0x10188C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 4</description>
          <addressOffset>0x101890</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 4</description>
          <addressOffset>0x101894</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 4</description>
          <addressOffset>0x101898</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 4</description>
          <addressOffset>0x10189C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 5</description>
          <addressOffset>0x1018A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 5</description>
          <addressOffset>0x1018A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_CTL</name>
          <description>Descriptor 0 control register for channel 5</description>
          <addressOffset>0x1018A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 5</description>
          <addressOffset>0x1018AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 5</description>
          <addressOffset>0x1018B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 5</description>
          <addressOffset>0x1018B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 5</description>
          <addressOffset>0x1018B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 5</description>
          <addressOffset>0x1018BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 6</description>
          <addressOffset>0x1018C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 6</description>
          <addressOffset>0x1018C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_CTL</name>
          <description>Descriptor 0 control register for channel 6</description>
          <addressOffset>0x1018C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 6</description>
          <addressOffset>0x1018CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 6</description>
          <addressOffset>0x1018D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 6</description>
          <addressOffset>0x1018D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 6</description>
          <addressOffset>0x1018D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 6</description>
          <addressOffset>0x1018DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 7</description>
          <addressOffset>0x1018E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 7</description>
          <addressOffset>0x1018E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_CTL</name>
          <description>Descriptor 0 control register for channel 7</description>
          <addressOffset>0x1018E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 7</description>
          <addressOffset>0x1018EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 7</description>
          <addressOffset>0x1018F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 7</description>
          <addressOffset>0x1018F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 7</description>
          <addressOffset>0x1018F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 7</description>
          <addressOffset>0x1018FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>engine_sensor_adc</name>
      <description>No description available</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>engine_sensor_adc_CTRL</name>
          <description>Analog control register.</description>
          <addressOffset>0x403A0000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VREF_SEL</name>
              <description>SARADC internal VREF selection.</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VREF0</name>
                  <description>VREF0 from PRB (VREF buffer on)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF1</name>
                  <description>VREF1 from PRB (VREF buffer on)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF2</name>
                  <description>VREF2 from PRB (VREF buffer on)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_AROUTE</name>
                  <description>VREF from AROUTE (VREF buffer on)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBGR</name>
                  <description>1.024V from BandGap (VREF buffer on)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_EXT</name>
                  <description>External precision Vref direct from a pin (low impedance path).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_DIV_2</name>
                  <description>Vdda/2  (VREF buffer on)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA</name>
                  <description>Vdda.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_BYP_CAP_EN</name>
              <description>VREF bypass cap enable for when VREF buffer is on</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_SEL</name>
              <description>SARADC internal NEG selection for Single ended conversion</description>
              <lsb>9</lsb>
              <msb>11</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_KELVIN</name>
                  <description>NEG input of SARADC is connected to "vssa_kelvin", gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ART_VSSA</name>
                  <description>NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P1</name>
                  <description>NEG input of SARADC is connected to P1 pin of SARMUX</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P3</name>
                  <description>NEG input of SARADC is connected to P3 pin of SARMUX</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P5</name>
                  <description>NEG input of SARADC is connected to P5 pin of SARMUX</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P7</name>
                  <description>NEG input of SARADC is connected to P7 pin of SARMUX</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACORE</name>
                  <description>NEG input of SARADC is connected to an ACORE in AROUTE</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF</name>
                  <description>NEG input of SARADC is shorted with VREF input of SARADC.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR_HW_CTRL_NEGVREF</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch.</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_CTRL_VREF</name>
              <description>VREF buffer low power mode.</description>
              <lsb>14</lsb>
              <msb>15</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), bypass cap, max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>deprecated</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD_PWR</name>
                  <description>Invalid for PSoC4A, otherwise 2X power, no bypass cap, max clk_sar is 1.8MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>deprecated</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare controls, not yet designated, for late changes done with an ECO</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOSTPUMP_EN</name>
              <description>SARADC internal pump: 0=disabled: pump output is VDDA, 1=enabled: pump output is boosted.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REFBUF_EN</name>
              <description>1 - Enable the SARREFBUF. This bit needs to be set when SAR is enabled and needs reference buffer.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ICONT_LV</name>
              <description>SARADC low power mode.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>1/2 power mode, max clk_sar is 9MHz.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MORE_PWR</name>
                  <description>1.333 power mode, max clk_sar is 18MHz.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>1/4 power mode, max clk_sar is 4.5MHz.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: SARMUX IP disabled off during DeepSleep power mode?- 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_CONFIG</name>
              <description>- 0: bypass clock domain synchronisation of the DSI config signals.?- 1: synchronize the DSI config signals to peripheral clock domain.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_MODE</name>
              <description>SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1)?- 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations?- 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_DISABLE</name>
              <description>Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)?- 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations?- 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgaiting) on write.?- 1: SAR IP enabled.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_SAMPLE_CTRL</name>
          <description>Sample control register.</description>
          <addressOffset>0x403A0004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SUB_RESOLUTION</name>
              <description>Conversion resolution for channels that have sub-resolution enabled (RESOLUTION=1) (otherwise resolution is 12-bit).</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Cy8B</name>
                  <description>8-bit.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Cy10B</name>
                  <description>10-bit.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEFT_ALIGN</name>
              <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLE_ENDED_SIGNED</name>
              <description>Output data from a single ended conversion as a signed value</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Default: result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_SIGNED</name>
              <description>Output data from a differential conversion as a signed value when DIFFERENTIAL_EN or NEG_ADDR_EN is set to 1</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Default: result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_CNT</name>
              <description>Averaging Count for channels that have averaging enabled (AVG_EN). A channel will be sampled (1&lt;&lt;(AVG_CNT+1)) = [2..256] times.?- In ACCUNDUMP mode  (1st order accumulate and dump filter) a channel will be sampled back to back, the average result is calculated and stored and then the next enabled channel is sampled. If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).?- In INTERLEAVED mode one sample is taken per triggered scan, only in the scan where the final averaging count is reached a valid average is calculated and stored in the RESULT register (by definition the same scan for all the channels that have averaging enabled). In all other scans the RESULT register for averaged channels will have an invalid result and the intermediate accumulated value is stored in the 16-bit WORK register. In this mode make sure that the averaging count is low enough to ensure that the intermediate value does not exceed 16-bits otherwise the MSBs will be lost. So for a 12-bit resolution the averaging count should be set to 16 or less (AVG_CNT=&lt;3).</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SHIFT</name>
              <description>Averaging shifting: after averaging the result is shifted right to fit in the sample resolution. For averaging the sample resolution is the highest resolution allowed by wounding.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_MODE</name>
              <description>Averaging mode,  in DSI mode this bit is ignored and only AccuNDump mode is available.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACCUNDUMP</name>
                  <description>Accumulate and Dump (1st order accumulate and dump filter): a channel will be sampled back to back and averaged</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INTERLEAVED</name>
                  <description>Interleaved: Each scan (trigger) one sample is taken per channel and averaged over several scans.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>- 0: Wait for next FW_TRIGGER (one shot) or hardware (DSI) trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.?- 1: Continuously scan enabled channels, ignore triggers.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_EN</name>
              <description>- 0: firmware trigger only: disable hardware (DSI) trigger.?- 1: enable hardware (DSI) trigger (e.g. from TCPWM, GPIO or UDB).</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_LEVEL</name>
              <description>- 0: DSI trigger signal is a pulse input, a positive edge detected on the DSI trigger signal triggers a new scan.?- 1: DSI trigger signal is a level input, as long as the DSI trigger signal remains high the SAR will do continuous scans.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_TRIGGER</name>
              <description>- 0: bypass clock domain synchronisation of the DSI trigger signal.?- 1: synchronize the DSI trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UAB_SCAN_MODE</name>
              <description>Select whether UABs are scheduled or unscheduled. When no UAB is scanned this selection is ignored.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSCHEDULED</name>
                  <description>Unscheduled UABs: one or more of the UABs scanned by the SAR is not scheduled, for each channel that scans a UAB the SAR will wait for a positive edge on the trigger output of that UAB. Caveat: in this mode the length of SAR scan can be variable.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCHEDULED</name>
                  <description>Scheduled UABs: All UABs scanned by the SAR are assumed to be properly scheduled, i.e. their output is assumed to be valid when sampled by the SAR and the SAR does not wait. In this mode the length of the SAR scan is constant. ?This mode requires that the SAR scans strictly periodically, i.e. the SAR has to either run continuously or has to be triggered by a periodic hardware trigger (TCPWM or UDB timer). It also requires that the end of the UAB valid phase is precisely aligned with the end of the SAR sample period (using UAB.STARTUP_DELAY). Normally this scheduling is done by Creator.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REPEAT_INVALID</name>
              <description>For unscheduled UAB_SCAN_MODE only, do the following if an invalid sample is received:?- 0: use the last known valid sample for that channel and clear the NEWVALUE flag?- 1: repeat the conversions until a valid sample is received (caveat: could be never if the UAB valid window is incorrectly schedule w.r.t. SAR sampling)</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_SEL</name>
              <description>Static UAB Valid select?0=UAB0 half 0 Valid output?1=UAB0 half 1 Valid output?2=UAB1 half 0 Valid output?3=UAB1 half 1 Valid output?4=UAB2 half 0 Valid output?5=UAB2 half 1 Valid output?6=UAB3 half 0 Valid output?7=UAB3 half 1 Valid output</description>
              <lsb>24</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_SEL_EN</name>
              <description>Enable static UAB Valid selection (override Hardware)</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_IGNORE</name>
              <description>Ignore UAB valid signal, including the dynamic/Hardware from AROUTE and the static Valid selection from the VALID_SEL fields above</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER_OUT_EN</name>
              <description>SAR output trigger enable (used for UAB synchronization). To ensure multiple UABs starting at the same trigger it is recommended to use this bit to temporarily disable the trigger output until all those UABs are set to run (UAB.SRAM_CTRL.RUN=1).</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_DSI_OUT_EN</name>
              <description>Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a pulse is send on the dsi_eos signal.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_SAMPLE_TIME01</name>
          <description>Sample time specification ST0 and ST1</description>
          <addressOffset>0x403A0010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME0</name>
              <description>Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is half a clock less than specified here. The minimum sample time is 194ns, which is 3.5 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2.</description>
              <lsb>0</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME1</name>
              <description>Sample time1</description>
              <lsb>16</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_SAMPLE_TIME23</name>
          <description>Sample time specification ST2 and ST3</description>
          <addressOffset>0x403A0014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME2</name>
              <description>Sample time2</description>
              <lsb>0</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME3</name>
              <description>Sample time3</description>
              <lsb>16</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_RANGE_THRES</name>
          <description>Global range detect threshold register.</description>
          <addressOffset>0x403A0018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_LOW</name>
              <description>Low threshold for range detect.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE_HIGH</name>
              <description>High threshold for range detect.</description>
              <lsb>16</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_RANGE_COND</name>
          <description>Global range detect mode register.</description>
          <addressOffset>0x403A001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_COND</name>
              <description>Range condition select.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BELOW</name>
                  <description>result &lt; RANGE_LOW</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INSIDE</name>
                  <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ABOVE</name>
                  <description>RANGE_HIGH &lt;= result</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUTSIDE</name>
                  <description>result &lt; RANGE_LOW || RANGE_HIGH &lt;= result</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_EN</name>
          <description>Enable bits for the channels</description>
          <addressOffset>0x403A0020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_EN</name>
              <description>Channel enable. ?- 0: the corresponding channel is disabled.?- 1: the corresponding channel is enabled, it will be included in the next scan.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_START_CTRL</name>
          <description>Start control register (firmware trigger).</description>
          <addressOffset>0x403A0024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_DFT_CTRL</name>
          <description>DFT control register.</description>
          <addressOffset>0x403A0030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DLY_INC</name>
              <description>DFT control: Control for delay circuits on sampling phase, =1 doubes the non-overlap delay</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>HIZ</name>
              <description>DFT control for getting higher input impedance, must be 1 (0 is deprecated)</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_INC</name>
              <description>DFT control for preamp inputs</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OUTC</name>
              <description>DFT control for preamp outputs</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CSEL_DFT</name>
              <description>Usage 1: DFT bits for DAC array?Usage 2: For [0]=1 (when dcen=0): Delay timing for latch enable increased by 20%?[1]=1: comparator preamp power level increased by 25%</description>
              <lsb>24</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CSEL_DFT</name>
              <description>Mux select signal for DAC control</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DCEN</name>
              <description>Delay Control Enable for latch.?- 0: doubles the latch enable time.?- 1: normal latch enable time.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ADFT_OVERRIDE</name>
              <description>During deepsleep/ hibernate mode keep SARMUX active, i.e. do not open all switches (disconnect), to be used for ADFT</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG0</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A0080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG1</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A0084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG2</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A0088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG3</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG4</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A0090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG5</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A0094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG6</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A0098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG7</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG8</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG9</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG10</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG11</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG12</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG13</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG14</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_CONFIG15</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x403A00BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <description>Unused fields</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.?- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.?- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK0</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK1</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK2</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK3</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A010C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK4</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK5</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK6</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK7</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A011C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK8</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK9</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK10</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK11</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A012C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK12</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK13</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK14</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A0138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK15</name>
          <description>Channel working data register</description>
          <addressOffset>0x403A013C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT0</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A0180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT1</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A0184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT2</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A0188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT3</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A018C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT4</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A0190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_HAN_RESULT5</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A0194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT6</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A0198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT7</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A019C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT8</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT9</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT10</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT11</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT12</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT13</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT14</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT15</name>
          <description>Channel result data register</description>
          <addressOffset>0x403A01BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK_UPDATED</name>
          <description>Channel working data register 'updated' bits</description>
          <addressOffset>0x403A0200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_UPDATED</name>
              <description>If set the corresponding WORK register was updated, i.e. was already sampled during the current scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT_UPDATED</name>
          <description>Channel result data register 'updated' bits</description>
          <addressOffset>0x403A0204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_UPDATED</name>
              <description>If set the corresponding RESULT register was updated, i.e. was sampled during the previous scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_WORK_NEWVALUE</name>
          <description>Channel working data register 'new value' bits</description>
          <addressOffset>0x403A0208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_NEWVALUE</name>
              <description>If set the corresponding WORK data received a new value, i.e. was already sampled during the current scan and data was valid.?In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.?In case of averaging this New Value bit is an OR of all the valid bits received by each conversion.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_CHAN_RESULT_NEWVALUE</name>
          <description>Channel result data register 'new value' bits</description>
          <addressOffset>0x403A020C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_NEWVALUE</name>
              <description>If set the corresponding RESULT data received a new value, i.e. was sampled during the last scan and data was valid.?In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.?In case of averaging this New Value bit is an OR of all the valid bits received by each conversion.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_INTR</name>
          <description>Interrupt request register.</description>
          <addressOffset>0x403A0210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x403A0214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_INTR_MASK</name>
          <description>Interrupt mask register.</description>
          <addressOffset>0x403A0218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x403A021C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_SATURATE_INTR</name>
          <description>Saturate interrupt request register.</description>
          <addressOffset>0x403A0220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_SATURATE_INTR_SET</name>
          <description>Saturate interrupt set request register</description>
          <addressOffset>0x403A0224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_SATURATE_INTR_MASK</name>
          <description>Saturate interrupt mask register.</description>
          <addressOffset>0x403A0228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_SATURATE_INTR_MASKED</name>
          <description>Saturate interrupt masked request register</description>
          <addressOffset>0x403A022C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_RANGE_INTR</name>
          <description>Range detect interrupt request register.</description>
          <addressOffset>0x403A0230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_RANGE_INTR_SET</name>
          <description>Range detect interrupt set request register</description>
          <addressOffset>0x403A0234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_RANGE_INTR_MASK</name>
          <description>Range detect interrupt mask register.</description>
          <addressOffset>0x403A0238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_RANGE_INTR_MASKED</name>
          <description>Range interrupt masked request register</description>
          <addressOffset>0x403A023C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x403A0240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_MASKED_RED</name>
              <description>Reduction OR of all SAR_SATURATION_INTR_MASKED bits</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_MASKED_RED</name>
              <description>Reduction OR of all SAR_RANGE_INTR_MASKED bits</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_INJ_CHAN_CONFIG</name>
          <description>Injection channel configuration register.</description>
          <addressOffset>0x403A0280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>INJ_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this injection channel. If differential is enabled then INJ_PIN_ADDR[0] is ignored and considered to be 0, i.e. INJ_PIN_ADDR points to the even pin of a pin pair.</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel.</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT</name>
                  <description>AROUTE virtual port</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.?- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.?- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (INJ_PIN_ADDR[0] is ignored).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RESOLUTION</name>
              <description>Resolution for this channel.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Cy12B</name>
                  <description>12-bit resolution is used for this channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SAMPLE_TIME_SEL</name>
              <description>Injection sample time select: select which of the 4 global sample times to use for this channel</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_TAILGATING</name>
              <description>Injection channel tailgating.?- 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set.?- 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_START_EN</name>
              <description>Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_INJ_RESULT</name>
          <description>Injection channel result register</description>
          <addressOffset>0x403A0290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>INJ_RESULT</name>
              <description>SAR conversion result of the channel.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_NEWVALUE</name>
              <description>The data in this register received a new value (only relevant for UAB, this bit shows the value of the UAB valid bit)</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x403A02A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CUR_CHAN</name>
              <description>current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY.</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_VREF_NEG</name>
              <description>the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL).</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x403A02A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CUR_AVG_ACCU</name>
              <description>the current value of the averaging accumulator</description>
              <lsb>0</lsb>
              <msb>19</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRLV_BUSY</name>
              <description>If high then the SAR is in the middle of Interleaved averaging spanning several scans. While this bit is high the Firmware should not make any changes to the configuration registers otherwise some results may be incorrect. Note that the CUR_AVG_CNT status register below gives an indication how many more scans need to be done to complete the Interleaved averaging.?This bit can be cleared by changing the averaging mode to ACCUNDUMP or by disabling the SAR.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_AVG_CNT</name>
              <description>the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update.</description>
              <lsb>24</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_MUX_SWITCH0</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x403A0300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, also powers on the temperature sensor. Write with '1' to set bit.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit.</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit.</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_MUX_SWITCH_CLEAR0</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x403A0304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_MUX_SWITCH1</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x403A0308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Firmware control: 0=open, 1=close switch between P4 pin and dft_inp signal. Write with '1' to set bit.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Firmware control: 0=open, 1=close switch between P5 pin and dft_inm signal. Write with '1' to set bit.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Firmware control: 0=open, 1=close switch between adft0 signal and sarbus0 signal. Write with '1' to set bit.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Firmware control: 0=open, 1=close switch between adft1 signal and sarbus1 signal. Write with '1' to set bit.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_MUX_SWITCH_CLEAR1</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x403A030C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_MUX_SWITCH_HW_CTRL</name>
          <description>SARMUX switch hardware control</description>
          <addressOffset>0x403A0340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MUX_HW_CTRL_P0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P0 switches.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P1 switches.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P2</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P2 switches.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P3</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P3 switches.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P4</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P4 switches.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P5</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P5 switches.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P6</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P6 switches.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P7</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P7 switches.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_VSSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for vssa switch.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_TEMP</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for temp switch.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusa switches.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSB</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusb switches.</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus0 switches.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus1 switches.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_MUX_SWITCH_STATUS</name>
          <description>SARMUX switch status</description>
          <addressOffset>0x403A0348</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_PUMP_CTRL</name>
          <description>Switch pump control</description>
          <addressOffset>0x403A0380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select: 0=external clock, 1=internal clock (deprecated).</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>0=disabled: pump output is VDDA_PUMP, 1=enabled: pump output is boosted.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_ANA_TRIM</name>
          <description>Analog trim register.</description>
          <addressOffset>0x403A0F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CAP_TRIM</name>
              <description>Attenuation cap trimming</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIMUNIT</name>
              <description>Attenuation cap trimming</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>engine_sensor_adc_WOUNDING</name>
          <description>SAR wounding register</description>
          <addressOffset>0x403A0F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WOUND_RESOLUTION</name>
              <description>Maximum SAR resolution allowed</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Cy12BIT</name>
                  <description>unwounded: up to full 12-bit SAR resolution allowed</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Cy10BIT</name>
                  <description>wounded: max resolution upto 10-bit SAR resolution allowed</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Cy8BIT</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Cy8BIT_TOO</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>engine_sensor_adc_UABH_B</name>
      <description>No description available</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>UAB_UAB_CTRL</name>
          <description>Global UAB control</description>
          <addressOffset>0x40340000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>- 0: UAB IP disabled (put analog in power down, open all switches)?- 1: UAB IP enabled</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x40340020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC0_EMPTY</name>
              <description>VDAC 0 Interrupt: hardware sets this interrupt when VDAC 0 next value field is empty. Write with '1' to clear bit.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RES</name>
              <description>Decimator 0 Result Interrupt: hardware sets this interrupt when Decimator 0 writes a new result value in DC0_RES register. Write with '1' to clear bit.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC1_EMPTY</name>
              <description>VDAC 1 Interrupt: hardware sets this interrupt when VDAC 1 next value field is empty. Write with '1' to clear bit.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RES</name>
              <description>Decimator 1 Result Interrupt: hardware sets this interrupt when Decimator 1 writes a new result value in DC1_RES register. Write with '1' to clear bit.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR_SET</name>
          <description>Interrupt request set register</description>
          <addressOffset>0x40340024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC0_EMPTY_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RES_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC1_EMPTY_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RES_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR_MASK</name>
          <description>Interrupt request mask</description>
          <addressOffset>0x40340028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC0_EMPTY_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RES_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC1_EMPTY_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RES_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR_MASKED</name>
          <description>Interrupt request masked</description>
          <addressOffset>0x4034002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>VDAC0_EMPTY_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DC0_RES_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>VDAC1_EMPTY_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DC1_RES_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA0_CTRL</name>
          <description>Opamp, comparator, buffer  controls</description>
          <addressOffset>0x40340200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA0_PWR</name>
              <description>Opamp0 power level</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_PWR</name>
              <description>Comparator0 power level</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_EDGE</name>
              <description>Comparator0 edge detect for interrupt and trigger</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP0_DSI_LEVEL</name>
              <description>Comparator0 trigger out level : 0=pulse, 1=level</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL0_SPARE</name>
              <description>Spare bit</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF0_PWR</name>
              <description>Reference0 buffer power level</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF0_PTS</name>
              <description>1- Pull the Reference0 buffer output to VDDA</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND0_PWR</name>
              <description>Agnd0 buffer power level</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND0_PTS</name>
              <description>1 - Pull Agnd0 buffer output to VDDA</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_GG</name>
              <description>Connect outputs of Agnd0 and Agnd1 buffer, one buffer must be off.?This is to drive both UAB halves with the same buffer, so both halves get the same offset noise.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE0_EN</name>
              <description>1 - Enable spare reference</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>H0_PWR</name>
              <description>UAB Half, power profile</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, for normal analog clock speeds</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_LOW</name>
                  <description>Ultra low power, only allowed for lower analog clock speeds</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_HIGH</name>
                  <description>Ultra high performance, for higher analog clock speeds (also ultra high power)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Reserved</name>
                  <description>Reserved, do not use</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CTRL0</name>
          <description>Capacitance controls</description>
          <addressOffset>0x40340204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB0_GND</name>
              <description>Ground unused caps of CB0 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used, e.g. for VDAC use-case)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_GND</name>
              <description>Ground unused caps of CC0 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used)</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRC0_SIGN_BIT</name>
              <description>Forces the sign bit to be 1 in DAC mode.  This is used to achieve ?0 - AGND0 range for unsigned numbers using DAC mode 2</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC0_MODE_EN</name>
              <description>0: SIGN0_VAL can be programmed to be a modbit source?1: SIGN0_VAL is a dedicated sign bit (FW modbit source tied to 0)</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC0_MODE</name>
              <description>DAC mode, this determines the AB Cap Value decoding</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED12</name>
                  <description>Off or Unsigned 12-bit VDAC, i.e. no AB Cap value decoding.?SIGN1_VAL can be used as Firmware controlled modbit (e.g. to invert the Voltage for a Sign + Magnitude VDAC)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIRT_SIGNED12</name>
                  <description>Virtual signed 12-bits' VDAC. AB Cap value decoding: ?add 0x800 to the 12-bit AB Cap Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED13</name>
                  <description>Signed 13-bit twos complement. AB Cap value decoding: ?for negative values (SIGN0_VAL=1) the AB Cap values are inverted, the 64th B cap unit is enabled and the Voltage should be inverted.?- Voltage inversion only works if the right clocking waveforms, switch settings and reference voltages are used.?- Enabling the 64th B cap unit adds 1 so that only a AB Cap value inversion is needed to create a true twos complement.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_ABCF0_VAL</name>
          <description>Capacitance values for CA0, CB0, CC0 and CF0</description>
          <addressOffset>0x40340208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB0_VAL</name>
              <description>Cap B0 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA0_VAL</name>
              <description>Cap A0 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN0_VAL</name>
              <description>Sign bit Value, when used in DAC_MODE, otherwise Firmware modbit.?In DAC_MODE the modbit should be used to invert the voltage on the AB Caps for the negative DAC values.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB0_64</name>
              <description>Enable 64th Cap of CB0 array.  In DAC mode the FW setting is overridden by the hardware based on DAC_MODE setting.?1 - Enables the 64th cap.  This will also set CB0_val[5:0] to be 6'h3F</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_VAL</name>
              <description>Cap C0 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_VAL</name>
              <description>Cap F0 Value [2..64 is the range in steps of 2]</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_AB0_VAL_NXT</name>
          <description>Next capacitance values for CA0 and CB0</description>
          <addressOffset>0x4034020C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB0_VAL</name>
              <description>Cap B0 Value</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA0_VAL</name>
              <description>Cap A0 Value</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN0_VAL</name>
              <description>Sign bit Value</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CF0_VAL_NXT</name>
          <description>Next capacitance values for CC0 and CF0</description>
          <addressOffset>0x40340210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CC0_VAL</name>
              <description>Cap C0 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_VAL</name>
              <description>Cap F0 Value</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_VAL_UPDATE</name>
              <description>1 - Update the CC0 cap value with CAP_CC0_VAL_NXT.CC0_VAL</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_VAL_UPDATE</name>
              <description>1 - Update the CF0 cap value with CAP_CF0_VAL_NXT.CF0_VAL</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STARTUP_DELAY0</name>
          <description>Startup delay</description>
          <addressOffset>0x40340220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>STARTUP_DELAY</name>
              <description>Startup delay to synchronize the UAB-SAR interface. The usage and meaning of this field depends on the value of the ALIGN_MODE bit (below).   A value of 0 disables this function.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIGN_MODE</name>
              <description>0 - STARTUP_DELAY is number of clk_hf clocks to delay the UAB clock after a SAR Trigger for UAB-SAR alignment in scheduled mode?1 - STARTUP_DELAY is number of clk_hf clocks to delay UAB trigger to SAR for UAB-SAR alignment in unscheduled mode</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SUBSAMPLE_CTRL0</name>
          <description>Subsample control</description>
          <addressOffset>0x40340224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SUBSAMPLE</name>
              <description>Subsampling: suppress Valid output during the first SUBSAMPLE analog clock periods. Only allow Valid output in the last of the SUBSAMPLE+1 analog clock periods.?A value of 0 will not suppress Valid output.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBSAMPLE_INIT</name>
              <description>Initial value of the subsampling down counter. Before this UAB half is running the firmware can write to this field the initial value of the subsample down counter. It is recommend that the following is true for the initial value  SUBSAMPLE_INIT&lt;=SUBSAMPLE, however this is not a requirement. Writing a bigger value can be used to postpone the very first Valid output.</description>
              <lsb>8</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_STATIC0</name>
          <description>Static switches for half 0 of the UAB</description>
          <addressOffset>0x40340230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G00</name>
              <description>VIN00 to OA0.vplus (AG0)</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G01</name>
              <description>VIN01 to OA0.vplus (AG0)</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G02</name>
              <description>VIN02 to OA0.vplus (AG0)</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G03</name>
              <description>VIN03 to OA0.vplus (AG0)</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R0G</name>
              <description>REF0 to OA0.vplus (AG0)</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0G</name>
              <description>AGND0 to OA0.vplus (AG0)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R0T</name>
              <description>REF0 to cmp0.vminus (Threshold)</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0T</name>
              <description>AGND0 to cmp0.vminus (Threshold)</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q0T</name>
              <description>OUT1 to cmp0.vminus (Threshold)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_P0S</name>
              <description>OUT0 to Sum0 switch timing: 0=Regular, 1=Early</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_P0O</name>
              <description>OUT0 to VOUT0 switch timing: 0=Regular, 1=Early</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RMB0_BITS</name>
              <description>Risk mitigation bits (To be defined if they are used)</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST0_SEL</name>
              <description>Select source either for VDAC strobe or analog-reset to discharge all Caps (Delsig Modulator use-case)?0 = Decimator0 half 0 analog-reset output?1 = Decimator0 half 1 analog-reset output?2 = Decimator1 half 0 analog-reset output?3 = Decimator1 half 1 analog-reset output?4 = Decimator2 half 0 analog-reset output?5 = Decimator2 half 1 analog-reset output?6 = Decimator3 half 0 analog-reset output?7 = Decimator3 half 1 analog-reset output?8-31 = generic trigger input 0-23?For PASS4B  only values 0-1 and 8-13 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST0_EN</name>
              <description>Enable VDAC strobe or UAB analog-reset:?0: Use selected source as VDAC strobe for next CA0 and CB0 values?1: Use selected source as Analog-reset (discharge all Caps)</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_MODBIT_SRC0</name>
          <description>Select source of Modbit for A,B and C branches of half 0</description>
          <addressOffset>0x40340234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODBIT0_SRC0_SEL</name>
              <description>Select source of modbit for A &amp; B branches?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN0_VAL, also used as Firmware modbit. ?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MODBIT1_SRC0_SEL</name>
              <description>Select source of modbit for C branch?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN0_VAL, also used as Firmware modbit. ?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA0_IN0</name>
          <description>Cap A0 input switches set 0</description>
          <addressOffset>0x40340240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_A00_CMP</name>
              <description>VIN00 to Cap A0 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A01_CMP</name>
              <description>VIN01 to Cap A0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A02_CMP</name>
              <description>VIN02 to Cap A0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A03_CMP</name>
              <description>VIN03 to Cap A0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0P</name>
              <description>OUT0 to Cap A0 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0Q</name>
              <description>OUT1 to Cap A0 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA0_IN1</name>
          <description>Cap A0 input switches set 1</description>
          <addressOffset>0x40340244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_AA</name>
              <description>Cap A0 input to Cap A1 input?(Note: In the UAB design this is the called AM switch)</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0R_CMP</name>
              <description>REF0 to Cap A0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0G_CMP</name>
              <description>AGND0 to Cap A0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0V_CMP</name>
              <description>VSS to Cap A0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA0_TOP</name>
          <description>Cap A0 top plate switches</description>
          <addressOffset>0x40340248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R0A_CMP</name>
              <description>Cap A0 top plate to REF0, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0A_CMP</name>
              <description>Cap A0 top plate to AGND0, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V0A_CMP</name>
              <description>Cap A0 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S0A</name>
              <description>Cap A0 top plate to SUM0</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB0_IN0</name>
          <description>Cap B0 input switches set 0</description>
          <addressOffset>0x40340250</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_B00_CMP</name>
              <description>VIN00 to Cap B0 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B01_CMP</name>
              <description>VIN01 to Cap B0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B02_CMP</name>
              <description>VIN02 to Cap B0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B03_CMP</name>
              <description>VIN03 to Cap B0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0P</name>
              <description>OUT0 to Cap B0 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0Q</name>
              <description>OUT1 to Cap B0 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB0_IN1</name>
          <description>Cap B0 input switches set 1</description>
          <addressOffset>0x40340254</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_BB</name>
              <description>Cap B0 input to Cap B1 input?(Note: In the UAB design this is called the BM switch)</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0R_CMP</name>
              <description>REF0 to Cap B0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0G_CMP</name>
              <description>AGND0 to Cap B0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0V_CMP</name>
              <description>VSS to Cap B0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB0_TOP</name>
          <description>Cap A0 top plate switches</description>
          <addressOffset>0x40340258</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R0B_CMP</name>
              <description>Cap B0 top plate to REF0, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0B_CMP</name>
              <description>Cap B0 top plate to AGND0, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V0B_CMP</name>
              <description>Cap B0 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T0B</name>
              <description>Cap B0 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S0B</name>
              <description>Cap B0 top plate to SUM0</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC0_IN0</name>
          <description>Cap C0 input switches set 0</description>
          <addressOffset>0x40340260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_C00_CMP</name>
              <description>VIN00 to Cap C0 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C01_CMP</name>
              <description>VIN01 to Cap C0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C02_CMP</name>
              <description>VIN02 to Cap C0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C03_CMP</name>
              <description>VIN03 to Cap C0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0P</name>
              <description>OUT0 to Cap C0 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0Q</name>
              <description>OUT1 to Cap C0 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC0_IN1</name>
          <description>Cap C0 input switches set 1</description>
          <addressOffset>0x40340264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_CC</name>
              <description>Cap C0 input to Cap C1 input?(Note: In the UAB design this is called the CM switch)</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0R_CMP</name>
              <description>REF0 to Cap C0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0G_CMP</name>
              <description>AGND0 to Cap C0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0V_CMP</name>
              <description>VSS to Cap C0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC0_TOP</name>
          <description>Cap A0 top plate switches</description>
          <addressOffset>0x40340268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R0C_CMP</name>
              <description>Cap C0 top plate to REF0, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0C_CMP</name>
              <description>Cap C0 top plate to AGND0, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V0C_CMP</name>
              <description>Cap C0 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T0C</name>
              <description>Cap C0 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S0C</name>
              <description>Cap C0 top plate to SUM0</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S10</name>
              <description>Cap C0 top plate to SUM1</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CF0_BOT</name>
          <description>Cap F0 bottom plate and output switches</description>
          <addressOffset>0x4034026C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G0F</name>
              <description>Cap F0 bottom plate to AGND0</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P0F</name>
              <description>Cap F0 bottom plate to OUT0</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P0S</name>
              <description>Cap F bypass, OUT0 to SUM0</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P0O</name>
              <description>OUT0 to VOUT0</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_OTHER0</name>
          <description>Other clocked controls</description>
          <addressOffset>0x40340270</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CMP0_FF</name>
              <description>Clock for Flip-Flop after Comparator 0</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID0</name>
              <description>Valid0, output flag to indicated that VOUT0 is valid. The Valid output can be suppressed due to sub-sampling. Note that when sub-sampling is used this clocking waveform is used to decrement the counter (decrement is aligned with the positive edge of this clocking waveform).</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG0_OUT</name>
              <description>Trigger output (for other UABs or SAR)</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_SW0</name>
              <description>Strobe for dsi_sw_ctrl (modbit) update, dsi_sw_ctrl updates in sync with posedge of this wave. To disable set to 0. To enable update anytime use 15.</description>
              <lsb>24</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_RST0</name>
              <description>Use the positive edge of the selected clocking waveform to synchronize: ? STRB_RST0_EN=0: Capacitor Value update (Capacitor Strobe)? STRB_RST0_EN=1: UAB analog-reset update?Set to 0 to disable both functions. Result undefined for value 15.</description>
              <lsb>28</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_BOOST_CTRL0</name>
          <description>Bootstrap clock control</description>
          <addressOffset>0x40340274</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CA0_BOOST</name>
              <description>Clock for boot strap master in A branch</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB0_BOOST</name>
              <description>Clock for boot strap master in B branch</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_BOOST</name>
              <description>Clock for boot strap master in C branch</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_BOOST</name>
              <description>Clock for boot strap master in F branch</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUM0_BOOST</name>
              <description>Clock for boot strap master in Summing node branch</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP0_WAVE</name>
              <description>Clock for pump in half0</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM0_CTRL</name>
          <description>SRAM programmed size</description>
          <addressOffset>0x40340278</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>LAST_STEP</name>
              <description>Last step of wave programmed in the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SEL0</name>
              <description>input Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER_EN</name>
              <description>Enable input trigger:?0: Ignore triggers, start running immediately after setting RUN bit?1: After RUN bit is set wait for a positive edge on the selected trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>Set to start executing the waveform (may need to wait for a trigger). Clear to stop this UAB half. When RUN=0 all dynamic switches are forced open.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STAT0</name>
          <description>Status Current SRAM counter and comparator</description>
          <addressOffset>0x4034027C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CURR_STEP</name>
              <description>Current step executed from the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP</name>
              <description>Current comparator status</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_SUBSAMPLE</name>
              <description>Current value of the subsampling down counter. The Valid is suppressed when SUBSAMPLE_CUR!=0.</description>
              <lsb>24</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM00</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM01</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM02</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM03</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x4034028C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM04</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM05</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM06</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM07</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x4034029C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM08</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM09</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM010</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM011</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM012</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM013</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM014</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM015</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA1_CTRL</name>
          <description>Opamp, comparator, buffer  controls</description>
          <addressOffset>0x40340300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA1_PWR</name>
              <description>Opamp1 power level</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_PWR</name>
              <description>Comparator1 power level</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_EDGE</name>
              <description>Comparator1 edge detect for interrupt and trigger</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP1_DSI_LEVEL</name>
              <description>Comparator trigger out level : 0=pulse, 1=level</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL1_SPARE</name>
              <description>Spare bit</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF1_PWR</name>
              <description>Reference1 buffer power</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF1_PTS</name>
              <description>1- Pull the Reference1 buffer output to VDDA</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND1_PWR</name>
              <description>Agnd1 buffer power</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND1_PTS</name>
              <description>1- Pull the Agnd1 buffer output to VDDA</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RR</name>
              <description>Connect outputs of Reference0 and Reference1 buffer, one buffer must be off.?This is to drive both UAB halves with the same buffer, so both halves get the same offset noise.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE1_EN</name>
              <description>1 - Enable the spare reference</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>H1_PWR</name>
              <description>UAB Half, power profile</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, for normal analog clock speeds</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_LOW</name>
                  <description>Ultra low power, only allowed for lower analog clock speeds</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_HIGH</name>
                  <description>Ultra high performance, for higher analog clock speeds (also ultra high power)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Reserved</name>
                  <description>Reserved, do not use</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CTRL1</name>
          <description>Capacitance controls</description>
          <addressOffset>0x40340304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB1_GND</name>
              <description>Ground unused caps of CB1 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used, e.g. for VDAC use-case)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_GND</name>
              <description>Ground unused caps of CC1 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used)</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRC1_SIGN_BIT</name>
              <description>Forces the sign bit to be 1 in DAC mode.  This is used to achieve ?0 - AGND1 range for unsigned numbers using DAC mode 2</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC1_MODE_EN</name>
              <description>1: SIGN1_VAL is dedicated sign bit (FW modbit source tied to 0)                                                           0: SIGN1_VAL can be programmed to be a modbit source</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC1_MODE</name>
              <description>DAC mode, this determines the AB Cap Value decoding</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED12</name>
                  <description>Off or Unsigned 12-bit VDAC, i.e. no AB Cap value decoding.?SIGN1_VAL can be used as Firmware controlled modbit (e.g. to invert the Voltage for a Sign + Magnitude VDAC)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIRT_SIGNED12</name>
                  <description>Virtual signed 12-bits' VDAC. AB Cap value decoding: ?add 0x800 to the 12-bit AB Cap Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED13</name>
                  <description>Signed 13-bit twos complement. AB Cap value decoding: ?for negative values (SIGN1_VAL=1) the AB Cap values are inverted, the 64th B cap unit is enabled and the Voltage should be inverted.?- Voltage inversion only works if the right clocking waveforms, switch settings and reference voltages are used.?- Enabling the 64th B cap unit adds 1 so that only a AB Cap value inversion is needed to create a true twos complement.  .</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_ABCF1_VAL</name>
          <description>Capacitance values for CA1, CB1, CC1 and CF1</description>
          <addressOffset>0x40340308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB1_VAL</name>
              <description>Cap B1 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA1_VAL</name>
              <description>Cap A1 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN1_VAL</name>
              <description>Sign bit Value, when used in DAC_MODE, otherwise Firmware modbit.?In DAC_MODE the modbit should be used to invert the voltage on the AB Caps for the negative DAC values.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB1_64</name>
              <description>Enable 64th Cap of CB1 array. In DAC mode the FW setting is overridden by the hardware based on DAC_MODE setting.                                                           1 - Enables the 64th cap. This will also set CB1_val[5:0] to be 6'h3F</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_VAL</name>
              <description>Cap C1 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_VAL</name>
              <description>Cap F1 Value</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_AB1_VAL_NXT</name>
          <description>Next capacitance values for CA1 and CB1</description>
          <addressOffset>0x4034030C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB1_VAL</name>
              <description>Cap B1 Value</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA1_VAL</name>
              <description>Cap A1 Value</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN1_VAL</name>
              <description>Sign bit Value</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CF1_VAL_NXT</name>
          <description>Next capacitance values for CC1 and CF1</description>
          <addressOffset>0x40340310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CC1_VAL</name>
              <description>Cap C1 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_VAL</name>
              <description>Cap F1 Value</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_VAL_UPDATE</name>
              <description>1 - Update the CC1 cap value with CAP_CC1_VAL_NXT.CC1_VAL</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_VAL_UPDATE</name>
              <description>1 - Update the CF1 cap value with CAP_CF1_VAL_NXT.CF1_VAL</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STARTUP_DELAY1</name>
          <description>Startup delay</description>
          <addressOffset>0x40340320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>STARTUP_DELAY</name>
              <description>Startup delay to synchronize the UAB-SAR interface. The usage and meaning of this field depends on the value of the ALIGN_MODE bit (below).   A value of 0 disables this function.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIGN_MODE</name>
              <description>0 - STARTUP_DELAY is number of clk_hf clocks to delay the UAB clock after a SAR Trigger for UAB-SAR alignment in scheduled mode?1 - STARTUP_DELAY is number of clk_hf clocks to delay UAB trigger to SAR for UAB-SAR alignment in unscheduled mode</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SUBSAMPLE_CTRL1</name>
          <description>Subsample control</description>
          <addressOffset>0x40340324</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SUBSAMPLE</name>
              <description>Subsampling: suppress Valid output during the first SUBSAMPLE analog clock periods. Only allow Valid output in the last of the SUBSAMPLE+1 analog clock periods.?A value of 0 will not suppress Valid output.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBSAMPLE_INIT</name>
              <description>Initial value of the subsampling down counter. Before this UAB half is running the firmware can write to this field the initial value of the subsample down counter. It is recommend that the following is true for the initial value  SUBSAMPLE_INIT&lt;=SUBSAMPLE, however this is not a requirement. Writing a bigger value can be used to postpone the very first Valid output.</description>
              <lsb>8</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_STATIC1</name>
          <description>Static switches for half 1 of the UAB</description>
          <addressOffset>0x40340330</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G10</name>
              <description>VIN10 to OA1.vplus (AG1)</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G11</name>
              <description>VIN11 to OA1.vplus (AG1)</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G12</name>
              <description>VIN12 to OA1.vplus (AG1)</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G13</name>
              <description>VIN13 to OA1.vplus (AG1)</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R1G</name>
              <description>REF1 to OA1.vplus (AG1)</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1G</name>
              <description>AGND1 to OA1.vplus (AG1)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R1T</name>
              <description>REF1 to cmp1.vminus (Threshold)</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1T</name>
              <description>AGND1 to cmp1.vminus (Threshold)</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P1T</name>
              <description>OUT0 to cmp1.vminus (Threshold)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_Q1S</name>
              <description>OUT1 to Sum1 switch timing: 0=Regular, 1=Early</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_Q1O</name>
              <description>OUT1 to VOUT1 switch timing: 0=Regular, 1=Early</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RMB1_BITS</name>
              <description>Risk mitigation bits (To be defined if they are used)</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST1_SEL</name>
              <description>Select source either for VDAC strobe or analog-reset to discharge all Caps (Delsig Modulator use-case)?0 = Decimator0 half 0 analog-reset output?1 = Decimator0 half 1 analog-reset output?2 = Decimator1 half 0 analog-reset output?3 = Decimator1 half 1 analog-reset output?4 = Decimator2 half 0 analog-reset output?5 = Decimator2 half 1 analog-reset output?6 = Decimator3 half 0 analog-reset output?7 = Decimator3 half 1 analog-reset output?8-31 = generic trigger input 0-23?For PASS4B  only values 0-1 and 8-13 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST1_EN</name>
              <description>Enable VDAC strobe or UAB analog-reset:?0: Use selected source as VDAC strobe for next CA1 and CB1 values?1: Use selected source as Analog-reset (discharge all Caps)</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_MODBIT_SRC1</name>
          <description>Select source of Modbit for A,B and C branches of half 1</description>
          <addressOffset>0x40340334</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODBIT0_SRC1_SEL</name>
              <description>Select source of modbit for A &amp; B branches?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN1_VAL, also used as Firmware modbit.?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MODBIT1_SRC1_SEL</name>
              <description>Select source of modbit for C branch?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN1_VAL, also used as Firmware modbit.?For PASS4B  only values 0-1 and 8-11 and 31 are legal.</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA1_IN0</name>
          <description>Cap A1 input switches set 0</description>
          <addressOffset>0x40340340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_A10_CMP</name>
              <description>VIN10 to Cap A1 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A11_CMP</name>
              <description>VIN11 to Cap A1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A12_CMP</name>
              <description>VIN12 to Cap A1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A13_CMP</name>
              <description>VIN13 to Cap A1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1P</name>
              <description>OUT1 to Cap A1 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1Q</name>
              <description>OUT0 to Cap A1 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA1_IN1</name>
          <description>Cap A1 input switches set 1</description>
          <addressOffset>0x40340344</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_A1R_CMP</name>
              <description>REF1 to Cap A1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1G_CMP</name>
              <description>AGND1 to Cap A1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1V_CMP</name>
              <description>VSS to Cap A1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA1_TOP</name>
          <description>Cap A1 top plate switches</description>
          <addressOffset>0x40340348</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R1A_CMP</name>
              <description>Cap A1 top plate to REF1, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1A_CMP</name>
              <description>Cap A1 top plate to AGND1, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V1A_CMP</name>
              <description>Cap A1 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S1A</name>
              <description>Cap A1 top plate to SUM1</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB1_IN0</name>
          <description>Cap B1 input switches set 0</description>
          <addressOffset>0x40340350</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_B10_CMP</name>
              <description>VIN10 to Cap B1 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B11_CMP</name>
              <description>VIN11 to Cap B1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B12_CMP</name>
              <description>VIN12 to Cap B1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B13_CMP</name>
              <description>VIN13 to Cap B1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1P</name>
              <description>OUT1 to Cap B1 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1Q</name>
              <description>OUT0 to Cap B1 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB1_IN1</name>
          <description>Cap B1 input switches set 1</description>
          <addressOffset>0x40340354</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_B1R_CMP</name>
              <description>REF1 to Cap B1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1G_CMP</name>
              <description>AGND1 to Cap B1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1V_CMP</name>
              <description>VSS to Cap B1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB1_TOP</name>
          <description>Cap A1 top plate switches</description>
          <addressOffset>0x40340358</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R1B_CMP</name>
              <description>Cap B1 top plate to REF1, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1B_CMP</name>
              <description>Cap B1 top plate to AGND1, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V1B_CMP</name>
              <description>Cap B1 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T1B</name>
              <description>Cap B1 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S1B</name>
              <description>Cap B1 top plate to SUM1</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC1_IN0</name>
          <description>Cap C1 input switches set 0</description>
          <addressOffset>0x40340360</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_C10_CMP</name>
              <description>VIN10 to Cap C1 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C11_CMP</name>
              <description>VIN11 to Cap C1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C12_CMP</name>
              <description>VIN12 to Cap C1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C13_CMP</name>
              <description>VIN13 to Cap C1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1P</name>
              <description>OUT1 to Cap C1 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1Q</name>
              <description>OUT0 to Cap C1 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC1_IN1</name>
          <description>Cap C1 input switches set 1</description>
          <addressOffset>0x40340364</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_C1R_CMP</name>
              <description>REF1 to Cap C1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1G_CMP</name>
              <description>AGND1 to Cap C1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1V_CMP</name>
              <description>VSS to Cap C1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC1_TOP</name>
          <description>Cap A1 top plate switches</description>
          <addressOffset>0x40340368</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R1C_CMP</name>
              <description>Cap C1 top plate to REF1, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1C_CMP</name>
              <description>Cap C1 top plate to AGND1, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V1C_CMP</name>
              <description>Cap C1 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T1C</name>
              <description>Cap C1 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S1C</name>
              <description>Cap C1 top plate to SUM1</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S01</name>
              <description>Cap C1 top plate to SUM0</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CF1_BOT</name>
          <description>Cap F1 bottom plate and output switches</description>
          <addressOffset>0x4034036C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G1F</name>
              <description>Cap F1 bottom plate to AGND1</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q1F</name>
              <description>Cap F1 bottom plate to OUT1</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q1S</name>
              <description>Cap F bypass, OUT1 to SUM1</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q1O</name>
              <description>OUT1 to VOUT1</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_OTHER1</name>
          <description>Other clocked controls</description>
          <addressOffset>0x40340370</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CMP1_FF</name>
              <description>Clock for Flip-Flop after Comparator 1</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID1</name>
              <description>Valid1, output flag to indicated that VOUT1 is valid. The Valid output can be suppressed due to sub-sampling. Note that when sub-sampling is used this clocking waveform is used to decrement the counter (decrement is aligned with the positive edge of this clocking waveform).</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG1_OUT</name>
              <description>Trigger output (for other UABs or SAR)</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_SW1</name>
              <description>Strobe for dsi_sw_ctrl (modbit) update, dsi_sw_ctrl updates in sync with posedge of this wave. To disable set to 0. To enable update anytime use 15.</description>
              <lsb>24</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_RST1</name>
              <description>Use the positive edge of the selected clocking waveform to synchronize: ? STRB_RST0_EN=0: Capacitor Value update (Capacitor Strobe)? STRB_RST0_EN=1: UAB analog-reset update?Set to 0 to disable both functions. Result undefined for value 15.</description>
              <lsb>28</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_BOOST_CTRL1</name>
          <description>Bootstrap clock control</description>
          <addressOffset>0x40340374</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CA1_BOOST</name>
              <description>Clock for boot strap master in A branch</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB1_BOOST</name>
              <description>Clock for boot strap master in B branch</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_BOOST</name>
              <description>Clock for boot strap master in C branch</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_BOOST</name>
              <description>Clock for boot strap master in F branch</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUM1_BOOST</name>
              <description>Clock for boot strap master in Summing node branch</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP1_WAVE</name>
              <description>Clock for pump in half1</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM1_CTRL</name>
          <description>SRAM programmed size</description>
          <addressOffset>0x40340378</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>LAST_STEP</name>
              <description>Last step of wave programmed in the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SEL1</name>
              <description>Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER_EN</name>
              <description>Enable input trigger:?0: Ignore triggers, start running immediately after setting RUN bit?1: After RUN bit is set wait for a positive edge on the selected trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>Set to start executing the waveform (may need to wait for a trigger). Clear to stop this UAB half. When RUN=0 all dynamic switches are forced open.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STAT1</name>
          <description>Status Current SRAM counter and comparator</description>
          <addressOffset>0x4034037C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CURR_STEP</name>
              <description>Current step executed from the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP</name>
              <description>Current comparator status</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_SUBSAMPLE</name>
              <description>Current value of the subsampling down counter. The Valid is suppressed when SUBSAMPLE_CUR!=0.</description>
              <lsb>24</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM10</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM11</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340384</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM12</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM13</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x4034038C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM14</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340390</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM15</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340394</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM16</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340398</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM17</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x4034039C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM18</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM19</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM110</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM111</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM112</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM113</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM114</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM115</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DECM_CTRL</name>
          <description>Global decimator control</description>
          <addressOffset>0x40340400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>- 0: Decimator disabled (independent of UAB)?- 1: Decimator enabled (independent of UAB)</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_CTRL</name>
          <description>decimator0 control</description>
          <addressOffset>0x40340404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC0_START</name>
              <description>Start decimator, in incremental mode, this bit is cleared by HW when done. If DSI trigger enable is set then only start after a DSI trigger.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_MODE</name>
              <description>Operation mode?0: Incremental (one-shot) operation?1: Continuous operation</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_SEL</name>
              <description>Source select</description>
              <lsb>4</lsb>
              <msb>5</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UAB_H0</name>
                  <description>Comparator output from Half0 of this UAB</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UAB_H1</name>
                  <description>Comparator output from Half1 of this UAB</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>No description available</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC0_TYPE</name>
              <description>decimator type (filter order)</description>
              <lsb>6</lsb>
              <msb>7</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINC1</name>
                  <description>first order</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINC2</name>
                  <description>second order</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINC3</name>
                  <description>third order, this uses half of decimator1, therefore cannot be combined with dc1_mode SINC2</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>reserved</name>
                  <description>reserved value, do not use</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC0_SHIFT</name>
              <description>shift the result right by specified amount, legal range 0..16</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RATIO</name>
              <description>decimation ratio = DC0_RATIO+1, range 1..512</description>
              <lsb>16</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_TRIG</name>
          <description>decimator0 trigger control</description>
          <addressOffset>0x40340408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC0_TRIG_SEL</name>
              <description>Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-11 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_DSI_TRIG_EN</name>
              <description>Decimator DSI trigger input Enable?0: Ignore decimator DSI trigger input?1: Wait for positive edge on selected DSI trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_OVR</name>
          <description>decimator 0 overflow control</description>
          <addressOffset>0x4034040C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC0_OVR_CORR_LOC</name>
              <description>Bit location for overflow correction. This should be set to FILTER_ORDER*log2(DC0_RATIO)</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_A0</name>
          <description>decimator0 accumulator 0</description>
          <addressOffset>0x40340410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A0</name>
              <description>24-bit sign extended accumulator0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_A1</name>
          <description>decimator0 accumulator 1</description>
          <addressOffset>0x40340414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A1</name>
              <description>24-bit sign extended accumulator1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_DEC_CNT</name>
          <description>decimator0 decimation counter</description>
          <addressOffset>0x40340418</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>INT_CNT</name>
              <description>integration/decimation down counter</description>
              <lsb>0</lsb>
              <msb>8</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DIFF_CNT</name>
              <description>differentiation down counter</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_TMP</name>
          <description>decimator0 temporary value for differentiator</description>
          <addressOffset>0x4034041C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TMP</name>
              <description>24-bit sign extended differentiator temporary value status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_D0</name>
          <description>decimator0 differentiator 0</description>
          <addressOffset>0x40340420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D0</name>
              <description>24-bit sign extended differentiator 0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_D1</name>
          <description>decimator0 differentiator 1</description>
          <addressOffset>0x40340424</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D1</name>
              <description>24-bit sign extended differentiator 1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_RES</name>
          <description>decimator0 result</description>
          <addressOffset>0x40340428</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RES</name>
              <description>24-bit sign extended result</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_CTRL</name>
          <description>decimator1 control</description>
          <addressOffset>0x40340434</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC1_START</name>
              <description>Start decimator, in incremental mode, this bit is cleared by HW when done. If DSI trigger enable is set then only start after a DSI trigger.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_MODE</name>
              <description>Operation mode?0: Incremental (one-shot) operation?1: Continuous operation</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_SEL</name>
              <description>Source select</description>
              <lsb>4</lsb>
              <msb>5</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UAB_H0</name>
                  <description>Comparator output from Half0 of this UAB</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UAB_H1</name>
                  <description>Comparator output from Half1 of this UAB</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>No description available</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC1_TYPE</name>
              <description>decimator type (filter order)</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINC1</name>
                  <description>first order</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINC2</name>
                  <description>second order</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC01_CHAIN</name>
              <description>Chain decimator0 and decimator1</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_SHIFT</name>
              <description>shift the result right by specified amount, legal range 0..16</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RATIO</name>
              <description>decimation ratio = DC1_RATIO+1, range 1..512</description>
              <lsb>16</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_TRIG</name>
          <description>decimator1 trigger control</description>
          <addressOffset>0x40340438</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC1_TRIG_SEL</name>
              <description>Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-11 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_DSI_TRIG_EN</name>
              <description>Decimator DSI trigger input Enable?0: Ignore decimator DSI trigger input?1: Wait for positive edge on selected DSI trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_OVR</name>
          <description>decimator 1 overflow control</description>
          <addressOffset>0x4034043C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC1_OVR_CORR_LOC</name>
              <description>Bit location for overflow correction. This should be set to FILTER_ORDER*log2(DC1_RATIO)</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_A0</name>
          <description>decimator1 accumulator 0</description>
          <addressOffset>0x40340440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A0</name>
              <description>27-bit sign extended accumulator0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_A1</name>
          <description>decimator1 accumulator 1</description>
          <addressOffset>0x40340444</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A1</name>
              <description>27-bit sign extended accumulator1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_DEC_CNT</name>
          <description>decimator1 decimation counter</description>
          <addressOffset>0x40340448</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>INT_CNT</name>
              <description>integration/decimation down counter</description>
              <lsb>0</lsb>
              <msb>8</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DIFF_CNT</name>
              <description>differentiation down counter</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_TMP</name>
          <description>decimator1 temporary value for differentiator</description>
          <addressOffset>0x4034044C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TMP</name>
              <description>27-bit sign extended differentiator temporary value status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_D0</name>
          <description>decimator1 differentiator 0</description>
          <addressOffset>0x40340450</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D0</name>
              <description>27-bit sign extended differentiator 0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_D1</name>
          <description>decimator1 differentiator 1</description>
          <addressOffset>0x40340454</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D1</name>
              <description>27-bit sign extended differentiator 1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_RES</name>
          <description>decimator1 result</description>
          <addressOffset>0x40340458</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RES</name>
              <description>27-bit sign extended result</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_TRIM0</name>
          <description>Trim for attenuation cap half0</description>
          <addressOffset>0x40340F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CBTC0_VAL</name>
              <description>Cap B Trim 0 Value?Trim attenuation cap in branch B for DAC correctness</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CCTC0_VAL</name>
              <description>Cap C Trim 0 Value?Do not measure value, instead use same value as for CBTC0_VAL</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_TRIM1</name>
          <description>Trim for attenuation cap half1</description>
          <addressOffset>0x40340F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CBTC1_VAL</name>
              <description>Cap B Trim 1 Value?Trim attenuation cap in branch B for DAC correctness</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CCTC1_VAL</name>
              <description>Cap C Trim 1 Value?Do not measure value, instead use same value as for CBTC1_VAL</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA_TRIM0</name>
          <description>Trim for opamp and buffers half0</description>
          <addressOffset>0x40340F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA0_OFFSET</name>
              <description>Opamp offset trim</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF0_OFFSET</name>
              <description>Reference buffer offset trim</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND0_OFFSET</name>
              <description>Agnd buffer offset trim</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA_TRIM1</name>
          <description>Trim for opamp and buffers half1</description>
          <addressOffset>0x40340F0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA1_OFFSET</name>
              <description>Opamp offset trim</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF1_OFFSET</name>
              <description>Reference buffer offset trim</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND1_OFFSET</name>
              <description>Agnd buffer offset trim</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>engine_sensor_adc_UABH_A</name>
      <description>No description available</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>UAB_UAB_CTRL</name>
          <description>Global UAB control</description>
          <addressOffset>0x40340000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>- 0: UAB IP disabled (put analog in power down, open all switches)?- 1: UAB IP enabled</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x40340020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC0_EMPTY</name>
              <description>VDAC 0 Interrupt: hardware sets this interrupt when VDAC 0 next value field is empty. Write with '1' to clear bit.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RES</name>
              <description>Decimator 0 Result Interrupt: hardware sets this interrupt when Decimator 0 writes a new result value in DC0_RES register. Write with '1' to clear bit.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC1_EMPTY</name>
              <description>VDAC 1 Interrupt: hardware sets this interrupt when VDAC 1 next value field is empty. Write with '1' to clear bit.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RES</name>
              <description>Decimator 1 Result Interrupt: hardware sets this interrupt when Decimator 1 writes a new result value in DC1_RES register. Write with '1' to clear bit.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR_SET</name>
          <description>Interrupt request set register</description>
          <addressOffset>0x40340024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC0_EMPTY_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RES_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC1_EMPTY_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RES_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR_MASK</name>
          <description>Interrupt request mask</description>
          <addressOffset>0x40340028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC0_EMPTY_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RES_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VDAC1_EMPTY_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RES_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_INTR_MASKED</name>
          <description>Interrupt request masked</description>
          <addressOffset>0x4034002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>VDAC0_EMPTY_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DC0_RES_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>VDAC1_EMPTY_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DC1_RES_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA0_CTRL</name>
          <description>Opamp, comparator, buffer  controls</description>
          <addressOffset>0x40340200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA0_PWR</name>
              <description>Opamp0 power level</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_PWR</name>
              <description>Comparator0 power level</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_EDGE</name>
              <description>Comparator0 edge detect for interrupt and trigger</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP0_DSI_LEVEL</name>
              <description>Comparator0 trigger out level : 0=pulse, 1=level</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL0_SPARE</name>
              <description>Spare bit</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF0_PWR</name>
              <description>Reference0 buffer power level</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF0_PTS</name>
              <description>1- Pull the Reference0 buffer output to VDDA</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND0_PWR</name>
              <description>Agnd0 buffer power level</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND0_PTS</name>
              <description>1 - Pull Agnd0 buffer output to VDDA</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_GG</name>
              <description>Connect outputs of Agnd0 and Agnd1 buffer, one buffer must be off.?This is to drive both UAB halves with the same buffer, so both halves get the same offset noise.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE0_EN</name>
              <description>1 - Enable spare reference</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>H0_PWR</name>
              <description>UAB Half, power profile</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, for normal analog clock speeds</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_LOW</name>
                  <description>Ultra low power, only allowed for lower analog clock speeds</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_HIGH</name>
                  <description>Ultra high performance, for higher analog clock speeds (also ultra high power)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Reserved</name>
                  <description>Reserved, do not use</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CTRL0</name>
          <description>Capacitance controls</description>
          <addressOffset>0x40340204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB0_GND</name>
              <description>Ground unused caps of CB0 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used, e.g. for VDAC use-case)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_GND</name>
              <description>Ground unused caps of CC0 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used)</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRC0_SIGN_BIT</name>
              <description>Forces the sign bit to be 1 in DAC mode.  This is used to achieve ?0 - AGND0 range for unsigned numbers using DAC mode 2</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC0_MODE_EN</name>
              <description>0: SIGN0_VAL can be programmed to be a modbit source?1: SIGN0_VAL is a dedicated sign bit (FW modbit source tied to 0)</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC0_MODE</name>
              <description>DAC mode, this determines the AB Cap Value decoding</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED12</name>
                  <description>Off or Unsigned 12-bit VDAC, i.e. no AB Cap value decoding.?SIGN1_VAL can be used as Firmware controlled modbit (e.g. to invert the Voltage for a Sign + Magnitude VDAC)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIRT_SIGNED12</name>
                  <description>Virtual signed 12-bits' VDAC. AB Cap value decoding: ?add 0x800 to the 12-bit AB Cap Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED13</name>
                  <description>Signed 13-bit twos complement. AB Cap value decoding: ?for negative values (SIGN0_VAL=1) the AB Cap values are inverted, the 64th B cap unit is enabled and the Voltage should be inverted.?- Voltage inversion only works if the right clocking waveforms, switch settings and reference voltages are used.?- Enabling the 64th B cap unit adds 1 so that only a AB Cap value inversion is needed to create a true twos complement.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_ABCF0_VAL</name>
          <description>Capacitance values for CA0, CB0, CC0 and CF0</description>
          <addressOffset>0x40340208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB0_VAL</name>
              <description>Cap B0 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA0_VAL</name>
              <description>Cap A0 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN0_VAL</name>
              <description>Sign bit Value, when used in DAC_MODE, otherwise Firmware modbit.?In DAC_MODE the modbit should be used to invert the voltage on the AB Caps for the negative DAC values.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB0_64</name>
              <description>Enable 64th Cap of CB0 array.  In DAC mode the FW setting is overridden by the hardware based on DAC_MODE setting.?1 - Enables the 64th cap.  This will also set CB0_val[5:0] to be 6'h3F</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_VAL</name>
              <description>Cap C0 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_VAL</name>
              <description>Cap F0 Value [2..64 is the range in steps of 2]</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_AB0_VAL_NXT</name>
          <description>Next capacitance values for CA0 and CB0</description>
          <addressOffset>0x4034020C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB0_VAL</name>
              <description>Cap B0 Value</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA0_VAL</name>
              <description>Cap A0 Value</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN0_VAL</name>
              <description>Sign bit Value</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CF0_VAL_NXT</name>
          <description>Next capacitance values for CC0 and CF0</description>
          <addressOffset>0x40340210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CC0_VAL</name>
              <description>Cap C0 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_VAL</name>
              <description>Cap F0 Value</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_VAL_UPDATE</name>
              <description>1 - Update the CC0 cap value with CAP_CC0_VAL_NXT.CC0_VAL</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_VAL_UPDATE</name>
              <description>1 - Update the CF0 cap value with CAP_CF0_VAL_NXT.CF0_VAL</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STARTUP_DELAY0</name>
          <description>Startup delay</description>
          <addressOffset>0x40340220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>STARTUP_DELAY</name>
              <description>Startup delay to synchronize the UAB-SAR interface. The usage and meaning of this field depends on the value of the ALIGN_MODE bit (below).   A value of 0 disables this function.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIGN_MODE</name>
              <description>0 - STARTUP_DELAY is number of clk_hf clocks to delay the UAB clock after a SAR Trigger for UAB-SAR alignment in scheduled mode?1 - STARTUP_DELAY is number of clk_hf clocks to delay UAB trigger to SAR for UAB-SAR alignment in unscheduled mode</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SUBSAMPLE_CTRL0</name>
          <description>Subsample control</description>
          <addressOffset>0x40340224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SUBSAMPLE</name>
              <description>Subsampling: suppress Valid output during the first SUBSAMPLE analog clock periods. Only allow Valid output in the last of the SUBSAMPLE+1 analog clock periods.?A value of 0 will not suppress Valid output.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBSAMPLE_INIT</name>
              <description>Initial value of the subsampling down counter. Before this UAB half is running the firmware can write to this field the initial value of the subsample down counter. It is recommend that the following is true for the initial value  SUBSAMPLE_INIT&lt;=SUBSAMPLE, however this is not a requirement. Writing a bigger value can be used to postpone the very first Valid output.</description>
              <lsb>8</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_STATIC0</name>
          <description>Static switches for half 0 of the UAB</description>
          <addressOffset>0x40340230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G00</name>
              <description>VIN00 to OA0.vplus (AG0)</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G01</name>
              <description>VIN01 to OA0.vplus (AG0)</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G02</name>
              <description>VIN02 to OA0.vplus (AG0)</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G03</name>
              <description>VIN03 to OA0.vplus (AG0)</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R0G</name>
              <description>REF0 to OA0.vplus (AG0)</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0G</name>
              <description>AGND0 to OA0.vplus (AG0)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R0T</name>
              <description>REF0 to cmp0.vminus (Threshold)</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0T</name>
              <description>AGND0 to cmp0.vminus (Threshold)</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q0T</name>
              <description>OUT1 to cmp0.vminus (Threshold)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_P0S</name>
              <description>OUT0 to Sum0 switch timing: 0=Regular, 1=Early</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_P0O</name>
              <description>OUT0 to VOUT0 switch timing: 0=Regular, 1=Early</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RMB0_BITS</name>
              <description>Risk mitigation bits (To be defined if they are used)</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST0_SEL</name>
              <description>Select source either for VDAC strobe or analog-reset to discharge all Caps (Delsig Modulator use-case)?0 = Decimator0 half 0 analog-reset output?1 = Decimator0 half 1 analog-reset output?2 = Decimator1 half 0 analog-reset output?3 = Decimator1 half 1 analog-reset output?4 = Decimator2 half 0 analog-reset output?5 = Decimator2 half 1 analog-reset output?6 = Decimator3 half 0 analog-reset output?7 = Decimator3 half 1 analog-reset output?8-31 = generic trigger input 0-23?For PASS4B  only values 0-1 and 8-13 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST0_EN</name>
              <description>Enable VDAC strobe or UAB analog-reset:?0: Use selected source as VDAC strobe for next CA0 and CB0 values?1: Use selected source as Analog-reset (discharge all Caps)</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_MODBIT_SRC0</name>
          <description>Select source of Modbit for A,B and C branches of half 0</description>
          <addressOffset>0x40340234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODBIT0_SRC0_SEL</name>
              <description>Select source of modbit for A &amp; B branches?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN0_VAL, also used as Firmware modbit. ?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MODBIT1_SRC0_SEL</name>
              <description>Select source of modbit for C branch?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN0_VAL, also used as Firmware modbit. ?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA0_IN0</name>
          <description>Cap A0 input switches set 0</description>
          <addressOffset>0x40340240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_A00_CMP</name>
              <description>VIN00 to Cap A0 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A01_CMP</name>
              <description>VIN01 to Cap A0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A02_CMP</name>
              <description>VIN02 to Cap A0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A03_CMP</name>
              <description>VIN03 to Cap A0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0P</name>
              <description>OUT0 to Cap A0 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0Q</name>
              <description>OUT1 to Cap A0 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA0_IN1</name>
          <description>Cap A0 input switches set 1</description>
          <addressOffset>0x40340244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_AA</name>
              <description>Cap A0 input to Cap A1 input?(Note: In the UAB design this is the called AM switch)</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0R_CMP</name>
              <description>REF0 to Cap A0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0G_CMP</name>
              <description>AGND0 to Cap A0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A0V_CMP</name>
              <description>VSS to Cap A0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA0_TOP</name>
          <description>Cap A0 top plate switches</description>
          <addressOffset>0x40340248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R0A_CMP</name>
              <description>Cap A0 top plate to REF0, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0A_CMP</name>
              <description>Cap A0 top plate to AGND0, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V0A_CMP</name>
              <description>Cap A0 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S0A</name>
              <description>Cap A0 top plate to SUM0</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB0_IN0</name>
          <description>Cap B0 input switches set 0</description>
          <addressOffset>0x40340250</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_B00_CMP</name>
              <description>VIN00 to Cap B0 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B01_CMP</name>
              <description>VIN01 to Cap B0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B02_CMP</name>
              <description>VIN02 to Cap B0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B03_CMP</name>
              <description>VIN03 to Cap B0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0P</name>
              <description>OUT0 to Cap B0 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0Q</name>
              <description>OUT1 to Cap B0 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB0_IN1</name>
          <description>Cap B0 input switches set 1</description>
          <addressOffset>0x40340254</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_BB</name>
              <description>Cap B0 input to Cap B1 input?(Note: In the UAB design this is called the BM switch)</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0R_CMP</name>
              <description>REF0 to Cap B0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0G_CMP</name>
              <description>AGND0 to Cap B0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B0V_CMP</name>
              <description>VSS to Cap B0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB0_TOP</name>
          <description>Cap A0 top plate switches</description>
          <addressOffset>0x40340258</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R0B_CMP</name>
              <description>Cap B0 top plate to REF0, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0B_CMP</name>
              <description>Cap B0 top plate to AGND0, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V0B_CMP</name>
              <description>Cap B0 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T0B</name>
              <description>Cap B0 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S0B</name>
              <description>Cap B0 top plate to SUM0</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC0_IN0</name>
          <description>Cap C0 input switches set 0</description>
          <addressOffset>0x40340260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_C00_CMP</name>
              <description>VIN00 to Cap C0 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C01_CMP</name>
              <description>VIN01 to Cap C0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C02_CMP</name>
              <description>VIN02 to Cap C0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C03_CMP</name>
              <description>VIN03 to Cap C0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0P</name>
              <description>OUT0 to Cap C0 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0Q</name>
              <description>OUT1 to Cap C0 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC0_IN1</name>
          <description>Cap C0 input switches set 1</description>
          <addressOffset>0x40340264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_CC</name>
              <description>Cap C0 input to Cap C1 input?(Note: In the UAB design this is called the CM switch)</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0R_CMP</name>
              <description>REF0 to Cap C0 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0G_CMP</name>
              <description>AGND0 to Cap C0 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C0V_CMP</name>
              <description>VSS to Cap C0 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC0_TOP</name>
          <description>Cap A0 top plate switches</description>
          <addressOffset>0x40340268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R0C_CMP</name>
              <description>Cap C0 top plate to REF0, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G0C_CMP</name>
              <description>Cap C0 top plate to AGND0, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V0C_CMP</name>
              <description>Cap C0 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T0C</name>
              <description>Cap C0 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S0C</name>
              <description>Cap C0 top plate to SUM0</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S10</name>
              <description>Cap C0 top plate to SUM1</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CF0_BOT</name>
          <description>Cap F0 bottom plate and output switches</description>
          <addressOffset>0x4034026C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G0F</name>
              <description>Cap F0 bottom plate to AGND0</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P0F</name>
              <description>Cap F0 bottom plate to OUT0</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P0S</name>
              <description>Cap F bypass, OUT0 to SUM0</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P0O</name>
              <description>OUT0 to VOUT0</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_OTHER0</name>
          <description>Other clocked controls</description>
          <addressOffset>0x40340270</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CMP0_FF</name>
              <description>Clock for Flip-Flop after Comparator 0</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID0</name>
              <description>Valid0, output flag to indicated that VOUT0 is valid. The Valid output can be suppressed due to sub-sampling. Note that when sub-sampling is used this clocking waveform is used to decrement the counter (decrement is aligned with the positive edge of this clocking waveform).</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG0_OUT</name>
              <description>Trigger output (for other UABs or SAR)</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_SW0</name>
              <description>Strobe for dsi_sw_ctrl (modbit) update, dsi_sw_ctrl updates in sync with posedge of this wave. To disable set to 0. To enable update anytime use 15.</description>
              <lsb>24</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_RST0</name>
              <description>Use the positive edge of the selected clocking waveform to synchronize: ? STRB_RST0_EN=0: Capacitor Value update (Capacitor Strobe)? STRB_RST0_EN=1: UAB analog-reset update?Set to 0 to disable both functions. Result undefined for value 15.</description>
              <lsb>28</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_BOOST_CTRL0</name>
          <description>Bootstrap clock control</description>
          <addressOffset>0x40340274</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CA0_BOOST</name>
              <description>Clock for boot strap master in A branch</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB0_BOOST</name>
              <description>Clock for boot strap master in B branch</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC0_BOOST</name>
              <description>Clock for boot strap master in C branch</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF0_BOOST</name>
              <description>Clock for boot strap master in F branch</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUM0_BOOST</name>
              <description>Clock for boot strap master in Summing node branch</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP0_WAVE</name>
              <description>Clock for pump in half0</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM0_CTRL</name>
          <description>SRAM programmed size</description>
          <addressOffset>0x40340278</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>LAST_STEP</name>
              <description>Last step of wave programmed in the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SEL0</name>
              <description>input Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER_EN</name>
              <description>Enable input trigger:?0: Ignore triggers, start running immediately after setting RUN bit?1: After RUN bit is set wait for a positive edge on the selected trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>Set to start executing the waveform (may need to wait for a trigger). Clear to stop this UAB half. When RUN=0 all dynamic switches are forced open.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STAT0</name>
          <description>Status Current SRAM counter and comparator</description>
          <addressOffset>0x4034027C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CURR_STEP</name>
              <description>Current step executed from the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP</name>
              <description>Current comparator status</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_SUBSAMPLE</name>
              <description>Current value of the subsampling down counter. The Valid is suppressed when SUBSAMPLE_CUR!=0.</description>
              <lsb>24</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM00</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM01</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM02</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM03</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x4034028C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM04</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM05</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM06</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x40340298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM07</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x4034029C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM08</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM09</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM010</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM011</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM012</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM013</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM014</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM015</name>
          <description>Waveform SRAM for half 0 of the UAB</description>
          <addressOffset>0x403402BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA1_CTRL</name>
          <description>Opamp, comparator, buffer  controls</description>
          <addressOffset>0x40340300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA1_PWR</name>
              <description>Opamp1 power level</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_PWR</name>
              <description>Comparator1 power level</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_EDGE</name>
              <description>Comparator1 edge detect for interrupt and trigger</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP1_DSI_LEVEL</name>
              <description>Comparator trigger out level : 0=pulse, 1=level</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL1_SPARE</name>
              <description>Spare bit</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF1_PWR</name>
              <description>Reference1 buffer power</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF1_PTS</name>
              <description>1- Pull the Reference1 buffer output to VDDA</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND1_PWR</name>
              <description>Agnd1 buffer power</description>
              <lsb>20</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND1_PTS</name>
              <description>1- Pull the Agnd1 buffer output to VDDA</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RR</name>
              <description>Connect outputs of Reference0 and Reference1 buffer, one buffer must be off.?This is to drive both UAB halves with the same buffer, so both halves get the same offset noise.</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE1_EN</name>
              <description>1 - Enable the spare reference</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>H1_PWR</name>
              <description>UAB Half, power profile</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, for normal analog clock speeds</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_LOW</name>
                  <description>Ultra low power, only allowed for lower analog clock speeds</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULTRA_HIGH</name>
                  <description>Ultra high performance, for higher analog clock speeds (also ultra high power)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Reserved</name>
                  <description>Reserved, do not use</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CTRL1</name>
          <description>Capacitance controls</description>
          <addressOffset>0x40340304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB1_GND</name>
              <description>Ground unused caps of CB1 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used, e.g. for VDAC use-case)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_GND</name>
              <description>Ground unused caps of CC1 array?0: leave unused caps floating?1: ground unused caps (typical when attentuation Cap is used)</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRC1_SIGN_BIT</name>
              <description>Forces the sign bit to be 1 in DAC mode.  This is used to achieve ?0 - AGND1 range for unsigned numbers using DAC mode 2</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC1_MODE_EN</name>
              <description>1: SIGN1_VAL is dedicated sign bit (FW modbit source tied to 0)                                                           0: SIGN1_VAL can be programmed to be a modbit source</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC1_MODE</name>
              <description>DAC mode, this determines the AB Cap Value decoding</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED12</name>
                  <description>Off or Unsigned 12-bit VDAC, i.e. no AB Cap value decoding.?SIGN1_VAL can be used as Firmware controlled modbit (e.g. to invert the Voltage for a Sign + Magnitude VDAC)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIRT_SIGNED12</name>
                  <description>Virtual signed 12-bits' VDAC. AB Cap value decoding: ?add 0x800 to the 12-bit AB Cap Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED13</name>
                  <description>Signed 13-bit twos complement. AB Cap value decoding: ?for negative values (SIGN1_VAL=1) the AB Cap values are inverted, the 64th B cap unit is enabled and the Voltage should be inverted.?- Voltage inversion only works if the right clocking waveforms, switch settings and reference voltages are used.?- Enabling the 64th B cap unit adds 1 so that only a AB Cap value inversion is needed to create a true twos complement.  .</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_ABCF1_VAL</name>
          <description>Capacitance values for CA1, CB1, CC1 and CF1</description>
          <addressOffset>0x40340308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB1_VAL</name>
              <description>Cap B1 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA1_VAL</name>
              <description>Cap A1 Value, in DAC_MODE 1 and 2 this value is decoded</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN1_VAL</name>
              <description>Sign bit Value, when used in DAC_MODE, otherwise Firmware modbit.?In DAC_MODE the modbit should be used to invert the voltage on the AB Caps for the negative DAC values.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB1_64</name>
              <description>Enable 64th Cap of CB1 array. In DAC mode the FW setting is overridden by the hardware based on DAC_MODE setting.                                                           1 - Enables the 64th cap. This will also set CB1_val[5:0] to be 6'h3F</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_VAL</name>
              <description>Cap C1 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_VAL</name>
              <description>Cap F1 Value</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_AB1_VAL_NXT</name>
          <description>Next capacitance values for CA1 and CB1</description>
          <addressOffset>0x4034030C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CB1_VAL</name>
              <description>Cap B1 Value</description>
              <lsb>0</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CA1_VAL</name>
              <description>Cap A1 Value</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGN1_VAL</name>
              <description>Sign bit Value</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_CF1_VAL_NXT</name>
          <description>Next capacitance values for CC1 and CF1</description>
          <addressOffset>0x40340310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CC1_VAL</name>
              <description>Cap C1 Value</description>
              <lsb>16</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_VAL</name>
              <description>Cap F1 Value</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_VAL_UPDATE</name>
              <description>1 - Update the CC1 cap value with CAP_CC1_VAL_NXT.CC1_VAL</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_VAL_UPDATE</name>
              <description>1 - Update the CF1 cap value with CAP_CF1_VAL_NXT.CF1_VAL</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STARTUP_DELAY1</name>
          <description>Startup delay</description>
          <addressOffset>0x40340320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>STARTUP_DELAY</name>
              <description>Startup delay to synchronize the UAB-SAR interface. The usage and meaning of this field depends on the value of the ALIGN_MODE bit (below).   A value of 0 disables this function.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIGN_MODE</name>
              <description>0 - STARTUP_DELAY is number of clk_hf clocks to delay the UAB clock after a SAR Trigger for UAB-SAR alignment in scheduled mode?1 - STARTUP_DELAY is number of clk_hf clocks to delay UAB trigger to SAR for UAB-SAR alignment in unscheduled mode</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SUBSAMPLE_CTRL1</name>
          <description>Subsample control</description>
          <addressOffset>0x40340324</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SUBSAMPLE</name>
              <description>Subsampling: suppress Valid output during the first SUBSAMPLE analog clock periods. Only allow Valid output in the last of the SUBSAMPLE+1 analog clock periods.?A value of 0 will not suppress Valid output.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBSAMPLE_INIT</name>
              <description>Initial value of the subsampling down counter. Before this UAB half is running the firmware can write to this field the initial value of the subsample down counter. It is recommend that the following is true for the initial value  SUBSAMPLE_INIT&lt;=SUBSAMPLE, however this is not a requirement. Writing a bigger value can be used to postpone the very first Valid output.</description>
              <lsb>8</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_STATIC1</name>
          <description>Static switches for half 1 of the UAB</description>
          <addressOffset>0x40340330</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G10</name>
              <description>VIN10 to OA1.vplus (AG1)</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G11</name>
              <description>VIN11 to OA1.vplus (AG1)</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G12</name>
              <description>VIN12 to OA1.vplus (AG1)</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G13</name>
              <description>VIN13 to OA1.vplus (AG1)</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R1G</name>
              <description>REF1 to OA1.vplus (AG1)</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1G</name>
              <description>AGND1 to OA1.vplus (AG1)</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_R1T</name>
              <description>REF1 to cmp1.vminus (Threshold)</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1T</name>
              <description>AGND1 to cmp1.vminus (Threshold)</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_P1T</name>
              <description>OUT0 to cmp1.vminus (Threshold)</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_Q1S</name>
              <description>OUT1 to Sum1 switch timing: 0=Regular, 1=Early</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EARLY_Q1O</name>
              <description>OUT1 to VOUT1 switch timing: 0=Regular, 1=Early</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RMB1_BITS</name>
              <description>Risk mitigation bits (To be defined if they are used)</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST1_SEL</name>
              <description>Select source either for VDAC strobe or analog-reset to discharge all Caps (Delsig Modulator use-case)?0 = Decimator0 half 0 analog-reset output?1 = Decimator0 half 1 analog-reset output?2 = Decimator1 half 0 analog-reset output?3 = Decimator1 half 1 analog-reset output?4 = Decimator2 half 0 analog-reset output?5 = Decimator2 half 1 analog-reset output?6 = Decimator3 half 0 analog-reset output?7 = Decimator3 half 1 analog-reset output?8-31 = generic trigger input 0-23?For PASS4B  only values 0-1 and 8-13 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STRB_RST1_EN</name>
              <description>Enable VDAC strobe or UAB analog-reset:?0: Use selected source as VDAC strobe for next CA1 and CB1 values?1: Use selected source as Analog-reset (discharge all Caps)</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_MODBIT_SRC1</name>
          <description>Select source of Modbit for A,B and C branches of half 1</description>
          <addressOffset>0x40340334</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODBIT0_SRC1_SEL</name>
              <description>Select source of modbit for A &amp; B branches?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN1_VAL, also used as Firmware modbit.?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MODBIT1_SRC1_SEL</name>
              <description>Select source of modbit for C branch?0=UAB0 half 0 comparator output?1=UAB0 half 1 comparator output?2=UAB1 half 0 comparator output?3=UAB1 half 1 comparator output?4=UAB2 half 0 comparator output?5=UAB2 half 1 comparator output?6=UAB3 half 0 comparator output?7=UAB3 half 1 comparator output?8-30 = generic trigger inputs 0-22?31=SIGN1_VAL, also used as Firmware modbit.?For PASS4B  only values 0-1 and 8-11 and 31 are legal.</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA1_IN0</name>
          <description>Cap A1 input switches set 0</description>
          <addressOffset>0x40340340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_A10_CMP</name>
              <description>VIN10 to Cap A1 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A11_CMP</name>
              <description>VIN11 to Cap A1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A12_CMP</name>
              <description>VIN12 to Cap A1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A13_CMP</name>
              <description>VIN13 to Cap A1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1P</name>
              <description>OUT1 to Cap A1 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1Q</name>
              <description>OUT0 to Cap A1 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA1_IN1</name>
          <description>Cap A1 input switches set 1</description>
          <addressOffset>0x40340344</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_A1R_CMP</name>
              <description>REF1 to Cap A1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1G_CMP</name>
              <description>AGND1 to Cap A1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_A1V_CMP</name>
              <description>VSS to Cap A1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CA1_TOP</name>
          <description>Cap A1 top plate switches</description>
          <addressOffset>0x40340348</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R1A_CMP</name>
              <description>Cap A1 top plate to REF1, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1A_CMP</name>
              <description>Cap A1 top plate to AGND1, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V1A_CMP</name>
              <description>Cap A1 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S1A</name>
              <description>Cap A1 top plate to SUM1</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB1_IN0</name>
          <description>Cap B1 input switches set 0</description>
          <addressOffset>0x40340350</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_B10_CMP</name>
              <description>VIN10 to Cap B1 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B11_CMP</name>
              <description>VIN11 to Cap B1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B12_CMP</name>
              <description>VIN12 to Cap B1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B13_CMP</name>
              <description>VIN13 to Cap B1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1P</name>
              <description>OUT1 to Cap B1 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1Q</name>
              <description>OUT0 to Cap B1 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB1_IN1</name>
          <description>Cap B1 input switches set 1</description>
          <addressOffset>0x40340354</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_B1R_CMP</name>
              <description>REF1 to Cap B1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1G_CMP</name>
              <description>AGND1 to Cap B1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_B1V_CMP</name>
              <description>VSS to Cap B1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CB1_TOP</name>
          <description>Cap A1 top plate switches</description>
          <addressOffset>0x40340358</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R1B_CMP</name>
              <description>Cap B1 top plate to REF1, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1B_CMP</name>
              <description>Cap B1 top plate to AGND1, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V1B_CMP</name>
              <description>Cap B1 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T1B</name>
              <description>Cap B1 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S1B</name>
              <description>Cap B1 top plate to SUM1</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC1_IN0</name>
          <description>Cap C1 input switches set 0</description>
          <addressOffset>0x40340360</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_C10_CMP</name>
              <description>VIN10 to Cap C1 input, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C11_CMP</name>
              <description>VIN11 to Cap C1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C12_CMP</name>
              <description>VIN12 to Cap C1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C13_CMP</name>
              <description>VIN13 to Cap C1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1P</name>
              <description>OUT1 to Cap C1 input</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1Q</name>
              <description>OUT0 to Cap C1 input</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC1_IN1</name>
          <description>Cap C1 input switches set 1</description>
          <addressOffset>0x40340364</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_C1R_CMP</name>
              <description>REF1 to Cap C1 input, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1G_CMP</name>
              <description>AGND1 to Cap C1 input, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1V_CMP</name>
              <description>VSS to Cap C1 input, allows for modbit control</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CC1_TOP</name>
          <description>Cap A1 top plate switches</description>
          <addressOffset>0x40340368</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_R1C_CMP</name>
              <description>Cap C1 top plate to REF1, allows for modbit control</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_G1C_CMP</name>
              <description>Cap C1 top plate to AGND1, allows for modbit control</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_V1C_CMP</name>
              <description>Cap C1 top plate to VSS, allows for modbit control</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_T1C</name>
              <description>Cap C1 top plate Trim/Attenuation bypass</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S1C</name>
              <description>Cap C1 top plate to SUM1</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_S01</name>
              <description>Cap C1 top plate to SUM0</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_CF1_BOT</name>
          <description>Cap F1 bottom plate and output switches</description>
          <addressOffset>0x4034036C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SW_G1F</name>
              <description>Cap F1 bottom plate to AGND1</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q1F</name>
              <description>Cap F1 bottom plate to OUT1</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q1S</name>
              <description>Cap F bypass, OUT1 to SUM1</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_Q1O</name>
              <description>OUT1 to VOUT1</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_OTHER1</name>
          <description>Other clocked controls</description>
          <addressOffset>0x40340370</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CMP1_FF</name>
              <description>Clock for Flip-Flop after Comparator 1</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID1</name>
              <description>Valid1, output flag to indicated that VOUT1 is valid. The Valid output can be suppressed due to sub-sampling. Note that when sub-sampling is used this clocking waveform is used to decrement the counter (decrement is aligned with the positive edge of this clocking waveform).</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG1_OUT</name>
              <description>Trigger output (for other UABs or SAR)</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_SW1</name>
              <description>Strobe for dsi_sw_ctrl (modbit) update, dsi_sw_ctrl updates in sync with posedge of this wave. To disable set to 0. To enable update anytime use 15.</description>
              <lsb>24</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_RST1</name>
              <description>Use the positive edge of the selected clocking waveform to synchronize: ? STRB_RST0_EN=0: Capacitor Value update (Capacitor Strobe)? STRB_RST0_EN=1: UAB analog-reset update?Set to 0 to disable both functions. Result undefined for value 15.</description>
              <lsb>28</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SW_BOOST_CTRL1</name>
          <description>Bootstrap clock control</description>
          <addressOffset>0x40340374</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CA1_BOOST</name>
              <description>Clock for boot strap master in A branch</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CB1_BOOST</name>
              <description>Clock for boot strap master in B branch</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_BOOST</name>
              <description>Clock for boot strap master in C branch</description>
              <lsb>8</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CF1_BOOST</name>
              <description>Clock for boot strap master in F branch</description>
              <lsb>12</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUM1_BOOST</name>
              <description>Clock for boot strap master in Summing node branch</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP1_WAVE</name>
              <description>Clock for pump in half1</description>
              <lsb>20</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM1_CTRL</name>
          <description>SRAM programmed size</description>
          <addressOffset>0x40340378</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>LAST_STEP</name>
              <description>Last step of wave programmed in the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SEL1</name>
              <description>Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-13 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER_EN</name>
              <description>Enable input trigger:?0: Ignore triggers, start running immediately after setting RUN bit?1: After RUN bit is set wait for a positive edge on the selected trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>Set to start executing the waveform (may need to wait for a trigger). Clear to stop this UAB half. When RUN=0 all dynamic switches are forced open.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_STAT1</name>
          <description>Status Current SRAM counter and comparator</description>
          <addressOffset>0x4034037C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CURR_STEP</name>
              <description>Current step executed from the SRAM</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP</name>
              <description>Current comparator status</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_SUBSAMPLE</name>
              <description>Current value of the subsampling down counter. The Valid is suppressed when SUBSAMPLE_CUR!=0.</description>
              <lsb>24</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM10</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM11</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340384</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM12</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM13</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x4034038C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM14</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340390</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM15</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340394</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM16</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x40340398</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM17</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x4034039C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM18</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM19</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM110</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM111</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM112</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM113</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM114</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_SRAM115</name>
          <description>Waveform SRAM for half 1 of the UAB</description>
          <addressOffset>0x403403BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAVE_STEP</name>
              <description>one step of the clocking waveform sequence</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DECM_CTRL</name>
          <description>Global decimator control</description>
          <addressOffset>0x40340400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>- 0: Decimator disabled (independent of UAB)?- 1: Decimator enabled (independent of UAB)</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_CTRL</name>
          <description>decimator0 control</description>
          <addressOffset>0x40340404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC0_START</name>
              <description>Start decimator, in incremental mode, this bit is cleared by HW when done. If DSI trigger enable is set then only start after a DSI trigger.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_MODE</name>
              <description>Operation mode?0: Incremental (one-shot) operation?1: Continuous operation</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_SEL</name>
              <description>Source select</description>
              <lsb>4</lsb>
              <msb>5</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UAB_H0</name>
                  <description>Comparator output from Half0 of this UAB</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UAB_H1</name>
                  <description>Comparator output from Half1 of this UAB</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>No description available</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC0_TYPE</name>
              <description>decimator type (filter order)</description>
              <lsb>6</lsb>
              <msb>7</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINC1</name>
                  <description>first order</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINC2</name>
                  <description>second order</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINC3</name>
                  <description>third order, this uses half of decimator1, therefore cannot be combined with dc1_mode SINC2</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>reserved</name>
                  <description>reserved value, do not use</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC0_SHIFT</name>
              <description>shift the result right by specified amount, legal range 0..16</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_RATIO</name>
              <description>decimation ratio = DC0_RATIO+1, range 1..512</description>
              <lsb>16</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_TRIG</name>
          <description>decimator0 trigger control</description>
          <addressOffset>0x40340408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC0_TRIG_SEL</name>
              <description>Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-11 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC0_DSI_TRIG_EN</name>
              <description>Decimator DSI trigger input Enable?0: Ignore decimator DSI trigger input?1: Wait for positive edge on selected DSI trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_OVR</name>
          <description>decimator 0 overflow control</description>
          <addressOffset>0x4034040C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC0_OVR_CORR_LOC</name>
              <description>Bit location for overflow correction. This should be set to FILTER_ORDER*log2(DC0_RATIO)</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_A0</name>
          <description>decimator0 accumulator 0</description>
          <addressOffset>0x40340410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A0</name>
              <description>24-bit sign extended accumulator0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_A1</name>
          <description>decimator0 accumulator 1</description>
          <addressOffset>0x40340414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A1</name>
              <description>24-bit sign extended accumulator1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_DEC_CNT</name>
          <description>decimator0 decimation counter</description>
          <addressOffset>0x40340418</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>INT_CNT</name>
              <description>integration/decimation down counter</description>
              <lsb>0</lsb>
              <msb>8</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DIFF_CNT</name>
              <description>differentiation down counter</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_TMP</name>
          <description>decimator0 temporary value for differentiator</description>
          <addressOffset>0x4034041C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TMP</name>
              <description>24-bit sign extended differentiator temporary value status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_D0</name>
          <description>decimator0 differentiator 0</description>
          <addressOffset>0x40340420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D0</name>
              <description>24-bit sign extended differentiator 0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_D1</name>
          <description>decimator0 differentiator 1</description>
          <addressOffset>0x40340424</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D1</name>
              <description>24-bit sign extended differentiator 1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC0_RES</name>
          <description>decimator0 result</description>
          <addressOffset>0x40340428</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RES</name>
              <description>24-bit sign extended result</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_CTRL</name>
          <description>decimator1 control</description>
          <addressOffset>0x40340434</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC1_START</name>
              <description>Start decimator, in incremental mode, this bit is cleared by HW when done. If DSI trigger enable is set then only start after a DSI trigger.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_MODE</name>
              <description>Operation mode?0: Incremental (one-shot) operation?1: Continuous operation</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_SEL</name>
              <description>Source select</description>
              <lsb>4</lsb>
              <msb>5</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UAB_H0</name>
                  <description>Comparator output from Half0 of this UAB</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UAB_H1</name>
                  <description>Comparator output from Half1 of this UAB</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>No description available</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC1_TYPE</name>
              <description>decimator type (filter order)</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINC1</name>
                  <description>first order</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINC2</name>
                  <description>second order</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC01_CHAIN</name>
              <description>Chain decimator0 and decimator1</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_SHIFT</name>
              <description>shift the result right by specified amount, legal range 0..16</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_RATIO</name>
              <description>decimation ratio = DC1_RATIO+1, range 1..512</description>
              <lsb>16</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_TRIG</name>
          <description>decimator1 trigger control</description>
          <addressOffset>0x40340438</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC1_TRIG_SEL</name>
              <description>Trigger select?0=UAB0 half 0 trigger output?1=UAB0 half 1 trigger output?2=UAB1 half 0 trigger output?3=UAB1 half 1 trigger output?4=UAB2 half 0 trigger output?5=UAB2 half 1 trigger output?6=UAB3 half 0 trigger output?7=UAB3 half 1 trigger output?8-30 = generic trigger inputs 0-22?31=SAR trigger output?For PASS4B  only values 0-1 and 8-11 and 31 are legal.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DC1_DSI_TRIG_EN</name>
              <description>Decimator DSI trigger input Enable?0: Ignore decimator DSI trigger input?1: Wait for positive edge on selected DSI trigger input</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_OVR</name>
          <description>decimator 1 overflow control</description>
          <addressOffset>0x4034043C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DC1_OVR_CORR_LOC</name>
              <description>Bit location for overflow correction. This should be set to FILTER_ORDER*log2(DC1_RATIO)</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_A0</name>
          <description>decimator1 accumulator 0</description>
          <addressOffset>0x40340440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A0</name>
              <description>27-bit sign extended accumulator0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_A1</name>
          <description>decimator1 accumulator 1</description>
          <addressOffset>0x40340444</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>A1</name>
              <description>27-bit sign extended accumulator1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_DEC_CNT</name>
          <description>decimator1 decimation counter</description>
          <addressOffset>0x40340448</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>INT_CNT</name>
              <description>integration/decimation down counter</description>
              <lsb>0</lsb>
              <msb>8</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DIFF_CNT</name>
              <description>differentiation down counter</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_TMP</name>
          <description>decimator1 temporary value for differentiator</description>
          <addressOffset>0x4034044C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TMP</name>
              <description>27-bit sign extended differentiator temporary value status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_D0</name>
          <description>decimator1 differentiator 0</description>
          <addressOffset>0x40340450</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D0</name>
              <description>27-bit sign extended differentiator 0 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_D1</name>
          <description>decimator1 differentiator 1</description>
          <addressOffset>0x40340454</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>D1</name>
              <description>27-bit sign extended differentiator 1 status</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_DC1_RES</name>
          <description>decimator1 result</description>
          <addressOffset>0x40340458</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RES</name>
              <description>27-bit sign extended result</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_TRIM0</name>
          <description>Trim for attenuation cap half0</description>
          <addressOffset>0x40340F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CBTC0_VAL</name>
              <description>Cap B Trim 0 Value?Trim attenuation cap in branch B for DAC correctness</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CCTC0_VAL</name>
              <description>Cap C Trim 0 Value?Do not measure value, instead use same value as for CBTC0_VAL</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_CAP_TRIM1</name>
          <description>Trim for attenuation cap half1</description>
          <addressOffset>0x40340F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CBTC1_VAL</name>
              <description>Cap B Trim 1 Value?Trim attenuation cap in branch B for DAC correctness</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CCTC1_VAL</name>
              <description>Cap C Trim 1 Value?Do not measure value, instead use same value as for CBTC1_VAL</description>
              <lsb>8</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA_TRIM0</name>
          <description>Trim for opamp and buffers half0</description>
          <addressOffset>0x40340F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA0_OFFSET</name>
              <description>Opamp offset trim</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF0_OFFSET</name>
              <description>Reference buffer offset trim</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND0_OFFSET</name>
              <description>Agnd buffer offset trim</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UAB_OA_TRIM1</name>
          <description>Trim for opamp and buffers half1</description>
          <addressOffset>0x40340F0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA1_OFFSET</name>
              <description>Opamp offset trim</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF1_OFFSET</name>
              <description>Reference buffer offset trim</description>
              <lsb>8</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AGND1_OFFSET</name>
              <description>Agnd buffer offset trim</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>engine_sensor_adc_FILTERAGND2SAR_BUFFER</name>
      <description>OpAmp</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTB_CTRL</name>
          <description>Global CTB IP and power control</description>
          <addressOffset>0x40300000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>Selects component behavior in DeepSleep power mode</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>CTB IP disabled off during DeepSleep power mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Selects component behavior in DeepSleep power mode</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>CTB IP disabled (put analog in power down, open all switches)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>CTB IP enabledCTB IP enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES_CTRL</name>
          <description>Opamp and resistor control</description>
          <addressOffset>0x40300004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA_PWR_MODE</name>
              <description>Selects power for opamp</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low power</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium power</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High power</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_DRIVE_STR_SEL</name>
              <description>Opamp output strenght select</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Cy1x</name>
                  <description>Internal only</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Cy10x</name>
                  <description>Output to pin</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA_PUMP_EN</name>
              <description>Selects pump</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Pump disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Pump enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_COMP_TRIM</name>
          <description>Opamp Compenation Capacitor Trim</description>
          <addressOffset>0x40300F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA_COMP_TRIM</name>
              <description>Opamp Compenation Capacitor Trim</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH_SPEED</name>
                  <description>High Speed</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BALANCED</name>
                  <description>Balanced</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH_STABILITY</name>
                  <description>High Stability</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>engine_vref_buf</name>
      <description>OpAmp</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTB_CTRL</name>
          <description>Global CTB IP and power control</description>
          <addressOffset>0x40310000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>Selects component behavior in DeepSleep power mode</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>CTB IP disabled off during DeepSleep power mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Selects component behavior in DeepSleep power mode</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>CTB IP disabled (put analog in power down, open all switches)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>CTB IP enabledCTB IP enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES_CTRL</name>
          <description>Opamp and resistor control</description>
          <addressOffset>0x40310008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA_PWR_MODE</name>
              <description>Selects power for opamp</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low power</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium power</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High power</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_DRIVE_STR_SEL</name>
              <description>Opamp output strenght select</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Cy1x</name>
                  <description>Internal only</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Cy10x</name>
                  <description>Output to pin</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA_PUMP_EN</name>
              <description>Selects pump</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Pump disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Pump enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_COMP_TRIM</name>
          <description>Opamp Compenation Capacitor Trim</description>
          <addressOffset>0x40310F14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA_COMP_TRIM</name>
              <description>Opamp Compenation Capacitor Trim</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH_SPEED</name>
                  <description>High Speed</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BALANCED</name>
                  <description>Balanced</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH_STABILITY</name>
                  <description>High Stability</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>engine_sensor_uart</name>
      <description>Serial Communication Block</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>Cy_CTRL</name>
          <description>Generic control register</description>
          <addressOffset>0x40080000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>Serial interface bit period oversampling factor expressed in lP clock cycles. Used for SPI and UART functionality. OVS + 1 IP clock cycles constitute a single serial interface clock/bit cycle.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI).In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>Determines the number of bits per FIFO data element: '0' - 16-bit FIFO data elements (FIFO entries 8), '1' - 8-bit FIFO data elements (FIFO entries 16). Setting data elemelents to 8-bits doubles the amount of FIFO entries.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').his field is used in the I2C mode.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description> If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0')</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Mode of operation: I2C = 0, SPI = 1, UART = 2</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0').</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_SPI_CTRL</name>
          <description>SPI control register</description>
          <addressOffset>0x40080020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0').</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode. When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit. When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Only applicable in SPI Motorola submode. Indicates the clock phase.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Only applicable in SPI Motorola submode. Indicates the clock polarity.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Only applicable in master mode. Changes the SCLK edge on which MISO is captured.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Enables SCLK generation continuiusly by master regars data is avaiable in TX FIFO or not.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity of SS0.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity of SS1.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity of SS2.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity of SS3.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Submode of SPI operation: Motorola = 0, Texas Instruments = 1, National Semiconducturs = 2.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_SELECT</name>
              <description>Selects one of the four SPI slave select signals: SS0 = 0, SS1 = 1 , SS2 = 2, SS3 = 3.</description>
              <lsb>26</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_SPI_STATUS</name>
          <description>SPI status register</description>
          <addressOffset>0x40080024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_UART_CTRL</name>
          <description>UART control register</description>
          <addressOffset>0x40080040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Submode of UART operation: Standard = 0, Smart Card = 1, IrDA = 2.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_UART_TX_CTRL</name>
          <description>UART transmitter control register</description>
          <addressOffset>0x40080044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>STOP_BTIS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods.</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_UART_RX_CTRL</name>
          <description>UART receiver control register</description>
          <addressOffset>0x40080048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods.</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERR</name>
              <description>Behaviour when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERR</name>
              <description>Behaviour when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'.</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break.</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_UART_FLOW_CTRL</name>
          <description>UART flow control register</description>
          <addressOffset>0x40080050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a RTS signal is activated. Setting this field to 0 disables RTS generation.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal</description>
              <lsb>24</lsb>
              <msb>24</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal by the UART transmitter</description>
              <lsb>25</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_I2C_CTRL</name>
          <description>I2C control register</description>
          <addressOffset>0x40080060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period</description>
              <lsb>4</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element byte the master is immediately NACK'd when the receiver FIFO is full. When '0', clock stretching is used instead (till the receiver FIFO is no longer full).</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>When '1', a received address by the slave is immediately ACK'd when the receiver FIFO is not full</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description> When '1' a received data element byte the slave is immediately NACK'd when the receiver FIFO is full. When '1' clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_I2C_STATUS</name>
          <description>I2C status register</description>
          <addressOffset>0x40080064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1').</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0'.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_I2C_M_CMD</name>
          <description>I2C master command register</description>
          <addressOffset>0x40080068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. When this action is performed, the hardware sets this field to '0'.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>M_IDLE_START</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). When this action is performed, the hardware sets this field to '0'.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. This command has a higher priority than I2C_M_CMD.M_START: in situations where both a STOP and a REPEATED START could be transmitted, M_STOP takes precedence over M_START.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_I2C_S_CMD</name>
          <description>I2C slave command register</description>
          <addressOffset>0x4008006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_I2C_CFG</name>
          <description>I2C fitler trimm register</description>
          <addressOffset>0x40080070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>No description available</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>No description available</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>No description available</description>
              <lsb>8</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>No description available</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>No description available</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>No description available</description>
              <lsb>18</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>No description available</description>
              <lsb>20</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>No description available</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_TX_CTRL</name>
          <description>Transmitter control register</description>
          <addressOffset>0x40080200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Data frame width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control register</description>
          <addressOffset>0x40080204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the amount of this field, a transmitter trigger event is generated.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status register</description>
          <addressOffset>0x40080208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to 8.</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0')</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_TX_FIFO_WR</name>
          <description>Transmitter FIFO write register</description>
          <addressOffset>0x40080240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_RX_CTRL</name>
          <description>Receiver control register</description>
          <addressOffset>0x40080300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Data frame width. DATA_WIDTH + 1 is the expected amount of bits in received data frame.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1').</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_RX_FIFO_CTRL</name>
          <description>Receiver FIFO control register</description>
          <addressOffset>0x40080304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the amount of this field, a receiver trigger event is generated.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_RX_FIFO_STATUS</name>
          <description>Receiver FIFO status registerS</description>
          <addressOffset>0x40080308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to 8.</description>
              <lsb>0</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0').</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <lsb>24</lsb>
              <msb>28</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_RX_MATCH</name>
          <description>Slave address and mask register</description>
          <addressOffset>0x40080310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address. For UART multi-processor mode all eight bits a reused. For I2C, bit 0 of the register is not used.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a 8 bit mask that specifies which of the ADDR field bits in the SCB_RX_MATCH_ADDR register take part in the matching of the slave address.</description>
              <lsb>16</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_RX_FIFO_RD</name>
          <description>Receiver FIFO read register</description>
          <addressOffset>0x40080340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x40080E00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MASTER</name>
              <description>Master interrupt active.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave interrupt active.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request register</description>
          <addressOffset>0x40080E80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match). Only used when EC_AM is '1'.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask register</description>
          <addressOffset>0x40080E88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_I2C_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked register</description>
          <addressOffset>0x40080E8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request register</description>
          <addressOffset>0x40080EC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask register</description>
          <addressOffset>0x40080EC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked register</description>
          <addressOffset>0x40080ECC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_M</name>
          <description>Master interrupt request register.</description>
          <addressOffset>0x40080F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_LOST_ARB</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent and the transmit FIFO is empty.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_M_SET</name>
          <description>Master interrupt set request register</description>
          <addressOffset>0x40080F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_LOST_ARB</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_M_MASK</name>
          <description>Master interrupt mask register</description>
          <addressOffset>0x40080F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_LOST_ARB</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_M_MASKED</name>
          <description>Master interrupt masked request register</description>
          <addressOffset>0x40080F0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_LOST_ARB</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_S</name>
          <description>Slave interrupt request register</description>
          <addressOffset>0x40080F40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1').</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data).</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data).</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed).Set to '1', when STOP or REPEATED START event is detected.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition).</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_S_SET</name>
          <description>Slave interrupt set request register</description>
          <addressOffset>0x40080F44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_S_MASK</name>
          <description>Slave interrupt mask register</description>
          <addressOffset>0x40080F48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_S_MASKED</name>
          <description>Slave interrupt masked register</description>
          <addressOffset>0x40080F4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_TX</name>
          <description>Transmitter interrupt request register</description>
          <addressOffset>0x40080F80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TRIGGER_LEVEL in SCB_TX_FIFO_CTL.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO; i.e. EMPTY is '1'. Set to '1', when event is detected.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. </description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_TX_SET</name>
          <description>Transmitter interrupt set request register</description>
          <addressOffset>0x40080F84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_TX_MASK</name>
          <description>Transmitter interrupt mask request register</description>
          <addressOffset>0x40080F88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request register</description>
          <addressOffset>0x40080F8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_RX</name>
          <description>Receiver interrupt request register</description>
          <addressOffset>0x40080FC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in SCB_RX_FIFO_CTL.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO is full.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baud rate detection is completed.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_RX_SET</name>
          <description>Receiver interrupt set request register</description>
          <addressOffset>0x40080FC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_RX_MASK</name>
          <description>Receiver interrupt mask register</description>
          <addressOffset>0x40080FC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_RX_MASKED</name>
          <description>Receiver interrupt masked register</description>
          <addressOffset>0x40080FCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERR</name>
              <description>Logical and of corresponding request and mask bits</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERR</name>
              <description>Logical and of corresponding request and mask bits</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>engine_sensor_pga</name>
      <description>PGA</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Global CTB IP and power control</description>
          <addressOffset>0x40310000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>Selects component behavior in DeepSleep power mode</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>CTB IP disabled off during DeepSleep power mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Selects component behavior in DeepSleep power mode</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>CTB IP disabled (put analog in power down, open all switches)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>CTB IP enabledCTB IP enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES_CTRL</name>
          <description>Opamp and resistor control</description>
          <addressOffset>0x40310004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA_PWR_MODE</name>
              <description>Selects power for opamp</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low power</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium power</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High power</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA_DRIVE_STR_SEL</name>
              <description>Opamp output strenght select</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Cy1x</name>
                  <description>Internal only</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Cy10x</name>
                  <description>Output to pin</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA_PUMP_EN</name>
              <description>Selects pump</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Pump disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Pump enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_TAP</name>
              <description>Selects PGA gain (resistor tap point)</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GAIN_1_0</name>
                  <description>disconnect resistor</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_1_4</name>
                  <description>No description available</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_2_0</name>
                  <description>No description available</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_2_8</name>
                  <description>No description available</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_4_0</name>
                  <description>No description available</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_5_8</name>
                  <description>No description available</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_8_0</name>
                  <description>No description available</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_10_7</name>
                  <description>No description available</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_16_0</name>
                  <description>No description available</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_21_3</name>
                  <description>No description available</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GAIN_32_0</name>
                  <description>max. gain</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_SWAP</name>
              <description>Swaps Top and Bottom resistor value</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWAPPED</name>
                  <description>Top and Bottom are swapped</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_SW</name>
          <description>Opamp switch control</description>
          <addressOffset>0x40310080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RES0_R6</name>
              <description>Resistor bottom to VSSA</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>No description available</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>No description available</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_COMP_TRIM</name>
          <description>Opamp Compenation Capacitor Trim</description>
          <addressOffset>0x40310F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>OA_COMP_TRIM</name>
              <description>Opamp Compenation Capacitor Trim</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH_SPEED</name>
                  <description>High Speed</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BALANCED</name>
                  <description>Balanced</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH_STABILITY</name>
                  <description>High Stability</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>