ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 1


   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"arm_fir_sparse_q15.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.arm_fir_sparse_q15,"ax",%progbits
  18              		.align	2
  19              		.global	arm_fir_sparse_q15
  20              		.code	16
  21              		.thumb_func
  22              		.type	arm_fir_sparse_q15, %function
  23              	arm_fir_sparse_q15:
  24              	.LFB82:
  25              		.file 1 "Source\\FilteringFunctions\\arm_fir_sparse_q15.c"
   1:Source\FilteringFunctions/arm_fir_sparse_q15.c **** /* ----------------------------------------------------------------------
   2:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Project:      CMSIS DSP Library
   3:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Title:        arm_fir_sparse_q15.c
   4:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Description:  Q15 sparse FIR filter processing function
   5:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  *
   6:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * $Date:        27. January 2017
   7:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * $Revision:    V.1.5.1
   8:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  *
   9:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Target Processor: Cortex-M cores
  10:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * -------------------------------------------------------------------- */
  11:Source\FilteringFunctions/arm_fir_sparse_q15.c **** /*
  12:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  *
  14:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * SPDX-License-Identifier: Apache-2.0
  15:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  *
  16:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * not use this file except in compliance with the License.
  18:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * You may obtain a copy of the License at
  19:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  *
  20:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  *
  22:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Unless required by applicable law or agreed to in writing, software
  23:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * See the License for the specific language governing permissions and
  26:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * limitations under the License.
  27:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  */
  28:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  29:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #include "arm_math.h"
  30:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  31:Source\FilteringFunctions/arm_fir_sparse_q15.c **** /**
  32:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @addtogroup FIR_Sparse
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 2


  33:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @{
  34:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  */
  35:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  36:Source\FilteringFunctions/arm_fir_sparse_q15.c **** /**
  37:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @brief Processing function for the Q15 sparse FIR filter.
  38:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @param[in]  *S           points to an instance of the Q15 sparse FIR structure.
  39:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @param[in]  *pSrc        points to the block of input data.
  40:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @param[out] *pDst        points to the block of output data
  41:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
  42:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
  43:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @param[in]  blockSize    number of input samples to process per call.
  44:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * @return none.
  45:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  *
  46:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * <b>Scaling and Overflow Behavior:</b>
  47:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * \par
  48:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * The function is implemented using an internal 32-bit accumulator.
  49:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * The 1.15 x 1.15 multiplications yield a 2.30 result and these are added to a 2.30 accumulator.
  50:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * Thus the full precision of the multiplications is maintained but there is only a single guard bi
  51:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * If the accumulator result overflows it will wrap around rather than saturate.
  52:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * After all multiply-accumulates are performed, the 2.30 accumulator is truncated to 2.15 format a
  53:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  * In order to avoid overflows the input signal or coefficients must be scaled down by log2(numTaps
  54:Source\FilteringFunctions/arm_fir_sparse_q15.c ****  */
  55:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  56:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  57:Source\FilteringFunctions/arm_fir_sparse_q15.c **** void arm_fir_sparse_q15(
  58:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   arm_fir_sparse_instance_q15 * S,
  59:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t * pSrc,
  60:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t * pDst,
  61:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t * pScratchIn,
  62:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q31_t * pScratchOut,
  63:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   uint32_t blockSize)
  64:Source\FilteringFunctions/arm_fir_sparse_q15.c **** {
  26              		.loc 1 64 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 7, -8
  31              		.cfi_offset 14, -4
  32 0002 C6B0     		sub	sp, sp, #280
  33              		.cfi_def_cfa_offset 288
  34 0004 00AF     		add	r7, sp, #0
  35              		.cfi_def_cfa_register 7
  36 0006 F860     		str	r0, [r7, #12]
  37 0008 B960     		str	r1, [r7, #8]
  38 000a 7A60     		str	r2, [r7, #4]
  39 000c 3B60     		str	r3, [r7]
  65:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  66:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t *pState = S->pState;                     /* State pointer */
  40              		.loc 1 66 0
  41 000e FB68     		ldr	r3, [r7, #12]
  42 0010 5B68     		ldr	r3, [r3, #4]
  43 0012 F422     		mov	r2, #244
  44 0014 BA18     		add	r2, r7, r2
  45 0016 1360     		str	r3, [r2]
  67:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t *pIn = pSrc;                             /* Working pointer for input */
  46              		.loc 1 67 0
  47 0018 BB68     		ldr	r3, [r7, #8]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 3


  48 001a F022     		mov	r2, #240
  49 001c BA18     		add	r2, r7, r2
  50 001e 1360     		str	r3, [r2]
  68:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t *pOut = pDst;                            /* Working pointer for output */
  51              		.loc 1 68 0
  52 0020 7B68     		ldr	r3, [r7, #4]
  53 0022 8A22     		mov	r2, #138
  54 0024 5200     		lsl	r2, r2, #1
  55 0026 BA18     		add	r2, r7, r2
  56 0028 1360     		str	r3, [r2]
  69:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
  57              		.loc 1 69 0
  58 002a FB68     		ldr	r3, [r7, #12]
  59 002c 9B68     		ldr	r3, [r3, #8]
  60 002e 8822     		mov	r2, #136
  61 0030 5200     		lsl	r2, r2, #1
  62 0032 BA18     		add	r2, r7, r2
  63 0034 1360     		str	r3, [r2]
  70:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t *px;                                     /* Temporary pointers for scratch buffer */
  71:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t *pb = pScratchIn;                        /* Temporary pointers for scratch buffer */
  64              		.loc 1 71 0
  65 0036 3B68     		ldr	r3, [r7]
  66 0038 EC22     		mov	r2, #236
  67 003a BA18     		add	r2, r7, r2
  68 003c 1360     		str	r3, [r2]
  72:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t *py = pState;                            /* Temporary pointers for state buffer */
  69              		.loc 1 72 0
  70 003e F423     		mov	r3, #244
  71 0040 FB18     		add	r3, r7, r3
  72 0042 1B68     		ldr	r3, [r3]
  73 0044 E822     		mov	r2, #232
  74 0046 BA18     		add	r2, r7, r2
  75 0048 1360     		str	r3, [r2]
  73:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the n
  76              		.loc 1 73 0
  77 004a FB68     		ldr	r3, [r7, #12]
  78 004c 1B69     		ldr	r3, [r3, #16]
  79 004e 8422     		mov	r2, #132
  80 0050 5200     		lsl	r2, r2, #1
  81 0052 BA18     		add	r2, r7, r2
  82 0054 1360     		str	r3, [r2]
  74:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
  83              		.loc 1 74 0
  84 0056 FB68     		ldr	r3, [r7, #12]
  85 0058 9B89     		ldrh	r3, [r3, #12]
  86 005a 1A1C     		mov	r2, r3
  87 005c 9223     		mov	r3, #146
  88 005e 5B00     		lsl	r3, r3, #1
  89 0060 FB18     		add	r3, r7, r3
  90 0062 1B68     		ldr	r3, [r3]
  91 0064 D318     		add	r3, r2, r3
  92 0066 E422     		mov	r2, #228
  93 0068 BA18     		add	r2, r7, r2
  94 006a 1360     		str	r3, [r2]
  75:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   uint16_t numTaps = S->numTaps;                 /* Filter order */
  95              		.loc 1 75 0
  96 006c E223     		mov	r3, #226
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 4


  97 006e FB18     		add	r3, r7, r3
  98 0070 FA68     		ldr	r2, [r7, #12]
  99 0072 1288     		ldrh	r2, [r2]
 100 0074 1A80     		strh	r2, [r3]
  76:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   int32_t readIndex;                             /* Read index of the state buffer */
  77:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   uint32_t tapCnt, blkCnt;                       /* loop counters */
  78:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q15_t coeff = *pCoeffs++;                      /* Read the first coefficient value */
 101              		.loc 1 78 0
 102 0076 8823     		mov	r3, #136
 103 0078 5B00     		lsl	r3, r3, #1
 104 007a FB18     		add	r3, r7, r3
 105 007c 1B68     		ldr	r3, [r3]
 106 007e 9A1C     		add	r2, r3, #2
 107 0080 8821     		mov	r1, #136
 108 0082 4900     		lsl	r1, r1, #1
 109 0084 7918     		add	r1, r7, r1
 110 0086 0A60     		str	r2, [r1]
 111 0088 FE22     		mov	r2, #254
 112 008a BA18     		add	r2, r7, r2
 113 008c 1B88     		ldrh	r3, [r3]
 114 008e 1380     		strh	r3, [r2]
  79:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q31_t *pScr2 = pScratchOut;                    /* Working pointer for pScratchOut */
 115              		.loc 1 79 0
 116 0090 9023     		mov	r3, #144
 117 0092 5B00     		lsl	r3, r3, #1
 118 0094 FB18     		add	r3, r7, r3
 119 0096 1B68     		ldr	r3, [r3]
 120 0098 F822     		mov	r2, #248
 121 009a BA18     		add	r2, r7, r2
 122 009c 1360     		str	r3, [r2]
  80:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  81:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  82:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #if defined (ARM_MATH_DSP)
  83:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  84:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
  85:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  86:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   q31_t in1, in2;                                /* Temporary variables */
  87:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  88:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  89:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* BlockSize of Input samples are copied into the state buffer */
  90:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* StateIndex points to the starting position to write in the state buffer */
  91:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);
  92:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  93:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Loop over the number of taps. */
  94:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   tapCnt = numTaps;
  95:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  96:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
  97:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
  98:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
  99:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Wraparound of readIndex */
 100:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   if (readIndex < 0)
 101:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 102:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     readIndex += (int32_t) delaySize;
 103:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 104:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 105:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Working pointer for state buffer is updated */
 106:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   py = pState;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 5


 107:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 108:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* blockSize samples are read from the state buffer */
 109:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   arm_circularRead_q15(py, delaySize, &readIndex, 1,
 110:Source\FilteringFunctions/arm_fir_sparse_q15.c ****                        pb, pb, blockSize, 1, blockSize);
 111:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 112:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Working pointer for the scratch buffer of state values */
 113:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   px = pb;
 114:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 115:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Working pointer for scratch buffer of output values */
 116:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   pScratchOut = pScr2;
 117:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 118:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Loop over the blockSize. Unroll by a factor of 4.
 119:Source\FilteringFunctions/arm_fir_sparse_q15.c ****    * Compute 4 multiplications at a time. */
 120:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   blkCnt = blockSize >> 2;
 121:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 122:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (blkCnt > 0u)
 123:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 124:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Perform multiplication and store in the scratch buffer */
 125:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 126:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 127:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 128:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 129:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 130:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Decrement the loop counter */
 131:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt--;
 132:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 133:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 134:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* If the blockSize is not a multiple of 4,
 135:Source\FilteringFunctions/arm_fir_sparse_q15.c ****    * compute the remaining samples */
 136:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   blkCnt = blockSize % 0x4u;
 137:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 138:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (blkCnt > 0u)
 139:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 140:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Perform multiplication and store in the scratch buffer */
 141:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 142:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 143:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Decrement the loop counter */
 144:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt--;
 145:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 146:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 147:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Load the coefficient value and
 148:Source\FilteringFunctions/arm_fir_sparse_q15.c ****    * increment the coefficient buffer for the next set of state values */
 149:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   coeff = *pCoeffs++;
 150:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 151:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 152:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
 153:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 154:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Wraparound of readIndex */
 155:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   if (readIndex < 0)
 156:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 157:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     readIndex += (int32_t) delaySize;
 158:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 159:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 160:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Loop over the number of taps. */
 161:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   tapCnt = (uint32_t) numTaps - 2u;
 162:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 163:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (tapCnt > 0u)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 6


 164:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 165:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Working pointer for state buffer is updated */
 166:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     py = pState;
 167:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 168:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* blockSize samples are read from the state buffer */
 169:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     arm_circularRead_q15(py, delaySize, &readIndex, 1,
 170:Source\FilteringFunctions/arm_fir_sparse_q15.c ****                          pb, pb, blockSize, 1, blockSize);
 171:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 172:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Working pointer for the scratch buffer of state values */
 173:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     px = pb;
 174:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 175:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Working pointer for scratch buffer of output values */
 176:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     pScratchOut = pScr2;
 177:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 178:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Loop over the blockSize. Unroll by a factor of 4.
 179:Source\FilteringFunctions/arm_fir_sparse_q15.c ****      * Compute 4 MACS at a time. */
 180:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt = blockSize >> 2;
 181:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 182:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     while (blkCnt > 0u)
 183:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     {
 184:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       /* Perform Multiply-Accumulate */
 185:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       *pScratchOut++ += (q31_t) * px++ * coeff;
 186:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       *pScratchOut++ += (q31_t) * px++ * coeff;
 187:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       *pScratchOut++ += (q31_t) * px++ * coeff;
 188:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       *pScratchOut++ += (q31_t) * px++ * coeff;
 189:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 190:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       /* Decrement the loop counter */
 191:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       blkCnt--;
 192:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     }
 193:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 194:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* If the blockSize is not a multiple of 4,
 195:Source\FilteringFunctions/arm_fir_sparse_q15.c ****      * compute the remaining samples */
 196:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt = blockSize % 0x4u;
 197:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 198:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     while (blkCnt > 0u)
 199:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     {
 200:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       /* Perform Multiply-Accumulate */
 201:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       *pScratchOut++ += (q31_t) * px++ * coeff;
 202:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 203:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       /* Decrement the loop counter */
 204:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       blkCnt--;
 205:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     }
 206:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 207:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Load the coefficient value and
 208:Source\FilteringFunctions/arm_fir_sparse_q15.c ****      * increment the coefficient buffer for the next set of state values */
 209:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     coeff = *pCoeffs++;
 210:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 211:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 212:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
 213:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 214:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Wraparound of readIndex */
 215:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     if (readIndex < 0)
 216:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     {
 217:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       readIndex += (int32_t) delaySize;
 218:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     }
 219:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 220:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Decrement the tap loop counter */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 7


 221:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     tapCnt--;
 222:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 223:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 224:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Compute last tap without the final read of pTapDelay */
 225:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 226:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Working pointer for state buffer is updated */
 227:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	py = pState;
 228:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 229:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* blockSize samples are read from the state buffer */
 230:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	arm_circularRead_q15(py, delaySize, &readIndex, 1,
 231:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 											 pb, pb, blockSize, 1, blockSize);
 232:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 233:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Working pointer for the scratch buffer of state values */
 234:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	px = pb;
 235:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 236:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Working pointer for scratch buffer of output values */
 237:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	pScratchOut = pScr2;
 238:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 239:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Loop over the blockSize. Unroll by a factor of 4.
 240:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	 * Compute 4 MACS at a time. */
 241:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	blkCnt = blockSize >> 2;
 242:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 243:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	while (blkCnt > 0u)
 244:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	{
 245:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		/* Perform Multiply-Accumulate */
 246:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		*pScratchOut++ += (q31_t) * px++ * coeff;
 247:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		*pScratchOut++ += (q31_t) * px++ * coeff;
 248:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		*pScratchOut++ += (q31_t) * px++ * coeff;
 249:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		*pScratchOut++ += (q31_t) * px++ * coeff;
 250:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 251:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		/* Decrement the loop counter */
 252:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		blkCnt--;
 253:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	}
 254:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 255:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* If the blockSize is not a multiple of 4,
 256:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	 * compute the remaining samples */
 257:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	blkCnt = blockSize % 0x4u;
 258:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 259:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	while (blkCnt > 0u)
 260:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	{
 261:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		/* Perform Multiply-Accumulate */
 262:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		*pScratchOut++ += (q31_t) * px++ * coeff;
 263:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 264:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		/* Decrement the loop counter */
 265:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		blkCnt--;
 266:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	}
 267:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 268:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* All the output values are in pScratchOut buffer.
 269:Source\FilteringFunctions/arm_fir_sparse_q15.c ****      Convert them into 1.15 format, saturate and store in the destination buffer. */
 270:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Loop over the blockSize. */
 271:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   blkCnt = blockSize >> 2;
 272:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 273:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (blkCnt > 0u)
 274:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 275:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     in1 = *pScr2++;
 276:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     in2 = *pScr2++;
 277:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 8


 278:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #ifndef  ARM_MATH_BIG_ENDIAN
 279:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 280:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *__SIMD32(pOut)++ =
 281:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       __PKHBT((q15_t) __SSAT(in1 >> 15, 16), (q15_t) __SSAT(in2 >> 15, 16),
 282:Source\FilteringFunctions/arm_fir_sparse_q15.c ****               16);
 283:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 284:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #else
 285:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *__SIMD32(pOut)++ =
 286:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       __PKHBT((q15_t) __SSAT(in2 >> 15, 16), (q15_t) __SSAT(in1 >> 15, 16),
 287:Source\FilteringFunctions/arm_fir_sparse_q15.c ****               16);
 288:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 289:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
 290:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 291:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     in1 = *pScr2++;
 292:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 293:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     in2 = *pScr2++;
 294:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 295:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #ifndef  ARM_MATH_BIG_ENDIAN
 296:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 297:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *__SIMD32(pOut)++ =
 298:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       __PKHBT((q15_t) __SSAT(in1 >> 15, 16), (q15_t) __SSAT(in2 >> 15, 16),
 299:Source\FilteringFunctions/arm_fir_sparse_q15.c ****               16);
 300:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 301:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #else
 302:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 303:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *__SIMD32(pOut)++ =
 304:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       __PKHBT((q15_t) __SSAT(in2 >> 15, 16), (q15_t) __SSAT(in1 >> 15, 16),
 305:Source\FilteringFunctions/arm_fir_sparse_q15.c ****               16);
 306:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 307:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
 308:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 309:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 310:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt--;
 311:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 312:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 313:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 314:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* If the blockSize is not a multiple of 4,
 315:Source\FilteringFunctions/arm_fir_sparse_q15.c ****      remaining samples are processed in the below loop */
 316:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   blkCnt = blockSize % 0x4u;
 317:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 318:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (blkCnt > 0u)
 319:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 320:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pOut++ = (q15_t) __SSAT(*pScr2++ >> 15, 16);
 321:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt--;
 322:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 323:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 324:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #else
 325:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 326:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Run the below code for Cortex-M0 */
 327:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 328:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* BlockSize of Input samples are copied into the state buffer */
 329:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* StateIndex points to the starting position to write in the state buffer */
 330:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);
 123              		.loc 1 330 0
 124 009e E423     		mov	r3, #228
 125 00a0 FB18     		add	r3, r7, r3
 126 00a2 1A68     		ldr	r2, [r3]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 9


 127 00a4 FB68     		ldr	r3, [r7, #12]
 128 00a6 0233     		add	r3, r3, #2
 129 00a8 E821     		mov	r1, #232
 130 00aa 7918     		add	r1, r7, r1
 131 00ac 0968     		ldr	r1, [r1]
 132 00ae DC20     		mov	r0, #220
 133 00b0 3818     		add	r0, r7, r0
 134 00b2 0160     		str	r1, [r0]
 135 00b4 D821     		mov	r1, #216
 136 00b6 7918     		add	r1, r7, r1
 137 00b8 0A60     		str	r2, [r1]
 138 00ba D422     		mov	r2, #212
 139 00bc BA18     		add	r2, r7, r2
 140 00be 1360     		str	r3, [r2]
 141 00c0 0123     		mov	r3, #1
 142 00c2 D022     		mov	r2, #208
 143 00c4 BA18     		add	r2, r7, r2
 144 00c6 1360     		str	r3, [r2]
 145 00c8 F023     		mov	r3, #240
 146 00ca FB18     		add	r3, r7, r3
 147 00cc 1B68     		ldr	r3, [r3]
 148 00ce CC22     		mov	r2, #204
 149 00d0 BA18     		add	r2, r7, r2
 150 00d2 1360     		str	r3, [r2]
 151 00d4 0123     		mov	r3, #1
 152 00d6 C822     		mov	r2, #200
 153 00d8 BA18     		add	r2, r7, r2
 154 00da 1360     		str	r3, [r2]
 155 00dc 9223     		mov	r3, #146
 156 00de 5B00     		lsl	r3, r3, #1
 157 00e0 FB18     		add	r3, r7, r3
 158 00e2 1B68     		ldr	r3, [r3]
 159 00e4 C422     		mov	r2, #196
 160 00e6 BA18     		add	r2, r7, r2
 161 00e8 1360     		str	r3, [r2]
 162              	.LBB12:
 163              	.LBB13:
 164              		.file 2 ".\\Include/arm_math.h"
   1:.\Include/arm_math.h **** /* ----------------------------------------------------------------------
   2:.\Include/arm_math.h ****  * Project:      CMSIS DSP Library
   3:.\Include/arm_math.h ****  * Title:        arm_math.h
   4:.\Include/arm_math.h ****  * Description:  Public header file for CMSIS DSP Library
   5:.\Include/arm_math.h ****  *
   6:.\Include/arm_math.h ****  * $Date:        27. January 2017
   7:.\Include/arm_math.h ****  * $Revision:    V.1.5.1
   8:.\Include/arm_math.h ****  *
   9:.\Include/arm_math.h ****  * Target Processor: Cortex-M cores
  10:.\Include/arm_math.h ****  * -------------------------------------------------------------------- */
  11:.\Include/arm_math.h **** /*
  12:.\Include/arm_math.h ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:.\Include/arm_math.h ****  *
  14:.\Include/arm_math.h ****  * SPDX-License-Identifier: Apache-2.0
  15:.\Include/arm_math.h ****  *
  16:.\Include/arm_math.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:.\Include/arm_math.h ****  * not use this file except in compliance with the License.
  18:.\Include/arm_math.h ****  * You may obtain a copy of the License at
  19:.\Include/arm_math.h ****  *
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 10


  20:.\Include/arm_math.h ****  * www.apache.org/licenses/LICENSE-2.0
  21:.\Include/arm_math.h ****  *
  22:.\Include/arm_math.h ****  * Unless required by applicable law or agreed to in writing, software
  23:.\Include/arm_math.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:.\Include/arm_math.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:.\Include/arm_math.h ****  * See the License for the specific language governing permissions and
  26:.\Include/arm_math.h ****  * limitations under the License.
  27:.\Include/arm_math.h ****  */
  28:.\Include/arm_math.h **** 
  29:.\Include/arm_math.h **** /**
  30:.\Include/arm_math.h ****    \mainpage CMSIS DSP Software Library
  31:.\Include/arm_math.h ****    *
  32:.\Include/arm_math.h ****    * Introduction
  33:.\Include/arm_math.h ****    * ------------
  34:.\Include/arm_math.h ****    *
  35:.\Include/arm_math.h ****    * This user manual describes the CMSIS DSP software library,
  36:.\Include/arm_math.h ****    * a suite of common signal processing functions for use on Cortex-M processor based devices.
  37:.\Include/arm_math.h ****    *
  38:.\Include/arm_math.h ****    * The library is divided into a number of functions each covering a specific category:
  39:.\Include/arm_math.h ****    * - Basic math functions
  40:.\Include/arm_math.h ****    * - Fast math functions
  41:.\Include/arm_math.h ****    * - Complex math functions
  42:.\Include/arm_math.h ****    * - Filters
  43:.\Include/arm_math.h ****    * - Matrix functions
  44:.\Include/arm_math.h ****    * - Transforms
  45:.\Include/arm_math.h ****    * - Motor control functions
  46:.\Include/arm_math.h ****    * - Statistical functions
  47:.\Include/arm_math.h ****    * - Support functions
  48:.\Include/arm_math.h ****    * - Interpolation functions
  49:.\Include/arm_math.h ****    *
  50:.\Include/arm_math.h ****    * The library has separate functions for operating on 8-bit integers, 16-bit integers,
  51:.\Include/arm_math.h ****    * 32-bit integer and 32-bit floating-point values.
  52:.\Include/arm_math.h ****    *
  53:.\Include/arm_math.h ****    * Using the Library
  54:.\Include/arm_math.h ****    * ------------
  55:.\Include/arm_math.h ****    *
  56:.\Include/arm_math.h ****    * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> fold
  57:.\Include/arm_math.h ****    * - arm_cortexM7lfdp_math.lib (Cortex-M7, Little endian, Double Precision Floating Point Unit)
  58:.\Include/arm_math.h ****    * - arm_cortexM7bfdp_math.lib (Cortex-M7, Big endian, Double Precision Floating Point Unit)
  59:.\Include/arm_math.h ****    * - arm_cortexM7lfsp_math.lib (Cortex-M7, Little endian, Single Precision Floating Point Unit)
  60:.\Include/arm_math.h ****    * - arm_cortexM7bfsp_math.lib (Cortex-M7, Big endian and Single Precision Floating Point Unit on
  61:.\Include/arm_math.h ****    * - arm_cortexM7l_math.lib (Cortex-M7, Little endian)
  62:.\Include/arm_math.h ****    * - arm_cortexM7b_math.lib (Cortex-M7, Big endian)
  63:.\Include/arm_math.h ****    * - arm_cortexM4lf_math.lib (Cortex-M4, Little endian, Floating Point Unit)
  64:.\Include/arm_math.h ****    * - arm_cortexM4bf_math.lib (Cortex-M4, Big endian, Floating Point Unit)
  65:.\Include/arm_math.h ****    * - arm_cortexM4l_math.lib (Cortex-M4, Little endian)
  66:.\Include/arm_math.h ****    * - arm_cortexM4b_math.lib (Cortex-M4, Big endian)
  67:.\Include/arm_math.h ****    * - arm_cortexM3l_math.lib (Cortex-M3, Little endian)
  68:.\Include/arm_math.h ****    * - arm_cortexM3b_math.lib (Cortex-M3, Big endian)
  69:.\Include/arm_math.h ****    * - arm_cortexM0l_math.lib (Cortex-M0 / Cortex-M0+, Little endian)
  70:.\Include/arm_math.h ****    * - arm_cortexM0b_math.lib (Cortex-M0 / Cortex-M0+, Big endian)
  71:.\Include/arm_math.h ****    * - arm_ARMv8MBLl_math.lib (ARMv8M Baseline, Little endian)
  72:.\Include/arm_math.h ****    * - arm_ARMv8MMLl_math.lib (ARMv8M Mainline, Little endian)
  73:.\Include/arm_math.h ****    * - arm_ARMv8MMLlfsp_math.lib (ARMv8M Mainline, Little endian, Single Precision Floating Point U
  74:.\Include/arm_math.h ****    * - arm_ARMv8MMLld_math.lib (ARMv8M Mainline, Little endian, DSP instructions)
  75:.\Include/arm_math.h ****    * - arm_ARMv8MMLldfsp_math.lib (ARMv8M Mainline, Little endian, DSP instructions, Single Precisi
  76:.\Include/arm_math.h ****    *
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 11


  77:.\Include/arm_math.h ****    * The library functions are declared in the public file <code>arm_math.h</code> which is placed 
  78:.\Include/arm_math.h ****    * Simply include this file and link the appropriate library in the application and begin calling
  79:.\Include/arm_math.h ****    * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endi
  80:.\Include/arm_math.h ****    * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
  81:.\Include/arm_math.h ****    * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
  82:.\Include/arm_math.h ****    * For ARMv8M cores define pre processor MACRO ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
  83:.\Include/arm_math.h ****    * Set Pre processor MACRO __DSP_PRESENT if ARMv8M Mainline core supports DSP instructions.
  84:.\Include/arm_math.h ****    * 
  85:.\Include/arm_math.h ****    *
  86:.\Include/arm_math.h ****    * Examples
  87:.\Include/arm_math.h ****    * --------
  88:.\Include/arm_math.h ****    *
  89:.\Include/arm_math.h ****    * The library ships with a number of examples which demonstrate how to use the library functions
  90:.\Include/arm_math.h ****    *
  91:.\Include/arm_math.h ****    * Toolchain Support
  92:.\Include/arm_math.h ****    * ------------
  93:.\Include/arm_math.h ****    *
  94:.\Include/arm_math.h ****    * The library has been developed and tested with MDK-ARM version 5.14.0.0
  95:.\Include/arm_math.h ****    * The library is being tested in GCC and IAR toolchains and updates on this activity will be mad
  96:.\Include/arm_math.h ****    *
  97:.\Include/arm_math.h ****    * Building the Library
  98:.\Include/arm_math.h ****    * ------------
  99:.\Include/arm_math.h ****    *
 100:.\Include/arm_math.h ****    * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in t
 101:.\Include/arm_math.h ****    * - arm_cortexM_math.uvprojx
 102:.\Include/arm_math.h ****    *
 103:.\Include/arm_math.h ****    *
 104:.\Include/arm_math.h ****    * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecti
 105:.\Include/arm_math.h ****    *
 106:.\Include/arm_math.h ****    * Pre-processor Macros
 107:.\Include/arm_math.h ****    * ------------
 108:.\Include/arm_math.h ****    *
 109:.\Include/arm_math.h ****    * Each library project have differant pre-processor macros.
 110:.\Include/arm_math.h ****    *
 111:.\Include/arm_math.h ****    * - UNALIGNED_SUPPORT_DISABLE:
 112:.\Include/arm_math.h ****    *
 113:.\Include/arm_math.h ****    * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory acces
 114:.\Include/arm_math.h ****    *
 115:.\Include/arm_math.h ****    * - ARM_MATH_BIG_ENDIAN:
 116:.\Include/arm_math.h ****    *
 117:.\Include/arm_math.h ****    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default libra
 118:.\Include/arm_math.h ****    *
 119:.\Include/arm_math.h ****    * - ARM_MATH_MATRIX_CHECK:
 120:.\Include/arm_math.h ****    *
 121:.\Include/arm_math.h ****    * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
 122:.\Include/arm_math.h ****    *
 123:.\Include/arm_math.h ****    * - ARM_MATH_ROUNDING:
 124:.\Include/arm_math.h ****    *
 125:.\Include/arm_math.h ****    * Define macro ARM_MATH_ROUNDING for rounding on support functions
 126:.\Include/arm_math.h ****    *
 127:.\Include/arm_math.h ****    * - ARM_MATH_CMx:
 128:.\Include/arm_math.h ****    *
 129:.\Include/arm_math.h ****    * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for build
 130:.\Include/arm_math.h ****    * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building libra
 131:.\Include/arm_math.h ****    * ARM_MATH_CM7 for building the library on cortex-M7.
 132:.\Include/arm_math.h ****    *
 133:.\Include/arm_math.h ****    * - ARM_MATH_ARMV8MxL:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 12


 134:.\Include/arm_math.h ****    *
 135:.\Include/arm_math.h ****    * Define macro ARM_MATH_ARMV8MBL for building the library on ARMv8M Baseline target, ARM_MATH_AR
 136:.\Include/arm_math.h ****    * on ARMv8M Mainline target.
 137:.\Include/arm_math.h ****    *
 138:.\Include/arm_math.h ****    * - __FPU_PRESENT:
 139:.\Include/arm_math.h ****    *
 140:.\Include/arm_math.h ****    * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro f
 141:.\Include/arm_math.h ****    *
 142:.\Include/arm_math.h ****    * - __DSP_PRESENT:
 143:.\Include/arm_math.h ****    *
 144:.\Include/arm_math.h ****    * Initialize macro __DSP_PRESENT = 1 when ARMv8M Mainline core supports DSP instructions.
 145:.\Include/arm_math.h ****    *
 146:.\Include/arm_math.h ****    * <hr>
 147:.\Include/arm_math.h ****    * CMSIS-DSP in ARM::CMSIS Pack
 148:.\Include/arm_math.h ****    * -----------------------------
 149:.\Include/arm_math.h ****    *
 150:.\Include/arm_math.h ****    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directorie
 151:.\Include/arm_math.h ****    * |File/Folder                   |Content                                                       
 152:.\Include/arm_math.h ****    * |------------------------------|--------------------------------------------------------------
 153:.\Include/arm_math.h ****    * |\b CMSIS\\Documentation\\DSP  | This documentation                                           
 154:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                     
 155:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library funct
 156:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                      
 157:.\Include/arm_math.h ****    *
 158:.\Include/arm_math.h ****    * <hr>
 159:.\Include/arm_math.h ****    * Revision History of CMSIS-DSP
 160:.\Include/arm_math.h ****    * ------------
 161:.\Include/arm_math.h ****    * Please refer to \ref ChangeLog_pg.
 162:.\Include/arm_math.h ****    *
 163:.\Include/arm_math.h ****    * Copyright Notice
 164:.\Include/arm_math.h ****    * ------------
 165:.\Include/arm_math.h ****    *
 166:.\Include/arm_math.h ****    * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
 167:.\Include/arm_math.h ****    */
 168:.\Include/arm_math.h **** 
 169:.\Include/arm_math.h **** 
 170:.\Include/arm_math.h **** /**
 171:.\Include/arm_math.h ****  * @defgroup groupMath Basic Math Functions
 172:.\Include/arm_math.h ****  */
 173:.\Include/arm_math.h **** 
 174:.\Include/arm_math.h **** /**
 175:.\Include/arm_math.h ****  * @defgroup groupFastMath Fast Math Functions
 176:.\Include/arm_math.h ****  * This set of functions provides a fast approximation to sine, cosine, and square root.
 177:.\Include/arm_math.h ****  * As compared to most of the other functions in the CMSIS math library, the fast math functions
 178:.\Include/arm_math.h ****  * operate on individual values and not arrays.
 179:.\Include/arm_math.h ****  * There are separate functions for Q15, Q31, and floating-point data.
 180:.\Include/arm_math.h ****  *
 181:.\Include/arm_math.h ****  */
 182:.\Include/arm_math.h **** 
 183:.\Include/arm_math.h **** /**
 184:.\Include/arm_math.h ****  * @defgroup groupCmplxMath Complex Math Functions
 185:.\Include/arm_math.h ****  * This set of functions operates on complex data vectors.
 186:.\Include/arm_math.h ****  * The data in the complex arrays is stored in an interleaved fashion
 187:.\Include/arm_math.h ****  * (real, imag, real, imag, ...).
 188:.\Include/arm_math.h ****  * In the API functions, the number of samples in a complex array refers
 189:.\Include/arm_math.h ****  * to the number of complex values; the array contains twice this number of
 190:.\Include/arm_math.h ****  * real values.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 13


 191:.\Include/arm_math.h ****  */
 192:.\Include/arm_math.h **** 
 193:.\Include/arm_math.h **** /**
 194:.\Include/arm_math.h ****  * @defgroup groupFilters Filtering Functions
 195:.\Include/arm_math.h ****  */
 196:.\Include/arm_math.h **** 
 197:.\Include/arm_math.h **** /**
 198:.\Include/arm_math.h ****  * @defgroup groupMatrix Matrix Functions
 199:.\Include/arm_math.h ****  *
 200:.\Include/arm_math.h ****  * This set of functions provides basic matrix math operations.
 201:.\Include/arm_math.h ****  * The functions operate on matrix data structures.  For example,
 202:.\Include/arm_math.h ****  * the type
 203:.\Include/arm_math.h ****  * definition for the floating-point matrix structure is shown
 204:.\Include/arm_math.h ****  * below:
 205:.\Include/arm_math.h ****  * <pre>
 206:.\Include/arm_math.h ****  *     typedef struct
 207:.\Include/arm_math.h ****  *     {
 208:.\Include/arm_math.h ****  *       uint16_t numRows;     // number of rows of the matrix.
 209:.\Include/arm_math.h ****  *       uint16_t numCols;     // number of columns of the matrix.
 210:.\Include/arm_math.h ****  *       float32_t *pData;     // points to the data of the matrix.
 211:.\Include/arm_math.h ****  *     } arm_matrix_instance_f32;
 212:.\Include/arm_math.h ****  * </pre>
 213:.\Include/arm_math.h ****  * There are similar definitions for Q15 and Q31 data types.
 214:.\Include/arm_math.h ****  *
 215:.\Include/arm_math.h ****  * The structure specifies the size of the matrix and then points to
 216:.\Include/arm_math.h ****  * an array of data.  The array is of size <code>numRows X numCols</code>
 217:.\Include/arm_math.h ****  * and the values are arranged in row order.  That is, the
 218:.\Include/arm_math.h ****  * matrix element (i, j) is stored at:
 219:.\Include/arm_math.h ****  * <pre>
 220:.\Include/arm_math.h ****  *     pData[i*numCols + j]
 221:.\Include/arm_math.h ****  * </pre>
 222:.\Include/arm_math.h ****  *
 223:.\Include/arm_math.h ****  * \par Init Functions
 224:.\Include/arm_math.h ****  * There is an associated initialization function for each type of matrix
 225:.\Include/arm_math.h ****  * data structure.
 226:.\Include/arm_math.h ****  * The initialization function sets the values of the internal structure fields.
 227:.\Include/arm_math.h ****  * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
 228:.\Include/arm_math.h ****  * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
 229:.\Include/arm_math.h ****  *
 230:.\Include/arm_math.h ****  * \par
 231:.\Include/arm_math.h ****  * Use of the initialization function is optional. However, if initialization function is used
 232:.\Include/arm_math.h ****  * then the instance structure cannot be placed into a const data section.
 233:.\Include/arm_math.h ****  * To place the instance structure in a const data
 234:.\Include/arm_math.h ****  * section, manually initialize the data structure.  For example:
 235:.\Include/arm_math.h ****  * <pre>
 236:.\Include/arm_math.h ****  * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
 237:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
 238:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
 239:.\Include/arm_math.h ****  * </pre>
 240:.\Include/arm_math.h ****  * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
 241:.\Include/arm_math.h ****  * specifies the number of columns, and <code>pData</code> points to the
 242:.\Include/arm_math.h ****  * data array.
 243:.\Include/arm_math.h ****  *
 244:.\Include/arm_math.h ****  * \par Size Checking
 245:.\Include/arm_math.h ****  * By default all of the matrix functions perform size checking on the input and
 246:.\Include/arm_math.h ****  * output matrices.  For example, the matrix addition function verifies that the
 247:.\Include/arm_math.h ****  * two input matrices and the output matrix all have the same number of rows and
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 14


 248:.\Include/arm_math.h ****  * columns.  If the size check fails the functions return:
 249:.\Include/arm_math.h ****  * <pre>
 250:.\Include/arm_math.h ****  *     ARM_MATH_SIZE_MISMATCH
 251:.\Include/arm_math.h ****  * </pre>
 252:.\Include/arm_math.h ****  * Otherwise the functions return
 253:.\Include/arm_math.h ****  * <pre>
 254:.\Include/arm_math.h ****  *     ARM_MATH_SUCCESS
 255:.\Include/arm_math.h ****  * </pre>
 256:.\Include/arm_math.h ****  * There is some overhead associated with this matrix size checking.
 257:.\Include/arm_math.h ****  * The matrix size checking is enabled via the \#define
 258:.\Include/arm_math.h ****  * <pre>
 259:.\Include/arm_math.h ****  *     ARM_MATH_MATRIX_CHECK
 260:.\Include/arm_math.h ****  * </pre>
 261:.\Include/arm_math.h ****  * within the library project settings.  By default this macro is defined
 262:.\Include/arm_math.h ****  * and size checking is enabled.  By changing the project settings and
 263:.\Include/arm_math.h ****  * undefining this macro size checking is eliminated and the functions
 264:.\Include/arm_math.h ****  * run a bit faster.  With size checking disabled the functions always
 265:.\Include/arm_math.h ****  * return <code>ARM_MATH_SUCCESS</code>.
 266:.\Include/arm_math.h ****  */
 267:.\Include/arm_math.h **** 
 268:.\Include/arm_math.h **** /**
 269:.\Include/arm_math.h ****  * @defgroup groupTransforms Transform Functions
 270:.\Include/arm_math.h ****  */
 271:.\Include/arm_math.h **** 
 272:.\Include/arm_math.h **** /**
 273:.\Include/arm_math.h ****  * @defgroup groupController Controller Functions
 274:.\Include/arm_math.h ****  */
 275:.\Include/arm_math.h **** 
 276:.\Include/arm_math.h **** /**
 277:.\Include/arm_math.h ****  * @defgroup groupStats Statistics Functions
 278:.\Include/arm_math.h ****  */
 279:.\Include/arm_math.h **** /**
 280:.\Include/arm_math.h ****  * @defgroup groupSupport Support Functions
 281:.\Include/arm_math.h ****  */
 282:.\Include/arm_math.h **** 
 283:.\Include/arm_math.h **** /**
 284:.\Include/arm_math.h ****  * @defgroup groupInterpolation Interpolation Functions
 285:.\Include/arm_math.h ****  * These functions perform 1- and 2-dimensional interpolation of data.
 286:.\Include/arm_math.h ****  * Linear interpolation is used for 1-dimensional data and
 287:.\Include/arm_math.h ****  * bilinear interpolation is used for 2-dimensional data.
 288:.\Include/arm_math.h ****  */
 289:.\Include/arm_math.h **** 
 290:.\Include/arm_math.h **** /**
 291:.\Include/arm_math.h ****  * @defgroup groupExamples Examples
 292:.\Include/arm_math.h ****  */
 293:.\Include/arm_math.h **** #ifndef _ARM_MATH_H
 294:.\Include/arm_math.h **** #define _ARM_MATH_H
 295:.\Include/arm_math.h **** 
 296:.\Include/arm_math.h **** /* ignore some GCC warnings */
 297:.\Include/arm_math.h **** #if defined ( __GNUC__ )
 298:.\Include/arm_math.h **** #pragma GCC diagnostic push
 299:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
 300:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wconversion"
 301:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
 302:.\Include/arm_math.h **** #endif
 303:.\Include/arm_math.h **** 
 304:.\Include/arm_math.h **** #define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 15


 305:.\Include/arm_math.h **** 
 306:.\Include/arm_math.h **** #if defined(ARM_MATH_CM7)
 307:.\Include/arm_math.h ****   #include "core_cm7.h"
 308:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 309:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM4)
 310:.\Include/arm_math.h ****   #include "core_cm4.h"
 311:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 312:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM3)
 313:.\Include/arm_math.h ****   #include "core_cm3.h"
 314:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0)
 315:.\Include/arm_math.h ****   #include "core_cm0.h"
 316:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 317:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0PLUS)
 318:.\Include/arm_math.h ****   #include "core_cm0plus.h"
 319:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 320:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MBL)
 321:.\Include/arm_math.h ****   #include "core_armv8mbl.h"
 322:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 323:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MML)
 324:.\Include/arm_math.h ****   #include "core_armv8mml.h"
 325:.\Include/arm_math.h ****   #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
 326:.\Include/arm_math.h ****     #define ARM_MATH_DSP
 327:.\Include/arm_math.h ****   #endif
 328:.\Include/arm_math.h **** #else
 329:.\Include/arm_math.h ****   #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_
 330:.\Include/arm_math.h **** #endif
 331:.\Include/arm_math.h **** 
 332:.\Include/arm_math.h **** #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 333:.\Include/arm_math.h **** #include "string.h"
 334:.\Include/arm_math.h **** #include "math.h"
 335:.\Include/arm_math.h **** #ifdef   __cplusplus
 336:.\Include/arm_math.h **** extern "C"
 337:.\Include/arm_math.h **** {
 338:.\Include/arm_math.h **** #endif
 339:.\Include/arm_math.h **** 
 340:.\Include/arm_math.h **** 
 341:.\Include/arm_math.h ****   /**
 342:.\Include/arm_math.h ****    * @brief Macros required for reciprocal calculation in Normalized LMS
 343:.\Include/arm_math.h ****    */
 344:.\Include/arm_math.h **** 
 345:.\Include/arm_math.h **** #define DELTA_Q31          (0x100)
 346:.\Include/arm_math.h **** #define DELTA_Q15          0x5
 347:.\Include/arm_math.h **** #define INDEX_MASK         0x0000003F
 348:.\Include/arm_math.h **** #ifndef PI
 349:.\Include/arm_math.h ****   #define PI               3.14159265358979f
 350:.\Include/arm_math.h **** #endif
 351:.\Include/arm_math.h **** 
 352:.\Include/arm_math.h ****   /**
 353:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Fast math approximations
 354:.\Include/arm_math.h ****    */
 355:.\Include/arm_math.h **** 
 356:.\Include/arm_math.h **** #define FAST_MATH_TABLE_SIZE  512
 357:.\Include/arm_math.h **** #define FAST_MATH_Q31_SHIFT   (32 - 10)
 358:.\Include/arm_math.h **** #define FAST_MATH_Q15_SHIFT   (16 - 10)
 359:.\Include/arm_math.h **** #define CONTROLLER_Q31_SHIFT  (32 - 9)
 360:.\Include/arm_math.h **** #define TABLE_SPACING_Q31     0x400000
 361:.\Include/arm_math.h **** #define TABLE_SPACING_Q15     0x80
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 16


 362:.\Include/arm_math.h **** 
 363:.\Include/arm_math.h ****   /**
 364:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Controller functions
 365:.\Include/arm_math.h ****    */
 366:.\Include/arm_math.h ****   /* 1.31(q31) Fixed value of 2/360 */
 367:.\Include/arm_math.h ****   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 368:.\Include/arm_math.h **** #define INPUT_SPACING         0xB60B61
 369:.\Include/arm_math.h **** 
 370:.\Include/arm_math.h ****   /**
 371:.\Include/arm_math.h ****    * @brief Macro for Unaligned Support
 372:.\Include/arm_math.h ****    */
 373:.\Include/arm_math.h **** #ifndef UNALIGNED_SUPPORT_DISABLE
 374:.\Include/arm_math.h ****     #define ALIGN4
 375:.\Include/arm_math.h **** #else
 376:.\Include/arm_math.h ****   #if defined  (__GNUC__)
 377:.\Include/arm_math.h ****     #define ALIGN4 __attribute__((aligned(4)))
 378:.\Include/arm_math.h ****   #else
 379:.\Include/arm_math.h ****     #define ALIGN4 __align(4)
 380:.\Include/arm_math.h ****   #endif
 381:.\Include/arm_math.h **** #endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 382:.\Include/arm_math.h **** 
 383:.\Include/arm_math.h ****   /**
 384:.\Include/arm_math.h ****    * @brief Error status returned by some functions in the library.
 385:.\Include/arm_math.h ****    */
 386:.\Include/arm_math.h **** 
 387:.\Include/arm_math.h ****   typedef enum
 388:.\Include/arm_math.h ****   {
 389:.\Include/arm_math.h ****     ARM_MATH_SUCCESS = 0,                /**< No error */
 390:.\Include/arm_math.h ****     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
 391:.\Include/arm_math.h ****     ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
 392:.\Include/arm_math.h ****     ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation
 393:.\Include/arm_math.h ****     ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
 394:.\Include/arm_math.h ****     ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is 
 395:.\Include/arm_math.h ****     ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
 396:.\Include/arm_math.h ****   } arm_status;
 397:.\Include/arm_math.h **** 
 398:.\Include/arm_math.h ****   /**
 399:.\Include/arm_math.h ****    * @brief 8-bit fractional data type in 1.7 format.
 400:.\Include/arm_math.h ****    */
 401:.\Include/arm_math.h ****   typedef int8_t q7_t;
 402:.\Include/arm_math.h **** 
 403:.\Include/arm_math.h ****   /**
 404:.\Include/arm_math.h ****    * @brief 16-bit fractional data type in 1.15 format.
 405:.\Include/arm_math.h ****    */
 406:.\Include/arm_math.h ****   typedef int16_t q15_t;
 407:.\Include/arm_math.h **** 
 408:.\Include/arm_math.h ****   /**
 409:.\Include/arm_math.h ****    * @brief 32-bit fractional data type in 1.31 format.
 410:.\Include/arm_math.h ****    */
 411:.\Include/arm_math.h ****   typedef int32_t q31_t;
 412:.\Include/arm_math.h **** 
 413:.\Include/arm_math.h ****   /**
 414:.\Include/arm_math.h ****    * @brief 64-bit fractional data type in 1.63 format.
 415:.\Include/arm_math.h ****    */
 416:.\Include/arm_math.h ****   typedef int64_t q63_t;
 417:.\Include/arm_math.h **** 
 418:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 17


 419:.\Include/arm_math.h ****    * @brief 32-bit floating-point type definition.
 420:.\Include/arm_math.h ****    */
 421:.\Include/arm_math.h ****   typedef float float32_t;
 422:.\Include/arm_math.h **** 
 423:.\Include/arm_math.h ****   /**
 424:.\Include/arm_math.h ****    * @brief 64-bit floating-point type definition.
 425:.\Include/arm_math.h ****    */
 426:.\Include/arm_math.h ****   typedef double float64_t;
 427:.\Include/arm_math.h **** 
 428:.\Include/arm_math.h ****   /**
 429:.\Include/arm_math.h ****    * @brief definition to read/write two 16 bit values.
 430:.\Include/arm_math.h ****    */
 431:.\Include/arm_math.h **** #if   defined ( __CC_ARM )
 432:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 433:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 434:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 435:.\Include/arm_math.h **** 
 436:.\Include/arm_math.h **** #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 437:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 438:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 439:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 440:.\Include/arm_math.h **** 
 441:.\Include/arm_math.h **** #elif defined ( __GNUC__ )
 442:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 443:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 444:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 445:.\Include/arm_math.h **** 
 446:.\Include/arm_math.h **** #elif defined ( __ICCARM__ )
 447:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 448:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 449:.\Include/arm_math.h ****   #define CMSIS_INLINE
 450:.\Include/arm_math.h **** 
 451:.\Include/arm_math.h **** #elif defined ( __TI_ARM__ )
 452:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 453:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 454:.\Include/arm_math.h ****   #define CMSIS_INLINE
 455:.\Include/arm_math.h **** 
 456:.\Include/arm_math.h **** #elif defined ( __CSMC__ )
 457:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 458:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 459:.\Include/arm_math.h ****   #define CMSIS_INLINE
 460:.\Include/arm_math.h **** 
 461:.\Include/arm_math.h **** #elif defined ( __TASKING__ )
 462:.\Include/arm_math.h ****   #define __SIMD32_TYPE __unaligned int32_t
 463:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 464:.\Include/arm_math.h ****   #define CMSIS_INLINE
 465:.\Include/arm_math.h **** 
 466:.\Include/arm_math.h **** #else
 467:.\Include/arm_math.h ****   #error Unknown compiler
 468:.\Include/arm_math.h **** #endif
 469:.\Include/arm_math.h **** 
 470:.\Include/arm_math.h **** #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
 471:.\Include/arm_math.h **** #define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
 472:.\Include/arm_math.h **** #define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
 473:.\Include/arm_math.h **** #define __SIMD64(addr)        (*(int64_t **) & (addr))
 474:.\Include/arm_math.h **** 
 475:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 18


 476:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 477:.\Include/arm_math.h ****   /**
 478:.\Include/arm_math.h ****    * @brief definition to pack two 16 bit values.
 479:.\Include/arm_math.h ****    */
 480:.\Include/arm_math.h **** #define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
 481:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
 482:.\Include/arm_math.h **** #define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
 483:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
 484:.\Include/arm_math.h **** 
 485:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 486:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
 487:.\Include/arm_math.h **** 
 488:.\Include/arm_math.h ****    /**
 489:.\Include/arm_math.h ****    * @brief definition to pack four 8 bit values.
 490:.\Include/arm_math.h ****    */
 491:.\Include/arm_math.h **** #ifndef ARM_MATH_BIG_ENDIAN
 492:.\Include/arm_math.h **** 
 493:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
 494:.\Include/arm_math.h ****                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
 495:.\Include/arm_math.h ****                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
 496:.\Include/arm_math.h ****                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 497:.\Include/arm_math.h **** #else
 498:.\Include/arm_math.h **** 
 499:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
 500:.\Include/arm_math.h ****                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
 501:.\Include/arm_math.h ****                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
 502:.\Include/arm_math.h ****                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 503:.\Include/arm_math.h **** 
 504:.\Include/arm_math.h **** #endif
 505:.\Include/arm_math.h **** 
 506:.\Include/arm_math.h **** 
 507:.\Include/arm_math.h ****   /**
 508:.\Include/arm_math.h ****    * @brief Clips Q63 to Q31 values.
 509:.\Include/arm_math.h ****    */
 510:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
 511:.\Include/arm_math.h ****   q63_t x)
 512:.\Include/arm_math.h ****   {
 513:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 514:.\Include/arm_math.h ****       ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
 515:.\Include/arm_math.h ****   }
 516:.\Include/arm_math.h **** 
 517:.\Include/arm_math.h ****   /**
 518:.\Include/arm_math.h ****    * @brief Clips Q63 to Q15 values.
 519:.\Include/arm_math.h ****    */
 520:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
 521:.\Include/arm_math.h ****   q63_t x)
 522:.\Include/arm_math.h ****   {
 523:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 524:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
 525:.\Include/arm_math.h ****   }
 526:.\Include/arm_math.h **** 
 527:.\Include/arm_math.h ****   /**
 528:.\Include/arm_math.h ****    * @brief Clips Q31 to Q7 values.
 529:.\Include/arm_math.h ****    */
 530:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
 531:.\Include/arm_math.h ****   q31_t x)
 532:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 19


 533:.\Include/arm_math.h ****     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
 534:.\Include/arm_math.h ****       ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
 535:.\Include/arm_math.h ****   }
 536:.\Include/arm_math.h **** 
 537:.\Include/arm_math.h ****   /**
 538:.\Include/arm_math.h ****    * @brief Clips Q31 to Q15 values.
 539:.\Include/arm_math.h ****    */
 540:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
 541:.\Include/arm_math.h ****   q31_t x)
 542:.\Include/arm_math.h ****   {
 543:.\Include/arm_math.h ****     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
 544:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
 545:.\Include/arm_math.h ****   }
 546:.\Include/arm_math.h **** 
 547:.\Include/arm_math.h ****   /**
 548:.\Include/arm_math.h ****    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
 549:.\Include/arm_math.h ****    */
 550:.\Include/arm_math.h **** 
 551:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
 552:.\Include/arm_math.h ****   q63_t x,
 553:.\Include/arm_math.h ****   q31_t y)
 554:.\Include/arm_math.h ****   {
 555:.\Include/arm_math.h ****     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
 556:.\Include/arm_math.h ****             (((q63_t) (x >> 32) * y)));
 557:.\Include/arm_math.h ****   }
 558:.\Include/arm_math.h **** 
 559:.\Include/arm_math.h **** /*
 560:.\Include/arm_math.h ****   #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
 561:.\Include/arm_math.h ****   #define __CLZ __clz
 562:.\Include/arm_math.h ****   #endif
 563:.\Include/arm_math.h ****  */
 564:.\Include/arm_math.h **** /* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
 565:.\Include/arm_math.h **** #if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
 566:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 567:.\Include/arm_math.h ****   q31_t data);
 568:.\Include/arm_math.h **** 
 569:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 570:.\Include/arm_math.h ****   q31_t data)
 571:.\Include/arm_math.h ****   {
 572:.\Include/arm_math.h ****     uint32_t count = 0;
 573:.\Include/arm_math.h ****     uint32_t mask = 0x80000000;
 574:.\Include/arm_math.h **** 
 575:.\Include/arm_math.h ****     while ((data & mask) == 0)
 576:.\Include/arm_math.h ****     {
 577:.\Include/arm_math.h ****       count += 1u;
 578:.\Include/arm_math.h ****       mask = mask >> 1u;
 579:.\Include/arm_math.h ****     }
 580:.\Include/arm_math.h **** 
 581:.\Include/arm_math.h ****     return (count);
 582:.\Include/arm_math.h ****   }
 583:.\Include/arm_math.h **** #endif
 584:.\Include/arm_math.h **** 
 585:.\Include/arm_math.h ****   /**
 586:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
 587:.\Include/arm_math.h ****    */
 588:.\Include/arm_math.h **** 
 589:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 20


 590:.\Include/arm_math.h ****   q31_t in,
 591:.\Include/arm_math.h ****   q31_t * dst,
 592:.\Include/arm_math.h ****   q31_t * pRecipTable)
 593:.\Include/arm_math.h ****   {
 594:.\Include/arm_math.h ****     q31_t out;
 595:.\Include/arm_math.h ****     uint32_t tempVal;
 596:.\Include/arm_math.h ****     uint32_t index, i;
 597:.\Include/arm_math.h ****     uint32_t signBits;
 598:.\Include/arm_math.h **** 
 599:.\Include/arm_math.h ****     if (in > 0)
 600:.\Include/arm_math.h ****     {
 601:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ( in) - 1));
 602:.\Include/arm_math.h ****     }
 603:.\Include/arm_math.h ****     else
 604:.\Include/arm_math.h ****     {
 605:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ(-in) - 1));
 606:.\Include/arm_math.h ****     }
 607:.\Include/arm_math.h **** 
 608:.\Include/arm_math.h ****     /* Convert input sample to 1.31 format */
 609:.\Include/arm_math.h ****     in = (in << signBits);
 610:.\Include/arm_math.h **** 
 611:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 612:.\Include/arm_math.h ****     index = (uint32_t)(in >> 24);
 613:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 614:.\Include/arm_math.h **** 
 615:.\Include/arm_math.h ****     /* 1.31 with exp 1 */
 616:.\Include/arm_math.h ****     out = pRecipTable[index];
 617:.\Include/arm_math.h **** 
 618:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 619:.\Include/arm_math.h ****     /* running approximation for two iterations */
 620:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 621:.\Include/arm_math.h ****     {
 622:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q63_t) in * out) >> 31);
 623:.\Include/arm_math.h ****       tempVal = 0x7FFFFFFFu - tempVal;
 624:.\Include/arm_math.h ****       /*      1.31 with exp 1 */
 625:.\Include/arm_math.h ****       /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
 626:.\Include/arm_math.h ****       out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
 627:.\Include/arm_math.h ****     }
 628:.\Include/arm_math.h **** 
 629:.\Include/arm_math.h ****     /* write output */
 630:.\Include/arm_math.h ****     *dst = out;
 631:.\Include/arm_math.h **** 
 632:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 633:.\Include/arm_math.h ****     return (signBits + 1u);
 634:.\Include/arm_math.h ****   }
 635:.\Include/arm_math.h **** 
 636:.\Include/arm_math.h **** 
 637:.\Include/arm_math.h ****   /**
 638:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
 639:.\Include/arm_math.h ****    */
 640:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
 641:.\Include/arm_math.h ****   q15_t in,
 642:.\Include/arm_math.h ****   q15_t * dst,
 643:.\Include/arm_math.h ****   q15_t * pRecipTable)
 644:.\Include/arm_math.h ****   {
 645:.\Include/arm_math.h ****     q15_t out = 0;
 646:.\Include/arm_math.h ****     uint32_t tempVal = 0;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 21


 647:.\Include/arm_math.h ****     uint32_t index = 0, i = 0;
 648:.\Include/arm_math.h ****     uint32_t signBits = 0;
 649:.\Include/arm_math.h **** 
 650:.\Include/arm_math.h ****     if (in > 0)
 651:.\Include/arm_math.h ****     {
 652:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ( in) - 17));
 653:.\Include/arm_math.h ****     }
 654:.\Include/arm_math.h ****     else
 655:.\Include/arm_math.h ****     {
 656:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ(-in) - 17));
 657:.\Include/arm_math.h ****     }
 658:.\Include/arm_math.h **** 
 659:.\Include/arm_math.h ****     /* Convert input sample to 1.15 format */
 660:.\Include/arm_math.h ****     in = (in << signBits);
 661:.\Include/arm_math.h **** 
 662:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 663:.\Include/arm_math.h ****     index = (uint32_t)(in >>  8);
 664:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 665:.\Include/arm_math.h **** 
 666:.\Include/arm_math.h ****     /*      1.15 with exp 1  */
 667:.\Include/arm_math.h ****     out = pRecipTable[index];
 668:.\Include/arm_math.h **** 
 669:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 670:.\Include/arm_math.h ****     /* running approximation for two iterations */
 671:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 672:.\Include/arm_math.h ****     {
 673:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q31_t) in * out) >> 15);
 674:.\Include/arm_math.h ****       tempVal = 0x7FFFu - tempVal;
 675:.\Include/arm_math.h ****       /*      1.15 with exp 1 */
 676:.\Include/arm_math.h ****       out = (q15_t) (((q31_t) out * tempVal) >> 14);
 677:.\Include/arm_math.h ****       /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
 678:.\Include/arm_math.h ****     }
 679:.\Include/arm_math.h **** 
 680:.\Include/arm_math.h ****     /* write output */
 681:.\Include/arm_math.h ****     *dst = out;
 682:.\Include/arm_math.h **** 
 683:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 684:.\Include/arm_math.h ****     return (signBits + 1);
 685:.\Include/arm_math.h ****   }
 686:.\Include/arm_math.h **** 
 687:.\Include/arm_math.h **** 
 688:.\Include/arm_math.h ****   /*
 689:.\Include/arm_math.h ****    * @brief C custom defined intrinisic function for only M0 processors
 690:.\Include/arm_math.h ****    */
 691:.\Include/arm_math.h **** #if defined(ARM_MATH_CM0_FAMILY)
 692:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t __SSAT(
 693:.\Include/arm_math.h ****   q31_t x,
 694:.\Include/arm_math.h ****   uint32_t y)
 695:.\Include/arm_math.h ****   {
 696:.\Include/arm_math.h ****     int32_t posMax, negMin;
 697:.\Include/arm_math.h ****     uint32_t i;
 698:.\Include/arm_math.h **** 
 699:.\Include/arm_math.h ****     posMax = 1;
 700:.\Include/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 701:.\Include/arm_math.h ****     {
 702:.\Include/arm_math.h ****       posMax = posMax * 2;
 703:.\Include/arm_math.h ****     }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 22


 704:.\Include/arm_math.h **** 
 705:.\Include/arm_math.h ****     if (x > 0)
 706:.\Include/arm_math.h ****     {
 707:.\Include/arm_math.h ****       posMax = (posMax - 1);
 708:.\Include/arm_math.h **** 
 709:.\Include/arm_math.h ****       if (x > posMax)
 710:.\Include/arm_math.h ****       {
 711:.\Include/arm_math.h ****         x = posMax;
 712:.\Include/arm_math.h ****       }
 713:.\Include/arm_math.h ****     }
 714:.\Include/arm_math.h ****     else
 715:.\Include/arm_math.h ****     {
 716:.\Include/arm_math.h ****       negMin = -posMax;
 717:.\Include/arm_math.h **** 
 718:.\Include/arm_math.h ****       if (x < negMin)
 719:.\Include/arm_math.h ****       {
 720:.\Include/arm_math.h ****         x = negMin;
 721:.\Include/arm_math.h ****       }
 722:.\Include/arm_math.h ****     }
 723:.\Include/arm_math.h ****     return (x);
 724:.\Include/arm_math.h ****   }
 725:.\Include/arm_math.h **** #endif /* end of ARM_MATH_CM0_FAMILY */
 726:.\Include/arm_math.h **** 
 727:.\Include/arm_math.h **** 
 728:.\Include/arm_math.h ****   /*
 729:.\Include/arm_math.h ****    * @brief C custom defined intrinsic function for M3 and M0 processors
 730:.\Include/arm_math.h ****    */
 731:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 732:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 733:.\Include/arm_math.h **** 
 734:.\Include/arm_math.h ****   /*
 735:.\Include/arm_math.h ****    * @brief C custom defined QADD8 for M3 and M0 processors
 736:.\Include/arm_math.h ****    */
 737:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
 738:.\Include/arm_math.h ****   uint32_t x,
 739:.\Include/arm_math.h ****   uint32_t y)
 740:.\Include/arm_math.h ****   {
 741:.\Include/arm_math.h ****     q31_t r, s, t, u;
 742:.\Include/arm_math.h **** 
 743:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 744:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 745:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 746:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 747:.\Include/arm_math.h **** 
 748:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 749:.\Include/arm_math.h ****   }
 750:.\Include/arm_math.h **** 
 751:.\Include/arm_math.h **** 
 752:.\Include/arm_math.h ****   /*
 753:.\Include/arm_math.h ****    * @brief C custom defined QSUB8 for M3 and M0 processors
 754:.\Include/arm_math.h ****    */
 755:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
 756:.\Include/arm_math.h ****   uint32_t x,
 757:.\Include/arm_math.h ****   uint32_t y)
 758:.\Include/arm_math.h ****   {
 759:.\Include/arm_math.h ****     q31_t r, s, t, u;
 760:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 23


 761:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 762:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 763:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 764:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 765:.\Include/arm_math.h **** 
 766:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 767:.\Include/arm_math.h ****   }
 768:.\Include/arm_math.h **** 
 769:.\Include/arm_math.h **** 
 770:.\Include/arm_math.h ****   /*
 771:.\Include/arm_math.h ****    * @brief C custom defined QADD16 for M3 and M0 processors
 772:.\Include/arm_math.h ****    */
 773:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
 774:.\Include/arm_math.h ****   uint32_t x,
 775:.\Include/arm_math.h ****   uint32_t y)
 776:.\Include/arm_math.h ****   {
 777:.\Include/arm_math.h **** /*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass
 778:.\Include/arm_math.h ****     q31_t r = 0, s = 0;
 779:.\Include/arm_math.h **** 
 780:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 781:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 782:.\Include/arm_math.h **** 
 783:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 784:.\Include/arm_math.h ****   }
 785:.\Include/arm_math.h **** 
 786:.\Include/arm_math.h **** 
 787:.\Include/arm_math.h ****   /*
 788:.\Include/arm_math.h ****    * @brief C custom defined SHADD16 for M3 and M0 processors
 789:.\Include/arm_math.h ****    */
 790:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
 791:.\Include/arm_math.h ****   uint32_t x,
 792:.\Include/arm_math.h ****   uint32_t y)
 793:.\Include/arm_math.h ****   {
 794:.\Include/arm_math.h ****     q31_t r, s;
 795:.\Include/arm_math.h **** 
 796:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 797:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 798:.\Include/arm_math.h **** 
 799:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 800:.\Include/arm_math.h ****   }
 801:.\Include/arm_math.h **** 
 802:.\Include/arm_math.h **** 
 803:.\Include/arm_math.h ****   /*
 804:.\Include/arm_math.h ****    * @brief C custom defined QSUB16 for M3 and M0 processors
 805:.\Include/arm_math.h ****    */
 806:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
 807:.\Include/arm_math.h ****   uint32_t x,
 808:.\Include/arm_math.h ****   uint32_t y)
 809:.\Include/arm_math.h ****   {
 810:.\Include/arm_math.h ****     q31_t r, s;
 811:.\Include/arm_math.h **** 
 812:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 813:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 814:.\Include/arm_math.h **** 
 815:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 816:.\Include/arm_math.h ****   }
 817:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 24


 818:.\Include/arm_math.h **** 
 819:.\Include/arm_math.h ****   /*
 820:.\Include/arm_math.h ****    * @brief C custom defined SHSUB16 for M3 and M0 processors
 821:.\Include/arm_math.h ****    */
 822:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
 823:.\Include/arm_math.h ****   uint32_t x,
 824:.\Include/arm_math.h ****   uint32_t y)
 825:.\Include/arm_math.h ****   {
 826:.\Include/arm_math.h ****     q31_t r, s;
 827:.\Include/arm_math.h **** 
 828:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 829:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 830:.\Include/arm_math.h **** 
 831:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 832:.\Include/arm_math.h ****   }
 833:.\Include/arm_math.h **** 
 834:.\Include/arm_math.h **** 
 835:.\Include/arm_math.h ****   /*
 836:.\Include/arm_math.h ****    * @brief C custom defined QASX for M3 and M0 processors
 837:.\Include/arm_math.h ****    */
 838:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
 839:.\Include/arm_math.h ****   uint32_t x,
 840:.\Include/arm_math.h ****   uint32_t y)
 841:.\Include/arm_math.h ****   {
 842:.\Include/arm_math.h ****     q31_t r, s;
 843:.\Include/arm_math.h **** 
 844:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 845:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 846:.\Include/arm_math.h **** 
 847:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 848:.\Include/arm_math.h ****   }
 849:.\Include/arm_math.h **** 
 850:.\Include/arm_math.h **** 
 851:.\Include/arm_math.h ****   /*
 852:.\Include/arm_math.h ****    * @brief C custom defined SHASX for M3 and M0 processors
 853:.\Include/arm_math.h ****    */
 854:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
 855:.\Include/arm_math.h ****   uint32_t x,
 856:.\Include/arm_math.h ****   uint32_t y)
 857:.\Include/arm_math.h ****   {
 858:.\Include/arm_math.h ****     q31_t r, s;
 859:.\Include/arm_math.h **** 
 860:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 861:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 862:.\Include/arm_math.h **** 
 863:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 864:.\Include/arm_math.h ****   }
 865:.\Include/arm_math.h **** 
 866:.\Include/arm_math.h **** 
 867:.\Include/arm_math.h ****   /*
 868:.\Include/arm_math.h ****    * @brief C custom defined QSAX for M3 and M0 processors
 869:.\Include/arm_math.h ****    */
 870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
 871:.\Include/arm_math.h ****   uint32_t x,
 872:.\Include/arm_math.h ****   uint32_t y)
 873:.\Include/arm_math.h ****   {
 874:.\Include/arm_math.h ****     q31_t r, s;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 25


 875:.\Include/arm_math.h **** 
 876:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 877:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 878:.\Include/arm_math.h **** 
 879:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 880:.\Include/arm_math.h ****   }
 881:.\Include/arm_math.h **** 
 882:.\Include/arm_math.h **** 
 883:.\Include/arm_math.h ****   /*
 884:.\Include/arm_math.h ****    * @brief C custom defined SHSAX for M3 and M0 processors
 885:.\Include/arm_math.h ****    */
 886:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
 887:.\Include/arm_math.h ****   uint32_t x,
 888:.\Include/arm_math.h ****   uint32_t y)
 889:.\Include/arm_math.h ****   {
 890:.\Include/arm_math.h ****     q31_t r, s;
 891:.\Include/arm_math.h **** 
 892:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 893:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 894:.\Include/arm_math.h **** 
 895:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 896:.\Include/arm_math.h ****   }
 897:.\Include/arm_math.h **** 
 898:.\Include/arm_math.h **** 
 899:.\Include/arm_math.h ****   /*
 900:.\Include/arm_math.h ****    * @brief C custom defined SMUSDX for M3 and M0 processors
 901:.\Include/arm_math.h ****    */
 902:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
 903:.\Include/arm_math.h ****   uint32_t x,
 904:.\Include/arm_math.h ****   uint32_t y)
 905:.\Include/arm_math.h ****   {
 906:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 907:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 908:.\Include/arm_math.h ****   }
 909:.\Include/arm_math.h **** 
 910:.\Include/arm_math.h ****   /*
 911:.\Include/arm_math.h ****    * @brief C custom defined SMUADX for M3 and M0 processors
 912:.\Include/arm_math.h ****    */
 913:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
 914:.\Include/arm_math.h ****   uint32_t x,
 915:.\Include/arm_math.h ****   uint32_t y)
 916:.\Include/arm_math.h ****   {
 917:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 918:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 919:.\Include/arm_math.h ****   }
 920:.\Include/arm_math.h **** 
 921:.\Include/arm_math.h **** 
 922:.\Include/arm_math.h ****   /*
 923:.\Include/arm_math.h ****    * @brief C custom defined QADD for M3 and M0 processors
 924:.\Include/arm_math.h ****    */
 925:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
 926:.\Include/arm_math.h ****   int32_t x,
 927:.\Include/arm_math.h ****   int32_t y)
 928:.\Include/arm_math.h ****   {
 929:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
 930:.\Include/arm_math.h ****   }
 931:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 26


 932:.\Include/arm_math.h **** 
 933:.\Include/arm_math.h ****   /*
 934:.\Include/arm_math.h ****    * @brief C custom defined QSUB for M3 and M0 processors
 935:.\Include/arm_math.h ****    */
 936:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
 937:.\Include/arm_math.h ****   int32_t x,
 938:.\Include/arm_math.h ****   int32_t y)
 939:.\Include/arm_math.h ****   {
 940:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
 941:.\Include/arm_math.h ****   }
 942:.\Include/arm_math.h **** 
 943:.\Include/arm_math.h **** 
 944:.\Include/arm_math.h ****   /*
 945:.\Include/arm_math.h ****    * @brief C custom defined SMLAD for M3 and M0 processors
 946:.\Include/arm_math.h ****    */
 947:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
 948:.\Include/arm_math.h ****   uint32_t x,
 949:.\Include/arm_math.h ****   uint32_t y,
 950:.\Include/arm_math.h ****   uint32_t sum)
 951:.\Include/arm_math.h ****   {
 952:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 953:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 954:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 955:.\Include/arm_math.h ****   }
 956:.\Include/arm_math.h **** 
 957:.\Include/arm_math.h **** 
 958:.\Include/arm_math.h ****   /*
 959:.\Include/arm_math.h ****    * @brief C custom defined SMLADX for M3 and M0 processors
 960:.\Include/arm_math.h ****    */
 961:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
 962:.\Include/arm_math.h ****   uint32_t x,
 963:.\Include/arm_math.h ****   uint32_t y,
 964:.\Include/arm_math.h ****   uint32_t sum)
 965:.\Include/arm_math.h ****   {
 966:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 967:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 968:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 969:.\Include/arm_math.h ****   }
 970:.\Include/arm_math.h **** 
 971:.\Include/arm_math.h **** 
 972:.\Include/arm_math.h ****   /*
 973:.\Include/arm_math.h ****    * @brief C custom defined SMLSDX for M3 and M0 processors
 974:.\Include/arm_math.h ****    */
 975:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
 976:.\Include/arm_math.h ****   uint32_t x,
 977:.\Include/arm_math.h ****   uint32_t y,
 978:.\Include/arm_math.h ****   uint32_t sum)
 979:.\Include/arm_math.h ****   {
 980:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 981:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 982:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 983:.\Include/arm_math.h ****   }
 984:.\Include/arm_math.h **** 
 985:.\Include/arm_math.h **** 
 986:.\Include/arm_math.h ****   /*
 987:.\Include/arm_math.h ****    * @brief C custom defined SMLALD for M3 and M0 processors
 988:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 27


 989:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
 990:.\Include/arm_math.h ****   uint32_t x,
 991:.\Include/arm_math.h ****   uint32_t y,
 992:.\Include/arm_math.h ****   uint64_t sum)
 993:.\Include/arm_math.h ****   {
 994:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
 995:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 996:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 997:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 998:.\Include/arm_math.h ****   }
 999:.\Include/arm_math.h **** 
1000:.\Include/arm_math.h **** 
1001:.\Include/arm_math.h ****   /*
1002:.\Include/arm_math.h ****    * @brief C custom defined SMLALDX for M3 and M0 processors
1003:.\Include/arm_math.h ****    */
1004:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
1005:.\Include/arm_math.h ****   uint32_t x,
1006:.\Include/arm_math.h ****   uint32_t y,
1007:.\Include/arm_math.h ****   uint64_t sum)
1008:.\Include/arm_math.h ****   {
1009:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
1010:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
1011:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
1012:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
1013:.\Include/arm_math.h ****   }
1014:.\Include/arm_math.h **** 
1015:.\Include/arm_math.h **** 
1016:.\Include/arm_math.h ****   /*
1017:.\Include/arm_math.h ****    * @brief C custom defined SMUAD for M3 and M0 processors
1018:.\Include/arm_math.h ****    */
1019:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
1020:.\Include/arm_math.h ****   uint32_t x,
1021:.\Include/arm_math.h ****   uint32_t y)
1022:.\Include/arm_math.h ****   {
1023:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
1024:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1025:.\Include/arm_math.h ****   }
1026:.\Include/arm_math.h **** 
1027:.\Include/arm_math.h **** 
1028:.\Include/arm_math.h ****   /*
1029:.\Include/arm_math.h ****    * @brief C custom defined SMUSD for M3 and M0 processors
1030:.\Include/arm_math.h ****    */
1031:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
1032:.\Include/arm_math.h ****   uint32_t x,
1033:.\Include/arm_math.h ****   uint32_t y)
1034:.\Include/arm_math.h ****   {
1035:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
1036:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1037:.\Include/arm_math.h ****   }
1038:.\Include/arm_math.h **** 
1039:.\Include/arm_math.h **** 
1040:.\Include/arm_math.h ****   /*
1041:.\Include/arm_math.h ****    * @brief C custom defined SXTB16 for M3 and M0 processors
1042:.\Include/arm_math.h ****    */
1043:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
1044:.\Include/arm_math.h ****   uint32_t x)
1045:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 28


1046:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
1047:.\Include/arm_math.h ****                        ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
1048:.\Include/arm_math.h ****   }
1049:.\Include/arm_math.h **** 
1050:.\Include/arm_math.h ****   /*
1051:.\Include/arm_math.h ****    * @brief C custom defined SMMLA for M3 and M0 processors
1052:.\Include/arm_math.h ****    */
1053:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
1054:.\Include/arm_math.h ****   int32_t x,
1055:.\Include/arm_math.h ****   int32_t y,
1056:.\Include/arm_math.h ****   int32_t sum)
1057:.\Include/arm_math.h ****   {
1058:.\Include/arm_math.h ****     return (sum + (int32_t) (((int64_t) x * y) >> 32));
1059:.\Include/arm_math.h ****   }
1060:.\Include/arm_math.h **** 
1061:.\Include/arm_math.h **** #if 0
1062:.\Include/arm_math.h ****   /*
1063:.\Include/arm_math.h ****    * @brief C custom defined PKHBT for unavailable DSP extension
1064:.\Include/arm_math.h ****    */
1065:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHBT(
1066:.\Include/arm_math.h ****   uint32_t x,
1067:.\Include/arm_math.h ****   uint32_t y,
1068:.\Include/arm_math.h ****   uint32_t leftshift)
1069:.\Include/arm_math.h ****   {
1070:.\Include/arm_math.h ****     return ( ((x             ) & 0x0000FFFFUL) |
1071:.\Include/arm_math.h ****              ((y << leftshift) & 0xFFFF0000UL)  );
1072:.\Include/arm_math.h ****   }
1073:.\Include/arm_math.h **** 
1074:.\Include/arm_math.h ****   /*
1075:.\Include/arm_math.h ****    * @brief C custom defined PKHTB for unavailable DSP extension
1076:.\Include/arm_math.h ****    */
1077:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHTB(
1078:.\Include/arm_math.h ****   uint32_t x,
1079:.\Include/arm_math.h ****   uint32_t y,
1080:.\Include/arm_math.h ****   uint32_t rightshift)
1081:.\Include/arm_math.h ****   {
1082:.\Include/arm_math.h ****     return ( ((x              ) & 0xFFFF0000UL) |
1083:.\Include/arm_math.h ****              ((y >> rightshift) & 0x0000FFFFUL)  );
1084:.\Include/arm_math.h ****   }
1085:.\Include/arm_math.h **** #endif
1086:.\Include/arm_math.h **** 
1087:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
1088:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
1089:.\Include/arm_math.h **** 
1090:.\Include/arm_math.h **** 
1091:.\Include/arm_math.h ****   /**
1092:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 FIR filter.
1093:.\Include/arm_math.h ****    */
1094:.\Include/arm_math.h ****   typedef struct
1095:.\Include/arm_math.h ****   {
1096:.\Include/arm_math.h ****     uint16_t numTaps;        /**< number of filter coefficients in the filter. */
1097:.\Include/arm_math.h ****     q7_t *pState;            /**< points to the state variable array. The array is of length numTap
1098:.\Include/arm_math.h ****     q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*
1099:.\Include/arm_math.h ****   } arm_fir_instance_q7;
1100:.\Include/arm_math.h **** 
1101:.\Include/arm_math.h ****   /**
1102:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 29


1103:.\Include/arm_math.h ****    */
1104:.\Include/arm_math.h ****   typedef struct
1105:.\Include/arm_math.h ****   {
1106:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1107:.\Include/arm_math.h ****     q15_t *pState;            /**< points to the state variable array. The array is of length numTa
1108:.\Include/arm_math.h ****     q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1109:.\Include/arm_math.h ****   } arm_fir_instance_q15;
1110:.\Include/arm_math.h **** 
1111:.\Include/arm_math.h ****   /**
1112:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR filter.
1113:.\Include/arm_math.h ****    */
1114:.\Include/arm_math.h ****   typedef struct
1115:.\Include/arm_math.h ****   {
1116:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1117:.\Include/arm_math.h ****     q31_t *pState;            /**< points to the state variable array. The array is of length numTa
1118:.\Include/arm_math.h ****     q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1119:.\Include/arm_math.h ****   } arm_fir_instance_q31;
1120:.\Include/arm_math.h **** 
1121:.\Include/arm_math.h ****   /**
1122:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR filter.
1123:.\Include/arm_math.h ****    */
1124:.\Include/arm_math.h ****   typedef struct
1125:.\Include/arm_math.h ****   {
1126:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of filter coefficients in the filter. */
1127:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
1128:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
1129:.\Include/arm_math.h ****   } arm_fir_instance_f32;
1130:.\Include/arm_math.h **** 
1131:.\Include/arm_math.h **** 
1132:.\Include/arm_math.h ****   /**
1133:.\Include/arm_math.h ****    * @brief Processing function for the Q7 FIR filter.
1134:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
1135:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1136:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1137:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1138:.\Include/arm_math.h ****    */
1139:.\Include/arm_math.h ****   void arm_fir_q7(
1140:.\Include/arm_math.h ****   const arm_fir_instance_q7 * S,
1141:.\Include/arm_math.h ****   q7_t * pSrc,
1142:.\Include/arm_math.h ****   q7_t * pDst,
1143:.\Include/arm_math.h ****   uint32_t blockSize);
1144:.\Include/arm_math.h **** 
1145:.\Include/arm_math.h **** 
1146:.\Include/arm_math.h ****   /**
1147:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 FIR filter.
1148:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 FIR structure.
1149:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1150:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1151:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1152:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed.
1153:.\Include/arm_math.h ****    */
1154:.\Include/arm_math.h ****   void arm_fir_init_q7(
1155:.\Include/arm_math.h ****   arm_fir_instance_q7 * S,
1156:.\Include/arm_math.h ****   uint16_t numTaps,
1157:.\Include/arm_math.h ****   q7_t * pCoeffs,
1158:.\Include/arm_math.h ****   q7_t * pState,
1159:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 30


1160:.\Include/arm_math.h **** 
1161:.\Include/arm_math.h **** 
1162:.\Include/arm_math.h ****   /**
1163:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR filter.
1164:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR structure.
1165:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1166:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1167:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1168:.\Include/arm_math.h ****    */
1169:.\Include/arm_math.h ****   void arm_fir_q15(
1170:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1171:.\Include/arm_math.h ****   q15_t * pSrc,
1172:.\Include/arm_math.h ****   q15_t * pDst,
1173:.\Include/arm_math.h ****   uint32_t blockSize);
1174:.\Include/arm_math.h **** 
1175:.\Include/arm_math.h **** 
1176:.\Include/arm_math.h ****   /**
1177:.\Include/arm_math.h ****    * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
1178:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
1179:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1180:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1181:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1182:.\Include/arm_math.h ****    */
1183:.\Include/arm_math.h ****   void arm_fir_fast_q15(
1184:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1185:.\Include/arm_math.h ****   q15_t * pSrc,
1186:.\Include/arm_math.h ****   q15_t * pDst,
1187:.\Include/arm_math.h ****   uint32_t blockSize);
1188:.\Include/arm_math.h **** 
1189:.\Include/arm_math.h **** 
1190:.\Include/arm_math.h ****   /**
1191:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR filter.
1192:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
1193:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greate
1194:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1195:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1196:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1197:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARG
1198:.\Include/arm_math.h ****    * <code>numTaps</code> is not a supported value.
1199:.\Include/arm_math.h ****    */
1200:.\Include/arm_math.h ****   arm_status arm_fir_init_q15(
1201:.\Include/arm_math.h ****   arm_fir_instance_q15 * S,
1202:.\Include/arm_math.h ****   uint16_t numTaps,
1203:.\Include/arm_math.h ****   q15_t * pCoeffs,
1204:.\Include/arm_math.h ****   q15_t * pState,
1205:.\Include/arm_math.h ****   uint32_t blockSize);
1206:.\Include/arm_math.h **** 
1207:.\Include/arm_math.h **** 
1208:.\Include/arm_math.h ****   /**
1209:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR filter.
1210:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR filter structure.
1211:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1212:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1213:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1214:.\Include/arm_math.h ****    */
1215:.\Include/arm_math.h ****   void arm_fir_q31(
1216:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 31


1217:.\Include/arm_math.h ****   q31_t * pSrc,
1218:.\Include/arm_math.h ****   q31_t * pDst,
1219:.\Include/arm_math.h ****   uint32_t blockSize);
1220:.\Include/arm_math.h **** 
1221:.\Include/arm_math.h **** 
1222:.\Include/arm_math.h ****   /**
1223:.\Include/arm_math.h ****    * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
1224:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR structure.
1225:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1226:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1227:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1228:.\Include/arm_math.h ****    */
1229:.\Include/arm_math.h ****   void arm_fir_fast_q31(
1230:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1231:.\Include/arm_math.h ****   q31_t * pSrc,
1232:.\Include/arm_math.h ****   q31_t * pDst,
1233:.\Include/arm_math.h ****   uint32_t blockSize);
1234:.\Include/arm_math.h **** 
1235:.\Include/arm_math.h **** 
1236:.\Include/arm_math.h ****   /**
1237:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR filter.
1238:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR structure.
1239:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1240:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1241:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1242:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1243:.\Include/arm_math.h ****    */
1244:.\Include/arm_math.h ****   void arm_fir_init_q31(
1245:.\Include/arm_math.h ****   arm_fir_instance_q31 * S,
1246:.\Include/arm_math.h ****   uint16_t numTaps,
1247:.\Include/arm_math.h ****   q31_t * pCoeffs,
1248:.\Include/arm_math.h ****   q31_t * pState,
1249:.\Include/arm_math.h ****   uint32_t blockSize);
1250:.\Include/arm_math.h **** 
1251:.\Include/arm_math.h **** 
1252:.\Include/arm_math.h ****   /**
1253:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR filter.
1254:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR structure.
1255:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1256:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1257:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1258:.\Include/arm_math.h ****    */
1259:.\Include/arm_math.h ****   void arm_fir_f32(
1260:.\Include/arm_math.h ****   const arm_fir_instance_f32 * S,
1261:.\Include/arm_math.h ****   float32_t * pSrc,
1262:.\Include/arm_math.h ****   float32_t * pDst,
1263:.\Include/arm_math.h ****   uint32_t blockSize);
1264:.\Include/arm_math.h **** 
1265:.\Include/arm_math.h **** 
1266:.\Include/arm_math.h ****   /**
1267:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR filter.
1268:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
1269:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1270:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1271:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1272:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1273:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 32


1274:.\Include/arm_math.h ****   void arm_fir_init_f32(
1275:.\Include/arm_math.h ****   arm_fir_instance_f32 * S,
1276:.\Include/arm_math.h ****   uint16_t numTaps,
1277:.\Include/arm_math.h ****   float32_t * pCoeffs,
1278:.\Include/arm_math.h ****   float32_t * pState,
1279:.\Include/arm_math.h ****   uint32_t blockSize);
1280:.\Include/arm_math.h **** 
1281:.\Include/arm_math.h **** 
1282:.\Include/arm_math.h ****   /**
1283:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 Biquad cascade filter.
1284:.\Include/arm_math.h ****    */
1285:.\Include/arm_math.h ****   typedef struct
1286:.\Include/arm_math.h ****   {
1287:.\Include/arm_math.h ****     int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*num
1288:.\Include/arm_math.h ****     q15_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1289:.\Include/arm_math.h ****     q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1290:.\Include/arm_math.h ****     int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
1291:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q15;
1292:.\Include/arm_math.h **** 
1293:.\Include/arm_math.h ****   /**
1294:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 Biquad cascade filter.
1295:.\Include/arm_math.h ****    */
1296:.\Include/arm_math.h ****   typedef struct
1297:.\Include/arm_math.h ****   {
1298:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1299:.\Include/arm_math.h ****     q31_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1300:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1301:.\Include/arm_math.h ****     uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
1302:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q31;
1303:.\Include/arm_math.h **** 
1304:.\Include/arm_math.h ****   /**
1305:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Biquad cascade filter.
1306:.\Include/arm_math.h ****    */
1307:.\Include/arm_math.h ****   typedef struct
1308:.\Include/arm_math.h ****   {
1309:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1310:.\Include/arm_math.h ****     float32_t *pState;       /**< Points to the array of state coefficients.  The array is of lengt
1311:.\Include/arm_math.h ****     float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*nu
1312:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_f32;
1313:.\Include/arm_math.h **** 
1314:.\Include/arm_math.h **** 
1315:.\Include/arm_math.h ****   /**
1316:.\Include/arm_math.h ****    * @brief Processing function for the Q15 Biquad cascade filter.
1317:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1318:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1319:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1320:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1321:.\Include/arm_math.h ****    */
1322:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q15(
1323:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1324:.\Include/arm_math.h ****   q15_t * pSrc,
1325:.\Include/arm_math.h ****   q15_t * pDst,
1326:.\Include/arm_math.h ****   uint32_t blockSize);
1327:.\Include/arm_math.h **** 
1328:.\Include/arm_math.h **** 
1329:.\Include/arm_math.h ****   /**
1330:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 Biquad cascade filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 33


1331:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
1332:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1333:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1334:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1335:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1336:.\Include/arm_math.h ****    */
1337:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q15(
1338:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q15 * S,
1339:.\Include/arm_math.h ****   uint8_t numStages,
1340:.\Include/arm_math.h ****   q15_t * pCoeffs,
1341:.\Include/arm_math.h ****   q15_t * pState,
1342:.\Include/arm_math.h ****   int8_t postShift);
1343:.\Include/arm_math.h **** 
1344:.\Include/arm_math.h **** 
1345:.\Include/arm_math.h ****   /**
1346:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-
1347:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1348:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1349:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1350:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1351:.\Include/arm_math.h ****    */
1352:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q15(
1353:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1354:.\Include/arm_math.h ****   q15_t * pSrc,
1355:.\Include/arm_math.h ****   q15_t * pDst,
1356:.\Include/arm_math.h ****   uint32_t blockSize);
1357:.\Include/arm_math.h **** 
1358:.\Include/arm_math.h **** 
1359:.\Include/arm_math.h ****   /**
1360:.\Include/arm_math.h ****    * @brief Processing function for the Q31 Biquad cascade filter
1361:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1362:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1363:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1364:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1365:.\Include/arm_math.h ****    */
1366:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q31(
1367:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1368:.\Include/arm_math.h ****   q31_t * pSrc,
1369:.\Include/arm_math.h ****   q31_t * pDst,
1370:.\Include/arm_math.h ****   uint32_t blockSize);
1371:.\Include/arm_math.h **** 
1372:.\Include/arm_math.h **** 
1373:.\Include/arm_math.h ****   /**
1374:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-
1375:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1376:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1377:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1378:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1379:.\Include/arm_math.h ****    */
1380:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q31(
1381:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1382:.\Include/arm_math.h ****   q31_t * pSrc,
1383:.\Include/arm_math.h ****   q31_t * pDst,
1384:.\Include/arm_math.h ****   uint32_t blockSize);
1385:.\Include/arm_math.h **** 
1386:.\Include/arm_math.h **** 
1387:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 34


1388:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 Biquad cascade filter.
1389:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
1390:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1391:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1392:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1393:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1394:.\Include/arm_math.h ****    */
1395:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q31(
1396:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q31 * S,
1397:.\Include/arm_math.h ****   uint8_t numStages,
1398:.\Include/arm_math.h ****   q31_t * pCoeffs,
1399:.\Include/arm_math.h ****   q31_t * pState,
1400:.\Include/arm_math.h ****   int8_t postShift);
1401:.\Include/arm_math.h **** 
1402:.\Include/arm_math.h **** 
1403:.\Include/arm_math.h ****   /**
1404:.\Include/arm_math.h ****    * @brief Processing function for the floating-point Biquad cascade filter.
1405:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
1406:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1407:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1408:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1409:.\Include/arm_math.h ****    */
1410:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_f32(
1411:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_f32 * S,
1412:.\Include/arm_math.h ****   float32_t * pSrc,
1413:.\Include/arm_math.h ****   float32_t * pDst,
1414:.\Include/arm_math.h ****   uint32_t blockSize);
1415:.\Include/arm_math.h **** 
1416:.\Include/arm_math.h **** 
1417:.\Include/arm_math.h ****   /**
1418:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point Biquad cascade filter.
1419:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure
1420:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1421:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1422:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1423:.\Include/arm_math.h ****    */
1424:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_f32(
1425:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_f32 * S,
1426:.\Include/arm_math.h ****   uint8_t numStages,
1427:.\Include/arm_math.h ****   float32_t * pCoeffs,
1428:.\Include/arm_math.h ****   float32_t * pState);
1429:.\Include/arm_math.h **** 
1430:.\Include/arm_math.h **** 
1431:.\Include/arm_math.h ****   /**
1432:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1433:.\Include/arm_math.h ****    */
1434:.\Include/arm_math.h ****   typedef struct
1435:.\Include/arm_math.h ****   {
1436:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1437:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1438:.\Include/arm_math.h ****     float32_t *pData;     /**< points to the data of the matrix. */
1439:.\Include/arm_math.h ****   } arm_matrix_instance_f32;
1440:.\Include/arm_math.h **** 
1441:.\Include/arm_math.h **** 
1442:.\Include/arm_math.h ****   /**
1443:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1444:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 35


1445:.\Include/arm_math.h ****   typedef struct
1446:.\Include/arm_math.h ****   {
1447:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1448:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1449:.\Include/arm_math.h ****     float64_t *pData;     /**< points to the data of the matrix. */
1450:.\Include/arm_math.h ****   } arm_matrix_instance_f64;
1451:.\Include/arm_math.h **** 
1452:.\Include/arm_math.h ****   /**
1453:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 matrix structure.
1454:.\Include/arm_math.h ****    */
1455:.\Include/arm_math.h ****   typedef struct
1456:.\Include/arm_math.h ****   {
1457:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1458:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1459:.\Include/arm_math.h ****     q15_t *pData;         /**< points to the data of the matrix. */
1460:.\Include/arm_math.h ****   } arm_matrix_instance_q15;
1461:.\Include/arm_math.h **** 
1462:.\Include/arm_math.h ****   /**
1463:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 matrix structure.
1464:.\Include/arm_math.h ****    */
1465:.\Include/arm_math.h ****   typedef struct
1466:.\Include/arm_math.h ****   {
1467:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1468:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1469:.\Include/arm_math.h ****     q31_t *pData;         /**< points to the data of the matrix. */
1470:.\Include/arm_math.h ****   } arm_matrix_instance_q31;
1471:.\Include/arm_math.h **** 
1472:.\Include/arm_math.h **** 
1473:.\Include/arm_math.h ****   /**
1474:.\Include/arm_math.h ****    * @brief Floating-point matrix addition.
1475:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1476:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1477:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1478:.\Include/arm_math.h ****    * @return     The function returns either
1479:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1480:.\Include/arm_math.h ****    */
1481:.\Include/arm_math.h ****   arm_status arm_mat_add_f32(
1482:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1483:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1484:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1485:.\Include/arm_math.h **** 
1486:.\Include/arm_math.h **** 
1487:.\Include/arm_math.h ****   /**
1488:.\Include/arm_math.h ****    * @brief Q15 matrix addition.
1489:.\Include/arm_math.h ****    * @param[in]   pSrcA  points to the first input matrix structure
1490:.\Include/arm_math.h ****    * @param[in]   pSrcB  points to the second input matrix structure
1491:.\Include/arm_math.h ****    * @param[out]  pDst   points to output matrix structure
1492:.\Include/arm_math.h ****    * @return     The function returns either
1493:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1494:.\Include/arm_math.h ****    */
1495:.\Include/arm_math.h ****   arm_status arm_mat_add_q15(
1496:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1497:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1498:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1499:.\Include/arm_math.h **** 
1500:.\Include/arm_math.h **** 
1501:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 36


1502:.\Include/arm_math.h ****    * @brief Q31 matrix addition.
1503:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1504:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1505:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1506:.\Include/arm_math.h ****    * @return     The function returns either
1507:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1508:.\Include/arm_math.h ****    */
1509:.\Include/arm_math.h ****   arm_status arm_mat_add_q31(
1510:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1511:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1512:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1513:.\Include/arm_math.h **** 
1514:.\Include/arm_math.h **** 
1515:.\Include/arm_math.h ****   /**
1516:.\Include/arm_math.h ****    * @brief Floating-point, complex, matrix multiplication.
1517:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1518:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1519:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1520:.\Include/arm_math.h ****    * @return     The function returns either
1521:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1522:.\Include/arm_math.h ****    */
1523:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_f32(
1524:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1525:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1526:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1527:.\Include/arm_math.h **** 
1528:.\Include/arm_math.h **** 
1529:.\Include/arm_math.h ****   /**
1530:.\Include/arm_math.h ****    * @brief Q15, complex,  matrix multiplication.
1531:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1532:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1533:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1534:.\Include/arm_math.h ****    * @return     The function returns either
1535:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1536:.\Include/arm_math.h ****    */
1537:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q15(
1538:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1539:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1540:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1541:.\Include/arm_math.h ****   q15_t * pScratch);
1542:.\Include/arm_math.h **** 
1543:.\Include/arm_math.h **** 
1544:.\Include/arm_math.h ****   /**
1545:.\Include/arm_math.h ****    * @brief Q31, complex, matrix multiplication.
1546:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1547:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1548:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1549:.\Include/arm_math.h ****    * @return     The function returns either
1550:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1551:.\Include/arm_math.h ****    */
1552:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q31(
1553:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1554:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1555:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1556:.\Include/arm_math.h **** 
1557:.\Include/arm_math.h **** 
1558:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 37


1559:.\Include/arm_math.h ****    * @brief Floating-point matrix transpose.
1560:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1561:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1562:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1563:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1564:.\Include/arm_math.h ****    */
1565:.\Include/arm_math.h ****   arm_status arm_mat_trans_f32(
1566:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1567:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1568:.\Include/arm_math.h **** 
1569:.\Include/arm_math.h **** 
1570:.\Include/arm_math.h ****   /**
1571:.\Include/arm_math.h ****    * @brief Q15 matrix transpose.
1572:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1573:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1574:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1575:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1576:.\Include/arm_math.h ****    */
1577:.\Include/arm_math.h ****   arm_status arm_mat_trans_q15(
1578:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1579:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1580:.\Include/arm_math.h **** 
1581:.\Include/arm_math.h **** 
1582:.\Include/arm_math.h ****   /**
1583:.\Include/arm_math.h ****    * @brief Q31 matrix transpose.
1584:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1585:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1586:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1587:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1588:.\Include/arm_math.h ****    */
1589:.\Include/arm_math.h ****   arm_status arm_mat_trans_q31(
1590:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1591:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1592:.\Include/arm_math.h **** 
1593:.\Include/arm_math.h **** 
1594:.\Include/arm_math.h ****   /**
1595:.\Include/arm_math.h ****    * @brief Floating-point matrix multiplication
1596:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1597:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1598:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1599:.\Include/arm_math.h ****    * @return     The function returns either
1600:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1601:.\Include/arm_math.h ****    */
1602:.\Include/arm_math.h ****   arm_status arm_mat_mult_f32(
1603:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1604:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1605:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1606:.\Include/arm_math.h **** 
1607:.\Include/arm_math.h **** 
1608:.\Include/arm_math.h ****   /**
1609:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication
1610:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1611:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1612:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1613:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1614:.\Include/arm_math.h ****    * @return     The function returns either
1615:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 38


1616:.\Include/arm_math.h ****    */
1617:.\Include/arm_math.h ****   arm_status arm_mat_mult_q15(
1618:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1619:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1620:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1621:.\Include/arm_math.h ****   q15_t * pState);
1622:.\Include/arm_math.h **** 
1623:.\Include/arm_math.h **** 
1624:.\Include/arm_math.h ****   /**
1625:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1626:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1627:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1628:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1629:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1630:.\Include/arm_math.h ****    * @return     The function returns either
1631:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1632:.\Include/arm_math.h ****    */
1633:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q15(
1634:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1635:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1636:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1637:.\Include/arm_math.h ****   q15_t * pState);
1638:.\Include/arm_math.h **** 
1639:.\Include/arm_math.h **** 
1640:.\Include/arm_math.h ****   /**
1641:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication
1642:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1643:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1644:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1645:.\Include/arm_math.h ****    * @return     The function returns either
1646:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1647:.\Include/arm_math.h ****    */
1648:.\Include/arm_math.h ****   arm_status arm_mat_mult_q31(
1649:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1650:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1651:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1652:.\Include/arm_math.h **** 
1653:.\Include/arm_math.h **** 
1654:.\Include/arm_math.h ****   /**
1655:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1656:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1657:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1658:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1659:.\Include/arm_math.h ****    * @return     The function returns either
1660:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1661:.\Include/arm_math.h ****    */
1662:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q31(
1663:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1664:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1665:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1666:.\Include/arm_math.h **** 
1667:.\Include/arm_math.h **** 
1668:.\Include/arm_math.h ****   /**
1669:.\Include/arm_math.h ****    * @brief Floating-point matrix subtraction
1670:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1671:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1672:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 39


1673:.\Include/arm_math.h ****    * @return     The function returns either
1674:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1675:.\Include/arm_math.h ****    */
1676:.\Include/arm_math.h ****   arm_status arm_mat_sub_f32(
1677:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1678:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1679:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1680:.\Include/arm_math.h **** 
1681:.\Include/arm_math.h **** 
1682:.\Include/arm_math.h ****   /**
1683:.\Include/arm_math.h ****    * @brief Q15 matrix subtraction
1684:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1685:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1686:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1687:.\Include/arm_math.h ****    * @return     The function returns either
1688:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1689:.\Include/arm_math.h ****    */
1690:.\Include/arm_math.h ****   arm_status arm_mat_sub_q15(
1691:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1692:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1693:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1694:.\Include/arm_math.h **** 
1695:.\Include/arm_math.h **** 
1696:.\Include/arm_math.h ****   /**
1697:.\Include/arm_math.h ****    * @brief Q31 matrix subtraction
1698:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1699:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1700:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1701:.\Include/arm_math.h ****    * @return     The function returns either
1702:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1703:.\Include/arm_math.h ****    */
1704:.\Include/arm_math.h ****   arm_status arm_mat_sub_q31(
1705:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1706:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1707:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1708:.\Include/arm_math.h **** 
1709:.\Include/arm_math.h **** 
1710:.\Include/arm_math.h ****   /**
1711:.\Include/arm_math.h ****    * @brief Floating-point matrix scaling.
1712:.\Include/arm_math.h ****    * @param[in]  pSrc   points to the input matrix
1713:.\Include/arm_math.h ****    * @param[in]  scale  scale factor
1714:.\Include/arm_math.h ****    * @param[out] pDst   points to the output matrix
1715:.\Include/arm_math.h ****    * @return     The function returns either
1716:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1717:.\Include/arm_math.h ****    */
1718:.\Include/arm_math.h ****   arm_status arm_mat_scale_f32(
1719:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1720:.\Include/arm_math.h ****   float32_t scale,
1721:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1722:.\Include/arm_math.h **** 
1723:.\Include/arm_math.h **** 
1724:.\Include/arm_math.h ****   /**
1725:.\Include/arm_math.h ****    * @brief Q15 matrix scaling.
1726:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1727:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1728:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1729:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 40


1730:.\Include/arm_math.h ****    * @return     The function returns either
1731:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1732:.\Include/arm_math.h ****    */
1733:.\Include/arm_math.h ****   arm_status arm_mat_scale_q15(
1734:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1735:.\Include/arm_math.h ****   q15_t scaleFract,
1736:.\Include/arm_math.h ****   int32_t shift,
1737:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1738:.\Include/arm_math.h **** 
1739:.\Include/arm_math.h **** 
1740:.\Include/arm_math.h ****   /**
1741:.\Include/arm_math.h ****    * @brief Q31 matrix scaling.
1742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1743:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1744:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1745:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix structure
1746:.\Include/arm_math.h ****    * @return     The function returns either
1747:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1748:.\Include/arm_math.h ****    */
1749:.\Include/arm_math.h ****   arm_status arm_mat_scale_q31(
1750:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1751:.\Include/arm_math.h ****   q31_t scaleFract,
1752:.\Include/arm_math.h ****   int32_t shift,
1753:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1754:.\Include/arm_math.h **** 
1755:.\Include/arm_math.h **** 
1756:.\Include/arm_math.h ****   /**
1757:.\Include/arm_math.h ****    * @brief  Q31 matrix initialization.
1758:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1759:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1760:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1761:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1762:.\Include/arm_math.h ****    */
1763:.\Include/arm_math.h ****   void arm_mat_init_q31(
1764:.\Include/arm_math.h ****   arm_matrix_instance_q31 * S,
1765:.\Include/arm_math.h ****   uint16_t nRows,
1766:.\Include/arm_math.h ****   uint16_t nColumns,
1767:.\Include/arm_math.h ****   q31_t * pData);
1768:.\Include/arm_math.h **** 
1769:.\Include/arm_math.h **** 
1770:.\Include/arm_math.h ****   /**
1771:.\Include/arm_math.h ****    * @brief  Q15 matrix initialization.
1772:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1773:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1774:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1775:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1776:.\Include/arm_math.h ****    */
1777:.\Include/arm_math.h ****   void arm_mat_init_q15(
1778:.\Include/arm_math.h ****   arm_matrix_instance_q15 * S,
1779:.\Include/arm_math.h ****   uint16_t nRows,
1780:.\Include/arm_math.h ****   uint16_t nColumns,
1781:.\Include/arm_math.h ****   q15_t * pData);
1782:.\Include/arm_math.h **** 
1783:.\Include/arm_math.h **** 
1784:.\Include/arm_math.h ****   /**
1785:.\Include/arm_math.h ****    * @brief  Floating-point matrix initialization.
1786:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 41


1787:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1788:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1789:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1790:.\Include/arm_math.h ****    */
1791:.\Include/arm_math.h ****   void arm_mat_init_f32(
1792:.\Include/arm_math.h ****   arm_matrix_instance_f32 * S,
1793:.\Include/arm_math.h ****   uint16_t nRows,
1794:.\Include/arm_math.h ****   uint16_t nColumns,
1795:.\Include/arm_math.h ****   float32_t * pData);
1796:.\Include/arm_math.h **** 
1797:.\Include/arm_math.h **** 
1798:.\Include/arm_math.h **** 
1799:.\Include/arm_math.h ****   /**
1800:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 PID Control.
1801:.\Include/arm_math.h ****    */
1802:.\Include/arm_math.h ****   typedef struct
1803:.\Include/arm_math.h ****   {
1804:.\Include/arm_math.h ****     q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
1805:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
1806:.\Include/arm_math.h ****     q15_t A1;
1807:.\Include/arm_math.h ****     q15_t A2;
1808:.\Include/arm_math.h **** #else
1809:.\Include/arm_math.h ****     q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
1810:.\Include/arm_math.h **** #endif
1811:.\Include/arm_math.h ****     q15_t state[3];     /**< The state array of length 3. */
1812:.\Include/arm_math.h ****     q15_t Kp;           /**< The proportional gain. */
1813:.\Include/arm_math.h ****     q15_t Ki;           /**< The integral gain. */
1814:.\Include/arm_math.h ****     q15_t Kd;           /**< The derivative gain. */
1815:.\Include/arm_math.h ****   } arm_pid_instance_q15;
1816:.\Include/arm_math.h **** 
1817:.\Include/arm_math.h ****   /**
1818:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 PID Control.
1819:.\Include/arm_math.h ****    */
1820:.\Include/arm_math.h ****   typedef struct
1821:.\Include/arm_math.h ****   {
1822:.\Include/arm_math.h ****     q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
1823:.\Include/arm_math.h ****     q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
1824:.\Include/arm_math.h ****     q31_t A2;            /**< The derived gain, A2 = Kd . */
1825:.\Include/arm_math.h ****     q31_t state[3];      /**< The state array of length 3. */
1826:.\Include/arm_math.h ****     q31_t Kp;            /**< The proportional gain. */
1827:.\Include/arm_math.h ****     q31_t Ki;            /**< The integral gain. */
1828:.\Include/arm_math.h ****     q31_t Kd;            /**< The derivative gain. */
1829:.\Include/arm_math.h ****   } arm_pid_instance_q31;
1830:.\Include/arm_math.h **** 
1831:.\Include/arm_math.h ****   /**
1832:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point PID Control.
1833:.\Include/arm_math.h ****    */
1834:.\Include/arm_math.h ****   typedef struct
1835:.\Include/arm_math.h ****   {
1836:.\Include/arm_math.h ****     float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
1837:.\Include/arm_math.h ****     float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
1838:.\Include/arm_math.h ****     float32_t A2;          /**< The derived gain, A2 = Kd . */
1839:.\Include/arm_math.h ****     float32_t state[3];    /**< The state array of length 3. */
1840:.\Include/arm_math.h ****     float32_t Kp;          /**< The proportional gain. */
1841:.\Include/arm_math.h ****     float32_t Ki;          /**< The integral gain. */
1842:.\Include/arm_math.h ****     float32_t Kd;          /**< The derivative gain. */
1843:.\Include/arm_math.h ****   } arm_pid_instance_f32;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 42


1844:.\Include/arm_math.h **** 
1845:.\Include/arm_math.h **** 
1846:.\Include/arm_math.h **** 
1847:.\Include/arm_math.h ****   /**
1848:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point PID Control.
1849:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the PID structure.
1850:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1851:.\Include/arm_math.h ****    */
1852:.\Include/arm_math.h ****   void arm_pid_init_f32(
1853:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
1854:.\Include/arm_math.h ****   int32_t resetStateFlag);
1855:.\Include/arm_math.h **** 
1856:.\Include/arm_math.h **** 
1857:.\Include/arm_math.h ****   /**
1858:.\Include/arm_math.h ****    * @brief  Reset function for the floating-point PID Control.
1859:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point PID Control structure
1860:.\Include/arm_math.h ****    */
1861:.\Include/arm_math.h ****   void arm_pid_reset_f32(
1862:.\Include/arm_math.h ****   arm_pid_instance_f32 * S);
1863:.\Include/arm_math.h **** 
1864:.\Include/arm_math.h **** 
1865:.\Include/arm_math.h ****   /**
1866:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 PID Control.
1867:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1868:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1869:.\Include/arm_math.h ****    */
1870:.\Include/arm_math.h ****   void arm_pid_init_q31(
1871:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
1872:.\Include/arm_math.h ****   int32_t resetStateFlag);
1873:.\Include/arm_math.h **** 
1874:.\Include/arm_math.h **** 
1875:.\Include/arm_math.h ****   /**
1876:.\Include/arm_math.h ****    * @brief  Reset function for the Q31 PID Control.
1877:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q31 PID Control structure
1878:.\Include/arm_math.h ****    */
1879:.\Include/arm_math.h **** 
1880:.\Include/arm_math.h ****   void arm_pid_reset_q31(
1881:.\Include/arm_math.h ****   arm_pid_instance_q31 * S);
1882:.\Include/arm_math.h **** 
1883:.\Include/arm_math.h **** 
1884:.\Include/arm_math.h ****   /**
1885:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 PID Control.
1886:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1887:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1888:.\Include/arm_math.h ****    */
1889:.\Include/arm_math.h ****   void arm_pid_init_q15(
1890:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
1891:.\Include/arm_math.h ****   int32_t resetStateFlag);
1892:.\Include/arm_math.h **** 
1893:.\Include/arm_math.h **** 
1894:.\Include/arm_math.h ****   /**
1895:.\Include/arm_math.h ****    * @brief  Reset function for the Q15 PID Control.
1896:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the q15 PID Control structure
1897:.\Include/arm_math.h ****    */
1898:.\Include/arm_math.h ****   void arm_pid_reset_q15(
1899:.\Include/arm_math.h ****   arm_pid_instance_q15 * S);
1900:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 43


1901:.\Include/arm_math.h **** 
1902:.\Include/arm_math.h ****   /**
1903:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Linear Interpolate function.
1904:.\Include/arm_math.h ****    */
1905:.\Include/arm_math.h ****   typedef struct
1906:.\Include/arm_math.h ****   {
1907:.\Include/arm_math.h ****     uint32_t nValues;           /**< nValues */
1908:.\Include/arm_math.h ****     float32_t x1;               /**< x1 */
1909:.\Include/arm_math.h ****     float32_t xSpacing;         /**< xSpacing */
1910:.\Include/arm_math.h ****     float32_t *pYData;          /**< pointer to the table of Y values */
1911:.\Include/arm_math.h ****   } arm_linear_interp_instance_f32;
1912:.\Include/arm_math.h **** 
1913:.\Include/arm_math.h ****   /**
1914:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point bilinear interpolation function.
1915:.\Include/arm_math.h ****    */
1916:.\Include/arm_math.h ****   typedef struct
1917:.\Include/arm_math.h ****   {
1918:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1919:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1920:.\Include/arm_math.h ****     float32_t *pData;   /**< points to the data table. */
1921:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_f32;
1922:.\Include/arm_math.h **** 
1923:.\Include/arm_math.h ****    /**
1924:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 bilinear interpolation function.
1925:.\Include/arm_math.h ****    */
1926:.\Include/arm_math.h ****   typedef struct
1927:.\Include/arm_math.h ****   {
1928:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1929:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1930:.\Include/arm_math.h ****     q31_t *pData;       /**< points to the data table. */
1931:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q31;
1932:.\Include/arm_math.h **** 
1933:.\Include/arm_math.h ****    /**
1934:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1935:.\Include/arm_math.h ****    */
1936:.\Include/arm_math.h ****   typedef struct
1937:.\Include/arm_math.h ****   {
1938:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1939:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1940:.\Include/arm_math.h ****     q15_t *pData;       /**< points to the data table. */
1941:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q15;
1942:.\Include/arm_math.h **** 
1943:.\Include/arm_math.h ****    /**
1944:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1945:.\Include/arm_math.h ****    */
1946:.\Include/arm_math.h ****   typedef struct
1947:.\Include/arm_math.h ****   {
1948:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1949:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1950:.\Include/arm_math.h ****     q7_t *pData;        /**< points to the data table. */
1951:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q7;
1952:.\Include/arm_math.h **** 
1953:.\Include/arm_math.h **** 
1954:.\Include/arm_math.h ****   /**
1955:.\Include/arm_math.h ****    * @brief Q7 vector multiplication.
1956:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1957:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 44


1958:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1959:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1960:.\Include/arm_math.h ****    */
1961:.\Include/arm_math.h ****   void arm_mult_q7(
1962:.\Include/arm_math.h ****   q7_t * pSrcA,
1963:.\Include/arm_math.h ****   q7_t * pSrcB,
1964:.\Include/arm_math.h ****   q7_t * pDst,
1965:.\Include/arm_math.h ****   uint32_t blockSize);
1966:.\Include/arm_math.h **** 
1967:.\Include/arm_math.h **** 
1968:.\Include/arm_math.h ****   /**
1969:.\Include/arm_math.h ****    * @brief Q15 vector multiplication.
1970:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1971:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1972:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1973:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1974:.\Include/arm_math.h ****    */
1975:.\Include/arm_math.h ****   void arm_mult_q15(
1976:.\Include/arm_math.h ****   q15_t * pSrcA,
1977:.\Include/arm_math.h ****   q15_t * pSrcB,
1978:.\Include/arm_math.h ****   q15_t * pDst,
1979:.\Include/arm_math.h ****   uint32_t blockSize);
1980:.\Include/arm_math.h **** 
1981:.\Include/arm_math.h **** 
1982:.\Include/arm_math.h ****   /**
1983:.\Include/arm_math.h ****    * @brief Q31 vector multiplication.
1984:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1985:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1986:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1987:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1988:.\Include/arm_math.h ****    */
1989:.\Include/arm_math.h ****   void arm_mult_q31(
1990:.\Include/arm_math.h ****   q31_t * pSrcA,
1991:.\Include/arm_math.h ****   q31_t * pSrcB,
1992:.\Include/arm_math.h ****   q31_t * pDst,
1993:.\Include/arm_math.h ****   uint32_t blockSize);
1994:.\Include/arm_math.h **** 
1995:.\Include/arm_math.h **** 
1996:.\Include/arm_math.h ****   /**
1997:.\Include/arm_math.h ****    * @brief Floating-point vector multiplication.
1998:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1999:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2000:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2001:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2002:.\Include/arm_math.h ****    */
2003:.\Include/arm_math.h ****   void arm_mult_f32(
2004:.\Include/arm_math.h ****   float32_t * pSrcA,
2005:.\Include/arm_math.h ****   float32_t * pSrcB,
2006:.\Include/arm_math.h ****   float32_t * pDst,
2007:.\Include/arm_math.h ****   uint32_t blockSize);
2008:.\Include/arm_math.h **** 
2009:.\Include/arm_math.h **** 
2010:.\Include/arm_math.h ****   /**
2011:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2012:.\Include/arm_math.h ****    */
2013:.\Include/arm_math.h ****   typedef struct
2014:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 45


2015:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2016:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2017:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2018:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
2019:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2020:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2021:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2022:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q15;
2023:.\Include/arm_math.h **** 
2024:.\Include/arm_math.h **** /* Deprecated */
2025:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q15(
2026:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q15 * S,
2027:.\Include/arm_math.h ****   uint16_t fftLen,
2028:.\Include/arm_math.h ****   uint8_t ifftFlag,
2029:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2030:.\Include/arm_math.h **** 
2031:.\Include/arm_math.h **** /* Deprecated */
2032:.\Include/arm_math.h ****   void arm_cfft_radix2_q15(
2033:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q15 * S,
2034:.\Include/arm_math.h ****   q15_t * pSrc);
2035:.\Include/arm_math.h **** 
2036:.\Include/arm_math.h **** 
2037:.\Include/arm_math.h ****   /**
2038:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2039:.\Include/arm_math.h ****    */
2040:.\Include/arm_math.h ****   typedef struct
2041:.\Include/arm_math.h ****   {
2042:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2043:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2044:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2045:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
2046:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2047:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2048:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2049:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q15;
2050:.\Include/arm_math.h **** 
2051:.\Include/arm_math.h **** /* Deprecated */
2052:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q15(
2053:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S,
2054:.\Include/arm_math.h ****   uint16_t fftLen,
2055:.\Include/arm_math.h ****   uint8_t ifftFlag,
2056:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2057:.\Include/arm_math.h **** 
2058:.\Include/arm_math.h **** /* Deprecated */
2059:.\Include/arm_math.h ****   void arm_cfft_radix4_q15(
2060:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q15 * S,
2061:.\Include/arm_math.h ****   q15_t * pSrc);
2062:.\Include/arm_math.h **** 
2063:.\Include/arm_math.h ****   /**
2064:.\Include/arm_math.h ****    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
2065:.\Include/arm_math.h ****    */
2066:.\Include/arm_math.h ****   typedef struct
2067:.\Include/arm_math.h ****   {
2068:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2069:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2070:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2071:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 46


2072:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2073:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2074:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2075:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q31;
2076:.\Include/arm_math.h **** 
2077:.\Include/arm_math.h **** /* Deprecated */
2078:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q31(
2079:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q31 * S,
2080:.\Include/arm_math.h ****   uint16_t fftLen,
2081:.\Include/arm_math.h ****   uint8_t ifftFlag,
2082:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2083:.\Include/arm_math.h **** 
2084:.\Include/arm_math.h **** /* Deprecated */
2085:.\Include/arm_math.h ****   void arm_cfft_radix2_q31(
2086:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q31 * S,
2087:.\Include/arm_math.h ****   q31_t * pSrc);
2088:.\Include/arm_math.h **** 
2089:.\Include/arm_math.h ****   /**
2090:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 CFFT/CIFFT function.
2091:.\Include/arm_math.h ****    */
2092:.\Include/arm_math.h ****   typedef struct
2093:.\Include/arm_math.h ****   {
2094:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2095:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2096:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2097:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
2098:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2099:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2100:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2101:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q31;
2102:.\Include/arm_math.h **** 
2103:.\Include/arm_math.h **** /* Deprecated */
2104:.\Include/arm_math.h ****   void arm_cfft_radix4_q31(
2105:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q31 * S,
2106:.\Include/arm_math.h ****   q31_t * pSrc);
2107:.\Include/arm_math.h **** 
2108:.\Include/arm_math.h **** /* Deprecated */
2109:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q31(
2110:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S,
2111:.\Include/arm_math.h ****   uint16_t fftLen,
2112:.\Include/arm_math.h ****   uint8_t ifftFlag,
2113:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2114:.\Include/arm_math.h **** 
2115:.\Include/arm_math.h ****   /**
2116:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2117:.\Include/arm_math.h ****    */
2118:.\Include/arm_math.h ****   typedef struct
2119:.\Include/arm_math.h ****   {
2120:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2121:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2122:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2123:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2124:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2125:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2126:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2127:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2128:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_f32;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 47


2129:.\Include/arm_math.h **** 
2130:.\Include/arm_math.h **** /* Deprecated */
2131:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_f32(
2132:.\Include/arm_math.h ****   arm_cfft_radix2_instance_f32 * S,
2133:.\Include/arm_math.h ****   uint16_t fftLen,
2134:.\Include/arm_math.h ****   uint8_t ifftFlag,
2135:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2136:.\Include/arm_math.h **** 
2137:.\Include/arm_math.h **** /* Deprecated */
2138:.\Include/arm_math.h ****   void arm_cfft_radix2_f32(
2139:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_f32 * S,
2140:.\Include/arm_math.h ****   float32_t * pSrc);
2141:.\Include/arm_math.h **** 
2142:.\Include/arm_math.h ****   /**
2143:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2144:.\Include/arm_math.h ****    */
2145:.\Include/arm_math.h ****   typedef struct
2146:.\Include/arm_math.h ****   {
2147:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2148:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2149:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2150:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2151:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2152:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2153:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2154:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2155:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_f32;
2156:.\Include/arm_math.h **** 
2157:.\Include/arm_math.h **** /* Deprecated */
2158:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_f32(
2159:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S,
2160:.\Include/arm_math.h ****   uint16_t fftLen,
2161:.\Include/arm_math.h ****   uint8_t ifftFlag,
2162:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2163:.\Include/arm_math.h **** 
2164:.\Include/arm_math.h **** /* Deprecated */
2165:.\Include/arm_math.h ****   void arm_cfft_radix4_f32(
2166:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_f32 * S,
2167:.\Include/arm_math.h ****   float32_t * pSrc);
2168:.\Include/arm_math.h **** 
2169:.\Include/arm_math.h ****   /**
2170:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2171:.\Include/arm_math.h ****    */
2172:.\Include/arm_math.h ****   typedef struct
2173:.\Include/arm_math.h ****   {
2174:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2175:.\Include/arm_math.h ****     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
2176:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2177:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2178:.\Include/arm_math.h ****   } arm_cfft_instance_q15;
2179:.\Include/arm_math.h **** 
2180:.\Include/arm_math.h **** void arm_cfft_q15(
2181:.\Include/arm_math.h ****     const arm_cfft_instance_q15 * S,
2182:.\Include/arm_math.h ****     q15_t * p1,
2183:.\Include/arm_math.h ****     uint8_t ifftFlag,
2184:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2185:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 48


2186:.\Include/arm_math.h ****   /**
2187:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2188:.\Include/arm_math.h ****    */
2189:.\Include/arm_math.h ****   typedef struct
2190:.\Include/arm_math.h ****   {
2191:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2192:.\Include/arm_math.h ****     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
2193:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2194:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2195:.\Include/arm_math.h ****   } arm_cfft_instance_q31;
2196:.\Include/arm_math.h **** 
2197:.\Include/arm_math.h **** void arm_cfft_q31(
2198:.\Include/arm_math.h ****     const arm_cfft_instance_q31 * S,
2199:.\Include/arm_math.h ****     q31_t * p1,
2200:.\Include/arm_math.h ****     uint8_t ifftFlag,
2201:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2202:.\Include/arm_math.h **** 
2203:.\Include/arm_math.h ****   /**
2204:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2205:.\Include/arm_math.h ****    */
2206:.\Include/arm_math.h ****   typedef struct
2207:.\Include/arm_math.h ****   {
2208:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2209:.\Include/arm_math.h ****     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
2210:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2211:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2212:.\Include/arm_math.h ****   } arm_cfft_instance_f32;
2213:.\Include/arm_math.h **** 
2214:.\Include/arm_math.h ****   void arm_cfft_f32(
2215:.\Include/arm_math.h ****   const arm_cfft_instance_f32 * S,
2216:.\Include/arm_math.h ****   float32_t * p1,
2217:.\Include/arm_math.h ****   uint8_t ifftFlag,
2218:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2219:.\Include/arm_math.h **** 
2220:.\Include/arm_math.h ****   /**
2221:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 RFFT/RIFFT function.
2222:.\Include/arm_math.h ****    */
2223:.\Include/arm_math.h ****   typedef struct
2224:.\Include/arm_math.h ****   {
2225:.\Include/arm_math.h ****     uint32_t fftLenReal;                      /**< length of the real FFT. */
2226:.\Include/arm_math.h ****     uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inver
2227:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disable
2228:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports diffe
2229:.\Include/arm_math.h ****     q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
2230:.\Include/arm_math.h ****     q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
2231:.\Include/arm_math.h ****     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
2232:.\Include/arm_math.h ****   } arm_rfft_instance_q15;
2233:.\Include/arm_math.h **** 
2234:.\Include/arm_math.h ****   arm_status arm_rfft_init_q15(
2235:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S,
2236:.\Include/arm_math.h ****   uint32_t fftLenReal,
2237:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2238:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2239:.\Include/arm_math.h **** 
2240:.\Include/arm_math.h ****   void arm_rfft_q15(
2241:.\Include/arm_math.h ****   const arm_rfft_instance_q15 * S,
2242:.\Include/arm_math.h ****   q15_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 49


2243:.\Include/arm_math.h ****   q15_t * pDst);
2244:.\Include/arm_math.h **** 
2245:.\Include/arm_math.h ****   /**
2246:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 RFFT/RIFFT function.
2247:.\Include/arm_math.h ****    */
2248:.\Include/arm_math.h ****   typedef struct
2249:.\Include/arm_math.h ****   {
2250:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2251:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2252:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2253:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports dif
2254:.\Include/arm_math.h ****     q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
2255:.\Include/arm_math.h ****     q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
2256:.\Include/arm_math.h ****     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
2257:.\Include/arm_math.h ****   } arm_rfft_instance_q31;
2258:.\Include/arm_math.h **** 
2259:.\Include/arm_math.h ****   arm_status arm_rfft_init_q31(
2260:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S,
2261:.\Include/arm_math.h ****   uint32_t fftLenReal,
2262:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2263:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2264:.\Include/arm_math.h **** 
2265:.\Include/arm_math.h ****   void arm_rfft_q31(
2266:.\Include/arm_math.h ****   const arm_rfft_instance_q31 * S,
2267:.\Include/arm_math.h ****   q31_t * pSrc,
2268:.\Include/arm_math.h ****   q31_t * pDst);
2269:.\Include/arm_math.h **** 
2270:.\Include/arm_math.h ****   /**
2271:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2272:.\Include/arm_math.h ****    */
2273:.\Include/arm_math.h ****   typedef struct
2274:.\Include/arm_math.h ****   {
2275:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2276:.\Include/arm_math.h ****     uint16_t fftLenBy2;                         /**< length of the complex FFT. */
2277:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2278:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2279:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports
2280:.\Include/arm_math.h ****     float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
2281:.\Include/arm_math.h ****     float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
2282:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
2283:.\Include/arm_math.h ****   } arm_rfft_instance_f32;
2284:.\Include/arm_math.h **** 
2285:.\Include/arm_math.h ****   arm_status arm_rfft_init_f32(
2286:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S,
2287:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2288:.\Include/arm_math.h ****   uint32_t fftLenReal,
2289:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2290:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2291:.\Include/arm_math.h **** 
2292:.\Include/arm_math.h ****   void arm_rfft_f32(
2293:.\Include/arm_math.h ****   const arm_rfft_instance_f32 * S,
2294:.\Include/arm_math.h ****   float32_t * pSrc,
2295:.\Include/arm_math.h ****   float32_t * pDst);
2296:.\Include/arm_math.h **** 
2297:.\Include/arm_math.h ****   /**
2298:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2299:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 50


2300:.\Include/arm_math.h **** typedef struct
2301:.\Include/arm_math.h ****   {
2302:.\Include/arm_math.h ****     arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
2303:.\Include/arm_math.h ****     uint16_t fftLenRFFT;             /**< length of the real sequence */
2304:.\Include/arm_math.h ****     float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
2305:.\Include/arm_math.h ****   } arm_rfft_fast_instance_f32 ;
2306:.\Include/arm_math.h **** 
2307:.\Include/arm_math.h **** arm_status arm_rfft_fast_init_f32 (
2308:.\Include/arm_math.h ****    arm_rfft_fast_instance_f32 * S,
2309:.\Include/arm_math.h ****    uint16_t fftLen);
2310:.\Include/arm_math.h **** 
2311:.\Include/arm_math.h **** void arm_rfft_fast_f32(
2312:.\Include/arm_math.h ****   arm_rfft_fast_instance_f32 * S,
2313:.\Include/arm_math.h ****   float32_t * p, float32_t * pOut,
2314:.\Include/arm_math.h ****   uint8_t ifftFlag);
2315:.\Include/arm_math.h **** 
2316:.\Include/arm_math.h ****   /**
2317:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
2318:.\Include/arm_math.h ****    */
2319:.\Include/arm_math.h ****   typedef struct
2320:.\Include/arm_math.h ****   {
2321:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2322:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2323:.\Include/arm_math.h ****     float32_t normalize;                 /**< normalizing factor. */
2324:.\Include/arm_math.h ****     float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
2325:.\Include/arm_math.h ****     float32_t *pCosFactor;               /**< points to the cosFactor table. */
2326:.\Include/arm_math.h ****     arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
2327:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
2328:.\Include/arm_math.h ****   } arm_dct4_instance_f32;
2329:.\Include/arm_math.h **** 
2330:.\Include/arm_math.h **** 
2331:.\Include/arm_math.h ****   /**
2332:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point DCT4/IDCT4.
2333:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
2334:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
2335:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
2336:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2337:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2338:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2339:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2340:.\Include/arm_math.h ****    */
2341:.\Include/arm_math.h ****   arm_status arm_dct4_init_f32(
2342:.\Include/arm_math.h ****   arm_dct4_instance_f32 * S,
2343:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S_RFFT,
2344:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2345:.\Include/arm_math.h ****   uint16_t N,
2346:.\Include/arm_math.h ****   uint16_t Nby2,
2347:.\Include/arm_math.h ****   float32_t normalize);
2348:.\Include/arm_math.h **** 
2349:.\Include/arm_math.h **** 
2350:.\Include/arm_math.h ****   /**
2351:.\Include/arm_math.h ****    * @brief Processing function for the floating-point DCT4/IDCT4.
2352:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure
2353:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2354:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2355:.\Include/arm_math.h ****    */
2356:.\Include/arm_math.h ****   void arm_dct4_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 51


2357:.\Include/arm_math.h ****   const arm_dct4_instance_f32 * S,
2358:.\Include/arm_math.h ****   float32_t * pState,
2359:.\Include/arm_math.h ****   float32_t * pInlineBuffer);
2360:.\Include/arm_math.h **** 
2361:.\Include/arm_math.h **** 
2362:.\Include/arm_math.h ****   /**
2363:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 DCT4/IDCT4 function.
2364:.\Include/arm_math.h ****    */
2365:.\Include/arm_math.h ****   typedef struct
2366:.\Include/arm_math.h ****   {
2367:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2368:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2369:.\Include/arm_math.h ****     q31_t normalize;                     /**< normalizing factor. */
2370:.\Include/arm_math.h ****     q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
2371:.\Include/arm_math.h ****     q31_t *pCosFactor;                   /**< points to the cosFactor table. */
2372:.\Include/arm_math.h ****     arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
2373:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
2374:.\Include/arm_math.h ****   } arm_dct4_instance_q31;
2375:.\Include/arm_math.h **** 
2376:.\Include/arm_math.h **** 
2377:.\Include/arm_math.h ****   /**
2378:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 DCT4/IDCT4.
2379:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
2380:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
2381:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
2382:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2383:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2384:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2385:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2386:.\Include/arm_math.h ****    */
2387:.\Include/arm_math.h ****   arm_status arm_dct4_init_q31(
2388:.\Include/arm_math.h ****   arm_dct4_instance_q31 * S,
2389:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S_RFFT,
2390:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S_CFFT,
2391:.\Include/arm_math.h ****   uint16_t N,
2392:.\Include/arm_math.h ****   uint16_t Nby2,
2393:.\Include/arm_math.h ****   q31_t normalize);
2394:.\Include/arm_math.h **** 
2395:.\Include/arm_math.h **** 
2396:.\Include/arm_math.h ****   /**
2397:.\Include/arm_math.h ****    * @brief Processing function for the Q31 DCT4/IDCT4.
2398:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q31 DCT4 structure.
2399:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2400:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2401:.\Include/arm_math.h ****    */
2402:.\Include/arm_math.h ****   void arm_dct4_q31(
2403:.\Include/arm_math.h ****   const arm_dct4_instance_q31 * S,
2404:.\Include/arm_math.h ****   q31_t * pState,
2405:.\Include/arm_math.h ****   q31_t * pInlineBuffer);
2406:.\Include/arm_math.h **** 
2407:.\Include/arm_math.h **** 
2408:.\Include/arm_math.h ****   /**
2409:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 DCT4/IDCT4 function.
2410:.\Include/arm_math.h ****    */
2411:.\Include/arm_math.h ****   typedef struct
2412:.\Include/arm_math.h ****   {
2413:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 52


2414:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2415:.\Include/arm_math.h ****     q15_t normalize;                     /**< normalizing factor. */
2416:.\Include/arm_math.h ****     q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
2417:.\Include/arm_math.h ****     q15_t *pCosFactor;                   /**< points to the cosFactor table. */
2418:.\Include/arm_math.h ****     arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
2419:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
2420:.\Include/arm_math.h ****   } arm_dct4_instance_q15;
2421:.\Include/arm_math.h **** 
2422:.\Include/arm_math.h **** 
2423:.\Include/arm_math.h ****   /**
2424:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 DCT4/IDCT4.
2425:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
2426:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
2427:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
2428:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2429:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2430:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2431:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2432:.\Include/arm_math.h ****    */
2433:.\Include/arm_math.h ****   arm_status arm_dct4_init_q15(
2434:.\Include/arm_math.h ****   arm_dct4_instance_q15 * S,
2435:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S_RFFT,
2436:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S_CFFT,
2437:.\Include/arm_math.h ****   uint16_t N,
2438:.\Include/arm_math.h ****   uint16_t Nby2,
2439:.\Include/arm_math.h ****   q15_t normalize);
2440:.\Include/arm_math.h **** 
2441:.\Include/arm_math.h **** 
2442:.\Include/arm_math.h ****   /**
2443:.\Include/arm_math.h ****    * @brief Processing function for the Q15 DCT4/IDCT4.
2444:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q15 DCT4 structure.
2445:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2446:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2447:.\Include/arm_math.h ****    */
2448:.\Include/arm_math.h ****   void arm_dct4_q15(
2449:.\Include/arm_math.h ****   const arm_dct4_instance_q15 * S,
2450:.\Include/arm_math.h ****   q15_t * pState,
2451:.\Include/arm_math.h ****   q15_t * pInlineBuffer);
2452:.\Include/arm_math.h **** 
2453:.\Include/arm_math.h **** 
2454:.\Include/arm_math.h ****   /**
2455:.\Include/arm_math.h ****    * @brief Floating-point vector addition.
2456:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2457:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2458:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2459:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2460:.\Include/arm_math.h ****    */
2461:.\Include/arm_math.h ****   void arm_add_f32(
2462:.\Include/arm_math.h ****   float32_t * pSrcA,
2463:.\Include/arm_math.h ****   float32_t * pSrcB,
2464:.\Include/arm_math.h ****   float32_t * pDst,
2465:.\Include/arm_math.h ****   uint32_t blockSize);
2466:.\Include/arm_math.h **** 
2467:.\Include/arm_math.h **** 
2468:.\Include/arm_math.h ****   /**
2469:.\Include/arm_math.h ****    * @brief Q7 vector addition.
2470:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 53


2471:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2472:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2473:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2474:.\Include/arm_math.h ****    */
2475:.\Include/arm_math.h ****   void arm_add_q7(
2476:.\Include/arm_math.h ****   q7_t * pSrcA,
2477:.\Include/arm_math.h ****   q7_t * pSrcB,
2478:.\Include/arm_math.h ****   q7_t * pDst,
2479:.\Include/arm_math.h ****   uint32_t blockSize);
2480:.\Include/arm_math.h **** 
2481:.\Include/arm_math.h **** 
2482:.\Include/arm_math.h ****   /**
2483:.\Include/arm_math.h ****    * @brief Q15 vector addition.
2484:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2485:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2486:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2487:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2488:.\Include/arm_math.h ****    */
2489:.\Include/arm_math.h ****   void arm_add_q15(
2490:.\Include/arm_math.h ****   q15_t * pSrcA,
2491:.\Include/arm_math.h ****   q15_t * pSrcB,
2492:.\Include/arm_math.h ****   q15_t * pDst,
2493:.\Include/arm_math.h ****   uint32_t blockSize);
2494:.\Include/arm_math.h **** 
2495:.\Include/arm_math.h **** 
2496:.\Include/arm_math.h ****   /**
2497:.\Include/arm_math.h ****    * @brief Q31 vector addition.
2498:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2499:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2500:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2501:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2502:.\Include/arm_math.h ****    */
2503:.\Include/arm_math.h ****   void arm_add_q31(
2504:.\Include/arm_math.h ****   q31_t * pSrcA,
2505:.\Include/arm_math.h ****   q31_t * pSrcB,
2506:.\Include/arm_math.h ****   q31_t * pDst,
2507:.\Include/arm_math.h ****   uint32_t blockSize);
2508:.\Include/arm_math.h **** 
2509:.\Include/arm_math.h **** 
2510:.\Include/arm_math.h ****   /**
2511:.\Include/arm_math.h ****    * @brief Floating-point vector subtraction.
2512:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2513:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2514:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2515:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2516:.\Include/arm_math.h ****    */
2517:.\Include/arm_math.h ****   void arm_sub_f32(
2518:.\Include/arm_math.h ****   float32_t * pSrcA,
2519:.\Include/arm_math.h ****   float32_t * pSrcB,
2520:.\Include/arm_math.h ****   float32_t * pDst,
2521:.\Include/arm_math.h ****   uint32_t blockSize);
2522:.\Include/arm_math.h **** 
2523:.\Include/arm_math.h **** 
2524:.\Include/arm_math.h ****   /**
2525:.\Include/arm_math.h ****    * @brief Q7 vector subtraction.
2526:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2527:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 54


2528:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2529:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2530:.\Include/arm_math.h ****    */
2531:.\Include/arm_math.h ****   void arm_sub_q7(
2532:.\Include/arm_math.h ****   q7_t * pSrcA,
2533:.\Include/arm_math.h ****   q7_t * pSrcB,
2534:.\Include/arm_math.h ****   q7_t * pDst,
2535:.\Include/arm_math.h ****   uint32_t blockSize);
2536:.\Include/arm_math.h **** 
2537:.\Include/arm_math.h **** 
2538:.\Include/arm_math.h ****   /**
2539:.\Include/arm_math.h ****    * @brief Q15 vector subtraction.
2540:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2541:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2542:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2543:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2544:.\Include/arm_math.h ****    */
2545:.\Include/arm_math.h ****   void arm_sub_q15(
2546:.\Include/arm_math.h ****   q15_t * pSrcA,
2547:.\Include/arm_math.h ****   q15_t * pSrcB,
2548:.\Include/arm_math.h ****   q15_t * pDst,
2549:.\Include/arm_math.h ****   uint32_t blockSize);
2550:.\Include/arm_math.h **** 
2551:.\Include/arm_math.h **** 
2552:.\Include/arm_math.h ****   /**
2553:.\Include/arm_math.h ****    * @brief Q31 vector subtraction.
2554:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2555:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2556:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2557:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2558:.\Include/arm_math.h ****    */
2559:.\Include/arm_math.h ****   void arm_sub_q31(
2560:.\Include/arm_math.h ****   q31_t * pSrcA,
2561:.\Include/arm_math.h ****   q31_t * pSrcB,
2562:.\Include/arm_math.h ****   q31_t * pDst,
2563:.\Include/arm_math.h ****   uint32_t blockSize);
2564:.\Include/arm_math.h **** 
2565:.\Include/arm_math.h **** 
2566:.\Include/arm_math.h ****   /**
2567:.\Include/arm_math.h ****    * @brief Multiplies a floating-point vector by a scalar.
2568:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2569:.\Include/arm_math.h ****    * @param[in]  scale      scale factor to be applied
2570:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2571:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2572:.\Include/arm_math.h ****    */
2573:.\Include/arm_math.h ****   void arm_scale_f32(
2574:.\Include/arm_math.h ****   float32_t * pSrc,
2575:.\Include/arm_math.h ****   float32_t scale,
2576:.\Include/arm_math.h ****   float32_t * pDst,
2577:.\Include/arm_math.h ****   uint32_t blockSize);
2578:.\Include/arm_math.h **** 
2579:.\Include/arm_math.h **** 
2580:.\Include/arm_math.h ****   /**
2581:.\Include/arm_math.h ****    * @brief Multiplies a Q7 vector by a scalar.
2582:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2583:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2584:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 55


2585:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2586:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2587:.\Include/arm_math.h ****    */
2588:.\Include/arm_math.h ****   void arm_scale_q7(
2589:.\Include/arm_math.h ****   q7_t * pSrc,
2590:.\Include/arm_math.h ****   q7_t scaleFract,
2591:.\Include/arm_math.h ****   int8_t shift,
2592:.\Include/arm_math.h ****   q7_t * pDst,
2593:.\Include/arm_math.h ****   uint32_t blockSize);
2594:.\Include/arm_math.h **** 
2595:.\Include/arm_math.h **** 
2596:.\Include/arm_math.h ****   /**
2597:.\Include/arm_math.h ****    * @brief Multiplies a Q15 vector by a scalar.
2598:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2599:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2600:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2601:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2602:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2603:.\Include/arm_math.h ****    */
2604:.\Include/arm_math.h ****   void arm_scale_q15(
2605:.\Include/arm_math.h ****   q15_t * pSrc,
2606:.\Include/arm_math.h ****   q15_t scaleFract,
2607:.\Include/arm_math.h ****   int8_t shift,
2608:.\Include/arm_math.h ****   q15_t * pDst,
2609:.\Include/arm_math.h ****   uint32_t blockSize);
2610:.\Include/arm_math.h **** 
2611:.\Include/arm_math.h **** 
2612:.\Include/arm_math.h ****   /**
2613:.\Include/arm_math.h ****    * @brief Multiplies a Q31 vector by a scalar.
2614:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2615:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2616:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2617:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2618:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2619:.\Include/arm_math.h ****    */
2620:.\Include/arm_math.h ****   void arm_scale_q31(
2621:.\Include/arm_math.h ****   q31_t * pSrc,
2622:.\Include/arm_math.h ****   q31_t scaleFract,
2623:.\Include/arm_math.h ****   int8_t shift,
2624:.\Include/arm_math.h ****   q31_t * pDst,
2625:.\Include/arm_math.h ****   uint32_t blockSize);
2626:.\Include/arm_math.h **** 
2627:.\Include/arm_math.h **** 
2628:.\Include/arm_math.h ****   /**
2629:.\Include/arm_math.h ****    * @brief Q7 vector absolute value.
2630:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2631:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2632:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2633:.\Include/arm_math.h ****    */
2634:.\Include/arm_math.h ****   void arm_abs_q7(
2635:.\Include/arm_math.h ****   q7_t * pSrc,
2636:.\Include/arm_math.h ****   q7_t * pDst,
2637:.\Include/arm_math.h ****   uint32_t blockSize);
2638:.\Include/arm_math.h **** 
2639:.\Include/arm_math.h **** 
2640:.\Include/arm_math.h ****   /**
2641:.\Include/arm_math.h ****    * @brief Floating-point vector absolute value.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 56


2642:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2643:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2644:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2645:.\Include/arm_math.h ****    */
2646:.\Include/arm_math.h ****   void arm_abs_f32(
2647:.\Include/arm_math.h ****   float32_t * pSrc,
2648:.\Include/arm_math.h ****   float32_t * pDst,
2649:.\Include/arm_math.h ****   uint32_t blockSize);
2650:.\Include/arm_math.h **** 
2651:.\Include/arm_math.h **** 
2652:.\Include/arm_math.h ****   /**
2653:.\Include/arm_math.h ****    * @brief Q15 vector absolute value.
2654:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2655:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2656:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2657:.\Include/arm_math.h ****    */
2658:.\Include/arm_math.h ****   void arm_abs_q15(
2659:.\Include/arm_math.h ****   q15_t * pSrc,
2660:.\Include/arm_math.h ****   q15_t * pDst,
2661:.\Include/arm_math.h ****   uint32_t blockSize);
2662:.\Include/arm_math.h **** 
2663:.\Include/arm_math.h **** 
2664:.\Include/arm_math.h ****   /**
2665:.\Include/arm_math.h ****    * @brief Q31 vector absolute value.
2666:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2667:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2668:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2669:.\Include/arm_math.h ****    */
2670:.\Include/arm_math.h ****   void arm_abs_q31(
2671:.\Include/arm_math.h ****   q31_t * pSrc,
2672:.\Include/arm_math.h ****   q31_t * pDst,
2673:.\Include/arm_math.h ****   uint32_t blockSize);
2674:.\Include/arm_math.h **** 
2675:.\Include/arm_math.h **** 
2676:.\Include/arm_math.h ****   /**
2677:.\Include/arm_math.h ****    * @brief Dot product of floating-point vectors.
2678:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2679:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2680:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2681:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2682:.\Include/arm_math.h ****    */
2683:.\Include/arm_math.h ****   void arm_dot_prod_f32(
2684:.\Include/arm_math.h ****   float32_t * pSrcA,
2685:.\Include/arm_math.h ****   float32_t * pSrcB,
2686:.\Include/arm_math.h ****   uint32_t blockSize,
2687:.\Include/arm_math.h ****   float32_t * result);
2688:.\Include/arm_math.h **** 
2689:.\Include/arm_math.h **** 
2690:.\Include/arm_math.h ****   /**
2691:.\Include/arm_math.h ****    * @brief Dot product of Q7 vectors.
2692:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2693:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2694:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2695:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2696:.\Include/arm_math.h ****    */
2697:.\Include/arm_math.h ****   void arm_dot_prod_q7(
2698:.\Include/arm_math.h ****   q7_t * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 57


2699:.\Include/arm_math.h ****   q7_t * pSrcB,
2700:.\Include/arm_math.h ****   uint32_t blockSize,
2701:.\Include/arm_math.h ****   q31_t * result);
2702:.\Include/arm_math.h **** 
2703:.\Include/arm_math.h **** 
2704:.\Include/arm_math.h ****   /**
2705:.\Include/arm_math.h ****    * @brief Dot product of Q15 vectors.
2706:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2707:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2708:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2709:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2710:.\Include/arm_math.h ****    */
2711:.\Include/arm_math.h ****   void arm_dot_prod_q15(
2712:.\Include/arm_math.h ****   q15_t * pSrcA,
2713:.\Include/arm_math.h ****   q15_t * pSrcB,
2714:.\Include/arm_math.h ****   uint32_t blockSize,
2715:.\Include/arm_math.h ****   q63_t * result);
2716:.\Include/arm_math.h **** 
2717:.\Include/arm_math.h **** 
2718:.\Include/arm_math.h ****   /**
2719:.\Include/arm_math.h ****    * @brief Dot product of Q31 vectors.
2720:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2721:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2722:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2723:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2724:.\Include/arm_math.h ****    */
2725:.\Include/arm_math.h ****   void arm_dot_prod_q31(
2726:.\Include/arm_math.h ****   q31_t * pSrcA,
2727:.\Include/arm_math.h ****   q31_t * pSrcB,
2728:.\Include/arm_math.h ****   uint32_t blockSize,
2729:.\Include/arm_math.h ****   q63_t * result);
2730:.\Include/arm_math.h **** 
2731:.\Include/arm_math.h **** 
2732:.\Include/arm_math.h ****   /**
2733:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q7 vector a specified number of bits.
2734:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2735:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2736:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2737:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2738:.\Include/arm_math.h ****    */
2739:.\Include/arm_math.h ****   void arm_shift_q7(
2740:.\Include/arm_math.h ****   q7_t * pSrc,
2741:.\Include/arm_math.h ****   int8_t shiftBits,
2742:.\Include/arm_math.h ****   q7_t * pDst,
2743:.\Include/arm_math.h ****   uint32_t blockSize);
2744:.\Include/arm_math.h **** 
2745:.\Include/arm_math.h **** 
2746:.\Include/arm_math.h ****   /**
2747:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q15 vector a specified number of bits.
2748:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2749:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2750:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2751:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2752:.\Include/arm_math.h ****    */
2753:.\Include/arm_math.h ****   void arm_shift_q15(
2754:.\Include/arm_math.h ****   q15_t * pSrc,
2755:.\Include/arm_math.h ****   int8_t shiftBits,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 58


2756:.\Include/arm_math.h ****   q15_t * pDst,
2757:.\Include/arm_math.h ****   uint32_t blockSize);
2758:.\Include/arm_math.h **** 
2759:.\Include/arm_math.h **** 
2760:.\Include/arm_math.h ****   /**
2761:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q31 vector a specified number of bits.
2762:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2763:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2764:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2765:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2766:.\Include/arm_math.h ****    */
2767:.\Include/arm_math.h ****   void arm_shift_q31(
2768:.\Include/arm_math.h ****   q31_t * pSrc,
2769:.\Include/arm_math.h ****   int8_t shiftBits,
2770:.\Include/arm_math.h ****   q31_t * pDst,
2771:.\Include/arm_math.h ****   uint32_t blockSize);
2772:.\Include/arm_math.h **** 
2773:.\Include/arm_math.h **** 
2774:.\Include/arm_math.h ****   /**
2775:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a floating-point vector.
2776:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2777:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2778:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2779:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2780:.\Include/arm_math.h ****    */
2781:.\Include/arm_math.h ****   void arm_offset_f32(
2782:.\Include/arm_math.h ****   float32_t * pSrc,
2783:.\Include/arm_math.h ****   float32_t offset,
2784:.\Include/arm_math.h ****   float32_t * pDst,
2785:.\Include/arm_math.h ****   uint32_t blockSize);
2786:.\Include/arm_math.h **** 
2787:.\Include/arm_math.h **** 
2788:.\Include/arm_math.h ****   /**
2789:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q7 vector.
2790:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2791:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2792:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2793:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2794:.\Include/arm_math.h ****    */
2795:.\Include/arm_math.h ****   void arm_offset_q7(
2796:.\Include/arm_math.h ****   q7_t * pSrc,
2797:.\Include/arm_math.h ****   q7_t offset,
2798:.\Include/arm_math.h ****   q7_t * pDst,
2799:.\Include/arm_math.h ****   uint32_t blockSize);
2800:.\Include/arm_math.h **** 
2801:.\Include/arm_math.h **** 
2802:.\Include/arm_math.h ****   /**
2803:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q15 vector.
2804:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2805:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2806:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2807:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2808:.\Include/arm_math.h ****    */
2809:.\Include/arm_math.h ****   void arm_offset_q15(
2810:.\Include/arm_math.h ****   q15_t * pSrc,
2811:.\Include/arm_math.h ****   q15_t offset,
2812:.\Include/arm_math.h ****   q15_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 59


2813:.\Include/arm_math.h ****   uint32_t blockSize);
2814:.\Include/arm_math.h **** 
2815:.\Include/arm_math.h **** 
2816:.\Include/arm_math.h ****   /**
2817:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q31 vector.
2818:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2819:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2820:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2821:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2822:.\Include/arm_math.h ****    */
2823:.\Include/arm_math.h ****   void arm_offset_q31(
2824:.\Include/arm_math.h ****   q31_t * pSrc,
2825:.\Include/arm_math.h ****   q31_t offset,
2826:.\Include/arm_math.h ****   q31_t * pDst,
2827:.\Include/arm_math.h ****   uint32_t blockSize);
2828:.\Include/arm_math.h **** 
2829:.\Include/arm_math.h **** 
2830:.\Include/arm_math.h ****   /**
2831:.\Include/arm_math.h ****    * @brief  Negates the elements of a floating-point vector.
2832:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2833:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2834:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2835:.\Include/arm_math.h ****    */
2836:.\Include/arm_math.h ****   void arm_negate_f32(
2837:.\Include/arm_math.h ****   float32_t * pSrc,
2838:.\Include/arm_math.h ****   float32_t * pDst,
2839:.\Include/arm_math.h ****   uint32_t blockSize);
2840:.\Include/arm_math.h **** 
2841:.\Include/arm_math.h **** 
2842:.\Include/arm_math.h ****   /**
2843:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q7 vector.
2844:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2845:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2846:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2847:.\Include/arm_math.h ****    */
2848:.\Include/arm_math.h ****   void arm_negate_q7(
2849:.\Include/arm_math.h ****   q7_t * pSrc,
2850:.\Include/arm_math.h ****   q7_t * pDst,
2851:.\Include/arm_math.h ****   uint32_t blockSize);
2852:.\Include/arm_math.h **** 
2853:.\Include/arm_math.h **** 
2854:.\Include/arm_math.h ****   /**
2855:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q15 vector.
2856:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2857:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2858:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2859:.\Include/arm_math.h ****    */
2860:.\Include/arm_math.h ****   void arm_negate_q15(
2861:.\Include/arm_math.h ****   q15_t * pSrc,
2862:.\Include/arm_math.h ****   q15_t * pDst,
2863:.\Include/arm_math.h ****   uint32_t blockSize);
2864:.\Include/arm_math.h **** 
2865:.\Include/arm_math.h **** 
2866:.\Include/arm_math.h ****   /**
2867:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q31 vector.
2868:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2869:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 60


2870:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2871:.\Include/arm_math.h ****    */
2872:.\Include/arm_math.h ****   void arm_negate_q31(
2873:.\Include/arm_math.h ****   q31_t * pSrc,
2874:.\Include/arm_math.h ****   q31_t * pDst,
2875:.\Include/arm_math.h ****   uint32_t blockSize);
2876:.\Include/arm_math.h **** 
2877:.\Include/arm_math.h **** 
2878:.\Include/arm_math.h ****   /**
2879:.\Include/arm_math.h ****    * @brief  Copies the elements of a floating-point vector.
2880:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2881:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2882:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2883:.\Include/arm_math.h ****    */
2884:.\Include/arm_math.h ****   void arm_copy_f32(
2885:.\Include/arm_math.h ****   float32_t * pSrc,
2886:.\Include/arm_math.h ****   float32_t * pDst,
2887:.\Include/arm_math.h ****   uint32_t blockSize);
2888:.\Include/arm_math.h **** 
2889:.\Include/arm_math.h **** 
2890:.\Include/arm_math.h ****   /**
2891:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q7 vector.
2892:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2893:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2894:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2895:.\Include/arm_math.h ****    */
2896:.\Include/arm_math.h ****   void arm_copy_q7(
2897:.\Include/arm_math.h ****   q7_t * pSrc,
2898:.\Include/arm_math.h ****   q7_t * pDst,
2899:.\Include/arm_math.h ****   uint32_t blockSize);
2900:.\Include/arm_math.h **** 
2901:.\Include/arm_math.h **** 
2902:.\Include/arm_math.h ****   /**
2903:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q15 vector.
2904:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2905:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2906:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2907:.\Include/arm_math.h ****    */
2908:.\Include/arm_math.h ****   void arm_copy_q15(
2909:.\Include/arm_math.h ****   q15_t * pSrc,
2910:.\Include/arm_math.h ****   q15_t * pDst,
2911:.\Include/arm_math.h ****   uint32_t blockSize);
2912:.\Include/arm_math.h **** 
2913:.\Include/arm_math.h **** 
2914:.\Include/arm_math.h ****   /**
2915:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q31 vector.
2916:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2917:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2918:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2919:.\Include/arm_math.h ****    */
2920:.\Include/arm_math.h ****   void arm_copy_q31(
2921:.\Include/arm_math.h ****   q31_t * pSrc,
2922:.\Include/arm_math.h ****   q31_t * pDst,
2923:.\Include/arm_math.h ****   uint32_t blockSize);
2924:.\Include/arm_math.h **** 
2925:.\Include/arm_math.h **** 
2926:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 61


2927:.\Include/arm_math.h ****    * @brief  Fills a constant value into a floating-point vector.
2928:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2929:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2930:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2931:.\Include/arm_math.h ****    */
2932:.\Include/arm_math.h ****   void arm_fill_f32(
2933:.\Include/arm_math.h ****   float32_t value,
2934:.\Include/arm_math.h ****   float32_t * pDst,
2935:.\Include/arm_math.h ****   uint32_t blockSize);
2936:.\Include/arm_math.h **** 
2937:.\Include/arm_math.h **** 
2938:.\Include/arm_math.h ****   /**
2939:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q7 vector.
2940:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2941:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2942:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2943:.\Include/arm_math.h ****    */
2944:.\Include/arm_math.h ****   void arm_fill_q7(
2945:.\Include/arm_math.h ****   q7_t value,
2946:.\Include/arm_math.h ****   q7_t * pDst,
2947:.\Include/arm_math.h ****   uint32_t blockSize);
2948:.\Include/arm_math.h **** 
2949:.\Include/arm_math.h **** 
2950:.\Include/arm_math.h ****   /**
2951:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q15 vector.
2952:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2953:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2954:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2955:.\Include/arm_math.h ****    */
2956:.\Include/arm_math.h ****   void arm_fill_q15(
2957:.\Include/arm_math.h ****   q15_t value,
2958:.\Include/arm_math.h ****   q15_t * pDst,
2959:.\Include/arm_math.h ****   uint32_t blockSize);
2960:.\Include/arm_math.h **** 
2961:.\Include/arm_math.h **** 
2962:.\Include/arm_math.h ****   /**
2963:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q31 vector.
2964:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2965:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2966:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2967:.\Include/arm_math.h ****    */
2968:.\Include/arm_math.h ****   void arm_fill_q31(
2969:.\Include/arm_math.h ****   q31_t value,
2970:.\Include/arm_math.h ****   q31_t * pDst,
2971:.\Include/arm_math.h ****   uint32_t blockSize);
2972:.\Include/arm_math.h **** 
2973:.\Include/arm_math.h **** 
2974:.\Include/arm_math.h **** /**
2975:.\Include/arm_math.h ****  * @brief Convolution of floating-point sequences.
2976:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2977:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2978:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2979:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2980:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2981:.\Include/arm_math.h ****  */
2982:.\Include/arm_math.h ****   void arm_conv_f32(
2983:.\Include/arm_math.h ****   float32_t * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 62


2984:.\Include/arm_math.h ****   uint32_t srcALen,
2985:.\Include/arm_math.h ****   float32_t * pSrcB,
2986:.\Include/arm_math.h ****   uint32_t srcBLen,
2987:.\Include/arm_math.h ****   float32_t * pDst);
2988:.\Include/arm_math.h **** 
2989:.\Include/arm_math.h **** 
2990:.\Include/arm_math.h ****   /**
2991:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences.
2992:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2993:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2994:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2995:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2996:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2997:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2998:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2999:.\Include/arm_math.h ****    */
3000:.\Include/arm_math.h ****   void arm_conv_opt_q15(
3001:.\Include/arm_math.h ****   q15_t * pSrcA,
3002:.\Include/arm_math.h ****   uint32_t srcALen,
3003:.\Include/arm_math.h ****   q15_t * pSrcB,
3004:.\Include/arm_math.h ****   uint32_t srcBLen,
3005:.\Include/arm_math.h ****   q15_t * pDst,
3006:.\Include/arm_math.h ****   q15_t * pScratch1,
3007:.\Include/arm_math.h ****   q15_t * pScratch2);
3008:.\Include/arm_math.h **** 
3009:.\Include/arm_math.h **** 
3010:.\Include/arm_math.h **** /**
3011:.\Include/arm_math.h ****  * @brief Convolution of Q15 sequences.
3012:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
3013:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
3014:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
3015:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
3016:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
3017:.\Include/arm_math.h ****  */
3018:.\Include/arm_math.h ****   void arm_conv_q15(
3019:.\Include/arm_math.h ****   q15_t * pSrcA,
3020:.\Include/arm_math.h ****   uint32_t srcALen,
3021:.\Include/arm_math.h ****   q15_t * pSrcB,
3022:.\Include/arm_math.h ****   uint32_t srcBLen,
3023:.\Include/arm_math.h ****   q15_t * pDst);
3024:.\Include/arm_math.h **** 
3025:.\Include/arm_math.h **** 
3026:.\Include/arm_math.h ****   /**
3027:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3028:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3029:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3030:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3031:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3032:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3033:.\Include/arm_math.h ****    */
3034:.\Include/arm_math.h ****   void arm_conv_fast_q15(
3035:.\Include/arm_math.h ****           q15_t * pSrcA,
3036:.\Include/arm_math.h ****           uint32_t srcALen,
3037:.\Include/arm_math.h ****           q15_t * pSrcB,
3038:.\Include/arm_math.h ****           uint32_t srcBLen,
3039:.\Include/arm_math.h ****           q15_t * pDst);
3040:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 63


3041:.\Include/arm_math.h **** 
3042:.\Include/arm_math.h ****   /**
3043:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3044:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3045:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3046:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3047:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3048:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3049:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
3050:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
3051:.\Include/arm_math.h ****    */
3052:.\Include/arm_math.h ****   void arm_conv_fast_opt_q15(
3053:.\Include/arm_math.h ****   q15_t * pSrcA,
3054:.\Include/arm_math.h ****   uint32_t srcALen,
3055:.\Include/arm_math.h ****   q15_t * pSrcB,
3056:.\Include/arm_math.h ****   uint32_t srcBLen,
3057:.\Include/arm_math.h ****   q15_t * pDst,
3058:.\Include/arm_math.h ****   q15_t * pScratch1,
3059:.\Include/arm_math.h ****   q15_t * pScratch2);
3060:.\Include/arm_math.h **** 
3061:.\Include/arm_math.h **** 
3062:.\Include/arm_math.h ****   /**
3063:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences.
3064:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3065:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3066:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3067:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3068:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3069:.\Include/arm_math.h ****    */
3070:.\Include/arm_math.h ****   void arm_conv_q31(
3071:.\Include/arm_math.h ****   q31_t * pSrcA,
3072:.\Include/arm_math.h ****   uint32_t srcALen,
3073:.\Include/arm_math.h ****   q31_t * pSrcB,
3074:.\Include/arm_math.h ****   uint32_t srcBLen,
3075:.\Include/arm_math.h ****   q31_t * pDst);
3076:.\Include/arm_math.h **** 
3077:.\Include/arm_math.h **** 
3078:.\Include/arm_math.h ****   /**
3079:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3080:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3081:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3082:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3083:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3084:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3085:.\Include/arm_math.h ****    */
3086:.\Include/arm_math.h ****   void arm_conv_fast_q31(
3087:.\Include/arm_math.h ****   q31_t * pSrcA,
3088:.\Include/arm_math.h ****   uint32_t srcALen,
3089:.\Include/arm_math.h ****   q31_t * pSrcB,
3090:.\Include/arm_math.h ****   uint32_t srcBLen,
3091:.\Include/arm_math.h ****   q31_t * pDst);
3092:.\Include/arm_math.h **** 
3093:.\Include/arm_math.h **** 
3094:.\Include/arm_math.h ****     /**
3095:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3096:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3097:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 64


3098:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3099:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3100:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3101:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
3102:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
3103:.\Include/arm_math.h ****    */
3104:.\Include/arm_math.h ****   void arm_conv_opt_q7(
3105:.\Include/arm_math.h ****   q7_t * pSrcA,
3106:.\Include/arm_math.h ****   uint32_t srcALen,
3107:.\Include/arm_math.h ****   q7_t * pSrcB,
3108:.\Include/arm_math.h ****   uint32_t srcBLen,
3109:.\Include/arm_math.h ****   q7_t * pDst,
3110:.\Include/arm_math.h ****   q15_t * pScratch1,
3111:.\Include/arm_math.h ****   q15_t * pScratch2);
3112:.\Include/arm_math.h **** 
3113:.\Include/arm_math.h **** 
3114:.\Include/arm_math.h ****   /**
3115:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3116:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3117:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3118:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3119:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3120:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3121:.\Include/arm_math.h ****    */
3122:.\Include/arm_math.h ****   void arm_conv_q7(
3123:.\Include/arm_math.h ****   q7_t * pSrcA,
3124:.\Include/arm_math.h ****   uint32_t srcALen,
3125:.\Include/arm_math.h ****   q7_t * pSrcB,
3126:.\Include/arm_math.h ****   uint32_t srcBLen,
3127:.\Include/arm_math.h ****   q7_t * pDst);
3128:.\Include/arm_math.h **** 
3129:.\Include/arm_math.h **** 
3130:.\Include/arm_math.h ****   /**
3131:.\Include/arm_math.h ****    * @brief Partial convolution of floating-point sequences.
3132:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3133:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3134:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3135:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3136:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3137:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3138:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3139:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3140:.\Include/arm_math.h ****    */
3141:.\Include/arm_math.h ****   arm_status arm_conv_partial_f32(
3142:.\Include/arm_math.h ****   float32_t * pSrcA,
3143:.\Include/arm_math.h ****   uint32_t srcALen,
3144:.\Include/arm_math.h ****   float32_t * pSrcB,
3145:.\Include/arm_math.h ****   uint32_t srcBLen,
3146:.\Include/arm_math.h ****   float32_t * pDst,
3147:.\Include/arm_math.h ****   uint32_t firstIndex,
3148:.\Include/arm_math.h ****   uint32_t numPoints);
3149:.\Include/arm_math.h **** 
3150:.\Include/arm_math.h **** 
3151:.\Include/arm_math.h ****   /**
3152:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3153:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3154:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 65


3155:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3156:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3157:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3158:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3159:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3160:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3161:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3162:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3163:.\Include/arm_math.h ****    */
3164:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q15(
3165:.\Include/arm_math.h ****   q15_t * pSrcA,
3166:.\Include/arm_math.h ****   uint32_t srcALen,
3167:.\Include/arm_math.h ****   q15_t * pSrcB,
3168:.\Include/arm_math.h ****   uint32_t srcBLen,
3169:.\Include/arm_math.h ****   q15_t * pDst,
3170:.\Include/arm_math.h ****   uint32_t firstIndex,
3171:.\Include/arm_math.h ****   uint32_t numPoints,
3172:.\Include/arm_math.h ****   q15_t * pScratch1,
3173:.\Include/arm_math.h ****   q15_t * pScratch2);
3174:.\Include/arm_math.h **** 
3175:.\Include/arm_math.h **** 
3176:.\Include/arm_math.h ****   /**
3177:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3178:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3179:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3180:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3181:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3182:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3183:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3184:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3185:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3186:.\Include/arm_math.h ****    */
3187:.\Include/arm_math.h ****   arm_status arm_conv_partial_q15(
3188:.\Include/arm_math.h ****   q15_t * pSrcA,
3189:.\Include/arm_math.h ****   uint32_t srcALen,
3190:.\Include/arm_math.h ****   q15_t * pSrcB,
3191:.\Include/arm_math.h ****   uint32_t srcBLen,
3192:.\Include/arm_math.h ****   q15_t * pDst,
3193:.\Include/arm_math.h ****   uint32_t firstIndex,
3194:.\Include/arm_math.h ****   uint32_t numPoints);
3195:.\Include/arm_math.h **** 
3196:.\Include/arm_math.h **** 
3197:.\Include/arm_math.h ****   /**
3198:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3199:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3200:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3201:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3202:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3203:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3204:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3205:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3206:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3207:.\Include/arm_math.h ****    */
3208:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q15(
3209:.\Include/arm_math.h ****   q15_t * pSrcA,
3210:.\Include/arm_math.h ****   uint32_t srcALen,
3211:.\Include/arm_math.h ****   q15_t * pSrcB,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 66


3212:.\Include/arm_math.h ****   uint32_t srcBLen,
3213:.\Include/arm_math.h ****   q15_t * pDst,
3214:.\Include/arm_math.h ****   uint32_t firstIndex,
3215:.\Include/arm_math.h ****   uint32_t numPoints);
3216:.\Include/arm_math.h **** 
3217:.\Include/arm_math.h **** 
3218:.\Include/arm_math.h ****   /**
3219:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3220:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3221:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3222:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3223:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3224:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3225:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3226:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3227:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3228:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3229:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3230:.\Include/arm_math.h ****    */
3231:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_opt_q15(
3232:.\Include/arm_math.h ****   q15_t * pSrcA,
3233:.\Include/arm_math.h ****   uint32_t srcALen,
3234:.\Include/arm_math.h ****   q15_t * pSrcB,
3235:.\Include/arm_math.h ****   uint32_t srcBLen,
3236:.\Include/arm_math.h ****   q15_t * pDst,
3237:.\Include/arm_math.h ****   uint32_t firstIndex,
3238:.\Include/arm_math.h ****   uint32_t numPoints,
3239:.\Include/arm_math.h ****   q15_t * pScratch1,
3240:.\Include/arm_math.h ****   q15_t * pScratch2);
3241:.\Include/arm_math.h **** 
3242:.\Include/arm_math.h **** 
3243:.\Include/arm_math.h ****   /**
3244:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences.
3245:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3246:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3247:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3248:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3249:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3250:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3251:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3252:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3253:.\Include/arm_math.h ****    */
3254:.\Include/arm_math.h ****   arm_status arm_conv_partial_q31(
3255:.\Include/arm_math.h ****   q31_t * pSrcA,
3256:.\Include/arm_math.h ****   uint32_t srcALen,
3257:.\Include/arm_math.h ****   q31_t * pSrcB,
3258:.\Include/arm_math.h ****   uint32_t srcBLen,
3259:.\Include/arm_math.h ****   q31_t * pDst,
3260:.\Include/arm_math.h ****   uint32_t firstIndex,
3261:.\Include/arm_math.h ****   uint32_t numPoints);
3262:.\Include/arm_math.h **** 
3263:.\Include/arm_math.h **** 
3264:.\Include/arm_math.h ****   /**
3265:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3266:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3267:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3268:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 67


3269:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3270:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3271:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3272:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3273:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3274:.\Include/arm_math.h ****    */
3275:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q31(
3276:.\Include/arm_math.h ****   q31_t * pSrcA,
3277:.\Include/arm_math.h ****   uint32_t srcALen,
3278:.\Include/arm_math.h ****   q31_t * pSrcB,
3279:.\Include/arm_math.h ****   uint32_t srcBLen,
3280:.\Include/arm_math.h ****   q31_t * pDst,
3281:.\Include/arm_math.h ****   uint32_t firstIndex,
3282:.\Include/arm_math.h ****   uint32_t numPoints);
3283:.\Include/arm_math.h **** 
3284:.\Include/arm_math.h **** 
3285:.\Include/arm_math.h ****   /**
3286:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences
3287:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3288:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3289:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3290:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3291:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3292:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3293:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3294:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) 
3295:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)
3296:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3297:.\Include/arm_math.h ****    */
3298:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q7(
3299:.\Include/arm_math.h ****   q7_t * pSrcA,
3300:.\Include/arm_math.h ****   uint32_t srcALen,
3301:.\Include/arm_math.h ****   q7_t * pSrcB,
3302:.\Include/arm_math.h ****   uint32_t srcBLen,
3303:.\Include/arm_math.h ****   q7_t * pDst,
3304:.\Include/arm_math.h ****   uint32_t firstIndex,
3305:.\Include/arm_math.h ****   uint32_t numPoints,
3306:.\Include/arm_math.h ****   q15_t * pScratch1,
3307:.\Include/arm_math.h ****   q15_t * pScratch2);
3308:.\Include/arm_math.h **** 
3309:.\Include/arm_math.h **** 
3310:.\Include/arm_math.h **** /**
3311:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences.
3312:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3313:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3314:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3315:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3316:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3317:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3318:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3319:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3320:.\Include/arm_math.h ****    */
3321:.\Include/arm_math.h ****   arm_status arm_conv_partial_q7(
3322:.\Include/arm_math.h ****   q7_t * pSrcA,
3323:.\Include/arm_math.h ****   uint32_t srcALen,
3324:.\Include/arm_math.h ****   q7_t * pSrcB,
3325:.\Include/arm_math.h ****   uint32_t srcBLen,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 68


3326:.\Include/arm_math.h ****   q7_t * pDst,
3327:.\Include/arm_math.h ****   uint32_t firstIndex,
3328:.\Include/arm_math.h ****   uint32_t numPoints);
3329:.\Include/arm_math.h **** 
3330:.\Include/arm_math.h **** 
3331:.\Include/arm_math.h ****   /**
3332:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR decimator.
3333:.\Include/arm_math.h ****    */
3334:.\Include/arm_math.h ****   typedef struct
3335:.\Include/arm_math.h ****   {
3336:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3337:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3338:.\Include/arm_math.h ****     q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3339:.\Include/arm_math.h ****     q15_t *pState;              /**< points to the state variable array. The array is of length num
3340:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q15;
3341:.\Include/arm_math.h **** 
3342:.\Include/arm_math.h ****   /**
3343:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR decimator.
3344:.\Include/arm_math.h ****    */
3345:.\Include/arm_math.h ****   typedef struct
3346:.\Include/arm_math.h ****   {
3347:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3348:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3349:.\Include/arm_math.h ****     q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3350:.\Include/arm_math.h ****     q31_t *pState;              /**< points to the state variable array. The array is of length num
3351:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q31;
3352:.\Include/arm_math.h **** 
3353:.\Include/arm_math.h ****   /**
3354:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR decimator.
3355:.\Include/arm_math.h ****    */
3356:.\Include/arm_math.h ****   typedef struct
3357:.\Include/arm_math.h ****   {
3358:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3359:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3360:.\Include/arm_math.h ****     float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTap
3361:.\Include/arm_math.h ****     float32_t *pState;          /**< points to the state variable array. The array is of length num
3362:.\Include/arm_math.h ****   } arm_fir_decimate_instance_f32;
3363:.\Include/arm_math.h **** 
3364:.\Include/arm_math.h **** 
3365:.\Include/arm_math.h ****   /**
3366:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR decimator.
3367:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
3368:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3369:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3370:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3371:.\Include/arm_math.h ****    */
3372:.\Include/arm_math.h ****   void arm_fir_decimate_f32(
3373:.\Include/arm_math.h ****   const arm_fir_decimate_instance_f32 * S,
3374:.\Include/arm_math.h ****   float32_t * pSrc,
3375:.\Include/arm_math.h ****   float32_t * pDst,
3376:.\Include/arm_math.h ****   uint32_t blockSize);
3377:.\Include/arm_math.h **** 
3378:.\Include/arm_math.h **** 
3379:.\Include/arm_math.h ****   /**
3380:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR decimator.
3381:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
3382:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 69


3383:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3384:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3385:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3386:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3387:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3388:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3389:.\Include/arm_math.h ****    */
3390:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_f32(
3391:.\Include/arm_math.h ****   arm_fir_decimate_instance_f32 * S,
3392:.\Include/arm_math.h ****   uint16_t numTaps,
3393:.\Include/arm_math.h ****   uint8_t M,
3394:.\Include/arm_math.h ****   float32_t * pCoeffs,
3395:.\Include/arm_math.h ****   float32_t * pState,
3396:.\Include/arm_math.h ****   uint32_t blockSize);
3397:.\Include/arm_math.h **** 
3398:.\Include/arm_math.h **** 
3399:.\Include/arm_math.h ****   /**
3400:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator.
3401:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3402:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3403:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3404:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3405:.\Include/arm_math.h ****    */
3406:.\Include/arm_math.h ****   void arm_fir_decimate_q15(
3407:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3408:.\Include/arm_math.h ****   q15_t * pSrc,
3409:.\Include/arm_math.h ****   q15_t * pDst,
3410:.\Include/arm_math.h ****   uint32_t blockSize);
3411:.\Include/arm_math.h **** 
3412:.\Include/arm_math.h **** 
3413:.\Include/arm_math.h ****   /**
3414:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3415:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3416:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3417:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3418:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3419:.\Include/arm_math.h ****    */
3420:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q15(
3421:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3422:.\Include/arm_math.h ****   q15_t * pSrc,
3423:.\Include/arm_math.h ****   q15_t * pDst,
3424:.\Include/arm_math.h ****   uint32_t blockSize);
3425:.\Include/arm_math.h **** 
3426:.\Include/arm_math.h **** 
3427:.\Include/arm_math.h ****   /**
3428:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR decimator.
3429:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
3430:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3431:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3432:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3433:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3434:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3435:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3436:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3437:.\Include/arm_math.h ****    */
3438:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q15(
3439:.\Include/arm_math.h ****   arm_fir_decimate_instance_q15 * S,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 70


3440:.\Include/arm_math.h ****   uint16_t numTaps,
3441:.\Include/arm_math.h ****   uint8_t M,
3442:.\Include/arm_math.h ****   q15_t * pCoeffs,
3443:.\Include/arm_math.h ****   q15_t * pState,
3444:.\Include/arm_math.h ****   uint32_t blockSize);
3445:.\Include/arm_math.h **** 
3446:.\Include/arm_math.h **** 
3447:.\Include/arm_math.h ****   /**
3448:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator.
3449:.\Include/arm_math.h ****    * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
3450:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the block of input data.
3451:.\Include/arm_math.h ****    * @param[out] pDst  points to the block of output data
3452:.\Include/arm_math.h ****    * @param[in] blockSize number of input samples to process per call.
3453:.\Include/arm_math.h ****    */
3454:.\Include/arm_math.h ****   void arm_fir_decimate_q31(
3455:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q31 * S,
3456:.\Include/arm_math.h ****   q31_t * pSrc,
3457:.\Include/arm_math.h ****   q31_t * pDst,
3458:.\Include/arm_math.h ****   uint32_t blockSize);
3459:.\Include/arm_math.h **** 
3460:.\Include/arm_math.h ****   /**
3461:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3462:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
3463:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3464:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3465:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3466:.\Include/arm_math.h ****    */
3467:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q31(
3468:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3469:.\Include/arm_math.h ****   q31_t * pSrc,
3470:.\Include/arm_math.h ****   q31_t * pDst,
3471:.\Include/arm_math.h ****   uint32_t blockSize);
3472:.\Include/arm_math.h **** 
3473:.\Include/arm_math.h **** 
3474:.\Include/arm_math.h ****   /**
3475:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR decimator.
3476:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
3477:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3478:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3479:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3480:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3481:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3482:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3483:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3484:.\Include/arm_math.h ****    */
3485:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q31(
3486:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3487:.\Include/arm_math.h ****   uint16_t numTaps,
3488:.\Include/arm_math.h ****   uint8_t M,
3489:.\Include/arm_math.h ****   q31_t * pCoeffs,
3490:.\Include/arm_math.h ****   q31_t * pState,
3491:.\Include/arm_math.h ****   uint32_t blockSize);
3492:.\Include/arm_math.h **** 
3493:.\Include/arm_math.h **** 
3494:.\Include/arm_math.h ****   /**
3495:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR interpolator.
3496:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 71


3497:.\Include/arm_math.h ****   typedef struct
3498:.\Include/arm_math.h ****   {
3499:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3500:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3501:.\Include/arm_math.h ****     q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3502:.\Include/arm_math.h ****     q15_t *pState;                  /**< points to the state variable array. The array is of length
3503:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q15;
3504:.\Include/arm_math.h **** 
3505:.\Include/arm_math.h ****   /**
3506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR interpolator.
3507:.\Include/arm_math.h ****    */
3508:.\Include/arm_math.h ****   typedef struct
3509:.\Include/arm_math.h ****   {
3510:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3511:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3512:.\Include/arm_math.h ****     q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3513:.\Include/arm_math.h ****     q31_t *pState;                  /**< points to the state variable array. The array is of length
3514:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q31;
3515:.\Include/arm_math.h **** 
3516:.\Include/arm_math.h ****   /**
3517:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR interpolator.
3518:.\Include/arm_math.h ****    */
3519:.\Include/arm_math.h ****   typedef struct
3520:.\Include/arm_math.h ****   {
3521:.\Include/arm_math.h ****     uint8_t L;                     /**< upsample factor. */
3522:.\Include/arm_math.h ****     uint16_t phaseLength;          /**< length of each polyphase filter component. */
3523:.\Include/arm_math.h ****     float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*p
3524:.\Include/arm_math.h ****     float32_t *pState;             /**< points to the state variable array. The array is of length 
3525:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_f32;
3526:.\Include/arm_math.h **** 
3527:.\Include/arm_math.h **** 
3528:.\Include/arm_math.h ****   /**
3529:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR interpolator.
3530:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3531:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3532:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3533:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3534:.\Include/arm_math.h ****    */
3535:.\Include/arm_math.h ****   void arm_fir_interpolate_q15(
3536:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q15 * S,
3537:.\Include/arm_math.h ****   q15_t * pSrc,
3538:.\Include/arm_math.h ****   q15_t * pDst,
3539:.\Include/arm_math.h ****   uint32_t blockSize);
3540:.\Include/arm_math.h **** 
3541:.\Include/arm_math.h **** 
3542:.\Include/arm_math.h ****   /**
3543:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR interpolator.
3544:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
3545:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3546:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3547:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3548:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3549:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3550:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3551:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3552:.\Include/arm_math.h ****    */
3553:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q15(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 72


3554:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q15 * S,
3555:.\Include/arm_math.h ****   uint8_t L,
3556:.\Include/arm_math.h ****   uint16_t numTaps,
3557:.\Include/arm_math.h ****   q15_t * pCoeffs,
3558:.\Include/arm_math.h ****   q15_t * pState,
3559:.\Include/arm_math.h ****   uint32_t blockSize);
3560:.\Include/arm_math.h **** 
3561:.\Include/arm_math.h **** 
3562:.\Include/arm_math.h ****   /**
3563:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR interpolator.
3564:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3565:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3566:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3567:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3568:.\Include/arm_math.h ****    */
3569:.\Include/arm_math.h ****   void arm_fir_interpolate_q31(
3570:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q31 * S,
3571:.\Include/arm_math.h ****   q31_t * pSrc,
3572:.\Include/arm_math.h ****   q31_t * pDst,
3573:.\Include/arm_math.h ****   uint32_t blockSize);
3574:.\Include/arm_math.h **** 
3575:.\Include/arm_math.h **** 
3576:.\Include/arm_math.h ****   /**
3577:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR interpolator.
3578:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
3579:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3580:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3581:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3582:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3583:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3584:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3585:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3586:.\Include/arm_math.h ****    */
3587:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q31(
3588:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q31 * S,
3589:.\Include/arm_math.h ****   uint8_t L,
3590:.\Include/arm_math.h ****   uint16_t numTaps,
3591:.\Include/arm_math.h ****   q31_t * pCoeffs,
3592:.\Include/arm_math.h ****   q31_t * pState,
3593:.\Include/arm_math.h ****   uint32_t blockSize);
3594:.\Include/arm_math.h **** 
3595:.\Include/arm_math.h **** 
3596:.\Include/arm_math.h ****   /**
3597:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR interpolator.
3598:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
3599:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3600:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3601:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3602:.\Include/arm_math.h ****    */
3603:.\Include/arm_math.h ****   void arm_fir_interpolate_f32(
3604:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_f32 * S,
3605:.\Include/arm_math.h ****   float32_t * pSrc,
3606:.\Include/arm_math.h ****   float32_t * pDst,
3607:.\Include/arm_math.h ****   uint32_t blockSize);
3608:.\Include/arm_math.h **** 
3609:.\Include/arm_math.h **** 
3610:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 73


3611:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR interpolator.
3612:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR interpolator structu
3613:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3614:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3615:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3616:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3617:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3618:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3619:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3620:.\Include/arm_math.h ****    */
3621:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_f32(
3622:.\Include/arm_math.h ****   arm_fir_interpolate_instance_f32 * S,
3623:.\Include/arm_math.h ****   uint8_t L,
3624:.\Include/arm_math.h ****   uint16_t numTaps,
3625:.\Include/arm_math.h ****   float32_t * pCoeffs,
3626:.\Include/arm_math.h ****   float32_t * pState,
3627:.\Include/arm_math.h ****   uint32_t blockSize);
3628:.\Include/arm_math.h **** 
3629:.\Include/arm_math.h **** 
3630:.\Include/arm_math.h ****   /**
3631:.\Include/arm_math.h ****    * @brief Instance structure for the high precision Q31 Biquad cascade filter.
3632:.\Include/arm_math.h ****    */
3633:.\Include/arm_math.h ****   typedef struct
3634:.\Include/arm_math.h ****   {
3635:.\Include/arm_math.h ****     uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*num
3636:.\Include/arm_math.h ****     q63_t *pState;           /**< points to the array of state coefficients.  The array is of lengt
3637:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*nu
3638:.\Include/arm_math.h ****     uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
3639:.\Include/arm_math.h ****   } arm_biquad_cas_df1_32x64_ins_q31;
3640:.\Include/arm_math.h **** 
3641:.\Include/arm_math.h **** 
3642:.\Include/arm_math.h ****   /**
3643:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter s
3644:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3645:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3646:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3647:.\Include/arm_math.h ****    */
3648:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_q31(
3649:.\Include/arm_math.h ****   const arm_biquad_cas_df1_32x64_ins_q31 * S,
3650:.\Include/arm_math.h ****   q31_t * pSrc,
3651:.\Include/arm_math.h ****   q31_t * pDst,
3652:.\Include/arm_math.h ****   uint32_t blockSize);
3653:.\Include/arm_math.h **** 
3654:.\Include/arm_math.h **** 
3655:.\Include/arm_math.h ****   /**
3656:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filte
3657:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3658:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3659:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3660:.\Include/arm_math.h ****    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficie
3661:.\Include/arm_math.h ****    */
3662:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_init_q31(
3663:.\Include/arm_math.h ****   arm_biquad_cas_df1_32x64_ins_q31 * S,
3664:.\Include/arm_math.h ****   uint8_t numStages,
3665:.\Include/arm_math.h ****   q31_t * pCoeffs,
3666:.\Include/arm_math.h ****   q63_t * pState,
3667:.\Include/arm_math.h ****   uint8_t postShift);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 74


3668:.\Include/arm_math.h **** 
3669:.\Include/arm_math.h **** 
3670:.\Include/arm_math.h ****   /**
3671:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3672:.\Include/arm_math.h ****    */
3673:.\Include/arm_math.h ****   typedef struct
3674:.\Include/arm_math.h ****   {
3675:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3676:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3677:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3678:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f32;
3679:.\Include/arm_math.h **** 
3680:.\Include/arm_math.h ****   /**
3681:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3682:.\Include/arm_math.h ****    */
3683:.\Include/arm_math.h ****   typedef struct
3684:.\Include/arm_math.h ****   {
3685:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3686:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3687:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3688:.\Include/arm_math.h ****   } arm_biquad_cascade_stereo_df2T_instance_f32;
3689:.\Include/arm_math.h **** 
3690:.\Include/arm_math.h ****   /**
3691:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3692:.\Include/arm_math.h ****    */
3693:.\Include/arm_math.h ****   typedef struct
3694:.\Include/arm_math.h ****   {
3695:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3696:.\Include/arm_math.h ****     float64_t *pState;         /**< points to the array of state coefficients.  The array is of len
3697:.\Include/arm_math.h ****     float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3698:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f64;
3699:.\Include/arm_math.h **** 
3700:.\Include/arm_math.h **** 
3701:.\Include/arm_math.h ****   /**
3702:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3703:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3704:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3705:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3706:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3707:.\Include/arm_math.h ****    */
3708:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f32(
3709:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f32 * S,
3710:.\Include/arm_math.h ****   float32_t * pSrc,
3711:.\Include/arm_math.h ****   float32_t * pDst,
3712:.\Include/arm_math.h ****   uint32_t blockSize);
3713:.\Include/arm_math.h **** 
3714:.\Include/arm_math.h **** 
3715:.\Include/arm_math.h ****   /**
3716:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3717:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3718:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3719:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3720:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3721:.\Include/arm_math.h ****    */
3722:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_f32(
3723:.\Include/arm_math.h ****   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3724:.\Include/arm_math.h ****   float32_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 75


3725:.\Include/arm_math.h ****   float32_t * pDst,
3726:.\Include/arm_math.h ****   uint32_t blockSize);
3727:.\Include/arm_math.h **** 
3728:.\Include/arm_math.h **** 
3729:.\Include/arm_math.h ****   /**
3730:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3731:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3732:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3733:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3734:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3735:.\Include/arm_math.h ****    */
3736:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f64(
3737:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f64 * S,
3738:.\Include/arm_math.h ****   float64_t * pSrc,
3739:.\Include/arm_math.h ****   float64_t * pDst,
3740:.\Include/arm_math.h ****   uint32_t blockSize);
3741:.\Include/arm_math.h **** 
3742:.\Include/arm_math.h **** 
3743:.\Include/arm_math.h ****   /**
3744:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3745:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3746:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3747:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3748:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3749:.\Include/arm_math.h ****    */
3750:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f32(
3751:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f32 * S,
3752:.\Include/arm_math.h ****   uint8_t numStages,
3753:.\Include/arm_math.h ****   float32_t * pCoeffs,
3754:.\Include/arm_math.h ****   float32_t * pState);
3755:.\Include/arm_math.h **** 
3756:.\Include/arm_math.h **** 
3757:.\Include/arm_math.h ****   /**
3758:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3759:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3760:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3761:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3762:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3763:.\Include/arm_math.h ****    */
3764:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_init_f32(
3765:.\Include/arm_math.h ****   arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3766:.\Include/arm_math.h ****   uint8_t numStages,
3767:.\Include/arm_math.h ****   float32_t * pCoeffs,
3768:.\Include/arm_math.h ****   float32_t * pState);
3769:.\Include/arm_math.h **** 
3770:.\Include/arm_math.h **** 
3771:.\Include/arm_math.h ****   /**
3772:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3773:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3774:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3775:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3776:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3777:.\Include/arm_math.h ****    */
3778:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f64(
3779:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f64 * S,
3780:.\Include/arm_math.h ****   uint8_t numStages,
3781:.\Include/arm_math.h ****   float64_t * pCoeffs,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 76


3782:.\Include/arm_math.h ****   float64_t * pState);
3783:.\Include/arm_math.h **** 
3784:.\Include/arm_math.h **** 
3785:.\Include/arm_math.h ****   /**
3786:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR lattice filter.
3787:.\Include/arm_math.h ****    */
3788:.\Include/arm_math.h ****   typedef struct
3789:.\Include/arm_math.h ****   {
3790:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3791:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3792:.\Include/arm_math.h ****     q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3793:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q15;
3794:.\Include/arm_math.h **** 
3795:.\Include/arm_math.h ****   /**
3796:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR lattice filter.
3797:.\Include/arm_math.h ****    */
3798:.\Include/arm_math.h ****   typedef struct
3799:.\Include/arm_math.h ****   {
3800:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3801:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3802:.\Include/arm_math.h ****     q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3803:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q31;
3804:.\Include/arm_math.h **** 
3805:.\Include/arm_math.h ****   /**
3806:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR lattice filter.
3807:.\Include/arm_math.h ****    */
3808:.\Include/arm_math.h ****   typedef struct
3809:.\Include/arm_math.h ****   {
3810:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3811:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3812:.\Include/arm_math.h ****     float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of leng
3813:.\Include/arm_math.h ****   } arm_fir_lattice_instance_f32;
3814:.\Include/arm_math.h **** 
3815:.\Include/arm_math.h **** 
3816:.\Include/arm_math.h ****   /**
3817:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 FIR lattice filter.
3818:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 FIR lattice structure.
3819:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3820:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3821:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages.
3822:.\Include/arm_math.h ****    */
3823:.\Include/arm_math.h ****   void arm_fir_lattice_init_q15(
3824:.\Include/arm_math.h ****   arm_fir_lattice_instance_q15 * S,
3825:.\Include/arm_math.h ****   uint16_t numStages,
3826:.\Include/arm_math.h ****   q15_t * pCoeffs,
3827:.\Include/arm_math.h ****   q15_t * pState);
3828:.\Include/arm_math.h **** 
3829:.\Include/arm_math.h **** 
3830:.\Include/arm_math.h ****   /**
3831:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR lattice filter.
3832:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
3833:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3834:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3835:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3836:.\Include/arm_math.h ****    */
3837:.\Include/arm_math.h ****   void arm_fir_lattice_q15(
3838:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q15 * S,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 77


3839:.\Include/arm_math.h ****   q15_t * pSrc,
3840:.\Include/arm_math.h ****   q15_t * pDst,
3841:.\Include/arm_math.h ****   uint32_t blockSize);
3842:.\Include/arm_math.h **** 
3843:.\Include/arm_math.h **** 
3844:.\Include/arm_math.h ****   /**
3845:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 FIR lattice filter.
3846:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 FIR lattice structure.
3847:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3848:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3849:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.   The array is of length numStages.
3850:.\Include/arm_math.h ****    */
3851:.\Include/arm_math.h ****   void arm_fir_lattice_init_q31(
3852:.\Include/arm_math.h ****   arm_fir_lattice_instance_q31 * S,
3853:.\Include/arm_math.h ****   uint16_t numStages,
3854:.\Include/arm_math.h ****   q31_t * pCoeffs,
3855:.\Include/arm_math.h ****   q31_t * pState);
3856:.\Include/arm_math.h **** 
3857:.\Include/arm_math.h **** 
3858:.\Include/arm_math.h ****   /**
3859:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR lattice filter.
3860:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
3861:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3862:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3863:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3864:.\Include/arm_math.h ****    */
3865:.\Include/arm_math.h ****   void arm_fir_lattice_q31(
3866:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q31 * S,
3867:.\Include/arm_math.h ****   q31_t * pSrc,
3868:.\Include/arm_math.h ****   q31_t * pDst,
3869:.\Include/arm_math.h ****   uint32_t blockSize);
3870:.\Include/arm_math.h **** 
3871:.\Include/arm_math.h **** 
3872:.\Include/arm_math.h **** /**
3873:.\Include/arm_math.h ****  * @brief Initialization function for the floating-point FIR lattice filter.
3874:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the floating-point FIR lattice structure.
3875:.\Include/arm_math.h ****  * @param[in] numStages  number of filter stages.
3876:.\Include/arm_math.h ****  * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3877:.\Include/arm_math.h ****  * @param[in] pState     points to the state buffer.  The array is of length numStages.
3878:.\Include/arm_math.h ****  */
3879:.\Include/arm_math.h ****   void arm_fir_lattice_init_f32(
3880:.\Include/arm_math.h ****   arm_fir_lattice_instance_f32 * S,
3881:.\Include/arm_math.h ****   uint16_t numStages,
3882:.\Include/arm_math.h ****   float32_t * pCoeffs,
3883:.\Include/arm_math.h ****   float32_t * pState);
3884:.\Include/arm_math.h **** 
3885:.\Include/arm_math.h **** 
3886:.\Include/arm_math.h ****   /**
3887:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR lattice filter.
3888:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
3889:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3890:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3891:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3892:.\Include/arm_math.h ****    */
3893:.\Include/arm_math.h ****   void arm_fir_lattice_f32(
3894:.\Include/arm_math.h ****   const arm_fir_lattice_instance_f32 * S,
3895:.\Include/arm_math.h ****   float32_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 78


3896:.\Include/arm_math.h ****   float32_t * pDst,
3897:.\Include/arm_math.h ****   uint32_t blockSize);
3898:.\Include/arm_math.h **** 
3899:.\Include/arm_math.h **** 
3900:.\Include/arm_math.h ****   /**
3901:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 IIR lattice filter.
3902:.\Include/arm_math.h ****    */
3903:.\Include/arm_math.h ****   typedef struct
3904:.\Include/arm_math.h ****   {
3905:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3906:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3907:.\Include/arm_math.h ****     q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3908:.\Include/arm_math.h ****     q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3909:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q15;
3910:.\Include/arm_math.h **** 
3911:.\Include/arm_math.h ****   /**
3912:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 IIR lattice filter.
3913:.\Include/arm_math.h ****    */
3914:.\Include/arm_math.h ****   typedef struct
3915:.\Include/arm_math.h ****   {
3916:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3917:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3918:.\Include/arm_math.h ****     q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3919:.\Include/arm_math.h ****     q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3920:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q31;
3921:.\Include/arm_math.h **** 
3922:.\Include/arm_math.h ****   /**
3923:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point IIR lattice filter.
3924:.\Include/arm_math.h ****    */
3925:.\Include/arm_math.h ****   typedef struct
3926:.\Include/arm_math.h ****   {
3927:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3928:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3929:.\Include/arm_math.h ****     float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array
3930:.\Include/arm_math.h ****     float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is 
3931:.\Include/arm_math.h ****   } arm_iir_lattice_instance_f32;
3932:.\Include/arm_math.h **** 
3933:.\Include/arm_math.h **** 
3934:.\Include/arm_math.h ****   /**
3935:.\Include/arm_math.h ****    * @brief Processing function for the floating-point IIR lattice filter.
3936:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
3937:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3938:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3939:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3940:.\Include/arm_math.h ****    */
3941:.\Include/arm_math.h ****   void arm_iir_lattice_f32(
3942:.\Include/arm_math.h ****   const arm_iir_lattice_instance_f32 * S,
3943:.\Include/arm_math.h ****   float32_t * pSrc,
3944:.\Include/arm_math.h ****   float32_t * pDst,
3945:.\Include/arm_math.h ****   uint32_t blockSize);
3946:.\Include/arm_math.h **** 
3947:.\Include/arm_math.h **** 
3948:.\Include/arm_math.h ****   /**
3949:.\Include/arm_math.h ****    * @brief Initialization function for the floating-point IIR lattice filter.
3950:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point IIR lattice structure.
3951:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3952:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 79


3953:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3954:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-
3955:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3956:.\Include/arm_math.h ****    */
3957:.\Include/arm_math.h ****   void arm_iir_lattice_init_f32(
3958:.\Include/arm_math.h ****   arm_iir_lattice_instance_f32 * S,
3959:.\Include/arm_math.h ****   uint16_t numStages,
3960:.\Include/arm_math.h ****   float32_t * pkCoeffs,
3961:.\Include/arm_math.h ****   float32_t * pvCoeffs,
3962:.\Include/arm_math.h ****   float32_t * pState,
3963:.\Include/arm_math.h ****   uint32_t blockSize);
3964:.\Include/arm_math.h **** 
3965:.\Include/arm_math.h **** 
3966:.\Include/arm_math.h ****   /**
3967:.\Include/arm_math.h ****    * @brief Processing function for the Q31 IIR lattice filter.
3968:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
3969:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3970:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3971:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3972:.\Include/arm_math.h ****    */
3973:.\Include/arm_math.h ****   void arm_iir_lattice_q31(
3974:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q31 * S,
3975:.\Include/arm_math.h ****   q31_t * pSrc,
3976:.\Include/arm_math.h ****   q31_t * pDst,
3977:.\Include/arm_math.h ****   uint32_t blockSize);
3978:.\Include/arm_math.h **** 
3979:.\Include/arm_math.h **** 
3980:.\Include/arm_math.h ****   /**
3981:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 IIR lattice filter.
3982:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 IIR lattice structure.
3983:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3984:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3985:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3986:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
3987:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3988:.\Include/arm_math.h ****    */
3989:.\Include/arm_math.h ****   void arm_iir_lattice_init_q31(
3990:.\Include/arm_math.h ****   arm_iir_lattice_instance_q31 * S,
3991:.\Include/arm_math.h ****   uint16_t numStages,
3992:.\Include/arm_math.h ****   q31_t * pkCoeffs,
3993:.\Include/arm_math.h ****   q31_t * pvCoeffs,
3994:.\Include/arm_math.h ****   q31_t * pState,
3995:.\Include/arm_math.h ****   uint32_t blockSize);
3996:.\Include/arm_math.h **** 
3997:.\Include/arm_math.h **** 
3998:.\Include/arm_math.h ****   /**
3999:.\Include/arm_math.h ****    * @brief Processing function for the Q15 IIR lattice filter.
4000:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
4001:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4002:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
4003:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4004:.\Include/arm_math.h ****    */
4005:.\Include/arm_math.h ****   void arm_iir_lattice_q15(
4006:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q15 * S,
4007:.\Include/arm_math.h ****   q15_t * pSrc,
4008:.\Include/arm_math.h ****   q15_t * pDst,
4009:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 80


4010:.\Include/arm_math.h **** 
4011:.\Include/arm_math.h **** 
4012:.\Include/arm_math.h **** /**
4013:.\Include/arm_math.h ****  * @brief Initialization function for the Q15 IIR lattice filter.
4014:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
4015:.\Include/arm_math.h ****  * @param[in] numStages  number of stages in the filter.
4016:.\Include/arm_math.h ****  * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages
4017:.\Include/arm_math.h ****  * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
4018:.\Include/arm_math.h ****  * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
4019:.\Include/arm_math.h ****  * @param[in] blockSize  number of samples to process per call.
4020:.\Include/arm_math.h ****  */
4021:.\Include/arm_math.h ****   void arm_iir_lattice_init_q15(
4022:.\Include/arm_math.h ****   arm_iir_lattice_instance_q15 * S,
4023:.\Include/arm_math.h ****   uint16_t numStages,
4024:.\Include/arm_math.h ****   q15_t * pkCoeffs,
4025:.\Include/arm_math.h ****   q15_t * pvCoeffs,
4026:.\Include/arm_math.h ****   q15_t * pState,
4027:.\Include/arm_math.h ****   uint32_t blockSize);
4028:.\Include/arm_math.h **** 
4029:.\Include/arm_math.h **** 
4030:.\Include/arm_math.h ****   /**
4031:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point LMS filter.
4032:.\Include/arm_math.h ****    */
4033:.\Include/arm_math.h ****   typedef struct
4034:.\Include/arm_math.h ****   {
4035:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4036:.\Include/arm_math.h ****     float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+bl
4037:.\Include/arm_math.h ****     float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
4038:.\Include/arm_math.h ****     float32_t mu;        /**< step size that controls filter coefficient updates. */
4039:.\Include/arm_math.h ****   } arm_lms_instance_f32;
4040:.\Include/arm_math.h **** 
4041:.\Include/arm_math.h **** 
4042:.\Include/arm_math.h ****   /**
4043:.\Include/arm_math.h ****    * @brief Processing function for floating-point LMS filter.
4044:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point LMS filter structure.
4045:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4046:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4047:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4048:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4049:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4050:.\Include/arm_math.h ****    */
4051:.\Include/arm_math.h ****   void arm_lms_f32(
4052:.\Include/arm_math.h ****   const arm_lms_instance_f32 * S,
4053:.\Include/arm_math.h ****   float32_t * pSrc,
4054:.\Include/arm_math.h ****   float32_t * pRef,
4055:.\Include/arm_math.h ****   float32_t * pOut,
4056:.\Include/arm_math.h ****   float32_t * pErr,
4057:.\Include/arm_math.h ****   uint32_t blockSize);
4058:.\Include/arm_math.h **** 
4059:.\Include/arm_math.h **** 
4060:.\Include/arm_math.h ****   /**
4061:.\Include/arm_math.h ****    * @brief Initialization function for floating-point LMS filter.
4062:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4063:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4064:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4065:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4066:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 81


4067:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4068:.\Include/arm_math.h ****    */
4069:.\Include/arm_math.h ****   void arm_lms_init_f32(
4070:.\Include/arm_math.h ****   arm_lms_instance_f32 * S,
4071:.\Include/arm_math.h ****   uint16_t numTaps,
4072:.\Include/arm_math.h ****   float32_t * pCoeffs,
4073:.\Include/arm_math.h ****   float32_t * pState,
4074:.\Include/arm_math.h ****   float32_t mu,
4075:.\Include/arm_math.h ****   uint32_t blockSize);
4076:.\Include/arm_math.h **** 
4077:.\Include/arm_math.h **** 
4078:.\Include/arm_math.h ****   /**
4079:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 LMS filter.
4080:.\Include/arm_math.h ****    */
4081:.\Include/arm_math.h ****   typedef struct
4082:.\Include/arm_math.h ****   {
4083:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4084:.\Include/arm_math.h ****     q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4085:.\Include/arm_math.h ****     q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4086:.\Include/arm_math.h ****     q15_t mu;            /**< step size that controls filter coefficient updates. */
4087:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4088:.\Include/arm_math.h ****   } arm_lms_instance_q15;
4089:.\Include/arm_math.h **** 
4090:.\Include/arm_math.h **** 
4091:.\Include/arm_math.h ****   /**
4092:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 LMS filter.
4093:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 LMS filter structure.
4094:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4095:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4096:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.
4097:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4098:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4099:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4100:.\Include/arm_math.h ****    */
4101:.\Include/arm_math.h ****   void arm_lms_init_q15(
4102:.\Include/arm_math.h ****   arm_lms_instance_q15 * S,
4103:.\Include/arm_math.h ****   uint16_t numTaps,
4104:.\Include/arm_math.h ****   q15_t * pCoeffs,
4105:.\Include/arm_math.h ****   q15_t * pState,
4106:.\Include/arm_math.h ****   q15_t mu,
4107:.\Include/arm_math.h ****   uint32_t blockSize,
4108:.\Include/arm_math.h ****   uint32_t postShift);
4109:.\Include/arm_math.h **** 
4110:.\Include/arm_math.h **** 
4111:.\Include/arm_math.h ****   /**
4112:.\Include/arm_math.h ****    * @brief Processing function for Q15 LMS filter.
4113:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4114:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4115:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4116:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4117:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4118:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4119:.\Include/arm_math.h ****    */
4120:.\Include/arm_math.h ****   void arm_lms_q15(
4121:.\Include/arm_math.h ****   const arm_lms_instance_q15 * S,
4122:.\Include/arm_math.h ****   q15_t * pSrc,
4123:.\Include/arm_math.h ****   q15_t * pRef,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 82


4124:.\Include/arm_math.h ****   q15_t * pOut,
4125:.\Include/arm_math.h ****   q15_t * pErr,
4126:.\Include/arm_math.h ****   uint32_t blockSize);
4127:.\Include/arm_math.h **** 
4128:.\Include/arm_math.h **** 
4129:.\Include/arm_math.h ****   /**
4130:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 LMS filter.
4131:.\Include/arm_math.h ****    */
4132:.\Include/arm_math.h ****   typedef struct
4133:.\Include/arm_math.h ****   {
4134:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4135:.\Include/arm_math.h ****     q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4136:.\Include/arm_math.h ****     q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4137:.\Include/arm_math.h ****     q31_t mu;            /**< step size that controls filter coefficient updates. */
4138:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4139:.\Include/arm_math.h ****   } arm_lms_instance_q31;
4140:.\Include/arm_math.h **** 
4141:.\Include/arm_math.h **** 
4142:.\Include/arm_math.h ****   /**
4143:.\Include/arm_math.h ****    * @brief Processing function for Q31 LMS filter.
4144:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4145:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4146:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4147:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4148:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4149:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4150:.\Include/arm_math.h ****    */
4151:.\Include/arm_math.h ****   void arm_lms_q31(
4152:.\Include/arm_math.h ****   const arm_lms_instance_q31 * S,
4153:.\Include/arm_math.h ****   q31_t * pSrc,
4154:.\Include/arm_math.h ****   q31_t * pRef,
4155:.\Include/arm_math.h ****   q31_t * pOut,
4156:.\Include/arm_math.h ****   q31_t * pErr,
4157:.\Include/arm_math.h ****   uint32_t blockSize);
4158:.\Include/arm_math.h **** 
4159:.\Include/arm_math.h **** 
4160:.\Include/arm_math.h ****   /**
4161:.\Include/arm_math.h ****    * @brief Initialization function for Q31 LMS filter.
4162:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 LMS filter structure.
4163:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4164:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4165:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4166:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4167:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4168:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4169:.\Include/arm_math.h ****    */
4170:.\Include/arm_math.h ****   void arm_lms_init_q31(
4171:.\Include/arm_math.h ****   arm_lms_instance_q31 * S,
4172:.\Include/arm_math.h ****   uint16_t numTaps,
4173:.\Include/arm_math.h ****   q31_t * pCoeffs,
4174:.\Include/arm_math.h ****   q31_t * pState,
4175:.\Include/arm_math.h ****   q31_t mu,
4176:.\Include/arm_math.h ****   uint32_t blockSize,
4177:.\Include/arm_math.h ****   uint32_t postShift);
4178:.\Include/arm_math.h **** 
4179:.\Include/arm_math.h **** 
4180:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 83


4181:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point normalized LMS filter.
4182:.\Include/arm_math.h ****    */
4183:.\Include/arm_math.h ****   typedef struct
4184:.\Include/arm_math.h ****   {
4185:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4186:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
4187:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
4188:.\Include/arm_math.h ****     float32_t mu;         /**< step size that control filter coefficient updates. */
4189:.\Include/arm_math.h ****     float32_t energy;     /**< saves previous frame energy. */
4190:.\Include/arm_math.h ****     float32_t x0;         /**< saves previous input sample. */
4191:.\Include/arm_math.h ****   } arm_lms_norm_instance_f32;
4192:.\Include/arm_math.h **** 
4193:.\Include/arm_math.h **** 
4194:.\Include/arm_math.h ****   /**
4195:.\Include/arm_math.h ****    * @brief Processing function for floating-point normalized LMS filter.
4196:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point normalized LMS filter struc
4197:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4198:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4199:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4200:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4201:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4202:.\Include/arm_math.h ****    */
4203:.\Include/arm_math.h ****   void arm_lms_norm_f32(
4204:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4205:.\Include/arm_math.h ****   float32_t * pSrc,
4206:.\Include/arm_math.h ****   float32_t * pRef,
4207:.\Include/arm_math.h ****   float32_t * pOut,
4208:.\Include/arm_math.h ****   float32_t * pErr,
4209:.\Include/arm_math.h ****   uint32_t blockSize);
4210:.\Include/arm_math.h **** 
4211:.\Include/arm_math.h **** 
4212:.\Include/arm_math.h ****   /**
4213:.\Include/arm_math.h ****    * @brief Initialization function for floating-point normalized LMS filter.
4214:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4215:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4216:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4217:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4218:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4219:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4220:.\Include/arm_math.h ****    */
4221:.\Include/arm_math.h ****   void arm_lms_norm_init_f32(
4222:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4223:.\Include/arm_math.h ****   uint16_t numTaps,
4224:.\Include/arm_math.h ****   float32_t * pCoeffs,
4225:.\Include/arm_math.h ****   float32_t * pState,
4226:.\Include/arm_math.h ****   float32_t mu,
4227:.\Include/arm_math.h ****   uint32_t blockSize);
4228:.\Include/arm_math.h **** 
4229:.\Include/arm_math.h **** 
4230:.\Include/arm_math.h ****   /**
4231:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 normalized LMS filter.
4232:.\Include/arm_math.h ****    */
4233:.\Include/arm_math.h ****   typedef struct
4234:.\Include/arm_math.h ****   {
4235:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4236:.\Include/arm_math.h ****     q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4237:.\Include/arm_math.h ****     q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 84


4238:.\Include/arm_math.h ****     q31_t mu;             /**< step size that controls filter coefficient updates. */
4239:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4240:.\Include/arm_math.h ****     q31_t *recipTable;    /**< points to the reciprocal initial value table. */
4241:.\Include/arm_math.h ****     q31_t energy;         /**< saves previous frame energy. */
4242:.\Include/arm_math.h ****     q31_t x0;             /**< saves previous input sample. */
4243:.\Include/arm_math.h ****   } arm_lms_norm_instance_q31;
4244:.\Include/arm_math.h **** 
4245:.\Include/arm_math.h **** 
4246:.\Include/arm_math.h ****   /**
4247:.\Include/arm_math.h ****    * @brief Processing function for Q31 normalized LMS filter.
4248:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
4249:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4250:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4251:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4252:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4253:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4254:.\Include/arm_math.h ****    */
4255:.\Include/arm_math.h ****   void arm_lms_norm_q31(
4256:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4257:.\Include/arm_math.h ****   q31_t * pSrc,
4258:.\Include/arm_math.h ****   q31_t * pRef,
4259:.\Include/arm_math.h ****   q31_t * pOut,
4260:.\Include/arm_math.h ****   q31_t * pErr,
4261:.\Include/arm_math.h ****   uint32_t blockSize);
4262:.\Include/arm_math.h **** 
4263:.\Include/arm_math.h **** 
4264:.\Include/arm_math.h ****   /**
4265:.\Include/arm_math.h ****    * @brief Initialization function for Q31 normalized LMS filter.
4266:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
4267:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4268:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4269:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4270:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4271:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4272:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4273:.\Include/arm_math.h ****    */
4274:.\Include/arm_math.h ****   void arm_lms_norm_init_q31(
4275:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4276:.\Include/arm_math.h ****   uint16_t numTaps,
4277:.\Include/arm_math.h ****   q31_t * pCoeffs,
4278:.\Include/arm_math.h ****   q31_t * pState,
4279:.\Include/arm_math.h ****   q31_t mu,
4280:.\Include/arm_math.h ****   uint32_t blockSize,
4281:.\Include/arm_math.h ****   uint8_t postShift);
4282:.\Include/arm_math.h **** 
4283:.\Include/arm_math.h **** 
4284:.\Include/arm_math.h ****   /**
4285:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 normalized LMS filter.
4286:.\Include/arm_math.h ****    */
4287:.\Include/arm_math.h ****   typedef struct
4288:.\Include/arm_math.h ****   {
4289:.\Include/arm_math.h ****     uint16_t numTaps;     /**< Number of coefficients in the filter. */
4290:.\Include/arm_math.h ****     q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4291:.\Include/arm_math.h ****     q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4292:.\Include/arm_math.h ****     q15_t mu;             /**< step size that controls filter coefficient updates. */
4293:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4294:.\Include/arm_math.h ****     q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 85


4295:.\Include/arm_math.h ****     q15_t energy;         /**< saves previous frame energy. */
4296:.\Include/arm_math.h ****     q15_t x0;             /**< saves previous input sample. */
4297:.\Include/arm_math.h ****   } arm_lms_norm_instance_q15;
4298:.\Include/arm_math.h **** 
4299:.\Include/arm_math.h **** 
4300:.\Include/arm_math.h ****   /**
4301:.\Include/arm_math.h ****    * @brief Processing function for Q15 normalized LMS filter.
4302:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
4303:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4304:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4305:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4306:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4307:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4308:.\Include/arm_math.h ****    */
4309:.\Include/arm_math.h ****   void arm_lms_norm_q15(
4310:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4311:.\Include/arm_math.h ****   q15_t * pSrc,
4312:.\Include/arm_math.h ****   q15_t * pRef,
4313:.\Include/arm_math.h ****   q15_t * pOut,
4314:.\Include/arm_math.h ****   q15_t * pErr,
4315:.\Include/arm_math.h ****   uint32_t blockSize);
4316:.\Include/arm_math.h **** 
4317:.\Include/arm_math.h **** 
4318:.\Include/arm_math.h ****   /**
4319:.\Include/arm_math.h ****    * @brief Initialization function for Q15 normalized LMS filter.
4320:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
4321:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4322:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4323:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4324:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4325:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4326:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4327:.\Include/arm_math.h ****    */
4328:.\Include/arm_math.h ****   void arm_lms_norm_init_q15(
4329:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4330:.\Include/arm_math.h ****   uint16_t numTaps,
4331:.\Include/arm_math.h ****   q15_t * pCoeffs,
4332:.\Include/arm_math.h ****   q15_t * pState,
4333:.\Include/arm_math.h ****   q15_t mu,
4334:.\Include/arm_math.h ****   uint32_t blockSize,
4335:.\Include/arm_math.h ****   uint8_t postShift);
4336:.\Include/arm_math.h **** 
4337:.\Include/arm_math.h **** 
4338:.\Include/arm_math.h ****   /**
4339:.\Include/arm_math.h ****    * @brief Correlation of floating-point sequences.
4340:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4341:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4342:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4343:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4344:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4345:.\Include/arm_math.h ****    */
4346:.\Include/arm_math.h ****   void arm_correlate_f32(
4347:.\Include/arm_math.h ****   float32_t * pSrcA,
4348:.\Include/arm_math.h ****   uint32_t srcALen,
4349:.\Include/arm_math.h ****   float32_t * pSrcB,
4350:.\Include/arm_math.h ****   uint32_t srcBLen,
4351:.\Include/arm_math.h ****   float32_t * pDst);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 86


4352:.\Include/arm_math.h **** 
4353:.\Include/arm_math.h **** 
4354:.\Include/arm_math.h ****    /**
4355:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences
4356:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4357:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4358:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4359:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4360:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4361:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4362:.\Include/arm_math.h ****    */
4363:.\Include/arm_math.h ****   void arm_correlate_opt_q15(
4364:.\Include/arm_math.h ****   q15_t * pSrcA,
4365:.\Include/arm_math.h ****   uint32_t srcALen,
4366:.\Include/arm_math.h ****   q15_t * pSrcB,
4367:.\Include/arm_math.h ****   uint32_t srcBLen,
4368:.\Include/arm_math.h ****   q15_t * pDst,
4369:.\Include/arm_math.h ****   q15_t * pScratch);
4370:.\Include/arm_math.h **** 
4371:.\Include/arm_math.h **** 
4372:.\Include/arm_math.h ****   /**
4373:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences.
4374:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4375:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4376:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4377:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4378:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4379:.\Include/arm_math.h ****    */
4380:.\Include/arm_math.h **** 
4381:.\Include/arm_math.h ****   void arm_correlate_q15(
4382:.\Include/arm_math.h ****   q15_t * pSrcA,
4383:.\Include/arm_math.h ****   uint32_t srcALen,
4384:.\Include/arm_math.h ****   q15_t * pSrcB,
4385:.\Include/arm_math.h ****   uint32_t srcBLen,
4386:.\Include/arm_math.h ****   q15_t * pDst);
4387:.\Include/arm_math.h **** 
4388:.\Include/arm_math.h **** 
4389:.\Include/arm_math.h ****   /**
4390:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4391:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4392:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4393:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4394:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4395:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4396:.\Include/arm_math.h ****    */
4397:.\Include/arm_math.h **** 
4398:.\Include/arm_math.h ****   void arm_correlate_fast_q15(
4399:.\Include/arm_math.h ****   q15_t * pSrcA,
4400:.\Include/arm_math.h ****   uint32_t srcALen,
4401:.\Include/arm_math.h ****   q15_t * pSrcB,
4402:.\Include/arm_math.h ****   uint32_t srcBLen,
4403:.\Include/arm_math.h ****   q15_t * pDst);
4404:.\Include/arm_math.h **** 
4405:.\Include/arm_math.h **** 
4406:.\Include/arm_math.h ****   /**
4407:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4408:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 87


4409:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4410:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4411:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4412:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4413:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4414:.\Include/arm_math.h ****    */
4415:.\Include/arm_math.h ****   void arm_correlate_fast_opt_q15(
4416:.\Include/arm_math.h ****   q15_t * pSrcA,
4417:.\Include/arm_math.h ****   uint32_t srcALen,
4418:.\Include/arm_math.h ****   q15_t * pSrcB,
4419:.\Include/arm_math.h ****   uint32_t srcBLen,
4420:.\Include/arm_math.h ****   q15_t * pDst,
4421:.\Include/arm_math.h ****   q15_t * pScratch);
4422:.\Include/arm_math.h **** 
4423:.\Include/arm_math.h **** 
4424:.\Include/arm_math.h ****   /**
4425:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences.
4426:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4427:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4428:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4429:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4430:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4431:.\Include/arm_math.h ****    */
4432:.\Include/arm_math.h ****   void arm_correlate_q31(
4433:.\Include/arm_math.h ****   q31_t * pSrcA,
4434:.\Include/arm_math.h ****   uint32_t srcALen,
4435:.\Include/arm_math.h ****   q31_t * pSrcB,
4436:.\Include/arm_math.h ****   uint32_t srcBLen,
4437:.\Include/arm_math.h ****   q31_t * pDst);
4438:.\Include/arm_math.h **** 
4439:.\Include/arm_math.h **** 
4440:.\Include/arm_math.h ****   /**
4441:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
4442:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4443:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4444:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4445:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4446:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4447:.\Include/arm_math.h ****    */
4448:.\Include/arm_math.h ****   void arm_correlate_fast_q31(
4449:.\Include/arm_math.h ****   q31_t * pSrcA,
4450:.\Include/arm_math.h ****   uint32_t srcALen,
4451:.\Include/arm_math.h ****   q31_t * pSrcB,
4452:.\Include/arm_math.h ****   uint32_t srcBLen,
4453:.\Include/arm_math.h ****   q31_t * pDst);
4454:.\Include/arm_math.h **** 
4455:.\Include/arm_math.h **** 
4456:.\Include/arm_math.h ****  /**
4457:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4458:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
4459:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
4460:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
4461:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
4462:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 
4463:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
4464:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
4465:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 88


4466:.\Include/arm_math.h ****   void arm_correlate_opt_q7(
4467:.\Include/arm_math.h ****   q7_t * pSrcA,
4468:.\Include/arm_math.h ****   uint32_t srcALen,
4469:.\Include/arm_math.h ****   q7_t * pSrcB,
4470:.\Include/arm_math.h ****   uint32_t srcBLen,
4471:.\Include/arm_math.h ****   q7_t * pDst,
4472:.\Include/arm_math.h ****   q15_t * pScratch1,
4473:.\Include/arm_math.h ****   q15_t * pScratch2);
4474:.\Include/arm_math.h **** 
4475:.\Include/arm_math.h **** 
4476:.\Include/arm_math.h ****   /**
4477:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4478:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4479:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4480:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4481:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4482:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4483:.\Include/arm_math.h ****    */
4484:.\Include/arm_math.h ****   void arm_correlate_q7(
4485:.\Include/arm_math.h ****   q7_t * pSrcA,
4486:.\Include/arm_math.h ****   uint32_t srcALen,
4487:.\Include/arm_math.h ****   q7_t * pSrcB,
4488:.\Include/arm_math.h ****   uint32_t srcBLen,
4489:.\Include/arm_math.h ****   q7_t * pDst);
4490:.\Include/arm_math.h **** 
4491:.\Include/arm_math.h **** 
4492:.\Include/arm_math.h ****   /**
4493:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point sparse FIR filter.
4494:.\Include/arm_math.h ****    */
4495:.\Include/arm_math.h ****   typedef struct
4496:.\Include/arm_math.h ****   {
4497:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4498:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4499:.\Include/arm_math.h ****     float32_t *pState;            /**< points to the state buffer array. The array is of length max
4500:.\Include/arm_math.h ****     float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numT
4501:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4502:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4503:.\Include/arm_math.h ****   } arm_fir_sparse_instance_f32;
4504:.\Include/arm_math.h **** 
4505:.\Include/arm_math.h ****   /**
4506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 sparse FIR filter.
4507:.\Include/arm_math.h ****    */
4508:.\Include/arm_math.h ****   typedef struct
4509:.\Include/arm_math.h ****   {
4510:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4511:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4512:.\Include/arm_math.h ****     q31_t *pState;                /**< points to the state buffer array. The array is of length max
4513:.\Include/arm_math.h ****     q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4514:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4515:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4516:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q31;
4517:.\Include/arm_math.h **** 
4518:.\Include/arm_math.h ****   /**
4519:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 sparse FIR filter.
4520:.\Include/arm_math.h ****    */
4521:.\Include/arm_math.h ****   typedef struct
4522:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 89


4523:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4524:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4525:.\Include/arm_math.h ****     q15_t *pState;                /**< points to the state buffer array. The array is of length max
4526:.\Include/arm_math.h ****     q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4527:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4528:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4529:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q15;
4530:.\Include/arm_math.h **** 
4531:.\Include/arm_math.h ****   /**
4532:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 sparse FIR filter.
4533:.\Include/arm_math.h ****    */
4534:.\Include/arm_math.h ****   typedef struct
4535:.\Include/arm_math.h ****   {
4536:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4537:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4538:.\Include/arm_math.h ****     q7_t *pState;                 /**< points to the state buffer array. The array is of length max
4539:.\Include/arm_math.h ****     q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numT
4540:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4541:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4542:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q7;
4543:.\Include/arm_math.h **** 
4544:.\Include/arm_math.h **** 
4545:.\Include/arm_math.h ****   /**
4546:.\Include/arm_math.h ****    * @brief Processing function for the floating-point sparse FIR filter.
4547:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
4548:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4549:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4550:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4551:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4552:.\Include/arm_math.h ****    */
4553:.\Include/arm_math.h ****   void arm_fir_sparse_f32(
4554:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4555:.\Include/arm_math.h ****   float32_t * pSrc,
4556:.\Include/arm_math.h ****   float32_t * pDst,
4557:.\Include/arm_math.h ****   float32_t * pScratchIn,
4558:.\Include/arm_math.h ****   uint32_t blockSize);
4559:.\Include/arm_math.h **** 
4560:.\Include/arm_math.h **** 
4561:.\Include/arm_math.h ****   /**
4562:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point sparse FIR filter.
4563:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
4564:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4565:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4566:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4567:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4568:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4569:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4570:.\Include/arm_math.h ****    */
4571:.\Include/arm_math.h ****   void arm_fir_sparse_init_f32(
4572:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4573:.\Include/arm_math.h ****   uint16_t numTaps,
4574:.\Include/arm_math.h ****   float32_t * pCoeffs,
4575:.\Include/arm_math.h ****   float32_t * pState,
4576:.\Include/arm_math.h ****   int32_t * pTapDelay,
4577:.\Include/arm_math.h ****   uint16_t maxDelay,
4578:.\Include/arm_math.h ****   uint32_t blockSize);
4579:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 90


4580:.\Include/arm_math.h **** 
4581:.\Include/arm_math.h ****   /**
4582:.\Include/arm_math.h ****    * @brief Processing function for the Q31 sparse FIR filter.
4583:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
4584:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4585:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4586:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4587:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4588:.\Include/arm_math.h ****    */
4589:.\Include/arm_math.h ****   void arm_fir_sparse_q31(
4590:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4591:.\Include/arm_math.h ****   q31_t * pSrc,
4592:.\Include/arm_math.h ****   q31_t * pDst,
4593:.\Include/arm_math.h ****   q31_t * pScratchIn,
4594:.\Include/arm_math.h ****   uint32_t blockSize);
4595:.\Include/arm_math.h **** 
4596:.\Include/arm_math.h **** 
4597:.\Include/arm_math.h ****   /**
4598:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 sparse FIR filter.
4599:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
4600:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4601:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4602:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4603:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4604:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4605:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4606:.\Include/arm_math.h ****    */
4607:.\Include/arm_math.h ****   void arm_fir_sparse_init_q31(
4608:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4609:.\Include/arm_math.h ****   uint16_t numTaps,
4610:.\Include/arm_math.h ****   q31_t * pCoeffs,
4611:.\Include/arm_math.h ****   q31_t * pState,
4612:.\Include/arm_math.h ****   int32_t * pTapDelay,
4613:.\Include/arm_math.h ****   uint16_t maxDelay,
4614:.\Include/arm_math.h ****   uint32_t blockSize);
4615:.\Include/arm_math.h **** 
4616:.\Include/arm_math.h **** 
4617:.\Include/arm_math.h ****   /**
4618:.\Include/arm_math.h ****    * @brief Processing function for the Q15 sparse FIR filter.
4619:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
4620:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4621:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4622:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4623:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4624:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4625:.\Include/arm_math.h ****    */
4626:.\Include/arm_math.h ****   void arm_fir_sparse_q15(
4627:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4628:.\Include/arm_math.h ****   q15_t * pSrc,
4629:.\Include/arm_math.h ****   q15_t * pDst,
4630:.\Include/arm_math.h ****   q15_t * pScratchIn,
4631:.\Include/arm_math.h ****   q31_t * pScratchOut,
4632:.\Include/arm_math.h ****   uint32_t blockSize);
4633:.\Include/arm_math.h **** 
4634:.\Include/arm_math.h **** 
4635:.\Include/arm_math.h ****   /**
4636:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 sparse FIR filter.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 91


4637:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
4638:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4639:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4640:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4641:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4642:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4643:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4644:.\Include/arm_math.h ****    */
4645:.\Include/arm_math.h ****   void arm_fir_sparse_init_q15(
4646:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4647:.\Include/arm_math.h ****   uint16_t numTaps,
4648:.\Include/arm_math.h ****   q15_t * pCoeffs,
4649:.\Include/arm_math.h ****   q15_t * pState,
4650:.\Include/arm_math.h ****   int32_t * pTapDelay,
4651:.\Include/arm_math.h ****   uint16_t maxDelay,
4652:.\Include/arm_math.h ****   uint32_t blockSize);
4653:.\Include/arm_math.h **** 
4654:.\Include/arm_math.h **** 
4655:.\Include/arm_math.h ****   /**
4656:.\Include/arm_math.h ****    * @brief Processing function for the Q7 sparse FIR filter.
4657:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
4658:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4659:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4660:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4661:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4662:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4663:.\Include/arm_math.h ****    */
4664:.\Include/arm_math.h ****   void arm_fir_sparse_q7(
4665:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4666:.\Include/arm_math.h ****   q7_t * pSrc,
4667:.\Include/arm_math.h ****   q7_t * pDst,
4668:.\Include/arm_math.h ****   q7_t * pScratchIn,
4669:.\Include/arm_math.h ****   q31_t * pScratchOut,
4670:.\Include/arm_math.h ****   uint32_t blockSize);
4671:.\Include/arm_math.h **** 
4672:.\Include/arm_math.h **** 
4673:.\Include/arm_math.h ****   /**
4674:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 sparse FIR filter.
4675:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
4676:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4677:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4678:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4679:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4680:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4681:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4682:.\Include/arm_math.h ****    */
4683:.\Include/arm_math.h ****   void arm_fir_sparse_init_q7(
4684:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4685:.\Include/arm_math.h ****   uint16_t numTaps,
4686:.\Include/arm_math.h ****   q7_t * pCoeffs,
4687:.\Include/arm_math.h ****   q7_t * pState,
4688:.\Include/arm_math.h ****   int32_t * pTapDelay,
4689:.\Include/arm_math.h ****   uint16_t maxDelay,
4690:.\Include/arm_math.h ****   uint32_t blockSize);
4691:.\Include/arm_math.h **** 
4692:.\Include/arm_math.h **** 
4693:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 92


4694:.\Include/arm_math.h ****    * @brief  Floating-point sin_cos function.
4695:.\Include/arm_math.h ****    * @param[in]  theta   input value in degrees
4696:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4697:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cos output.
4698:.\Include/arm_math.h ****    */
4699:.\Include/arm_math.h ****   void arm_sin_cos_f32(
4700:.\Include/arm_math.h ****   float32_t theta,
4701:.\Include/arm_math.h ****   float32_t * pSinVal,
4702:.\Include/arm_math.h ****   float32_t * pCosVal);
4703:.\Include/arm_math.h **** 
4704:.\Include/arm_math.h **** 
4705:.\Include/arm_math.h ****   /**
4706:.\Include/arm_math.h ****    * @brief  Q31 sin_cos function.
4707:.\Include/arm_math.h ****    * @param[in]  theta    scaled input value in degrees
4708:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4709:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cosine output.
4710:.\Include/arm_math.h ****    */
4711:.\Include/arm_math.h ****   void arm_sin_cos_q31(
4712:.\Include/arm_math.h ****   q31_t theta,
4713:.\Include/arm_math.h ****   q31_t * pSinVal,
4714:.\Include/arm_math.h ****   q31_t * pCosVal);
4715:.\Include/arm_math.h **** 
4716:.\Include/arm_math.h **** 
4717:.\Include/arm_math.h ****   /**
4718:.\Include/arm_math.h ****    * @brief  Floating-point complex conjugate.
4719:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4720:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4721:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4722:.\Include/arm_math.h ****    */
4723:.\Include/arm_math.h ****   void arm_cmplx_conj_f32(
4724:.\Include/arm_math.h ****   float32_t * pSrc,
4725:.\Include/arm_math.h ****   float32_t * pDst,
4726:.\Include/arm_math.h ****   uint32_t numSamples);
4727:.\Include/arm_math.h **** 
4728:.\Include/arm_math.h ****   /**
4729:.\Include/arm_math.h ****    * @brief  Q31 complex conjugate.
4730:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4731:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4732:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4733:.\Include/arm_math.h ****    */
4734:.\Include/arm_math.h ****   void arm_cmplx_conj_q31(
4735:.\Include/arm_math.h ****   q31_t * pSrc,
4736:.\Include/arm_math.h ****   q31_t * pDst,
4737:.\Include/arm_math.h ****   uint32_t numSamples);
4738:.\Include/arm_math.h **** 
4739:.\Include/arm_math.h **** 
4740:.\Include/arm_math.h ****   /**
4741:.\Include/arm_math.h ****    * @brief  Q15 complex conjugate.
4742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4743:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4744:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4745:.\Include/arm_math.h ****    */
4746:.\Include/arm_math.h ****   void arm_cmplx_conj_q15(
4747:.\Include/arm_math.h ****   q15_t * pSrc,
4748:.\Include/arm_math.h ****   q15_t * pDst,
4749:.\Include/arm_math.h ****   uint32_t numSamples);
4750:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 93


4751:.\Include/arm_math.h **** 
4752:.\Include/arm_math.h ****   /**
4753:.\Include/arm_math.h ****    * @brief  Floating-point complex magnitude squared
4754:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4755:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4756:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4757:.\Include/arm_math.h ****    */
4758:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_f32(
4759:.\Include/arm_math.h ****   float32_t * pSrc,
4760:.\Include/arm_math.h ****   float32_t * pDst,
4761:.\Include/arm_math.h ****   uint32_t numSamples);
4762:.\Include/arm_math.h **** 
4763:.\Include/arm_math.h **** 
4764:.\Include/arm_math.h ****   /**
4765:.\Include/arm_math.h ****    * @brief  Q31 complex magnitude squared
4766:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4767:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4768:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4769:.\Include/arm_math.h ****    */
4770:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q31(
4771:.\Include/arm_math.h ****   q31_t * pSrc,
4772:.\Include/arm_math.h ****   q31_t * pDst,
4773:.\Include/arm_math.h ****   uint32_t numSamples);
4774:.\Include/arm_math.h **** 
4775:.\Include/arm_math.h **** 
4776:.\Include/arm_math.h ****   /**
4777:.\Include/arm_math.h ****    * @brief  Q15 complex magnitude squared
4778:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4779:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4780:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4781:.\Include/arm_math.h ****    */
4782:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q15(
4783:.\Include/arm_math.h ****   q15_t * pSrc,
4784:.\Include/arm_math.h ****   q15_t * pDst,
4785:.\Include/arm_math.h ****   uint32_t numSamples);
4786:.\Include/arm_math.h **** 
4787:.\Include/arm_math.h **** 
4788:.\Include/arm_math.h ****  /**
4789:.\Include/arm_math.h ****    * @ingroup groupController
4790:.\Include/arm_math.h ****    */
4791:.\Include/arm_math.h **** 
4792:.\Include/arm_math.h ****   /**
4793:.\Include/arm_math.h ****    * @defgroup PID PID Motor Control
4794:.\Include/arm_math.h ****    *
4795:.\Include/arm_math.h ****    * A Proportional Integral Derivative (PID) controller is a generic feedback control
4796:.\Include/arm_math.h ****    * loop mechanism widely used in industrial control systems.
4797:.\Include/arm_math.h ****    * A PID controller is the most commonly used type of feedback controller.
4798:.\Include/arm_math.h ****    *
4799:.\Include/arm_math.h ****    * This set of functions implements (PID) controllers
4800:.\Include/arm_math.h ****    * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
4801:.\Include/arm_math.h ****    * of data and each call to the function returns a single processed value.
4802:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
4803:.\Include/arm_math.h ****    * is the input sample value. The functions return the output value.
4804:.\Include/arm_math.h ****    *
4805:.\Include/arm_math.h ****    * \par Algorithm:
4806:.\Include/arm_math.h ****    * <pre>
4807:.\Include/arm_math.h ****    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 94


4808:.\Include/arm_math.h ****    *    A0 = Kp + Ki + Kd
4809:.\Include/arm_math.h ****    *    A1 = (-Kp ) - (2 * Kd )
4810:.\Include/arm_math.h ****    *    A2 = Kd  </pre>
4811:.\Include/arm_math.h ****    *
4812:.\Include/arm_math.h ****    * \par
4813:.\Include/arm_math.h ****    * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative const
4814:.\Include/arm_math.h ****    *
4815:.\Include/arm_math.h ****    * \par
4816:.\Include/arm_math.h ****    * \image html PID.gif "Proportional Integral Derivative Controller"
4817:.\Include/arm_math.h ****    *
4818:.\Include/arm_math.h ****    * \par
4819:.\Include/arm_math.h ****    * The PID controller calculates an "error" value as the difference between
4820:.\Include/arm_math.h ****    * the measured output and the reference input.
4821:.\Include/arm_math.h ****    * The controller attempts to minimize the error by adjusting the process control inputs.
4822:.\Include/arm_math.h ****    * The proportional value determines the reaction to the current error,
4823:.\Include/arm_math.h ****    * the integral value determines the reaction based on the sum of recent errors,
4824:.\Include/arm_math.h ****    * and the derivative value determines the reaction based on the rate at which the error has been
4825:.\Include/arm_math.h ****    *
4826:.\Include/arm_math.h ****    * \par Instance Structure
4827:.\Include/arm_math.h ****    * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instan
4828:.\Include/arm_math.h ****    * A separate instance structure must be defined for each PID Controller.
4829:.\Include/arm_math.h ****    * There are separate instance structure declarations for each of the 3 supported data types.
4830:.\Include/arm_math.h ****    *
4831:.\Include/arm_math.h ****    * \par Reset Functions
4832:.\Include/arm_math.h ****    * There is also an associated reset function for each data type which clears the state array.
4833:.\Include/arm_math.h ****    *
4834:.\Include/arm_math.h ****    * \par Initialization Functions
4835:.\Include/arm_math.h ****    * There is also an associated initialization function for each data type.
4836:.\Include/arm_math.h ****    * The initialization function performs the following operations:
4837:.\Include/arm_math.h ****    * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
4838:.\Include/arm_math.h ****    * - Zeros out the values in the state buffer.
4839:.\Include/arm_math.h ****    *
4840:.\Include/arm_math.h ****    * \par
4841:.\Include/arm_math.h ****    * Instance structure cannot be placed into a const data section and it is recommended to use the
4842:.\Include/arm_math.h ****    *
4843:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
4844:.\Include/arm_math.h ****    * Care must be taken when using the fixed-point versions of the PID Controller functions.
4845:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used in each function m
4846:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4847:.\Include/arm_math.h ****    */
4848:.\Include/arm_math.h **** 
4849:.\Include/arm_math.h ****   /**
4850:.\Include/arm_math.h ****    * @addtogroup PID
4851:.\Include/arm_math.h ****    * @{
4852:.\Include/arm_math.h ****    */
4853:.\Include/arm_math.h **** 
4854:.\Include/arm_math.h ****   /**
4855:.\Include/arm_math.h ****    * @brief  Process function for the floating-point PID Control.
4856:.\Include/arm_math.h ****    * @param[in,out] S   is an instance of the floating-point PID Control structure
4857:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4858:.\Include/arm_math.h ****    * @return out processed output sample.
4859:.\Include/arm_math.h ****    */
4860:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_pid_f32(
4861:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
4862:.\Include/arm_math.h ****   float32_t in)
4863:.\Include/arm_math.h ****   {
4864:.\Include/arm_math.h ****     float32_t out;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 95


4865:.\Include/arm_math.h **** 
4866:.\Include/arm_math.h ****     /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
4867:.\Include/arm_math.h ****     out = (S->A0 * in) +
4868:.\Include/arm_math.h ****       (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
4869:.\Include/arm_math.h **** 
4870:.\Include/arm_math.h ****     /* Update state */
4871:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4872:.\Include/arm_math.h ****     S->state[0] = in;
4873:.\Include/arm_math.h ****     S->state[2] = out;
4874:.\Include/arm_math.h **** 
4875:.\Include/arm_math.h ****     /* return to application */
4876:.\Include/arm_math.h ****     return (out);
4877:.\Include/arm_math.h **** 
4878:.\Include/arm_math.h ****   }
4879:.\Include/arm_math.h **** 
4880:.\Include/arm_math.h ****   /**
4881:.\Include/arm_math.h ****    * @brief  Process function for the Q31 PID Control.
4882:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the Q31 PID Control structure
4883:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4884:.\Include/arm_math.h ****    * @return out processed output sample.
4885:.\Include/arm_math.h ****    *
4886:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4887:.\Include/arm_math.h ****    * \par
4888:.\Include/arm_math.h ****    * The function is implemented using an internal 64-bit accumulator.
4889:.\Include/arm_math.h ****    * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplicat
4890:.\Include/arm_math.h ****    * Thus, if the accumulator result overflows it wraps around rather than clip.
4891:.\Include/arm_math.h ****    * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there
4892:.\Include/arm_math.h ****    * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format
4893:.\Include/arm_math.h ****    */
4894:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_pid_q31(
4895:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
4896:.\Include/arm_math.h ****   q31_t in)
4897:.\Include/arm_math.h ****   {
4898:.\Include/arm_math.h ****     q63_t acc;
4899:.\Include/arm_math.h ****     q31_t out;
4900:.\Include/arm_math.h **** 
4901:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4902:.\Include/arm_math.h ****     acc = (q63_t) S->A0 * in;
4903:.\Include/arm_math.h **** 
4904:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] */
4905:.\Include/arm_math.h ****     acc += (q63_t) S->A1 * S->state[0];
4906:.\Include/arm_math.h **** 
4907:.\Include/arm_math.h ****     /* acc += A2 * x[n-2]  */
4908:.\Include/arm_math.h ****     acc += (q63_t) S->A2 * S->state[1];
4909:.\Include/arm_math.h **** 
4910:.\Include/arm_math.h ****     /* convert output to 1.31 format to add y[n-1] */
4911:.\Include/arm_math.h ****     out = (q31_t) (acc >> 31u);
4912:.\Include/arm_math.h **** 
4913:.\Include/arm_math.h ****     /* out += y[n-1] */
4914:.\Include/arm_math.h ****     out += S->state[2];
4915:.\Include/arm_math.h **** 
4916:.\Include/arm_math.h ****     /* Update state */
4917:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4918:.\Include/arm_math.h ****     S->state[0] = in;
4919:.\Include/arm_math.h ****     S->state[2] = out;
4920:.\Include/arm_math.h **** 
4921:.\Include/arm_math.h ****     /* return to application */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 96


4922:.\Include/arm_math.h ****     return (out);
4923:.\Include/arm_math.h ****   }
4924:.\Include/arm_math.h **** 
4925:.\Include/arm_math.h **** 
4926:.\Include/arm_math.h ****   /**
4927:.\Include/arm_math.h ****    * @brief  Process function for the Q15 PID Control.
4928:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q15 PID Control structure
4929:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4930:.\Include/arm_math.h ****    * @return out processed output sample.
4931:.\Include/arm_math.h ****    *
4932:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4933:.\Include/arm_math.h ****    * \par
4934:.\Include/arm_math.h ****    * The function is implemented using a 64-bit internal accumulator.
4935:.\Include/arm_math.h ****    * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30
4936:.\Include/arm_math.h ****    * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
4937:.\Include/arm_math.h ****    * There is no risk of internal overflow with this approach and the full precision of intermediat
4938:.\Include/arm_math.h ****    * After all additions have been performed, the accumulator is truncated to 34.15 format by disca
4939:.\Include/arm_math.h ****    * Lastly, the accumulator is saturated to yield a result in 1.15 format.
4940:.\Include/arm_math.h ****    */
4941:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_pid_q15(
4942:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
4943:.\Include/arm_math.h ****   q15_t in)
4944:.\Include/arm_math.h ****   {
4945:.\Include/arm_math.h ****     q63_t acc;
4946:.\Include/arm_math.h ****     q15_t out;
4947:.\Include/arm_math.h **** 
4948:.\Include/arm_math.h **** #if defined (ARM_MATH_DSP)
4949:.\Include/arm_math.h ****     __SIMD32_TYPE *vstate;
4950:.\Include/arm_math.h **** 
4951:.\Include/arm_math.h ****     /* Implementation of PID controller */
4952:.\Include/arm_math.h **** 
4953:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4954:.\Include/arm_math.h ****     acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
4955:.\Include/arm_math.h **** 
4956:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4957:.\Include/arm_math.h ****     vstate = __SIMD32_CONST(S->state);
4958:.\Include/arm_math.h ****     acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
4959:.\Include/arm_math.h **** #else
4960:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4961:.\Include/arm_math.h ****     acc = ((q31_t) S->A0) * in;
4962:.\Include/arm_math.h **** 
4963:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4964:.\Include/arm_math.h ****     acc += (q31_t) S->A1 * S->state[0];
4965:.\Include/arm_math.h ****     acc += (q31_t) S->A2 * S->state[1];
4966:.\Include/arm_math.h **** #endif
4967:.\Include/arm_math.h **** 
4968:.\Include/arm_math.h ****     /* acc += y[n-1] */
4969:.\Include/arm_math.h ****     acc += (q31_t) S->state[2] << 15;
4970:.\Include/arm_math.h **** 
4971:.\Include/arm_math.h ****     /* saturate the output */
4972:.\Include/arm_math.h ****     out = (q15_t) (__SSAT((acc >> 15), 16));
4973:.\Include/arm_math.h **** 
4974:.\Include/arm_math.h ****     /* Update state */
4975:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4976:.\Include/arm_math.h ****     S->state[0] = in;
4977:.\Include/arm_math.h ****     S->state[2] = out;
4978:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 97


4979:.\Include/arm_math.h ****     /* return to application */
4980:.\Include/arm_math.h ****     return (out);
4981:.\Include/arm_math.h ****   }
4982:.\Include/arm_math.h **** 
4983:.\Include/arm_math.h ****   /**
4984:.\Include/arm_math.h ****    * @} end of PID group
4985:.\Include/arm_math.h ****    */
4986:.\Include/arm_math.h **** 
4987:.\Include/arm_math.h **** 
4988:.\Include/arm_math.h ****   /**
4989:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
4990:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4991:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4992:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4993:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4994:.\Include/arm_math.h ****    */
4995:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f32(
4996:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * src,
4997:.\Include/arm_math.h ****   arm_matrix_instance_f32 * dst);
4998:.\Include/arm_math.h **** 
4999:.\Include/arm_math.h **** 
5000:.\Include/arm_math.h ****   /**
5001:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
5002:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
5003:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
5004:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
5005:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
5006:.\Include/arm_math.h ****    */
5007:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f64(
5008:.\Include/arm_math.h ****   const arm_matrix_instance_f64 * src,
5009:.\Include/arm_math.h ****   arm_matrix_instance_f64 * dst);
5010:.\Include/arm_math.h **** 
5011:.\Include/arm_math.h **** 
5012:.\Include/arm_math.h **** 
5013:.\Include/arm_math.h ****   /**
5014:.\Include/arm_math.h ****    * @ingroup groupController
5015:.\Include/arm_math.h ****    */
5016:.\Include/arm_math.h **** 
5017:.\Include/arm_math.h ****   /**
5018:.\Include/arm_math.h ****    * @defgroup clarke Vector Clarke Transform
5019:.\Include/arm_math.h ****    * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time i
5020:.\Include/arm_math.h ****    * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calcula
5021:.\Include/arm_math.h ****    * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
5022:.\Include/arm_math.h ****    * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
5023:.\Include/arm_math.h ****    * \image html clarke.gif Stator current space vector and its components in (a,b).
5024:.\Include/arm_math.h ****    * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code
5025:.\Include/arm_math.h ****    * can be calculated using only <code>Ia</code> and <code>Ib</code>.
5026:.\Include/arm_math.h ****    *
5027:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5028:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5029:.\Include/arm_math.h ****    * \par Algorithm
5030:.\Include/arm_math.h ****    * \image html clarkeFormula.gif
5031:.\Include/arm_math.h ****    * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
5032:.\Include/arm_math.h ****    * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
5033:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5034:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5035:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 98


5036:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5037:.\Include/arm_math.h ****    */
5038:.\Include/arm_math.h **** 
5039:.\Include/arm_math.h ****   /**
5040:.\Include/arm_math.h ****    * @addtogroup clarke
5041:.\Include/arm_math.h ****    * @{
5042:.\Include/arm_math.h ****    */
5043:.\Include/arm_math.h **** 
5044:.\Include/arm_math.h ****   /**
5045:.\Include/arm_math.h ****    *
5046:.\Include/arm_math.h ****    * @brief  Floating-point Clarke transform
5047:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5048:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5049:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5050:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5051:.\Include/arm_math.h ****    */
5052:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_f32(
5053:.\Include/arm_math.h ****   float32_t Ia,
5054:.\Include/arm_math.h ****   float32_t Ib,
5055:.\Include/arm_math.h ****   float32_t * pIalpha,
5056:.\Include/arm_math.h ****   float32_t * pIbeta)
5057:.\Include/arm_math.h ****   {
5058:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Ia */
5059:.\Include/arm_math.h ****     *pIalpha = Ia;
5060:.\Include/arm_math.h **** 
5061:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
5062:.\Include/arm_math.h ****     *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
5063:.\Include/arm_math.h ****   }
5064:.\Include/arm_math.h **** 
5065:.\Include/arm_math.h **** 
5066:.\Include/arm_math.h ****   /**
5067:.\Include/arm_math.h ****    * @brief  Clarke transform for Q31 version
5068:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5069:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5070:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5071:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5072:.\Include/arm_math.h ****    *
5073:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5074:.\Include/arm_math.h ****    * \par
5075:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5076:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5077:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5078:.\Include/arm_math.h ****    */
5079:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_q31(
5080:.\Include/arm_math.h ****   q31_t Ia,
5081:.\Include/arm_math.h ****   q31_t Ib,
5082:.\Include/arm_math.h ****   q31_t * pIalpha,
5083:.\Include/arm_math.h ****   q31_t * pIbeta)
5084:.\Include/arm_math.h ****   {
5085:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5086:.\Include/arm_math.h **** 
5087:.\Include/arm_math.h ****     /* Calculating pIalpha from Ia by equation pIalpha = Ia */
5088:.\Include/arm_math.h ****     *pIalpha = Ia;
5089:.\Include/arm_math.h **** 
5090:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
5091:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
5092:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 99


5093:.\Include/arm_math.h ****     /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
5094:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
5095:.\Include/arm_math.h **** 
5096:.\Include/arm_math.h ****     /* pIbeta is calculated by adding the intermediate products */
5097:.\Include/arm_math.h ****     *pIbeta = __QADD(product1, product2);
5098:.\Include/arm_math.h ****   }
5099:.\Include/arm_math.h **** 
5100:.\Include/arm_math.h ****   /**
5101:.\Include/arm_math.h ****    * @} end of clarke group
5102:.\Include/arm_math.h ****    */
5103:.\Include/arm_math.h **** 
5104:.\Include/arm_math.h ****   /**
5105:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q31 vector.
5106:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5107:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5108:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5109:.\Include/arm_math.h ****    */
5110:.\Include/arm_math.h ****   void arm_q7_to_q31(
5111:.\Include/arm_math.h ****   q7_t * pSrc,
5112:.\Include/arm_math.h ****   q31_t * pDst,
5113:.\Include/arm_math.h ****   uint32_t blockSize);
5114:.\Include/arm_math.h **** 
5115:.\Include/arm_math.h **** 
5116:.\Include/arm_math.h **** 
5117:.\Include/arm_math.h ****   /**
5118:.\Include/arm_math.h ****    * @ingroup groupController
5119:.\Include/arm_math.h ****    */
5120:.\Include/arm_math.h **** 
5121:.\Include/arm_math.h ****   /**
5122:.\Include/arm_math.h ****    * @defgroup inv_clarke Vector Inverse Clarke Transform
5123:.\Include/arm_math.h ****    * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous 
5124:.\Include/arm_math.h ****    *
5125:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5126:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5127:.\Include/arm_math.h ****    * \par Algorithm
5128:.\Include/arm_math.h ****    * \image html clarkeInvFormula.gif
5129:.\Include/arm_math.h ****    * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
5130:.\Include/arm_math.h ****    * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
5131:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5132:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5133:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5134:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5135:.\Include/arm_math.h ****    */
5136:.\Include/arm_math.h **** 
5137:.\Include/arm_math.h ****   /**
5138:.\Include/arm_math.h ****    * @addtogroup inv_clarke
5139:.\Include/arm_math.h ****    * @{
5140:.\Include/arm_math.h ****    */
5141:.\Include/arm_math.h **** 
5142:.\Include/arm_math.h ****    /**
5143:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Clarke transform
5144:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5145:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5146:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5147:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5148:.\Include/arm_math.h ****    */
5149:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 100


5150:.\Include/arm_math.h ****   float32_t Ialpha,
5151:.\Include/arm_math.h ****   float32_t Ibeta,
5152:.\Include/arm_math.h ****   float32_t * pIa,
5153:.\Include/arm_math.h ****   float32_t * pIb)
5154:.\Include/arm_math.h ****   {
5155:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5156:.\Include/arm_math.h ****     *pIa = Ialpha;
5157:.\Include/arm_math.h **** 
5158:.\Include/arm_math.h ****     /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibet
5159:.\Include/arm_math.h ****     *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
5160:.\Include/arm_math.h ****   }
5161:.\Include/arm_math.h **** 
5162:.\Include/arm_math.h **** 
5163:.\Include/arm_math.h ****   /**
5164:.\Include/arm_math.h ****    * @brief  Inverse Clarke transform for Q31 version
5165:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5166:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5167:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5168:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5169:.\Include/arm_math.h ****    *
5170:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5171:.\Include/arm_math.h ****    * \par
5172:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5173:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5174:.\Include/arm_math.h ****    * There is saturation on the subtraction, hence there is no risk of overflow.
5175:.\Include/arm_math.h ****    */
5176:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_q31(
5177:.\Include/arm_math.h ****   q31_t Ialpha,
5178:.\Include/arm_math.h ****   q31_t Ibeta,
5179:.\Include/arm_math.h ****   q31_t * pIa,
5180:.\Include/arm_math.h ****   q31_t * pIb)
5181:.\Include/arm_math.h ****   {
5182:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5183:.\Include/arm_math.h **** 
5184:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5185:.\Include/arm_math.h ****     *pIa = Ialpha;
5186:.\Include/arm_math.h **** 
5187:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
5188:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
5189:.\Include/arm_math.h **** 
5190:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
5191:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
5192:.\Include/arm_math.h **** 
5193:.\Include/arm_math.h ****     /* pIb is calculated by subtracting the products */
5194:.\Include/arm_math.h ****     *pIb = __QSUB(product2, product1);
5195:.\Include/arm_math.h ****   }
5196:.\Include/arm_math.h **** 
5197:.\Include/arm_math.h ****   /**
5198:.\Include/arm_math.h ****    * @} end of inv_clarke group
5199:.\Include/arm_math.h ****    */
5200:.\Include/arm_math.h **** 
5201:.\Include/arm_math.h ****   /**
5202:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q15 vector.
5203:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5204:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5205:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5206:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 101


5207:.\Include/arm_math.h ****   void arm_q7_to_q15(
5208:.\Include/arm_math.h ****   q7_t * pSrc,
5209:.\Include/arm_math.h ****   q15_t * pDst,
5210:.\Include/arm_math.h ****   uint32_t blockSize);
5211:.\Include/arm_math.h **** 
5212:.\Include/arm_math.h **** 
5213:.\Include/arm_math.h **** 
5214:.\Include/arm_math.h ****   /**
5215:.\Include/arm_math.h ****    * @ingroup groupController
5216:.\Include/arm_math.h ****    */
5217:.\Include/arm_math.h **** 
5218:.\Include/arm_math.h ****   /**
5219:.\Include/arm_math.h ****    * @defgroup park Vector Park Transform
5220:.\Include/arm_math.h ****    *
5221:.\Include/arm_math.h ****    * Forward Park transform converts the input two-coordinate vector to flux and torque components.
5222:.\Include/arm_math.h ****    * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and th
5223:.\Include/arm_math.h ****    * from the stationary to the moving reference frame and control the spatial relationship between
5224:.\Include/arm_math.h ****    * the stator vector current and rotor flux vector.
5225:.\Include/arm_math.h ****    * If we consider the d axis aligned with the rotor flux, the diagram below shows the
5226:.\Include/arm_math.h ****    * current vector and the relationship from the two reference frames:
5227:.\Include/arm_math.h ****    * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q ro
5228:.\Include/arm_math.h ****    *
5229:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5230:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5231:.\Include/arm_math.h ****    * \par Algorithm
5232:.\Include/arm_math.h ****    * \image html parkFormula.gif
5233:.\Include/arm_math.h ****    * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
5234:.\Include/arm_math.h ****    * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and 
5235:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5236:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5237:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5238:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5239:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5240:.\Include/arm_math.h ****    */
5241:.\Include/arm_math.h **** 
5242:.\Include/arm_math.h ****   /**
5243:.\Include/arm_math.h ****    * @addtogroup park
5244:.\Include/arm_math.h ****    * @{
5245:.\Include/arm_math.h ****    */
5246:.\Include/arm_math.h **** 
5247:.\Include/arm_math.h ****   /**
5248:.\Include/arm_math.h ****    * @brief Floating-point Park transform
5249:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5250:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5251:.\Include/arm_math.h ****    * @param[out] pId     points to output   rotor reference frame d
5252:.\Include/arm_math.h ****    * @param[out] pIq     points to output   rotor reference frame q
5253:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5254:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5255:.\Include/arm_math.h ****    *
5256:.\Include/arm_math.h ****    * The function implements the forward Park transform.
5257:.\Include/arm_math.h ****    *
5258:.\Include/arm_math.h ****    */
5259:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_f32(
5260:.\Include/arm_math.h ****   float32_t Ialpha,
5261:.\Include/arm_math.h ****   float32_t Ibeta,
5262:.\Include/arm_math.h ****   float32_t * pId,
5263:.\Include/arm_math.h ****   float32_t * pIq,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 102


5264:.\Include/arm_math.h ****   float32_t sinVal,
5265:.\Include/arm_math.h ****   float32_t cosVal)
5266:.\Include/arm_math.h ****   {
5267:.\Include/arm_math.h ****     /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
5268:.\Include/arm_math.h ****     *pId = Ialpha * cosVal + Ibeta * sinVal;
5269:.\Include/arm_math.h **** 
5270:.\Include/arm_math.h ****     /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
5271:.\Include/arm_math.h ****     *pIq = -Ialpha * sinVal + Ibeta * cosVal;
5272:.\Include/arm_math.h ****   }
5273:.\Include/arm_math.h **** 
5274:.\Include/arm_math.h **** 
5275:.\Include/arm_math.h ****   /**
5276:.\Include/arm_math.h ****    * @brief  Park transform for Q31 version
5277:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5278:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5279:.\Include/arm_math.h ****    * @param[out] pId     points to output rotor reference frame d
5280:.\Include/arm_math.h ****    * @param[out] pIq     points to output rotor reference frame q
5281:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5282:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5283:.\Include/arm_math.h ****    *
5284:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5285:.\Include/arm_math.h ****    * \par
5286:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5287:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5288:.\Include/arm_math.h ****    * There is saturation on the addition and subtraction, hence there is no risk of overflow.
5289:.\Include/arm_math.h ****    */
5290:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_q31(
5291:.\Include/arm_math.h ****   q31_t Ialpha,
5292:.\Include/arm_math.h ****   q31_t Ibeta,
5293:.\Include/arm_math.h ****   q31_t * pId,
5294:.\Include/arm_math.h ****   q31_t * pIq,
5295:.\Include/arm_math.h ****   q31_t sinVal,
5296:.\Include/arm_math.h ****   q31_t cosVal)
5297:.\Include/arm_math.h ****   {
5298:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5299:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5300:.\Include/arm_math.h **** 
5301:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * cosVal) */
5302:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
5303:.\Include/arm_math.h **** 
5304:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * sinVal) */
5305:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
5306:.\Include/arm_math.h **** 
5307:.\Include/arm_math.h **** 
5308:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * sinVal) */
5309:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
5310:.\Include/arm_math.h **** 
5311:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * cosVal) */
5312:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
5313:.\Include/arm_math.h **** 
5314:.\Include/arm_math.h ****     /* Calculate pId by adding the two intermediate products 1 and 2 */
5315:.\Include/arm_math.h ****     *pId = __QADD(product1, product2);
5316:.\Include/arm_math.h **** 
5317:.\Include/arm_math.h ****     /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
5318:.\Include/arm_math.h ****     *pIq = __QSUB(product4, product3);
5319:.\Include/arm_math.h ****   }
5320:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 103


5321:.\Include/arm_math.h ****   /**
5322:.\Include/arm_math.h ****    * @} end of park group
5323:.\Include/arm_math.h ****    */
5324:.\Include/arm_math.h **** 
5325:.\Include/arm_math.h ****   /**
5326:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to floating-point vector.
5327:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5328:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5329:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5330:.\Include/arm_math.h ****    */
5331:.\Include/arm_math.h ****   void arm_q7_to_float(
5332:.\Include/arm_math.h ****   q7_t * pSrc,
5333:.\Include/arm_math.h ****   float32_t * pDst,
5334:.\Include/arm_math.h ****   uint32_t blockSize);
5335:.\Include/arm_math.h **** 
5336:.\Include/arm_math.h **** 
5337:.\Include/arm_math.h ****   /**
5338:.\Include/arm_math.h ****    * @ingroup groupController
5339:.\Include/arm_math.h ****    */
5340:.\Include/arm_math.h **** 
5341:.\Include/arm_math.h ****   /**
5342:.\Include/arm_math.h ****    * @defgroup inv_park Vector Inverse Park transform
5343:.\Include/arm_math.h ****    * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
5344:.\Include/arm_math.h ****    *
5345:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5346:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5347:.\Include/arm_math.h ****    * \par Algorithm
5348:.\Include/arm_math.h ****    * \image html parkInvFormula.gif
5349:.\Include/arm_math.h ****    * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
5350:.\Include/arm_math.h ****    * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <c
5351:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5352:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5353:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5354:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5355:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5356:.\Include/arm_math.h ****    */
5357:.\Include/arm_math.h **** 
5358:.\Include/arm_math.h ****   /**
5359:.\Include/arm_math.h ****    * @addtogroup inv_park
5360:.\Include/arm_math.h ****    * @{
5361:.\Include/arm_math.h ****    */
5362:.\Include/arm_math.h **** 
5363:.\Include/arm_math.h ****    /**
5364:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Park transform
5365:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5366:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5367:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5368:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5369:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5370:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5371:.\Include/arm_math.h ****    */
5372:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_f32(
5373:.\Include/arm_math.h ****   float32_t Id,
5374:.\Include/arm_math.h ****   float32_t Iq,
5375:.\Include/arm_math.h ****   float32_t * pIalpha,
5376:.\Include/arm_math.h ****   float32_t * pIbeta,
5377:.\Include/arm_math.h ****   float32_t sinVal,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 104


5378:.\Include/arm_math.h ****   float32_t cosVal)
5379:.\Include/arm_math.h ****   {
5380:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
5381:.\Include/arm_math.h ****     *pIalpha = Id * cosVal - Iq * sinVal;
5382:.\Include/arm_math.h **** 
5383:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
5384:.\Include/arm_math.h ****     *pIbeta = Id * sinVal + Iq * cosVal;
5385:.\Include/arm_math.h ****   }
5386:.\Include/arm_math.h **** 
5387:.\Include/arm_math.h **** 
5388:.\Include/arm_math.h ****   /**
5389:.\Include/arm_math.h ****    * @brief  Inverse Park transform for   Q31 version
5390:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5391:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5392:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5393:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5394:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5395:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5396:.\Include/arm_math.h ****    *
5397:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5398:.\Include/arm_math.h ****    * \par
5399:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5400:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5401:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5402:.\Include/arm_math.h ****    */
5403:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_q31(
5404:.\Include/arm_math.h ****   q31_t Id,
5405:.\Include/arm_math.h ****   q31_t Iq,
5406:.\Include/arm_math.h ****   q31_t * pIalpha,
5407:.\Include/arm_math.h ****   q31_t * pIbeta,
5408:.\Include/arm_math.h ****   q31_t sinVal,
5409:.\Include/arm_math.h ****   q31_t cosVal)
5410:.\Include/arm_math.h ****   {
5411:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5412:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5413:.\Include/arm_math.h **** 
5414:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * cosVal) */
5415:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
5416:.\Include/arm_math.h **** 
5417:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * sinVal) */
5418:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
5419:.\Include/arm_math.h **** 
5420:.\Include/arm_math.h **** 
5421:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * sinVal) */
5422:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
5423:.\Include/arm_math.h **** 
5424:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * cosVal) */
5425:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
5426:.\Include/arm_math.h **** 
5427:.\Include/arm_math.h ****     /* Calculate pIalpha by using the two intermediate products 1 and 2 */
5428:.\Include/arm_math.h ****     *pIalpha = __QSUB(product1, product2);
5429:.\Include/arm_math.h **** 
5430:.\Include/arm_math.h ****     /* Calculate pIbeta by using the two intermediate products 3 and 4 */
5431:.\Include/arm_math.h ****     *pIbeta = __QADD(product4, product3);
5432:.\Include/arm_math.h ****   }
5433:.\Include/arm_math.h **** 
5434:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 105


5435:.\Include/arm_math.h ****    * @} end of Inverse park group
5436:.\Include/arm_math.h ****    */
5437:.\Include/arm_math.h **** 
5438:.\Include/arm_math.h **** 
5439:.\Include/arm_math.h ****   /**
5440:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q31 vector to floating-point vector.
5441:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5442:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5443:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5444:.\Include/arm_math.h ****    */
5445:.\Include/arm_math.h ****   void arm_q31_to_float(
5446:.\Include/arm_math.h ****   q31_t * pSrc,
5447:.\Include/arm_math.h ****   float32_t * pDst,
5448:.\Include/arm_math.h ****   uint32_t blockSize);
5449:.\Include/arm_math.h **** 
5450:.\Include/arm_math.h ****   /**
5451:.\Include/arm_math.h ****    * @ingroup groupInterpolation
5452:.\Include/arm_math.h ****    */
5453:.\Include/arm_math.h **** 
5454:.\Include/arm_math.h ****   /**
5455:.\Include/arm_math.h ****    * @defgroup LinearInterpolate Linear Interpolation
5456:.\Include/arm_math.h ****    *
5457:.\Include/arm_math.h ****    * Linear interpolation is a method of curve fitting using linear polynomials.
5458:.\Include/arm_math.h ****    * Linear interpolation works by effectively drawing a straight line between two neighboring samp
5459:.\Include/arm_math.h ****    *
5460:.\Include/arm_math.h ****    * \par
5461:.\Include/arm_math.h ****    * \image html LinearInterp.gif "Linear interpolation"
5462:.\Include/arm_math.h ****    *
5463:.\Include/arm_math.h ****    * \par
5464:.\Include/arm_math.h ****    * A  Linear Interpolate function calculates an output value(y), for the input(x)
5465:.\Include/arm_math.h ****    * using linear interpolation of the input values x0, x1( nearest input values) and the output va
5466:.\Include/arm_math.h ****    *
5467:.\Include/arm_math.h ****    * \par Algorithm:
5468:.\Include/arm_math.h ****    * <pre>
5469:.\Include/arm_math.h ****    *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
5470:.\Include/arm_math.h ****    *       where x0, x1 are nearest values of input x
5471:.\Include/arm_math.h ****    *             y0, y1 are nearest values to output y
5472:.\Include/arm_math.h ****    * </pre>
5473:.\Include/arm_math.h ****    *
5474:.\Include/arm_math.h ****    * \par
5475:.\Include/arm_math.h ****    * This set of functions implements Linear interpolation process
5476:.\Include/arm_math.h ****    * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
5477:.\Include/arm_math.h ****    * sample of data and each call to the function returns a single processed value.
5478:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the Linear Interpolate function data structure.
5479:.\Include/arm_math.h ****    * <code>x</code> is the input sample value. The functions returns the output value.
5480:.\Include/arm_math.h ****    *
5481:.\Include/arm_math.h ****    * \par
5482:.\Include/arm_math.h ****    * if x is outside of the table boundary, Linear interpolation returns first value of the table
5483:.\Include/arm_math.h ****    * if x is below input range and returns last value of table if x is above range.
5484:.\Include/arm_math.h ****    */
5485:.\Include/arm_math.h **** 
5486:.\Include/arm_math.h ****   /**
5487:.\Include/arm_math.h ****    * @addtogroup LinearInterpolate
5488:.\Include/arm_math.h ****    * @{
5489:.\Include/arm_math.h ****    */
5490:.\Include/arm_math.h **** 
5491:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 106


5492:.\Include/arm_math.h ****    * @brief  Process function for the floating-point Linear Interpolation Function.
5493:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
5494:.\Include/arm_math.h ****    * @param[in]     x  input sample to process
5495:.\Include/arm_math.h ****    * @return y processed output sample.
5496:.\Include/arm_math.h ****    *
5497:.\Include/arm_math.h ****    */
5498:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_linear_interp_f32(
5499:.\Include/arm_math.h ****   arm_linear_interp_instance_f32 * S,
5500:.\Include/arm_math.h ****   float32_t x)
5501:.\Include/arm_math.h ****   {
5502:.\Include/arm_math.h ****     float32_t y;
5503:.\Include/arm_math.h ****     float32_t x0, x1;                            /* Nearest input values */
5504:.\Include/arm_math.h ****     float32_t y0, y1;                            /* Nearest output values */
5505:.\Include/arm_math.h ****     float32_t xSpacing = S->xSpacing;            /* spacing between input values */
5506:.\Include/arm_math.h ****     int32_t i;                                   /* Index variable */
5507:.\Include/arm_math.h ****     float32_t *pYData = S->pYData;               /* pointer to output table */
5508:.\Include/arm_math.h **** 
5509:.\Include/arm_math.h ****     /* Calculation of index */
5510:.\Include/arm_math.h ****     i = (int32_t) ((x - S->x1) / xSpacing);
5511:.\Include/arm_math.h **** 
5512:.\Include/arm_math.h ****     if (i < 0)
5513:.\Include/arm_math.h ****     {
5514:.\Include/arm_math.h ****       /* Iniatilize output for below specified range as least output value of table */
5515:.\Include/arm_math.h ****       y = pYData[0];
5516:.\Include/arm_math.h ****     }
5517:.\Include/arm_math.h ****     else if ((uint32_t)i >= S->nValues)
5518:.\Include/arm_math.h ****     {
5519:.\Include/arm_math.h ****       /* Iniatilize output for above specified range as last output value of table */
5520:.\Include/arm_math.h ****       y = pYData[S->nValues - 1];
5521:.\Include/arm_math.h ****     }
5522:.\Include/arm_math.h ****     else
5523:.\Include/arm_math.h ****     {
5524:.\Include/arm_math.h ****       /* Calculation of nearest input values */
5525:.\Include/arm_math.h ****       x0 = S->x1 +  i      * xSpacing;
5526:.\Include/arm_math.h ****       x1 = S->x1 + (i + 1) * xSpacing;
5527:.\Include/arm_math.h **** 
5528:.\Include/arm_math.h ****       /* Read of nearest output values */
5529:.\Include/arm_math.h ****       y0 = pYData[i];
5530:.\Include/arm_math.h ****       y1 = pYData[i + 1];
5531:.\Include/arm_math.h **** 
5532:.\Include/arm_math.h ****       /* Calculation of output */
5533:.\Include/arm_math.h ****       y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
5534:.\Include/arm_math.h **** 
5535:.\Include/arm_math.h ****     }
5536:.\Include/arm_math.h **** 
5537:.\Include/arm_math.h ****     /* returns output value */
5538:.\Include/arm_math.h ****     return (y);
5539:.\Include/arm_math.h ****   }
5540:.\Include/arm_math.h **** 
5541:.\Include/arm_math.h **** 
5542:.\Include/arm_math.h ****    /**
5543:.\Include/arm_math.h ****    *
5544:.\Include/arm_math.h ****    * @brief  Process function for the Q31 Linear Interpolation Function.
5545:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q31 Linear Interpolation table
5546:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5547:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5548:.\Include/arm_math.h ****    * @return y processed output sample.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 107


5549:.\Include/arm_math.h ****    *
5550:.\Include/arm_math.h ****    * \par
5551:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5552:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5553:.\Include/arm_math.h ****    *
5554:.\Include/arm_math.h ****    */
5555:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_linear_interp_q31(
5556:.\Include/arm_math.h ****   q31_t * pYData,
5557:.\Include/arm_math.h ****   q31_t x,
5558:.\Include/arm_math.h ****   uint32_t nValues)
5559:.\Include/arm_math.h ****   {
5560:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5561:.\Include/arm_math.h ****     q31_t y0, y1;                                /* Nearest output values */
5562:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5563:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5564:.\Include/arm_math.h **** 
5565:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5566:.\Include/arm_math.h ****     /* 12 bits for the table index */
5567:.\Include/arm_math.h ****     /* Index value calculation */
5568:.\Include/arm_math.h ****     index = ((x & (q31_t)0xFFF00000) >> 20);
5569:.\Include/arm_math.h **** 
5570:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5571:.\Include/arm_math.h ****     {
5572:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5573:.\Include/arm_math.h ****     }
5574:.\Include/arm_math.h ****     else if (index < 0)
5575:.\Include/arm_math.h ****     {
5576:.\Include/arm_math.h ****       return (pYData[0]);
5577:.\Include/arm_math.h ****     }
5578:.\Include/arm_math.h ****     else
5579:.\Include/arm_math.h ****     {
5580:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5581:.\Include/arm_math.h ****       /* shift left by 11 to keep fract in 1.31 format */
5582:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF) << 11;
5583:.\Include/arm_math.h **** 
5584:.\Include/arm_math.h ****       /* Read two nearest output values from the index in 1.31(q31) format */
5585:.\Include/arm_math.h ****       y0 = pYData[index];
5586:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5587:.\Include/arm_math.h **** 
5588:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 2.30 format */
5589:.\Include/arm_math.h ****       y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
5590:.\Include/arm_math.h **** 
5591:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
5592:.\Include/arm_math.h ****       y += ((q31_t) (((q63_t) y1 * fract) >> 32));
5593:.\Include/arm_math.h **** 
5594:.\Include/arm_math.h ****       /* Convert y to 1.31 format */
5595:.\Include/arm_math.h ****       return (y << 1u);
5596:.\Include/arm_math.h ****     }
5597:.\Include/arm_math.h ****   }
5598:.\Include/arm_math.h **** 
5599:.\Include/arm_math.h **** 
5600:.\Include/arm_math.h ****   /**
5601:.\Include/arm_math.h ****    *
5602:.\Include/arm_math.h ****    * @brief  Process function for the Q15 Linear Interpolation Function.
5603:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q15 Linear Interpolation table
5604:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5605:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 108


5606:.\Include/arm_math.h ****    * @return y processed output sample.
5607:.\Include/arm_math.h ****    *
5608:.\Include/arm_math.h ****    * \par
5609:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5610:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5611:.\Include/arm_math.h ****    *
5612:.\Include/arm_math.h ****    */
5613:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_linear_interp_q15(
5614:.\Include/arm_math.h ****   q15_t * pYData,
5615:.\Include/arm_math.h ****   q31_t x,
5616:.\Include/arm_math.h ****   uint32_t nValues)
5617:.\Include/arm_math.h ****   {
5618:.\Include/arm_math.h ****     q63_t y;                                     /* output */
5619:.\Include/arm_math.h ****     q15_t y0, y1;                                /* Nearest output values */
5620:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5621:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5622:.\Include/arm_math.h **** 
5623:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5624:.\Include/arm_math.h ****     /* 12 bits for the table index */
5625:.\Include/arm_math.h ****     /* Index value calculation */
5626:.\Include/arm_math.h ****     index = ((x & (int32_t)0xFFF00000) >> 20);
5627:.\Include/arm_math.h **** 
5628:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5629:.\Include/arm_math.h ****     {
5630:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5631:.\Include/arm_math.h ****     }
5632:.\Include/arm_math.h ****     else if (index < 0)
5633:.\Include/arm_math.h ****     {
5634:.\Include/arm_math.h ****       return (pYData[0]);
5635:.\Include/arm_math.h ****     }
5636:.\Include/arm_math.h ****     else
5637:.\Include/arm_math.h ****     {
5638:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5639:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5640:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5641:.\Include/arm_math.h **** 
5642:.\Include/arm_math.h ****       /* Read two nearest output values from the index */
5643:.\Include/arm_math.h ****       y0 = pYData[index];
5644:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5645:.\Include/arm_math.h **** 
5646:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 13.35 format */
5647:.\Include/arm_math.h ****       y = ((q63_t) y0 * (0xFFFFF - fract));
5648:.\Include/arm_math.h **** 
5649:.\Include/arm_math.h ****       /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
5650:.\Include/arm_math.h ****       y += ((q63_t) y1 * (fract));
5651:.\Include/arm_math.h **** 
5652:.\Include/arm_math.h ****       /* convert y to 1.15 format */
5653:.\Include/arm_math.h ****       return (q15_t) (y >> 20);
5654:.\Include/arm_math.h ****     }
5655:.\Include/arm_math.h ****   }
5656:.\Include/arm_math.h **** 
5657:.\Include/arm_math.h **** 
5658:.\Include/arm_math.h ****   /**
5659:.\Include/arm_math.h ****    *
5660:.\Include/arm_math.h ****    * @brief  Process function for the Q7 Linear Interpolation Function.
5661:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q7 Linear Interpolation table
5662:.\Include/arm_math.h ****    * @param[in] x        input sample to process
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 109


5663:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5664:.\Include/arm_math.h ****    * @return y processed output sample.
5665:.\Include/arm_math.h ****    *
5666:.\Include/arm_math.h ****    * \par
5667:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5668:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5669:.\Include/arm_math.h ****    */
5670:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t arm_linear_interp_q7(
5671:.\Include/arm_math.h ****   q7_t * pYData,
5672:.\Include/arm_math.h ****   q31_t x,
5673:.\Include/arm_math.h ****   uint32_t nValues)
5674:.\Include/arm_math.h ****   {
5675:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5676:.\Include/arm_math.h ****     q7_t y0, y1;                                 /* Nearest output values */
5677:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5678:.\Include/arm_math.h ****     uint32_t index;                              /* Index to read nearest output values */
5679:.\Include/arm_math.h **** 
5680:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5681:.\Include/arm_math.h ****     /* 12 bits for the table index */
5682:.\Include/arm_math.h ****     /* Index value calculation */
5683:.\Include/arm_math.h ****     if (x < 0)
5684:.\Include/arm_math.h ****     {
5685:.\Include/arm_math.h ****       return (pYData[0]);
5686:.\Include/arm_math.h ****     }
5687:.\Include/arm_math.h ****     index = (x >> 20) & 0xfff;
5688:.\Include/arm_math.h **** 
5689:.\Include/arm_math.h ****     if (index >= (nValues - 1))
5690:.\Include/arm_math.h ****     {
5691:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5692:.\Include/arm_math.h ****     }
5693:.\Include/arm_math.h ****     else
5694:.\Include/arm_math.h ****     {
5695:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5696:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5697:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5698:.\Include/arm_math.h **** 
5699:.\Include/arm_math.h ****       /* Read two nearest output values from the index and are in 1.7(q7) format */
5700:.\Include/arm_math.h ****       y0 = pYData[index];
5701:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5702:.\Include/arm_math.h **** 
5703:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
5704:.\Include/arm_math.h ****       y = ((y0 * (0xFFFFF - fract)));
5705:.\Include/arm_math.h **** 
5706:.\Include/arm_math.h ****       /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
5707:.\Include/arm_math.h ****       y += (y1 * fract);
5708:.\Include/arm_math.h **** 
5709:.\Include/arm_math.h ****       /* convert y to 1.7(q7) format */
5710:.\Include/arm_math.h ****       return (q7_t) (y >> 20);
5711:.\Include/arm_math.h ****      }
5712:.\Include/arm_math.h ****   }
5713:.\Include/arm_math.h **** 
5714:.\Include/arm_math.h ****   /**
5715:.\Include/arm_math.h ****    * @} end of LinearInterpolate group
5716:.\Include/arm_math.h ****    */
5717:.\Include/arm_math.h **** 
5718:.\Include/arm_math.h ****   /**
5719:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for floating-point data.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 110


5720:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5721:.\Include/arm_math.h ****    * @return  sin(x).
5722:.\Include/arm_math.h ****    */
5723:.\Include/arm_math.h ****   float32_t arm_sin_f32(
5724:.\Include/arm_math.h ****   float32_t x);
5725:.\Include/arm_math.h **** 
5726:.\Include/arm_math.h **** 
5727:.\Include/arm_math.h ****   /**
5728:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q31 data.
5729:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5730:.\Include/arm_math.h ****    * @return  sin(x).
5731:.\Include/arm_math.h ****    */
5732:.\Include/arm_math.h ****   q31_t arm_sin_q31(
5733:.\Include/arm_math.h ****   q31_t x);
5734:.\Include/arm_math.h **** 
5735:.\Include/arm_math.h **** 
5736:.\Include/arm_math.h ****   /**
5737:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q15 data.
5738:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5739:.\Include/arm_math.h ****    * @return  sin(x).
5740:.\Include/arm_math.h ****    */
5741:.\Include/arm_math.h ****   q15_t arm_sin_q15(
5742:.\Include/arm_math.h ****   q15_t x);
5743:.\Include/arm_math.h **** 
5744:.\Include/arm_math.h **** 
5745:.\Include/arm_math.h ****   /**
5746:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
5747:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5748:.\Include/arm_math.h ****    * @return  cos(x).
5749:.\Include/arm_math.h ****    */
5750:.\Include/arm_math.h ****   float32_t arm_cos_f32(
5751:.\Include/arm_math.h ****   float32_t x);
5752:.\Include/arm_math.h **** 
5753:.\Include/arm_math.h **** 
5754:.\Include/arm_math.h ****   /**
5755:.\Include/arm_math.h ****    * @brief Fast approximation to the trigonometric cosine function for Q31 data.
5756:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5757:.\Include/arm_math.h ****    * @return  cos(x).
5758:.\Include/arm_math.h ****    */
5759:.\Include/arm_math.h ****   q31_t arm_cos_q31(
5760:.\Include/arm_math.h ****   q31_t x);
5761:.\Include/arm_math.h **** 
5762:.\Include/arm_math.h **** 
5763:.\Include/arm_math.h ****   /**
5764:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
5765:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5766:.\Include/arm_math.h ****    * @return  cos(x).
5767:.\Include/arm_math.h ****    */
5768:.\Include/arm_math.h ****   q15_t arm_cos_q15(
5769:.\Include/arm_math.h ****   q15_t x);
5770:.\Include/arm_math.h **** 
5771:.\Include/arm_math.h **** 
5772:.\Include/arm_math.h ****   /**
5773:.\Include/arm_math.h ****    * @ingroup groupFastMath
5774:.\Include/arm_math.h ****    */
5775:.\Include/arm_math.h **** 
5776:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 111


5777:.\Include/arm_math.h ****   /**
5778:.\Include/arm_math.h ****    * @defgroup SQRT Square Root
5779:.\Include/arm_math.h ****    *
5780:.\Include/arm_math.h ****    * Computes the square root of a number.
5781:.\Include/arm_math.h ****    * There are separate functions for Q15, Q31, and floating-point data types.
5782:.\Include/arm_math.h ****    * The square root function is computed using the Newton-Raphson algorithm.
5783:.\Include/arm_math.h ****    * This is an iterative algorithm of the form:
5784:.\Include/arm_math.h ****    * <pre>
5785:.\Include/arm_math.h ****    *      x1 = x0 - f(x0)/f'(x0)
5786:.\Include/arm_math.h ****    * </pre>
5787:.\Include/arm_math.h ****    * where <code>x1</code> is the current estimate,
5788:.\Include/arm_math.h ****    * <code>x0</code> is the previous estimate, and
5789:.\Include/arm_math.h ****    * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
5790:.\Include/arm_math.h ****    * For the square root function, the algorithm reduces to:
5791:.\Include/arm_math.h ****    * <pre>
5792:.\Include/arm_math.h ****    *     x0 = in/2                         [initial guess]
5793:.\Include/arm_math.h ****    *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
5794:.\Include/arm_math.h ****    * </pre>
5795:.\Include/arm_math.h ****    */
5796:.\Include/arm_math.h **** 
5797:.\Include/arm_math.h **** 
5798:.\Include/arm_math.h ****   /**
5799:.\Include/arm_math.h ****    * @addtogroup SQRT
5800:.\Include/arm_math.h ****    * @{
5801:.\Include/arm_math.h ****    */
5802:.\Include/arm_math.h **** 
5803:.\Include/arm_math.h ****   /**
5804:.\Include/arm_math.h ****    * @brief  Floating-point square root function.
5805:.\Include/arm_math.h ****    * @param[in]  in    input value.
5806:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5807:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5808:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5809:.\Include/arm_math.h ****    */
5810:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
5811:.\Include/arm_math.h ****   float32_t in,
5812:.\Include/arm_math.h ****   float32_t * pOut)
5813:.\Include/arm_math.h ****   {
5814:.\Include/arm_math.h ****     if (in >= 0.0f)
5815:.\Include/arm_math.h ****     {
5816:.\Include/arm_math.h **** 
5817:.\Include/arm_math.h **** #if   (__FPU_USED == 1) && defined ( __CC_ARM   )
5818:.\Include/arm_math.h ****       *pOut = __sqrtf(in);
5819:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
5820:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5821:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined(__GNUC__)
5822:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5823:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
5824:.\Include/arm_math.h ****       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
5825:.\Include/arm_math.h **** #else
5826:.\Include/arm_math.h ****       *pOut = sqrtf(in);
5827:.\Include/arm_math.h **** #endif
5828:.\Include/arm_math.h **** 
5829:.\Include/arm_math.h ****       return (ARM_MATH_SUCCESS);
5830:.\Include/arm_math.h ****     }
5831:.\Include/arm_math.h ****     else
5832:.\Include/arm_math.h ****     {
5833:.\Include/arm_math.h ****       *pOut = 0.0f;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 112


5834:.\Include/arm_math.h ****       return (ARM_MATH_ARGUMENT_ERROR);
5835:.\Include/arm_math.h ****     }
5836:.\Include/arm_math.h ****   }
5837:.\Include/arm_math.h **** 
5838:.\Include/arm_math.h **** 
5839:.\Include/arm_math.h ****   /**
5840:.\Include/arm_math.h ****    * @brief Q31 square root function.
5841:.\Include/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFF
5842:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5843:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5844:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5845:.\Include/arm_math.h ****    */
5846:.\Include/arm_math.h ****   arm_status arm_sqrt_q31(
5847:.\Include/arm_math.h ****   q31_t in,
5848:.\Include/arm_math.h ****   q31_t * pOut);
5849:.\Include/arm_math.h **** 
5850:.\Include/arm_math.h **** 
5851:.\Include/arm_math.h ****   /**
5852:.\Include/arm_math.h ****    * @brief  Q15 square root function.
5853:.\Include/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
5854:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5855:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5856:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5857:.\Include/arm_math.h ****    */
5858:.\Include/arm_math.h ****   arm_status arm_sqrt_q15(
5859:.\Include/arm_math.h ****   q15_t in,
5860:.\Include/arm_math.h ****   q15_t * pOut);
5861:.\Include/arm_math.h **** 
5862:.\Include/arm_math.h ****   /**
5863:.\Include/arm_math.h ****    * @} end of SQRT group
5864:.\Include/arm_math.h ****    */
5865:.\Include/arm_math.h **** 
5866:.\Include/arm_math.h **** 
5867:.\Include/arm_math.h ****   /**
5868:.\Include/arm_math.h ****    * @brief floating-point Circular write function.
5869:.\Include/arm_math.h ****    */
5870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_f32(
5871:.\Include/arm_math.h ****   int32_t * circBuffer,
5872:.\Include/arm_math.h ****   int32_t L,
5873:.\Include/arm_math.h ****   uint16_t * writeOffset,
5874:.\Include/arm_math.h ****   int32_t bufferInc,
5875:.\Include/arm_math.h ****   const int32_t * src,
5876:.\Include/arm_math.h ****   int32_t srcInc,
5877:.\Include/arm_math.h ****   uint32_t blockSize)
5878:.\Include/arm_math.h ****   {
5879:.\Include/arm_math.h ****     uint32_t i = 0u;
5880:.\Include/arm_math.h ****     int32_t wOffset;
5881:.\Include/arm_math.h **** 
5882:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5883:.\Include/arm_math.h ****      * to the current location where the input samples to be copied */
5884:.\Include/arm_math.h ****     wOffset = *writeOffset;
5885:.\Include/arm_math.h **** 
5886:.\Include/arm_math.h ****     /* Loop over the blockSize */
5887:.\Include/arm_math.h ****     i = blockSize;
5888:.\Include/arm_math.h **** 
5889:.\Include/arm_math.h ****     while (i > 0u)
5890:.\Include/arm_math.h ****     {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 113


5891:.\Include/arm_math.h ****       /* copy the input sample to the circular buffer */
5892:.\Include/arm_math.h ****       circBuffer[wOffset] = *src;
5893:.\Include/arm_math.h **** 
5894:.\Include/arm_math.h ****       /* Update the input pointer */
5895:.\Include/arm_math.h ****       src += srcInc;
5896:.\Include/arm_math.h **** 
5897:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
5898:.\Include/arm_math.h ****       wOffset += bufferInc;
5899:.\Include/arm_math.h ****       if (wOffset >= L)
5900:.\Include/arm_math.h ****         wOffset -= L;
5901:.\Include/arm_math.h **** 
5902:.\Include/arm_math.h ****       /* Decrement the loop counter */
5903:.\Include/arm_math.h ****       i--;
5904:.\Include/arm_math.h ****     }
5905:.\Include/arm_math.h **** 
5906:.\Include/arm_math.h ****     /* Update the index pointer */
5907:.\Include/arm_math.h ****     *writeOffset = (uint16_t)wOffset;
5908:.\Include/arm_math.h ****   }
5909:.\Include/arm_math.h **** 
5910:.\Include/arm_math.h **** 
5911:.\Include/arm_math.h **** 
5912:.\Include/arm_math.h ****   /**
5913:.\Include/arm_math.h ****    * @brief floating-point Circular Read function.
5914:.\Include/arm_math.h ****    */
5915:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularRead_f32(
5916:.\Include/arm_math.h ****   int32_t * circBuffer,
5917:.\Include/arm_math.h ****   int32_t L,
5918:.\Include/arm_math.h ****   int32_t * readOffset,
5919:.\Include/arm_math.h ****   int32_t bufferInc,
5920:.\Include/arm_math.h ****   int32_t * dst,
5921:.\Include/arm_math.h ****   int32_t * dst_base,
5922:.\Include/arm_math.h ****   int32_t dst_length,
5923:.\Include/arm_math.h ****   int32_t dstInc,
5924:.\Include/arm_math.h ****   uint32_t blockSize)
5925:.\Include/arm_math.h ****   {
5926:.\Include/arm_math.h ****     uint32_t i = 0u;
5927:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
5928:.\Include/arm_math.h **** 
5929:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5930:.\Include/arm_math.h ****      * to the current location from where the input samples to be read */
5931:.\Include/arm_math.h ****     rOffset = *readOffset;
5932:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
5933:.\Include/arm_math.h **** 
5934:.\Include/arm_math.h ****     /* Loop over the blockSize */
5935:.\Include/arm_math.h ****     i = blockSize;
5936:.\Include/arm_math.h **** 
5937:.\Include/arm_math.h ****     while (i > 0u)
5938:.\Include/arm_math.h ****     {
5939:.\Include/arm_math.h ****       /* copy the sample from the circular buffer to the destination buffer */
5940:.\Include/arm_math.h ****       *dst = circBuffer[rOffset];
5941:.\Include/arm_math.h **** 
5942:.\Include/arm_math.h ****       /* Update the input pointer */
5943:.\Include/arm_math.h ****       dst += dstInc;
5944:.\Include/arm_math.h **** 
5945:.\Include/arm_math.h ****       if (dst == (int32_t *) dst_end)
5946:.\Include/arm_math.h ****       {
5947:.\Include/arm_math.h ****         dst = dst_base;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 114


5948:.\Include/arm_math.h ****       }
5949:.\Include/arm_math.h **** 
5950:.\Include/arm_math.h ****       /* Circularly update rOffset.  Watch out for positive and negative value  */
5951:.\Include/arm_math.h ****       rOffset += bufferInc;
5952:.\Include/arm_math.h **** 
5953:.\Include/arm_math.h ****       if (rOffset >= L)
5954:.\Include/arm_math.h ****       {
5955:.\Include/arm_math.h ****         rOffset -= L;
5956:.\Include/arm_math.h ****       }
5957:.\Include/arm_math.h **** 
5958:.\Include/arm_math.h ****       /* Decrement the loop counter */
5959:.\Include/arm_math.h ****       i--;
5960:.\Include/arm_math.h ****     }
5961:.\Include/arm_math.h **** 
5962:.\Include/arm_math.h ****     /* Update the index pointer */
5963:.\Include/arm_math.h ****     *readOffset = rOffset;
5964:.\Include/arm_math.h ****   }
5965:.\Include/arm_math.h **** 
5966:.\Include/arm_math.h **** 
5967:.\Include/arm_math.h ****   /**
5968:.\Include/arm_math.h ****    * @brief Q15 Circular write function.
5969:.\Include/arm_math.h ****    */
5970:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_q15(
5971:.\Include/arm_math.h ****   q15_t * circBuffer,
5972:.\Include/arm_math.h ****   int32_t L,
5973:.\Include/arm_math.h ****   uint16_t * writeOffset,
5974:.\Include/arm_math.h ****   int32_t bufferInc,
5975:.\Include/arm_math.h ****   const q15_t * src,
5976:.\Include/arm_math.h ****   int32_t srcInc,
5977:.\Include/arm_math.h ****   uint32_t blockSize)
5978:.\Include/arm_math.h ****   {
5979:.\Include/arm_math.h ****     uint32_t i = 0u;
 165              		.loc 2 5979 0
 166 00ea 0023     		mov	r3, #0
 167 00ec C022     		mov	r2, #192
 168 00ee BA18     		add	r2, r7, r2
 169 00f0 1360     		str	r3, [r2]
5980:.\Include/arm_math.h ****     int32_t wOffset;
5981:.\Include/arm_math.h **** 
5982:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5983:.\Include/arm_math.h ****      * to the current location where the input samples to be copied */
5984:.\Include/arm_math.h ****     wOffset = *writeOffset;
 170              		.loc 2 5984 0
 171 00f2 D423     		mov	r3, #212
 172 00f4 FB18     		add	r3, r7, r3
 173 00f6 1B68     		ldr	r3, [r3]
 174 00f8 1B88     		ldrh	r3, [r3]
 175 00fa BC22     		mov	r2, #188
 176 00fc BA18     		add	r2, r7, r2
 177 00fe 1360     		str	r3, [r2]
5985:.\Include/arm_math.h **** 
5986:.\Include/arm_math.h ****     /* Loop over the blockSize */
5987:.\Include/arm_math.h ****     i = blockSize;
 178              		.loc 2 5987 0
 179 0100 C423     		mov	r3, #196
 180 0102 FB18     		add	r3, r7, r3
 181 0104 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 115


 182 0106 C022     		mov	r2, #192
 183 0108 BA18     		add	r2, r7, r2
 184 010a 1360     		str	r3, [r2]
 185 010c 3AE0     		b	.L2
 186              	.L4:
5988:.\Include/arm_math.h **** 
5989:.\Include/arm_math.h ****     while (i > 0u)
5990:.\Include/arm_math.h ****     {
5991:.\Include/arm_math.h ****       /* copy the input sample to the circular buffer */
5992:.\Include/arm_math.h ****       circBuffer[wOffset] = *src;
 187              		.loc 2 5992 0
 188 010e BC23     		mov	r3, #188
 189 0110 FB18     		add	r3, r7, r3
 190 0112 1B68     		ldr	r3, [r3]
 191 0114 5B00     		lsl	r3, r3, #1
 192 0116 DC22     		mov	r2, #220
 193 0118 BA18     		add	r2, r7, r2
 194 011a 1268     		ldr	r2, [r2]
 195 011c D318     		add	r3, r2, r3
 196 011e CC22     		mov	r2, #204
 197 0120 BA18     		add	r2, r7, r2
 198 0122 1268     		ldr	r2, [r2]
 199 0124 1288     		ldrh	r2, [r2]
 200 0126 1A80     		strh	r2, [r3]
5993:.\Include/arm_math.h **** 
5994:.\Include/arm_math.h ****       /* Update the input pointer */
5995:.\Include/arm_math.h ****       src += srcInc;
 201              		.loc 2 5995 0
 202 0128 C823     		mov	r3, #200
 203 012a FB18     		add	r3, r7, r3
 204 012c 1B68     		ldr	r3, [r3]
 205 012e 5B00     		lsl	r3, r3, #1
 206 0130 CC22     		mov	r2, #204
 207 0132 BA18     		add	r2, r7, r2
 208 0134 1268     		ldr	r2, [r2]
 209 0136 D318     		add	r3, r2, r3
 210 0138 CC22     		mov	r2, #204
 211 013a BA18     		add	r2, r7, r2
 212 013c 1360     		str	r3, [r2]
5996:.\Include/arm_math.h **** 
5997:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
5998:.\Include/arm_math.h ****       wOffset += bufferInc;
 213              		.loc 2 5998 0
 214 013e BC23     		mov	r3, #188
 215 0140 FB18     		add	r3, r7, r3
 216 0142 1A68     		ldr	r2, [r3]
 217 0144 D023     		mov	r3, #208
 218 0146 FB18     		add	r3, r7, r3
 219 0148 1B68     		ldr	r3, [r3]
 220 014a D318     		add	r3, r2, r3
 221 014c BC22     		mov	r2, #188
 222 014e BA18     		add	r2, r7, r2
 223 0150 1360     		str	r3, [r2]
5999:.\Include/arm_math.h ****       if (wOffset >= L)
 224              		.loc 2 5999 0
 225 0152 D823     		mov	r3, #216
 226 0154 FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 116


 227 0156 1A68     		ldr	r2, [r3]
 228 0158 BC23     		mov	r3, #188
 229 015a FB18     		add	r3, r7, r3
 230 015c 1B68     		ldr	r3, [r3]
 231 015e 9A42     		cmp	r2, r3
 232 0160 09DC     		bgt	.L3
6000:.\Include/arm_math.h ****         wOffset -= L;
 233              		.loc 2 6000 0
 234 0162 BC23     		mov	r3, #188
 235 0164 FB18     		add	r3, r7, r3
 236 0166 1A68     		ldr	r2, [r3]
 237 0168 D823     		mov	r3, #216
 238 016a FB18     		add	r3, r7, r3
 239 016c 1B68     		ldr	r3, [r3]
 240 016e D31A     		sub	r3, r2, r3
 241 0170 BC22     		mov	r2, #188
 242 0172 BA18     		add	r2, r7, r2
 243 0174 1360     		str	r3, [r2]
 244              	.L3:
6001:.\Include/arm_math.h **** 
6002:.\Include/arm_math.h ****       /* Decrement the loop counter */
6003:.\Include/arm_math.h ****       i--;
 245              		.loc 2 6003 0
 246 0176 C023     		mov	r3, #192
 247 0178 FB18     		add	r3, r7, r3
 248 017a 1B68     		ldr	r3, [r3]
 249 017c 013B     		sub	r3, r3, #1
 250 017e C022     		mov	r2, #192
 251 0180 BA18     		add	r2, r7, r2
 252 0182 1360     		str	r3, [r2]
 253              	.L2:
5989:.\Include/arm_math.h ****     {
 254              		.loc 2 5989 0
 255 0184 C023     		mov	r3, #192
 256 0186 FB18     		add	r3, r7, r3
 257 0188 1B68     		ldr	r3, [r3]
 258 018a 002B     		cmp	r3, #0
 259 018c BFD1     		bne	.L4
6004:.\Include/arm_math.h ****     }
6005:.\Include/arm_math.h **** 
6006:.\Include/arm_math.h ****     /* Update the index pointer */
6007:.\Include/arm_math.h ****     *writeOffset = (uint16_t)wOffset;
 260              		.loc 2 6007 0
 261 018e BC23     		mov	r3, #188
 262 0190 FB18     		add	r3, r7, r3
 263 0192 1B68     		ldr	r3, [r3]
 264 0194 9AB2     		uxth	r2, r3
 265 0196 D423     		mov	r3, #212
 266 0198 FB18     		add	r3, r7, r3
 267 019a 1B68     		ldr	r3, [r3]
 268 019c 1A80     		strh	r2, [r3]
 269              	.LBE13:
 270              	.LBE12:
 331:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 332:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Loop over the number of taps. */
 333:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   tapCnt = numTaps;
 271              		.loc 1 333 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 117


 272 019e E223     		mov	r3, #226
 273 01a0 FB18     		add	r3, r7, r3
 274 01a2 1B88     		ldrh	r3, [r3]
 275 01a4 7A1D     		add	r2, r7, #5
 276 01a6 FF32     		add	r2, r2, #255
 277 01a8 1360     		str	r3, [r2]
 334:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 335:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 336:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
 278              		.loc 1 336 0
 279 01aa FB68     		ldr	r3, [r7, #12]
 280 01ac 5B88     		ldrh	r3, [r3, #2]
 281 01ae 1A1C     		mov	r2, r3
 282 01b0 9223     		mov	r3, #146
 283 01b2 5B00     		lsl	r3, r3, #1
 284 01b4 FB18     		add	r3, r7, r3
 285 01b6 1B68     		ldr	r3, [r3]
 286 01b8 D21A     		sub	r2, r2, r3
 287 01ba 8423     		mov	r3, #132
 288 01bc 5B00     		lsl	r3, r3, #1
 289 01be FB18     		add	r3, r7, r3
 290 01c0 1B68     		ldr	r3, [r3]
 291 01c2 191D     		add	r1, r3, #4
 292 01c4 8420     		mov	r0, #132
 293 01c6 4000     		lsl	r0, r0, #1
 294 01c8 3818     		add	r0, r7, r0
 295 01ca 0160     		str	r1, [r0]
 296 01cc 1B68     		ldr	r3, [r3]
 297 01ce D31A     		sub	r3, r2, r3
 298 01d0 7B61     		str	r3, [r7, #20]
 337:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 338:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Wraparound of readIndex */
 339:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   if (readIndex < 0)
 299              		.loc 1 339 0
 300 01d2 7B69     		ldr	r3, [r7, #20]
 301 01d4 002B     		cmp	r3, #0
 302 01d6 05DA     		bge	.L5
 340:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 341:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     readIndex += (int32_t) delaySize;
 303              		.loc 1 341 0
 304 01d8 7A69     		ldr	r2, [r7, #20]
 305 01da E423     		mov	r3, #228
 306 01dc FB18     		add	r3, r7, r3
 307 01de 1B68     		ldr	r3, [r3]
 308 01e0 D318     		add	r3, r2, r3
 309 01e2 7B61     		str	r3, [r7, #20]
 310              	.L5:
 342:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 343:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 344:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Working pointer for state buffer is updated */
 345:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   py = pState;
 311              		.loc 1 345 0
 312 01e4 F423     		mov	r3, #244
 313 01e6 FB18     		add	r3, r7, r3
 314 01e8 1B68     		ldr	r3, [r3]
 315 01ea E822     		mov	r2, #232
 316 01ec BA18     		add	r2, r7, r2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 118


 317 01ee 1360     		str	r3, [r2]
 346:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 347:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* blockSize samples are read from the state buffer */
 348:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   arm_circularRead_q15(py, delaySize, &readIndex, 1,
 318              		.loc 1 348 0
 319 01f0 E423     		mov	r3, #228
 320 01f2 FB18     		add	r3, r7, r3
 321 01f4 1A68     		ldr	r2, [r3]
 322 01f6 9223     		mov	r3, #146
 323 01f8 5B00     		lsl	r3, r3, #1
 324 01fa FB18     		add	r3, r7, r3
 325 01fc 1B68     		ldr	r3, [r3]
 326 01fe E821     		mov	r1, #232
 327 0200 7918     		add	r1, r7, r1
 328 0202 0968     		ldr	r1, [r1]
 329 0204 B820     		mov	r0, #184
 330 0206 3818     		add	r0, r7, r0
 331 0208 0160     		str	r1, [r0]
 332 020a B421     		mov	r1, #180
 333 020c 7918     		add	r1, r7, r1
 334 020e 0A60     		str	r2, [r1]
 335 0210 1422     		mov	r2, #20
 336 0212 BA18     		add	r2, r7, r2
 337 0214 B021     		mov	r1, #176
 338 0216 7918     		add	r1, r7, r1
 339 0218 0A60     		str	r2, [r1]
 340 021a 0122     		mov	r2, #1
 341 021c AC21     		mov	r1, #172
 342 021e 7918     		add	r1, r7, r1
 343 0220 0A60     		str	r2, [r1]
 344 0222 EC22     		mov	r2, #236
 345 0224 BA18     		add	r2, r7, r2
 346 0226 1268     		ldr	r2, [r2]
 347 0228 A821     		mov	r1, #168
 348 022a 7918     		add	r1, r7, r1
 349 022c 0A60     		str	r2, [r1]
 350 022e EC22     		mov	r2, #236
 351 0230 BA18     		add	r2, r7, r2
 352 0232 1268     		ldr	r2, [r2]
 353 0234 A421     		mov	r1, #164
 354 0236 7918     		add	r1, r7, r1
 355 0238 0A60     		str	r2, [r1]
 356 023a A022     		mov	r2, #160
 357 023c BA18     		add	r2, r7, r2
 358 023e 1360     		str	r3, [r2]
 359 0240 0123     		mov	r3, #1
 360 0242 9C22     		mov	r2, #156
 361 0244 BA18     		add	r2, r7, r2
 362 0246 1360     		str	r3, [r2]
 363 0248 9223     		mov	r3, #146
 364 024a 5B00     		lsl	r3, r3, #1
 365 024c FB18     		add	r3, r7, r3
 366 024e 1B68     		ldr	r3, [r3]
 367 0250 9822     		mov	r2, #152
 368 0252 BA18     		add	r2, r7, r2
 369 0254 1360     		str	r3, [r2]
 370              	.LBB14:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 119


 371              	.LBB15:
6008:.\Include/arm_math.h ****   }
6009:.\Include/arm_math.h **** 
6010:.\Include/arm_math.h **** 
6011:.\Include/arm_math.h ****   /**
6012:.\Include/arm_math.h ****    * @brief Q15 Circular Read function.
6013:.\Include/arm_math.h ****    */
6014:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularRead_q15(
6015:.\Include/arm_math.h ****   q15_t * circBuffer,
6016:.\Include/arm_math.h ****   int32_t L,
6017:.\Include/arm_math.h ****   int32_t * readOffset,
6018:.\Include/arm_math.h ****   int32_t bufferInc,
6019:.\Include/arm_math.h ****   q15_t * dst,
6020:.\Include/arm_math.h ****   q15_t * dst_base,
6021:.\Include/arm_math.h ****   int32_t dst_length,
6022:.\Include/arm_math.h ****   int32_t dstInc,
6023:.\Include/arm_math.h ****   uint32_t blockSize)
6024:.\Include/arm_math.h ****   {
6025:.\Include/arm_math.h ****     uint32_t i = 0;
 372              		.loc 2 6025 0
 373 0256 0023     		mov	r3, #0
 374 0258 9422     		mov	r2, #148
 375 025a BA18     		add	r2, r7, r2
 376 025c 1360     		str	r3, [r2]
6026:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
6027:.\Include/arm_math.h **** 
6028:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
6029:.\Include/arm_math.h ****      * to the current location from where the input samples to be read */
6030:.\Include/arm_math.h ****     rOffset = *readOffset;
 377              		.loc 2 6030 0
 378 025e B023     		mov	r3, #176
 379 0260 FB18     		add	r3, r7, r3
 380 0262 1B68     		ldr	r3, [r3]
 381 0264 1B68     		ldr	r3, [r3]
 382 0266 9022     		mov	r2, #144
 383 0268 BA18     		add	r2, r7, r2
 384 026a 1360     		str	r3, [r2]
6031:.\Include/arm_math.h **** 
6032:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
 385              		.loc 2 6032 0
 386 026c A023     		mov	r3, #160
 387 026e FB18     		add	r3, r7, r3
 388 0270 1B68     		ldr	r3, [r3]
 389 0272 5B00     		lsl	r3, r3, #1
 390 0274 A422     		mov	r2, #164
 391 0276 BA18     		add	r2, r7, r2
 392 0278 1268     		ldr	r2, [r2]
 393 027a D318     		add	r3, r2, r3
 394 027c 8C22     		mov	r2, #140
 395 027e BA18     		add	r2, r7, r2
 396 0280 1360     		str	r3, [r2]
6033:.\Include/arm_math.h **** 
6034:.\Include/arm_math.h ****     /* Loop over the blockSize */
6035:.\Include/arm_math.h ****     i = blockSize;
 397              		.loc 2 6035 0
 398 0282 9823     		mov	r3, #152
 399 0284 FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 120


 400 0286 1B68     		ldr	r3, [r3]
 401 0288 9422     		mov	r2, #148
 402 028a BA18     		add	r2, r7, r2
 403 028c 1360     		str	r3, [r2]
 404 028e 48E0     		b	.L6
 405              	.L9:
6036:.\Include/arm_math.h **** 
6037:.\Include/arm_math.h ****     while (i > 0u)
6038:.\Include/arm_math.h ****     {
6039:.\Include/arm_math.h ****       /* copy the sample from the circular buffer to the destination buffer */
6040:.\Include/arm_math.h ****       *dst = circBuffer[rOffset];
 406              		.loc 2 6040 0
 407 0290 9023     		mov	r3, #144
 408 0292 FB18     		add	r3, r7, r3
 409 0294 1B68     		ldr	r3, [r3]
 410 0296 5B00     		lsl	r3, r3, #1
 411 0298 B822     		mov	r2, #184
 412 029a BA18     		add	r2, r7, r2
 413 029c 1268     		ldr	r2, [r2]
 414 029e D318     		add	r3, r2, r3
 415 02a0 1A88     		ldrh	r2, [r3]
 416 02a2 A823     		mov	r3, #168
 417 02a4 FB18     		add	r3, r7, r3
 418 02a6 1B68     		ldr	r3, [r3]
 419 02a8 1A80     		strh	r2, [r3]
6041:.\Include/arm_math.h **** 
6042:.\Include/arm_math.h ****       /* Update the input pointer */
6043:.\Include/arm_math.h ****       dst += dstInc;
 420              		.loc 2 6043 0
 421 02aa 9C23     		mov	r3, #156
 422 02ac FB18     		add	r3, r7, r3
 423 02ae 1B68     		ldr	r3, [r3]
 424 02b0 5B00     		lsl	r3, r3, #1
 425 02b2 A822     		mov	r2, #168
 426 02b4 BA18     		add	r2, r7, r2
 427 02b6 1268     		ldr	r2, [r2]
 428 02b8 D318     		add	r3, r2, r3
 429 02ba A822     		mov	r2, #168
 430 02bc BA18     		add	r2, r7, r2
 431 02be 1360     		str	r3, [r2]
6044:.\Include/arm_math.h **** 
6045:.\Include/arm_math.h ****       if (dst == (q15_t *) dst_end)
 432              		.loc 2 6045 0
 433 02c0 8C23     		mov	r3, #140
 434 02c2 FB18     		add	r3, r7, r3
 435 02c4 1B68     		ldr	r3, [r3]
 436 02c6 A822     		mov	r2, #168
 437 02c8 BA18     		add	r2, r7, r2
 438 02ca 1268     		ldr	r2, [r2]
 439 02cc 9A42     		cmp	r2, r3
 440 02ce 05D1     		bne	.L7
6046:.\Include/arm_math.h ****       {
6047:.\Include/arm_math.h ****         dst = dst_base;
 441              		.loc 2 6047 0
 442 02d0 A423     		mov	r3, #164
 443 02d2 FB18     		add	r3, r7, r3
 444 02d4 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 121


 445 02d6 A822     		mov	r2, #168
 446 02d8 BA18     		add	r2, r7, r2
 447 02da 1360     		str	r3, [r2]
 448              	.L7:
6048:.\Include/arm_math.h ****       }
6049:.\Include/arm_math.h **** 
6050:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
6051:.\Include/arm_math.h ****       rOffset += bufferInc;
 449              		.loc 2 6051 0
 450 02dc 9023     		mov	r3, #144
 451 02de FB18     		add	r3, r7, r3
 452 02e0 1A68     		ldr	r2, [r3]
 453 02e2 AC23     		mov	r3, #172
 454 02e4 FB18     		add	r3, r7, r3
 455 02e6 1B68     		ldr	r3, [r3]
 456 02e8 D318     		add	r3, r2, r3
 457 02ea 9022     		mov	r2, #144
 458 02ec BA18     		add	r2, r7, r2
 459 02ee 1360     		str	r3, [r2]
6052:.\Include/arm_math.h **** 
6053:.\Include/arm_math.h ****       if (rOffset >= L)
 460              		.loc 2 6053 0
 461 02f0 B423     		mov	r3, #180
 462 02f2 FB18     		add	r3, r7, r3
 463 02f4 1A68     		ldr	r2, [r3]
 464 02f6 9023     		mov	r3, #144
 465 02f8 FB18     		add	r3, r7, r3
 466 02fa 1B68     		ldr	r3, [r3]
 467 02fc 9A42     		cmp	r2, r3
 468 02fe 09DC     		bgt	.L8
6054:.\Include/arm_math.h ****       {
6055:.\Include/arm_math.h ****         rOffset -= L;
 469              		.loc 2 6055 0
 470 0300 9023     		mov	r3, #144
 471 0302 FB18     		add	r3, r7, r3
 472 0304 1A68     		ldr	r2, [r3]
 473 0306 B423     		mov	r3, #180
 474 0308 FB18     		add	r3, r7, r3
 475 030a 1B68     		ldr	r3, [r3]
 476 030c D31A     		sub	r3, r2, r3
 477 030e 9022     		mov	r2, #144
 478 0310 BA18     		add	r2, r7, r2
 479 0312 1360     		str	r3, [r2]
 480              	.L8:
6056:.\Include/arm_math.h ****       }
6057:.\Include/arm_math.h **** 
6058:.\Include/arm_math.h ****       /* Decrement the loop counter */
6059:.\Include/arm_math.h ****       i--;
 481              		.loc 2 6059 0
 482 0314 9423     		mov	r3, #148
 483 0316 FB18     		add	r3, r7, r3
 484 0318 1B68     		ldr	r3, [r3]
 485 031a 013B     		sub	r3, r3, #1
 486 031c 9422     		mov	r2, #148
 487 031e BA18     		add	r2, r7, r2
 488 0320 1360     		str	r3, [r2]
 489              	.L6:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 122


6037:.\Include/arm_math.h ****     {
 490              		.loc 2 6037 0
 491 0322 9423     		mov	r3, #148
 492 0324 FB18     		add	r3, r7, r3
 493 0326 1B68     		ldr	r3, [r3]
 494 0328 002B     		cmp	r3, #0
 495 032a B1D1     		bne	.L9
6060:.\Include/arm_math.h ****     }
6061:.\Include/arm_math.h **** 
6062:.\Include/arm_math.h ****     /* Update the index pointer */
6063:.\Include/arm_math.h ****     *readOffset = rOffset;
 496              		.loc 2 6063 0
 497 032c B023     		mov	r3, #176
 498 032e FB18     		add	r3, r7, r3
 499 0330 1B68     		ldr	r3, [r3]
 500 0332 9022     		mov	r2, #144
 501 0334 BA18     		add	r2, r7, r2
 502 0336 1268     		ldr	r2, [r2]
 503 0338 1A60     		str	r2, [r3]
 504              	.LBE15:
 505              	.LBE14:
 349:Source\FilteringFunctions/arm_fir_sparse_q15.c ****                        pb, pb, blockSize, 1, blockSize);
 350:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 351:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Working pointer for the scratch buffer of state values */
 352:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   px = pb;
 506              		.loc 1 352 0
 507 033a EC23     		mov	r3, #236
 508 033c FB18     		add	r3, r7, r3
 509 033e 1B68     		ldr	r3, [r3]
 510 0340 8622     		mov	r2, #134
 511 0342 5200     		lsl	r2, r2, #1
 512 0344 BA18     		add	r2, r7, r2
 513 0346 1360     		str	r3, [r2]
 353:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 354:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Working pointer for scratch buffer of output values */
 355:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   pScratchOut = pScr2;
 514              		.loc 1 355 0
 515 0348 F823     		mov	r3, #248
 516 034a FB18     		add	r3, r7, r3
 517 034c 1B68     		ldr	r3, [r3]
 518 034e 9022     		mov	r2, #144
 519 0350 5200     		lsl	r2, r2, #1
 520 0352 BA18     		add	r2, r7, r2
 521 0354 1360     		str	r3, [r2]
 356:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 357:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   blkCnt = blockSize;
 522              		.loc 1 357 0
 523 0356 9223     		mov	r3, #146
 524 0358 5B00     		lsl	r3, r3, #1
 525 035a FB18     		add	r3, r7, r3
 526 035c 1B68     		ldr	r3, [r3]
 527 035e 7A1C     		add	r2, r7, #1
 528 0360 FF32     		add	r2, r2, #255
 529 0362 1360     		str	r3, [r2]
 358:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 359:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (blkCnt > 0u)
 530              		.loc 1 359 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 123


 531 0364 20E0     		b	.L10
 532              	.L11:
 360:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 361:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Perform multiplication and store in the scratch buffer */
 362:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pScratchOut++ = ((q31_t) * px++ * coeff);
 533              		.loc 1 362 0
 534 0366 9023     		mov	r3, #144
 535 0368 5B00     		lsl	r3, r3, #1
 536 036a FB18     		add	r3, r7, r3
 537 036c 1B68     		ldr	r3, [r3]
 538 036e 1A1D     		add	r2, r3, #4
 539 0370 9021     		mov	r1, #144
 540 0372 4900     		lsl	r1, r1, #1
 541 0374 7918     		add	r1, r7, r1
 542 0376 0A60     		str	r2, [r1]
 543 0378 8622     		mov	r2, #134
 544 037a 5200     		lsl	r2, r2, #1
 545 037c BA18     		add	r2, r7, r2
 546 037e 1268     		ldr	r2, [r2]
 547 0380 911C     		add	r1, r2, #2
 548 0382 8620     		mov	r0, #134
 549 0384 4000     		lsl	r0, r0, #1
 550 0386 3818     		add	r0, r7, r0
 551 0388 0160     		str	r1, [r0]
 552 038a 1288     		ldrh	r2, [r2]
 553 038c 12B2     		sxth	r2, r2
 554 038e FE21     		mov	r1, #254
 555 0390 7918     		add	r1, r7, r1
 556 0392 0020     		mov	r0, #0
 557 0394 095E     		ldrsh	r1, [r1, r0]
 558 0396 4A43     		mul	r2, r1
 559 0398 1A60     		str	r2, [r3]
 363:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 364:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Decrement the loop counter */
 365:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt--;
 560              		.loc 1 365 0
 561 039a 7B1C     		add	r3, r7, #1
 562 039c FF33     		add	r3, r3, #255
 563 039e 1B68     		ldr	r3, [r3]
 564 03a0 013B     		sub	r3, r3, #1
 565 03a2 7A1C     		add	r2, r7, #1
 566 03a4 FF32     		add	r2, r2, #255
 567 03a6 1360     		str	r3, [r2]
 568              	.L10:
 359:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 569              		.loc 1 359 0
 570 03a8 7B1C     		add	r3, r7, #1
 571 03aa FF33     		add	r3, r3, #255
 572 03ac 1B68     		ldr	r3, [r3]
 573 03ae 002B     		cmp	r3, #0
 574 03b0 D9D1     		bne	.L11
 366:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 367:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 368:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Load the coefficient value and
 369:Source\FilteringFunctions/arm_fir_sparse_q15.c ****    * increment the coefficient buffer for the next set of state values */
 370:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   coeff = *pCoeffs++;
 575              		.loc 1 370 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 124


 576 03b2 8823     		mov	r3, #136
 577 03b4 5B00     		lsl	r3, r3, #1
 578 03b6 FB18     		add	r3, r7, r3
 579 03b8 1B68     		ldr	r3, [r3]
 580 03ba 9A1C     		add	r2, r3, #2
 581 03bc 8821     		mov	r1, #136
 582 03be 4900     		lsl	r1, r1, #1
 583 03c0 7918     		add	r1, r7, r1
 584 03c2 0A60     		str	r2, [r1]
 585 03c4 FE22     		mov	r2, #254
 586 03c6 BA18     		add	r2, r7, r2
 587 03c8 1B88     		ldrh	r3, [r3]
 588 03ca 1380     		strh	r3, [r2]
 371:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 372:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 373:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
 589              		.loc 1 373 0
 590 03cc FB68     		ldr	r3, [r7, #12]
 591 03ce 5B88     		ldrh	r3, [r3, #2]
 592 03d0 1A1C     		mov	r2, r3
 593 03d2 9223     		mov	r3, #146
 594 03d4 5B00     		lsl	r3, r3, #1
 595 03d6 FB18     		add	r3, r7, r3
 596 03d8 1B68     		ldr	r3, [r3]
 597 03da D21A     		sub	r2, r2, r3
 598 03dc 8423     		mov	r3, #132
 599 03de 5B00     		lsl	r3, r3, #1
 600 03e0 FB18     		add	r3, r7, r3
 601 03e2 1B68     		ldr	r3, [r3]
 602 03e4 191D     		add	r1, r3, #4
 603 03e6 8420     		mov	r0, #132
 604 03e8 4000     		lsl	r0, r0, #1
 605 03ea 3818     		add	r0, r7, r0
 606 03ec 0160     		str	r1, [r0]
 607 03ee 1B68     		ldr	r3, [r3]
 608 03f0 D31A     		sub	r3, r2, r3
 609 03f2 7B61     		str	r3, [r7, #20]
 374:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 375:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Wraparound of readIndex */
 376:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   if (readIndex < 0)
 610              		.loc 1 376 0
 611 03f4 7B69     		ldr	r3, [r7, #20]
 612 03f6 002B     		cmp	r3, #0
 613 03f8 05DA     		bge	.L12
 377:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 378:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     readIndex += (int32_t) delaySize;
 614              		.loc 1 378 0
 615 03fa 7A69     		ldr	r2, [r7, #20]
 616 03fc E423     		mov	r3, #228
 617 03fe FB18     		add	r3, r7, r3
 618 0400 1B68     		ldr	r3, [r3]
 619 0402 D318     		add	r3, r2, r3
 620 0404 7B61     		str	r3, [r7, #20]
 621              	.L12:
 379:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 380:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 381:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Loop over the number of taps. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 125


 382:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   tapCnt = (uint32_t) numTaps - 2u;
 622              		.loc 1 382 0
 623 0406 E223     		mov	r3, #226
 624 0408 FB18     		add	r3, r7, r3
 625 040a 1B88     		ldrh	r3, [r3]
 626 040c 023B     		sub	r3, r3, #2
 627 040e 7A1D     		add	r2, r7, #5
 628 0410 FF32     		add	r2, r2, #255
 629 0412 1360     		str	r3, [r2]
 383:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 384:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (tapCnt > 0u)
 630              		.loc 1 384 0
 631 0414 D9E0     		b	.L13
 632              	.L21:
 385:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 386:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Working pointer for state buffer is updated */
 387:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     py = pState;
 633              		.loc 1 387 0
 634 0416 F423     		mov	r3, #244
 635 0418 FB18     		add	r3, r7, r3
 636 041a 1B68     		ldr	r3, [r3]
 637 041c E822     		mov	r2, #232
 638 041e BA18     		add	r2, r7, r2
 639 0420 1360     		str	r3, [r2]
 388:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 389:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* blockSize samples are read from the state buffer */
 390:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     arm_circularRead_q15(py, delaySize, &readIndex, 1,
 640              		.loc 1 390 0
 641 0422 E423     		mov	r3, #228
 642 0424 FB18     		add	r3, r7, r3
 643 0426 1A68     		ldr	r2, [r3]
 644 0428 9223     		mov	r3, #146
 645 042a 5B00     		lsl	r3, r3, #1
 646 042c FB18     		add	r3, r7, r3
 647 042e 1B68     		ldr	r3, [r3]
 648 0430 E821     		mov	r1, #232
 649 0432 7918     		add	r1, r7, r1
 650 0434 0968     		ldr	r1, [r1]
 651 0436 8820     		mov	r0, #136
 652 0438 3818     		add	r0, r7, r0
 653 043a 0160     		str	r1, [r0]
 654 043c 8421     		mov	r1, #132
 655 043e 7918     		add	r1, r7, r1
 656 0440 0A60     		str	r2, [r1]
 657 0442 1422     		mov	r2, #20
 658 0444 BA18     		add	r2, r7, r2
 659 0446 8021     		mov	r1, #128
 660 0448 7918     		add	r1, r7, r1
 661 044a 0A60     		str	r2, [r1]
 662 044c 0122     		mov	r2, #1
 663 044e FA67     		str	r2, [r7, #124]
 664 0450 EC22     		mov	r2, #236
 665 0452 BA18     		add	r2, r7, r2
 666 0454 1268     		ldr	r2, [r2]
 667 0456 BA67     		str	r2, [r7, #120]
 668 0458 EC22     		mov	r2, #236
 669 045a BA18     		add	r2, r7, r2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 126


 670 045c 1268     		ldr	r2, [r2]
 671 045e 7A67     		str	r2, [r7, #116]
 672 0460 3B67     		str	r3, [r7, #112]
 673 0462 0123     		mov	r3, #1
 674 0464 FB66     		str	r3, [r7, #108]
 675 0466 9223     		mov	r3, #146
 676 0468 5B00     		lsl	r3, r3, #1
 677 046a FB18     		add	r3, r7, r3
 678 046c 1B68     		ldr	r3, [r3]
 679 046e BB66     		str	r3, [r7, #104]
 680              	.LBB16:
 681              	.LBB17:
6025:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
 682              		.loc 2 6025 0
 683 0470 0023     		mov	r3, #0
 684 0472 7B66     		str	r3, [r7, #100]
6030:.\Include/arm_math.h **** 
 685              		.loc 2 6030 0
 686 0474 8023     		mov	r3, #128
 687 0476 FB18     		add	r3, r7, r3
 688 0478 1B68     		ldr	r3, [r3]
 689 047a 1B68     		ldr	r3, [r3]
 690 047c 3B66     		str	r3, [r7, #96]
6032:.\Include/arm_math.h **** 
 691              		.loc 2 6032 0
 692 047e 3B6F     		ldr	r3, [r7, #112]
 693 0480 5B00     		lsl	r3, r3, #1
 694 0482 7A6F     		ldr	r2, [r7, #116]
 695 0484 D318     		add	r3, r2, r3
 696 0486 FB65     		str	r3, [r7, #92]
6035:.\Include/arm_math.h **** 
 697              		.loc 2 6035 0
 698 0488 BB6E     		ldr	r3, [r7, #104]
 699 048a 7B66     		str	r3, [r7, #100]
 700 048c 26E0     		b	.L14
 701              	.L17:
6040:.\Include/arm_math.h **** 
 702              		.loc 2 6040 0
 703 048e 3B6E     		ldr	r3, [r7, #96]
 704 0490 5B00     		lsl	r3, r3, #1
 705 0492 8822     		mov	r2, #136
 706 0494 BA18     		add	r2, r7, r2
 707 0496 1268     		ldr	r2, [r2]
 708 0498 D318     		add	r3, r2, r3
 709 049a 1A88     		ldrh	r2, [r3]
 710 049c BB6F     		ldr	r3, [r7, #120]
 711 049e 1A80     		strh	r2, [r3]
6043:.\Include/arm_math.h **** 
 712              		.loc 2 6043 0
 713 04a0 FB6E     		ldr	r3, [r7, #108]
 714 04a2 5B00     		lsl	r3, r3, #1
 715 04a4 BA6F     		ldr	r2, [r7, #120]
 716 04a6 D318     		add	r3, r2, r3
 717 04a8 BB67     		str	r3, [r7, #120]
6045:.\Include/arm_math.h ****       {
 718              		.loc 2 6045 0
 719 04aa FB6D     		ldr	r3, [r7, #92]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 127


 720 04ac BA6F     		ldr	r2, [r7, #120]
 721 04ae 9A42     		cmp	r2, r3
 722 04b0 01D1     		bne	.L15
6047:.\Include/arm_math.h ****       }
 723              		.loc 2 6047 0
 724 04b2 7B6F     		ldr	r3, [r7, #116]
 725 04b4 BB67     		str	r3, [r7, #120]
 726              	.L15:
6051:.\Include/arm_math.h **** 
 727              		.loc 2 6051 0
 728 04b6 3A6E     		ldr	r2, [r7, #96]
 729 04b8 FB6F     		ldr	r3, [r7, #124]
 730 04ba D318     		add	r3, r2, r3
 731 04bc 3B66     		str	r3, [r7, #96]
6053:.\Include/arm_math.h ****       {
 732              		.loc 2 6053 0
 733 04be 8423     		mov	r3, #132
 734 04c0 FB18     		add	r3, r7, r3
 735 04c2 1A68     		ldr	r2, [r3]
 736 04c4 3B6E     		ldr	r3, [r7, #96]
 737 04c6 9A42     		cmp	r2, r3
 738 04c8 05DC     		bgt	.L16
6055:.\Include/arm_math.h ****       }
 739              		.loc 2 6055 0
 740 04ca 3A6E     		ldr	r2, [r7, #96]
 741 04cc 8423     		mov	r3, #132
 742 04ce FB18     		add	r3, r7, r3
 743 04d0 1B68     		ldr	r3, [r3]
 744 04d2 D31A     		sub	r3, r2, r3
 745 04d4 3B66     		str	r3, [r7, #96]
 746              	.L16:
6059:.\Include/arm_math.h ****     }
 747              		.loc 2 6059 0
 748 04d6 7B6E     		ldr	r3, [r7, #100]
 749 04d8 013B     		sub	r3, r3, #1
 750 04da 7B66     		str	r3, [r7, #100]
 751              	.L14:
6037:.\Include/arm_math.h ****     {
 752              		.loc 2 6037 0
 753 04dc 7B6E     		ldr	r3, [r7, #100]
 754 04de 002B     		cmp	r3, #0
 755 04e0 D5D1     		bne	.L17
 756              		.loc 2 6063 0
 757 04e2 8023     		mov	r3, #128
 758 04e4 FB18     		add	r3, r7, r3
 759 04e6 1B68     		ldr	r3, [r3]
 760 04e8 3A6E     		ldr	r2, [r7, #96]
 761 04ea 1A60     		str	r2, [r3]
 762              	.LBE17:
 763              	.LBE16:
 391:Source\FilteringFunctions/arm_fir_sparse_q15.c ****                          pb, pb, blockSize, 1, blockSize);
 392:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 393:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Working pointer for the scratch buffer of state values */
 394:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     px = pb;
 764              		.loc 1 394 0
 765 04ec EC23     		mov	r3, #236
 766 04ee FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 128


 767 04f0 1B68     		ldr	r3, [r3]
 768 04f2 8622     		mov	r2, #134
 769 04f4 5200     		lsl	r2, r2, #1
 770 04f6 BA18     		add	r2, r7, r2
 771 04f8 1360     		str	r3, [r2]
 395:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 396:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Working pointer for scratch buffer of output values */
 397:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     pScratchOut = pScr2;
 772              		.loc 1 397 0
 773 04fa F823     		mov	r3, #248
 774 04fc FB18     		add	r3, r7, r3
 775 04fe 1B68     		ldr	r3, [r3]
 776 0500 9022     		mov	r2, #144
 777 0502 5200     		lsl	r2, r2, #1
 778 0504 BA18     		add	r2, r7, r2
 779 0506 1360     		str	r3, [r2]
 398:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 399:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt = blockSize;
 780              		.loc 1 399 0
 781 0508 9223     		mov	r3, #146
 782 050a 5B00     		lsl	r3, r3, #1
 783 050c FB18     		add	r3, r7, r3
 784 050e 1B68     		ldr	r3, [r3]
 785 0510 7A1C     		add	r2, r7, #1
 786 0512 FF32     		add	r2, r2, #255
 787 0514 1360     		str	r3, [r2]
 400:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 401:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     while (blkCnt > 0u)
 788              		.loc 1 401 0
 789 0516 22E0     		b	.L18
 790              	.L19:
 402:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     {
 403:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       /* Perform Multiply-Accumulate */
 404:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       *pScratchOut++ += (q31_t) * px++ * coeff;
 791              		.loc 1 404 0
 792 0518 8623     		mov	r3, #134
 793 051a 5B00     		lsl	r3, r3, #1
 794 051c FB18     		add	r3, r7, r3
 795 051e 1B68     		ldr	r3, [r3]
 796 0520 9A1C     		add	r2, r3, #2
 797 0522 8621     		mov	r1, #134
 798 0524 4900     		lsl	r1, r1, #1
 799 0526 7918     		add	r1, r7, r1
 800 0528 0A60     		str	r2, [r1]
 801 052a 1B88     		ldrh	r3, [r3]
 802 052c 1BB2     		sxth	r3, r3
 803 052e FE22     		mov	r2, #254
 804 0530 BA18     		add	r2, r7, r2
 805 0532 0021     		mov	r1, #0
 806 0534 525E     		ldrsh	r2, [r2, r1]
 807 0536 5A43     		mul	r2, r3
 808 0538 9023     		mov	r3, #144
 809 053a 5B00     		lsl	r3, r3, #1
 810 053c FB18     		add	r3, r7, r3
 811 053e 1B68     		ldr	r3, [r3]
 812 0540 191D     		add	r1, r3, #4
 813 0542 9020     		mov	r0, #144
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 129


 814 0544 4000     		lsl	r0, r0, #1
 815 0546 3818     		add	r0, r7, r0
 816 0548 0160     		str	r1, [r0]
 817 054a 1968     		ldr	r1, [r3]
 818 054c 8A18     		add	r2, r1, r2
 819 054e 1A60     		str	r2, [r3]
 405:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 406:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       /* Decrement the loop counter */
 407:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       blkCnt--;
 820              		.loc 1 407 0
 821 0550 7B1C     		add	r3, r7, #1
 822 0552 FF33     		add	r3, r3, #255
 823 0554 1B68     		ldr	r3, [r3]
 824 0556 013B     		sub	r3, r3, #1
 825 0558 7A1C     		add	r2, r7, #1
 826 055a FF32     		add	r2, r2, #255
 827 055c 1360     		str	r3, [r2]
 828              	.L18:
 401:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     {
 829              		.loc 1 401 0
 830 055e 7B1C     		add	r3, r7, #1
 831 0560 FF33     		add	r3, r3, #255
 832 0562 1B68     		ldr	r3, [r3]
 833 0564 002B     		cmp	r3, #0
 834 0566 D7D1     		bne	.L19
 408:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     }
 409:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 410:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Load the coefficient value and
 411:Source\FilteringFunctions/arm_fir_sparse_q15.c ****      * increment the coefficient buffer for the next set of state values */
 412:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     coeff = *pCoeffs++;
 835              		.loc 1 412 0
 836 0568 8823     		mov	r3, #136
 837 056a 5B00     		lsl	r3, r3, #1
 838 056c FB18     		add	r3, r7, r3
 839 056e 1B68     		ldr	r3, [r3]
 840 0570 9A1C     		add	r2, r3, #2
 841 0572 8821     		mov	r1, #136
 842 0574 4900     		lsl	r1, r1, #1
 843 0576 7918     		add	r1, r7, r1
 844 0578 0A60     		str	r2, [r1]
 845 057a FE22     		mov	r2, #254
 846 057c BA18     		add	r2, r7, r2
 847 057e 1B88     		ldrh	r3, [r3]
 848 0580 1380     		strh	r3, [r2]
 413:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 414:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 415:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
 849              		.loc 1 415 0
 850 0582 FB68     		ldr	r3, [r7, #12]
 851 0584 5B88     		ldrh	r3, [r3, #2]
 852 0586 1A1C     		mov	r2, r3
 853 0588 9223     		mov	r3, #146
 854 058a 5B00     		lsl	r3, r3, #1
 855 058c FB18     		add	r3, r7, r3
 856 058e 1B68     		ldr	r3, [r3]
 857 0590 D21A     		sub	r2, r2, r3
 858 0592 8423     		mov	r3, #132
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 130


 859 0594 5B00     		lsl	r3, r3, #1
 860 0596 FB18     		add	r3, r7, r3
 861 0598 1B68     		ldr	r3, [r3]
 862 059a 191D     		add	r1, r3, #4
 863 059c 8420     		mov	r0, #132
 864 059e 4000     		lsl	r0, r0, #1
 865 05a0 3818     		add	r0, r7, r0
 866 05a2 0160     		str	r1, [r0]
 867 05a4 1B68     		ldr	r3, [r3]
 868 05a6 D31A     		sub	r3, r2, r3
 869 05a8 7B61     		str	r3, [r7, #20]
 416:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 417:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Wraparound of readIndex */
 418:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     if (readIndex < 0)
 870              		.loc 1 418 0
 871 05aa 7B69     		ldr	r3, [r7, #20]
 872 05ac 002B     		cmp	r3, #0
 873 05ae 05DA     		bge	.L20
 419:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     {
 420:Source\FilteringFunctions/arm_fir_sparse_q15.c ****       readIndex += (int32_t) delaySize;
 874              		.loc 1 420 0
 875 05b0 7A69     		ldr	r2, [r7, #20]
 876 05b2 E423     		mov	r3, #228
 877 05b4 FB18     		add	r3, r7, r3
 878 05b6 1B68     		ldr	r3, [r3]
 879 05b8 D318     		add	r3, r2, r3
 880 05ba 7B61     		str	r3, [r7, #20]
 881              	.L20:
 421:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     }
 422:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 423:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     /* Decrement the tap loop counter */
 424:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     tapCnt--;
 882              		.loc 1 424 0
 883 05bc 7B1D     		add	r3, r7, #5
 884 05be FF33     		add	r3, r3, #255
 885 05c0 1B68     		ldr	r3, [r3]
 886 05c2 013B     		sub	r3, r3, #1
 887 05c4 7A1D     		add	r2, r7, #5
 888 05c6 FF32     		add	r2, r2, #255
 889 05c8 1360     		str	r3, [r2]
 890              	.L13:
 384:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 891              		.loc 1 384 0
 892 05ca 7B1D     		add	r3, r7, #5
 893 05cc FF33     		add	r3, r3, #255
 894 05ce 1B68     		ldr	r3, [r3]
 895 05d0 002B     		cmp	r3, #0
 896 05d2 00D0     		beq	.LCB810
 897 05d4 1FE7     		b	.L21	@long jump
 898              	.LCB810:
 425:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 426:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 427:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Compute last tap without the final read of pTapDelay */
 428:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 429:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Working pointer for state buffer is updated */
 430:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	py = pState;
 899              		.loc 1 430 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 131


 900 05d6 F423     		mov	r3, #244
 901 05d8 FB18     		add	r3, r7, r3
 902 05da 1B68     		ldr	r3, [r3]
 903 05dc E822     		mov	r2, #232
 904 05de BA18     		add	r2, r7, r2
 905 05e0 1360     		str	r3, [r2]
 431:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 432:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* blockSize samples are read from the state buffer */
 433:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	arm_circularRead_q15(py, delaySize, &readIndex, 1,
 906              		.loc 1 433 0
 907 05e2 E423     		mov	r3, #228
 908 05e4 FB18     		add	r3, r7, r3
 909 05e6 1A68     		ldr	r2, [r3]
 910 05e8 9223     		mov	r3, #146
 911 05ea 5B00     		lsl	r3, r3, #1
 912 05ec FB18     		add	r3, r7, r3
 913 05ee 1B68     		ldr	r3, [r3]
 914 05f0 E821     		mov	r1, #232
 915 05f2 7918     		add	r1, r7, r1
 916 05f4 0968     		ldr	r1, [r1]
 917 05f6 B965     		str	r1, [r7, #88]
 918 05f8 7A65     		str	r2, [r7, #84]
 919 05fa 1422     		mov	r2, #20
 920 05fc BA18     		add	r2, r7, r2
 921 05fe 3A65     		str	r2, [r7, #80]
 922 0600 0122     		mov	r2, #1
 923 0602 FA64     		str	r2, [r7, #76]
 924 0604 EC22     		mov	r2, #236
 925 0606 BA18     		add	r2, r7, r2
 926 0608 1268     		ldr	r2, [r2]
 927 060a BA64     		str	r2, [r7, #72]
 928 060c EC22     		mov	r2, #236
 929 060e BA18     		add	r2, r7, r2
 930 0610 1268     		ldr	r2, [r2]
 931 0612 7A64     		str	r2, [r7, #68]
 932 0614 3B64     		str	r3, [r7, #64]
 933 0616 0123     		mov	r3, #1
 934 0618 FB63     		str	r3, [r7, #60]
 935 061a 9223     		mov	r3, #146
 936 061c 5B00     		lsl	r3, r3, #1
 937 061e FB18     		add	r3, r7, r3
 938 0620 1B68     		ldr	r3, [r3]
 939 0622 BB63     		str	r3, [r7, #56]
 940              	.LBB18:
 941              	.LBB19:
6025:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
 942              		.loc 2 6025 0
 943 0624 0023     		mov	r3, #0
 944 0626 7B63     		str	r3, [r7, #52]
6030:.\Include/arm_math.h **** 
 945              		.loc 2 6030 0
 946 0628 3B6D     		ldr	r3, [r7, #80]
 947 062a 1B68     		ldr	r3, [r3]
 948 062c 3B63     		str	r3, [r7, #48]
6032:.\Include/arm_math.h **** 
 949              		.loc 2 6032 0
 950 062e 3B6C     		ldr	r3, [r7, #64]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 132


 951 0630 5B00     		lsl	r3, r3, #1
 952 0632 7A6C     		ldr	r2, [r7, #68]
 953 0634 D318     		add	r3, r2, r3
 954 0636 FB62     		str	r3, [r7, #44]
6035:.\Include/arm_math.h **** 
 955              		.loc 2 6035 0
 956 0638 BB6B     		ldr	r3, [r7, #56]
 957 063a 7B63     		str	r3, [r7, #52]
 958 063c 20E0     		b	.L22
 959              	.L25:
6040:.\Include/arm_math.h **** 
 960              		.loc 2 6040 0
 961 063e 3B6B     		ldr	r3, [r7, #48]
 962 0640 5B00     		lsl	r3, r3, #1
 963 0642 BA6D     		ldr	r2, [r7, #88]
 964 0644 D318     		add	r3, r2, r3
 965 0646 1A88     		ldrh	r2, [r3]
 966 0648 BB6C     		ldr	r3, [r7, #72]
 967 064a 1A80     		strh	r2, [r3]
6043:.\Include/arm_math.h **** 
 968              		.loc 2 6043 0
 969 064c FB6B     		ldr	r3, [r7, #60]
 970 064e 5B00     		lsl	r3, r3, #1
 971 0650 BA6C     		ldr	r2, [r7, #72]
 972 0652 D318     		add	r3, r2, r3
 973 0654 BB64     		str	r3, [r7, #72]
6045:.\Include/arm_math.h ****       {
 974              		.loc 2 6045 0
 975 0656 FB6A     		ldr	r3, [r7, #44]
 976 0658 BA6C     		ldr	r2, [r7, #72]
 977 065a 9A42     		cmp	r2, r3
 978 065c 01D1     		bne	.L23
6047:.\Include/arm_math.h ****       }
 979              		.loc 2 6047 0
 980 065e 7B6C     		ldr	r3, [r7, #68]
 981 0660 BB64     		str	r3, [r7, #72]
 982              	.L23:
6051:.\Include/arm_math.h **** 
 983              		.loc 2 6051 0
 984 0662 3A6B     		ldr	r2, [r7, #48]
 985 0664 FB6C     		ldr	r3, [r7, #76]
 986 0666 D318     		add	r3, r2, r3
 987 0668 3B63     		str	r3, [r7, #48]
6053:.\Include/arm_math.h ****       {
 988              		.loc 2 6053 0
 989 066a 7A6D     		ldr	r2, [r7, #84]
 990 066c 3B6B     		ldr	r3, [r7, #48]
 991 066e 9A42     		cmp	r2, r3
 992 0670 03DC     		bgt	.L24
6055:.\Include/arm_math.h ****       }
 993              		.loc 2 6055 0
 994 0672 3A6B     		ldr	r2, [r7, #48]
 995 0674 7B6D     		ldr	r3, [r7, #84]
 996 0676 D31A     		sub	r3, r2, r3
 997 0678 3B63     		str	r3, [r7, #48]
 998              	.L24:
6059:.\Include/arm_math.h ****     }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 133


 999              		.loc 2 6059 0
 1000 067a 7B6B     		ldr	r3, [r7, #52]
 1001 067c 013B     		sub	r3, r3, #1
 1002 067e 7B63     		str	r3, [r7, #52]
 1003              	.L22:
6037:.\Include/arm_math.h ****     {
 1004              		.loc 2 6037 0
 1005 0680 7B6B     		ldr	r3, [r7, #52]
 1006 0682 002B     		cmp	r3, #0
 1007 0684 DBD1     		bne	.L25
 1008              		.loc 2 6063 0
 1009 0686 3B6D     		ldr	r3, [r7, #80]
 1010 0688 3A6B     		ldr	r2, [r7, #48]
 1011 068a 1A60     		str	r2, [r3]
 1012              	.LBE19:
 1013              	.LBE18:
 434:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 											 pb, pb, blockSize, 1, blockSize);
 435:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 436:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Working pointer for the scratch buffer of state values */
 437:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	px = pb;
 1014              		.loc 1 437 0
 1015 068c EC23     		mov	r3, #236
 1016 068e FB18     		add	r3, r7, r3
 1017 0690 1B68     		ldr	r3, [r3]
 1018 0692 8622     		mov	r2, #134
 1019 0694 5200     		lsl	r2, r2, #1
 1020 0696 BA18     		add	r2, r7, r2
 1021 0698 1360     		str	r3, [r2]
 438:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 439:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	/* Working pointer for scratch buffer of output values */
 440:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	pScratchOut = pScr2;
 1022              		.loc 1 440 0
 1023 069a F823     		mov	r3, #248
 1024 069c FB18     		add	r3, r7, r3
 1025 069e 1B68     		ldr	r3, [r3]
 1026 06a0 9022     		mov	r2, #144
 1027 06a2 5200     		lsl	r2, r2, #1
 1028 06a4 BA18     		add	r2, r7, r2
 1029 06a6 1360     		str	r3, [r2]
 441:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 442:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	blkCnt = blockSize;
 1030              		.loc 1 442 0
 1031 06a8 9223     		mov	r3, #146
 1032 06aa 5B00     		lsl	r3, r3, #1
 1033 06ac FB18     		add	r3, r7, r3
 1034 06ae 1B68     		ldr	r3, [r3]
 1035 06b0 7A1C     		add	r2, r7, #1
 1036 06b2 FF32     		add	r2, r2, #255
 1037 06b4 1360     		str	r3, [r2]
 443:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 444:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	while (blkCnt > 0u)
 1038              		.loc 1 444 0
 1039 06b6 22E0     		b	.L26
 1040              	.L27:
 445:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	{
 446:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		/* Perform Multiply-Accumulate */
 447:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		*pScratchOut++ += (q31_t) * px++ * coeff;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 134


 1041              		.loc 1 447 0
 1042 06b8 8623     		mov	r3, #134
 1043 06ba 5B00     		lsl	r3, r3, #1
 1044 06bc FB18     		add	r3, r7, r3
 1045 06be 1B68     		ldr	r3, [r3]
 1046 06c0 9A1C     		add	r2, r3, #2
 1047 06c2 8621     		mov	r1, #134
 1048 06c4 4900     		lsl	r1, r1, #1
 1049 06c6 7918     		add	r1, r7, r1
 1050 06c8 0A60     		str	r2, [r1]
 1051 06ca 1B88     		ldrh	r3, [r3]
 1052 06cc 1BB2     		sxth	r3, r3
 1053 06ce FE22     		mov	r2, #254
 1054 06d0 BA18     		add	r2, r7, r2
 1055 06d2 0021     		mov	r1, #0
 1056 06d4 525E     		ldrsh	r2, [r2, r1]
 1057 06d6 5A43     		mul	r2, r3
 1058 06d8 9023     		mov	r3, #144
 1059 06da 5B00     		lsl	r3, r3, #1
 1060 06dc FB18     		add	r3, r7, r3
 1061 06de 1B68     		ldr	r3, [r3]
 1062 06e0 191D     		add	r1, r3, #4
 1063 06e2 9020     		mov	r0, #144
 1064 06e4 4000     		lsl	r0, r0, #1
 1065 06e6 3818     		add	r0, r7, r0
 1066 06e8 0160     		str	r1, [r0]
 1067 06ea 1968     		ldr	r1, [r3]
 1068 06ec 8A18     		add	r2, r1, r2
 1069 06ee 1A60     		str	r2, [r3]
 448:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 449:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		/* Decrement the loop counter */
 450:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 		blkCnt--;
 1070              		.loc 1 450 0
 1071 06f0 7B1C     		add	r3, r7, #1
 1072 06f2 FF33     		add	r3, r3, #255
 1073 06f4 1B68     		ldr	r3, [r3]
 1074 06f6 013B     		sub	r3, r3, #1
 1075 06f8 7A1C     		add	r2, r7, #1
 1076 06fa FF32     		add	r2, r2, #255
 1077 06fc 1360     		str	r3, [r2]
 1078              	.L26:
 444:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	{
 1079              		.loc 1 444 0
 1080 06fe 7B1C     		add	r3, r7, #1
 1081 0700 FF33     		add	r3, r3, #255
 1082 0702 1B68     		ldr	r3, [r3]
 1083 0704 002B     		cmp	r3, #0
 1084 0706 D7D1     		bne	.L27
 451:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 	}
 452:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 453:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* All the output values are in pScratchOut buffer.
 454:Source\FilteringFunctions/arm_fir_sparse_q15.c ****      Convert them into 1.15 format, saturate and store in the destination buffer. */
 455:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   /* Loop over the blockSize. */
 456:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   blkCnt = blockSize;
 1085              		.loc 1 456 0
 1086 0708 9223     		mov	r3, #146
 1087 070a 5B00     		lsl	r3, r3, #1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 135


 1088 070c FB18     		add	r3, r7, r3
 1089 070e 1B68     		ldr	r3, [r3]
 1090 0710 7A1C     		add	r2, r7, #1
 1091 0712 FF32     		add	r2, r2, #255
 1092 0714 1360     		str	r3, [r2]
 457:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 458:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   while (blkCnt > 0u)
 1093              		.loc 1 458 0
 1094 0716 46E0     		b	.L28
 1095              	.L35:
 459:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 460:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     *pOut++ = (q15_t) __SSAT(*pScr2++ >> 15, 16);
 1096              		.loc 1 460 0
 1097 0718 8A23     		mov	r3, #138
 1098 071a 5B00     		lsl	r3, r3, #1
 1099 071c FB18     		add	r3, r7, r3
 1100 071e 1A68     		ldr	r2, [r3]
 1101 0720 931C     		add	r3, r2, #2
 1102 0722 8A21     		mov	r1, #138
 1103 0724 4900     		lsl	r1, r1, #1
 1104 0726 7918     		add	r1, r7, r1
 1105 0728 0B60     		str	r3, [r1]
 1106 072a F823     		mov	r3, #248
 1107 072c FB18     		add	r3, r7, r3
 1108 072e 1B68     		ldr	r3, [r3]
 1109 0730 191D     		add	r1, r3, #4
 1110 0732 F820     		mov	r0, #248
 1111 0734 3818     		add	r0, r7, r0
 1112 0736 0160     		str	r1, [r0]
 1113 0738 1B68     		ldr	r3, [r3]
 1114 073a DB13     		asr	r3, r3, #15
 1115 073c BB62     		str	r3, [r7, #40]
 1116 073e 1023     		mov	r3, #16
 1117 0740 7B62     		str	r3, [r7, #36]
 1118              	.LBB20:
 1119              	.LBB21:
 699:.\Include/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 1120              		.loc 2 699 0
 1121 0742 0123     		mov	r3, #1
 1122 0744 3B62     		str	r3, [r7, #32]
 700:.\Include/arm_math.h ****     {
 1123              		.loc 2 700 0
 1124 0746 0023     		mov	r3, #0
 1125 0748 FB61     		str	r3, [r7, #28]
 1126 074a 05E0     		b	.L29
 1127              	.L30:
 702:.\Include/arm_math.h ****     }
 1128              		.loc 2 702 0
 1129 074c 3B6A     		ldr	r3, [r7, #32]
 1130 074e 5B00     		lsl	r3, r3, #1
 1131 0750 3B62     		str	r3, [r7, #32]
 700:.\Include/arm_math.h ****     {
 1132              		.loc 2 700 0
 1133 0752 FB69     		ldr	r3, [r7, #28]
 1134 0754 0133     		add	r3, r3, #1
 1135 0756 FB61     		str	r3, [r7, #28]
 1136              	.L29:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 136


 1137 0758 7B6A     		ldr	r3, [r7, #36]
 1138 075a 013B     		sub	r3, r3, #1
 1139 075c F969     		ldr	r1, [r7, #28]
 1140 075e 9942     		cmp	r1, r3
 1141 0760 F4D3     		bcc	.L30
 705:.\Include/arm_math.h ****     {
 1142              		.loc 2 705 0
 1143 0762 BB6A     		ldr	r3, [r7, #40]
 1144 0764 002B     		cmp	r3, #0
 1145 0766 09DD     		ble	.L31
 707:.\Include/arm_math.h **** 
 1146              		.loc 2 707 0
 1147 0768 3B6A     		ldr	r3, [r7, #32]
 1148 076a 013B     		sub	r3, r3, #1
 1149 076c 3B62     		str	r3, [r7, #32]
 709:.\Include/arm_math.h ****       {
 1150              		.loc 2 709 0
 1151 076e B96A     		ldr	r1, [r7, #40]
 1152 0770 3B6A     		ldr	r3, [r7, #32]
 1153 0772 9942     		cmp	r1, r3
 1154 0774 0CDD     		ble	.L36
 711:.\Include/arm_math.h ****       }
 1155              		.loc 2 711 0
 1156 0776 3B6A     		ldr	r3, [r7, #32]
 1157 0778 BB62     		str	r3, [r7, #40]
 1158 077a 0AE0     		b	.L33
 1159              	.L31:
 716:.\Include/arm_math.h **** 
 1160              		.loc 2 716 0
 1161 077c 3B6A     		ldr	r3, [r7, #32]
 1162 077e 5B42     		neg	r3, r3
 1163 0780 BB61     		str	r3, [r7, #24]
 718:.\Include/arm_math.h ****       {
 1164              		.loc 2 718 0
 1165 0782 B96A     		ldr	r1, [r7, #40]
 1166 0784 BB69     		ldr	r3, [r7, #24]
 1167 0786 9942     		cmp	r1, r3
 1168 0788 03DA     		bge	.L33
 720:.\Include/arm_math.h ****       }
 1169              		.loc 2 720 0
 1170 078a BB69     		ldr	r3, [r7, #24]
 1171 078c BB62     		str	r3, [r7, #40]
 1172 078e 00E0     		b	.L33
 1173              	.L36:
 711:.\Include/arm_math.h ****       }
 1174              		.loc 2 711 0
 1175 0790 C046     		mov	r8, r8
 1176              	.L33:
 723:.\Include/arm_math.h ****   }
 1177              		.loc 2 723 0
 1178 0792 BB6A     		ldr	r3, [r7, #40]
 1179              	.LBE21:
 1180              	.LBE20:
 1181              		.loc 1 460 0
 1182 0794 9BB2     		uxth	r3, r3
 1183 0796 1380     		strh	r3, [r2]
 461:Source\FilteringFunctions/arm_fir_sparse_q15.c ****     blkCnt--;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 137


 1184              		.loc 1 461 0
 1185 0798 7B1C     		add	r3, r7, #1
 1186 079a FF33     		add	r3, r3, #255
 1187 079c 1B68     		ldr	r3, [r3]
 1188 079e 013B     		sub	r3, r3, #1
 1189 07a0 7A1C     		add	r2, r7, #1
 1190 07a2 FF32     		add	r2, r2, #255
 1191 07a4 1360     		str	r3, [r2]
 1192              	.L28:
 458:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   {
 1193              		.loc 1 458 0
 1194 07a6 7B1C     		add	r3, r7, #1
 1195 07a8 FF33     		add	r3, r3, #255
 1196 07aa 1B68     		ldr	r3, [r3]
 1197 07ac 002B     		cmp	r3, #0
 1198 07ae B3D1     		bne	.L35
 462:Source\FilteringFunctions/arm_fir_sparse_q15.c ****   }
 463:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 464:Source\FilteringFunctions/arm_fir_sparse_q15.c **** #endif /*   #if defined (ARM_MATH_DSP) */
 465:Source\FilteringFunctions/arm_fir_sparse_q15.c **** 
 466:Source\FilteringFunctions/arm_fir_sparse_q15.c **** }
 1199              		.loc 1 466 0
 1200 07b0 BD46     		mov	sp, r7
 1201 07b2 46B0     		add	sp, sp, #280
 1202              		@ sp needed
 1203 07b4 80BD     		pop	{r7, pc}
 1204              		.cfi_endproc
 1205              	.LFE82:
 1206              		.size	arm_fir_sparse_q15, .-arm_fir_sparse_q15
 1207 07b6 C046     		.text
 1208              	.Letext0:
 1209              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 1210              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 1211              		.section	.debug_info,"",%progbits
 1212              	.Ldebug_info0:
 1213 0000 75060000 		.4byte	0x675
 1214 0004 0400     		.2byte	0x4
 1215 0006 00000000 		.4byte	.Ldebug_abbrev0
 1216 000a 04       		.byte	0x4
 1217 000b 01       		.uleb128 0x1
 1218 000c F7000000 		.4byte	.LASF58
 1219 0010 01       		.byte	0x1
 1220 0011 4F020000 		.4byte	.LASF59
 1221 0015 87020000 		.4byte	.LASF60
 1222 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1223 001d 00000000 		.4byte	0
 1224 0021 00000000 		.4byte	.Ldebug_line0
 1225 0025 02       		.uleb128 0x2
 1226 0026 01       		.byte	0x1
 1227 0027 06       		.byte	0x6
 1228 0028 67000000 		.4byte	.LASF0
 1229 002c 02       		.uleb128 0x2
 1230 002d 01       		.byte	0x1
 1231 002e 08       		.byte	0x8
 1232 002f 35020000 		.4byte	.LASF1
 1233 0033 03       		.uleb128 0x3
 1234 0034 AE000000 		.4byte	.LASF3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 138


 1235 0038 03       		.byte	0x3
 1236 0039 29       		.byte	0x29
 1237 003a 3E000000 		.4byte	0x3e
 1238 003e 02       		.uleb128 0x2
 1239 003f 02       		.byte	0x2
 1240 0040 05       		.byte	0x5
 1241 0041 A4010000 		.4byte	.LASF2
 1242 0045 03       		.uleb128 0x3
 1243 0046 FE020000 		.4byte	.LASF4
 1244 004a 03       		.byte	0x3
 1245 004b 2B       		.byte	0x2b
 1246 004c 50000000 		.4byte	0x50
 1247 0050 02       		.uleb128 0x2
 1248 0051 02       		.byte	0x2
 1249 0052 07       		.byte	0x7
 1250 0053 89010000 		.4byte	.LASF5
 1251 0057 03       		.uleb128 0x3
 1252 0058 09030000 		.4byte	.LASF6
 1253 005c 03       		.byte	0x3
 1254 005d 3F       		.byte	0x3f
 1255 005e 62000000 		.4byte	0x62
 1256 0062 02       		.uleb128 0x2
 1257 0063 04       		.byte	0x4
 1258 0064 05       		.byte	0x5
 1259 0065 73000000 		.4byte	.LASF7
 1260 0069 03       		.uleb128 0x3
 1261 006a A3000000 		.4byte	.LASF8
 1262 006e 03       		.byte	0x3
 1263 006f 41       		.byte	0x41
 1264 0070 74000000 		.4byte	0x74
 1265 0074 02       		.uleb128 0x2
 1266 0075 04       		.byte	0x4
 1267 0076 07       		.byte	0x7
 1268 0077 E5000000 		.4byte	.LASF9
 1269 007b 02       		.uleb128 0x2
 1270 007c 08       		.byte	0x8
 1271 007d 05       		.byte	0x5
 1272 007e 59000000 		.4byte	.LASF10
 1273 0082 02       		.uleb128 0x2
 1274 0083 08       		.byte	0x8
 1275 0084 07       		.byte	0x7
 1276 0085 28000000 		.4byte	.LASF11
 1277 0089 04       		.uleb128 0x4
 1278 008a 04       		.byte	0x4
 1279 008b 05       		.byte	0x5
 1280 008c 696E7400 		.ascii	"int\000"
 1281 0090 02       		.uleb128 0x2
 1282 0091 04       		.byte	0x4
 1283 0092 07       		.byte	0x7
 1284 0093 C1000000 		.4byte	.LASF12
 1285 0097 03       		.uleb128 0x3
 1286 0098 51000000 		.4byte	.LASF13
 1287 009c 04       		.byte	0x4
 1288 009d 20       		.byte	0x20
 1289 009e 33000000 		.4byte	0x33
 1290 00a2 03       		.uleb128 0x3
 1291 00a3 87000000 		.4byte	.LASF14
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 139


 1292 00a7 04       		.byte	0x4
 1293 00a8 21       		.byte	0x21
 1294 00a9 45000000 		.4byte	0x45
 1295 00ad 03       		.uleb128 0x3
 1296 00ae 2D020000 		.4byte	.LASF15
 1297 00b2 04       		.byte	0x4
 1298 00b3 2C       		.byte	0x2c
 1299 00b4 57000000 		.4byte	0x57
 1300 00b8 03       		.uleb128 0x3
 1301 00b9 DB020000 		.4byte	.LASF16
 1302 00bd 04       		.byte	0x4
 1303 00be 2D       		.byte	0x2d
 1304 00bf 69000000 		.4byte	0x69
 1305 00c3 02       		.uleb128 0x2
 1306 00c4 04       		.byte	0x4
 1307 00c5 07       		.byte	0x7
 1308 00c6 D4010000 		.4byte	.LASF17
 1309 00ca 02       		.uleb128 0x2
 1310 00cb 01       		.byte	0x1
 1311 00cc 08       		.byte	0x8
 1312 00cd F9020000 		.4byte	.LASF18
 1313 00d1 02       		.uleb128 0x2
 1314 00d2 08       		.byte	0x8
 1315 00d3 04       		.byte	0x4
 1316 00d4 90000000 		.4byte	.LASF19
 1317 00d8 02       		.uleb128 0x2
 1318 00d9 04       		.byte	0x4
 1319 00da 04       		.byte	0x4
 1320 00db 0A020000 		.4byte	.LASF20
 1321 00df 02       		.uleb128 0x2
 1322 00e0 08       		.byte	0x8
 1323 00e1 04       		.byte	0x4
 1324 00e2 DD010000 		.4byte	.LASF21
 1325 00e6 05       		.uleb128 0x5
 1326 00e7 81000000 		.4byte	.LASF22
 1327 00eb 02       		.byte	0x2
 1328 00ec 9601     		.2byte	0x196
 1329 00ee 97000000 		.4byte	0x97
 1330 00f2 05       		.uleb128 0x5
 1331 00f3 D5020000 		.4byte	.LASF23
 1332 00f7 02       		.byte	0x2
 1333 00f8 9B01     		.2byte	0x19b
 1334 00fa AD000000 		.4byte	0xad
 1335 00fe 06       		.uleb128 0x6
 1336 00ff 04       		.byte	0x4
 1337 0100 E6000000 		.4byte	0xe6
 1338 0104 06       		.uleb128 0x6
 1339 0105 04       		.byte	0x4
 1340 0106 F2000000 		.4byte	0xf2
 1341 010a 06       		.uleb128 0x6
 1342 010b 04       		.byte	0x4
 1343 010c A2000000 		.4byte	0xa2
 1344 0110 06       		.uleb128 0x6
 1345 0111 04       		.byte	0x4
 1346 0112 16010000 		.4byte	0x116
 1347 0116 07       		.uleb128 0x7
 1348 0117 E6000000 		.4byte	0xe6
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 140


 1349 011b 06       		.uleb128 0x6
 1350 011c 04       		.byte	0x4
 1351 011d AD000000 		.4byte	0xad
 1352 0121 08       		.uleb128 0x8
 1353 0122 14       		.byte	0x14
 1354 0123 02       		.byte	0x2
 1355 0124 A911     		.2byte	0x11a9
 1356 0126 79010000 		.4byte	0x179
 1357 012a 09       		.uleb128 0x9
 1358 012b CD020000 		.4byte	.LASF24
 1359 012f 02       		.byte	0x2
 1360 0130 AB11     		.2byte	0x11ab
 1361 0132 A2000000 		.4byte	0xa2
 1362 0136 00       		.byte	0
 1363 0137 09       		.uleb128 0x9
 1364 0138 FF010000 		.4byte	.LASF25
 1365 013c 02       		.byte	0x2
 1366 013d AC11     		.2byte	0x11ac
 1367 013f A2000000 		.4byte	0xa2
 1368 0143 02       		.byte	0x2
 1369 0144 09       		.uleb128 0x9
 1370 0145 43020000 		.4byte	.LASF26
 1371 0149 02       		.byte	0x2
 1372 014a AD11     		.2byte	0x11ad
 1373 014c FE000000 		.4byte	0xfe
 1374 0150 04       		.byte	0x4
 1375 0151 09       		.uleb128 0x9
 1376 0152 46030000 		.4byte	.LASF27
 1377 0156 02       		.byte	0x2
 1378 0157 AE11     		.2byte	0x11ae
 1379 0159 FE000000 		.4byte	0xfe
 1380 015d 08       		.byte	0x8
 1381 015e 09       		.uleb128 0x9
 1382 015f 7E020000 		.4byte	.LASF28
 1383 0163 02       		.byte	0x2
 1384 0164 AF11     		.2byte	0x11af
 1385 0166 A2000000 		.4byte	0xa2
 1386 016a 0C       		.byte	0xc
 1387 016b 09       		.uleb128 0x9
 1388 016c 10020000 		.4byte	.LASF29
 1389 0170 02       		.byte	0x2
 1390 0171 B011     		.2byte	0x11b0
 1391 0173 1B010000 		.4byte	0x11b
 1392 0177 10       		.byte	0x10
 1393 0178 00       		.byte	0
 1394 0179 05       		.uleb128 0x5
 1395 017a AE010000 		.4byte	.LASF30
 1396 017e 02       		.byte	0x2
 1397 017f B111     		.2byte	0x11b1
 1398 0181 21010000 		.4byte	0x121
 1399 0185 0A       		.uleb128 0xa
 1400 0186 E9010000 		.4byte	.LASF37
 1401 018a 02       		.byte	0x2
 1402 018b 5217     		.2byte	0x1752
 1403 018d 03       		.byte	0x3
 1404 018e FB010000 		.4byte	0x1fb
 1405 0192 0B       		.uleb128 0xb
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 141


 1406 0193 46000000 		.4byte	.LASF31
 1407 0197 02       		.byte	0x2
 1408 0198 5317     		.2byte	0x1753
 1409 019a FE000000 		.4byte	0xfe
 1410 019e 0C       		.uleb128 0xc
 1411 019f 4C00     		.ascii	"L\000"
 1412 01a1 02       		.byte	0x2
 1413 01a2 5417     		.2byte	0x1754
 1414 01a4 AD000000 		.4byte	0xad
 1415 01a8 0B       		.uleb128 0xb
 1416 01a9 1A020000 		.4byte	.LASF32
 1417 01ad 02       		.byte	0x2
 1418 01ae 5517     		.2byte	0x1755
 1419 01b0 0A010000 		.4byte	0x10a
 1420 01b4 0B       		.uleb128 0xb
 1421 01b5 CA010000 		.4byte	.LASF33
 1422 01b9 02       		.byte	0x2
 1423 01ba 5617     		.2byte	0x1756
 1424 01bc AD000000 		.4byte	0xad
 1425 01c0 0C       		.uleb128 0xc
 1426 01c1 73726300 		.ascii	"src\000"
 1427 01c5 02       		.byte	0x2
 1428 01c6 5717     		.2byte	0x1757
 1429 01c8 10010000 		.4byte	0x110
 1430 01cc 0B       		.uleb128 0xb
 1431 01cd 0E000000 		.4byte	.LASF34
 1432 01d1 02       		.byte	0x2
 1433 01d2 5817     		.2byte	0x1758
 1434 01d4 AD000000 		.4byte	0xad
 1435 01d8 0B       		.uleb128 0xb
 1436 01d9 2E030000 		.4byte	.LASF35
 1437 01dd 02       		.byte	0x2
 1438 01de 5917     		.2byte	0x1759
 1439 01e0 B8000000 		.4byte	0xb8
 1440 01e4 0D       		.uleb128 0xd
 1441 01e5 6900     		.ascii	"i\000"
 1442 01e7 02       		.byte	0x2
 1443 01e8 5B17     		.2byte	0x175b
 1444 01ea B8000000 		.4byte	0xb8
 1445 01ee 0E       		.uleb128 0xe
 1446 01ef 55030000 		.4byte	.LASF36
 1447 01f3 02       		.byte	0x2
 1448 01f4 5C17     		.2byte	0x175c
 1449 01f6 AD000000 		.4byte	0xad
 1450 01fa 00       		.byte	0
 1451 01fb 0A       		.uleb128 0xa
 1452 01fc E4020000 		.4byte	.LASF38
 1453 0200 02       		.byte	0x2
 1454 0201 7E17     		.2byte	0x177e
 1455 0203 03       		.byte	0x3
 1456 0204 95020000 		.4byte	0x295
 1457 0208 0B       		.uleb128 0xb
 1458 0209 46000000 		.4byte	.LASF31
 1459 020d 02       		.byte	0x2
 1460 020e 7F17     		.2byte	0x177f
 1461 0210 FE000000 		.4byte	0xfe
 1462 0214 0C       		.uleb128 0xc
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 142


 1463 0215 4C00     		.ascii	"L\000"
 1464 0217 02       		.byte	0x2
 1465 0218 8017     		.2byte	0x1780
 1466 021a AD000000 		.4byte	0xad
 1467 021e 0B       		.uleb128 0xb
 1468 021f DA000000 		.4byte	.LASF39
 1469 0223 02       		.byte	0x2
 1470 0224 8117     		.2byte	0x1781
 1471 0226 1B010000 		.4byte	0x11b
 1472 022a 0B       		.uleb128 0xb
 1473 022b CA010000 		.4byte	.LASF33
 1474 022f 02       		.byte	0x2
 1475 0230 8217     		.2byte	0x1782
 1476 0232 AD000000 		.4byte	0xad
 1477 0236 0C       		.uleb128 0xc
 1478 0237 64737400 		.ascii	"dst\000"
 1479 023b 02       		.byte	0x2
 1480 023c 8317     		.2byte	0x1783
 1481 023e FE000000 		.4byte	0xfe
 1482 0242 0B       		.uleb128 0xb
 1483 0243 B8000000 		.4byte	.LASF40
 1484 0247 02       		.byte	0x2
 1485 0248 8417     		.2byte	0x1784
 1486 024a FE000000 		.4byte	0xfe
 1487 024e 0B       		.uleb128 0xb
 1488 024f 23030000 		.4byte	.LASF41
 1489 0253 02       		.byte	0x2
 1490 0254 8517     		.2byte	0x1785
 1491 0256 AD000000 		.4byte	0xad
 1492 025a 0B       		.uleb128 0xb
 1493 025b 26020000 		.4byte	.LASF42
 1494 025f 02       		.byte	0x2
 1495 0260 8617     		.2byte	0x1786
 1496 0262 AD000000 		.4byte	0xad
 1497 0266 0B       		.uleb128 0xb
 1498 0267 2E030000 		.4byte	.LASF35
 1499 026b 02       		.byte	0x2
 1500 026c 8717     		.2byte	0x1787
 1501 026e B8000000 		.4byte	0xb8
 1502 0272 0D       		.uleb128 0xd
 1503 0273 6900     		.ascii	"i\000"
 1504 0275 02       		.byte	0x2
 1505 0276 8917     		.2byte	0x1789
 1506 0278 B8000000 		.4byte	0xb8
 1507 027c 0E       		.uleb128 0xe
 1508 027d 9C010000 		.4byte	.LASF43
 1509 0281 02       		.byte	0x2
 1510 0282 8A17     		.2byte	0x178a
 1511 0284 AD000000 		.4byte	0xad
 1512 0288 0E       		.uleb128 0xe
 1513 0289 38030000 		.4byte	.LASF44
 1514 028d 02       		.byte	0x2
 1515 028e 8A17     		.2byte	0x178a
 1516 0290 AD000000 		.4byte	0xad
 1517 0294 00       		.byte	0
 1518 0295 0F       		.uleb128 0xf
 1519 0296 00000000 		.4byte	.LASF61
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 143


 1520 029a 02       		.byte	0x2
 1521 029b B402     		.2byte	0x2b4
 1522 029d F2000000 		.4byte	0xf2
 1523 02a1 03       		.byte	0x3
 1524 02a2 DD020000 		.4byte	0x2dd
 1525 02a6 0C       		.uleb128 0xc
 1526 02a7 7800     		.ascii	"x\000"
 1527 02a9 02       		.byte	0x2
 1528 02aa B502     		.2byte	0x2b5
 1529 02ac F2000000 		.4byte	0xf2
 1530 02b0 0C       		.uleb128 0xc
 1531 02b1 7900     		.ascii	"y\000"
 1532 02b3 02       		.byte	0x2
 1533 02b4 B602     		.2byte	0x2b6
 1534 02b6 B8000000 		.4byte	0xb8
 1535 02ba 0E       		.uleb128 0xe
 1536 02bb 4E030000 		.4byte	.LASF45
 1537 02bf 02       		.byte	0x2
 1538 02c0 B802     		.2byte	0x2b8
 1539 02c2 AD000000 		.4byte	0xad
 1540 02c6 0E       		.uleb128 0xe
 1541 02c7 07000000 		.4byte	.LASF46
 1542 02cb 02       		.byte	0x2
 1543 02cc B802     		.2byte	0x2b8
 1544 02ce AD000000 		.4byte	0xad
 1545 02d2 0D       		.uleb128 0xd
 1546 02d3 6900     		.ascii	"i\000"
 1547 02d5 02       		.byte	0x2
 1548 02d6 B902     		.2byte	0x2b9
 1549 02d8 B8000000 		.4byte	0xb8
 1550 02dc 00       		.byte	0
 1551 02dd 10       		.uleb128 0x10
 1552 02de 15000000 		.4byte	.LASF62
 1553 02e2 01       		.byte	0x1
 1554 02e3 39       		.byte	0x39
 1555 02e4 00000000 		.4byte	.LFB82
 1556 02e8 B6070000 		.4byte	.LFE82-.LFB82
 1557 02ec 01       		.uleb128 0x1
 1558 02ed 9C       		.byte	0x9c
 1559 02ee 72060000 		.4byte	0x672
 1560 02f2 11       		.uleb128 0x11
 1561 02f3 5300     		.ascii	"S\000"
 1562 02f5 01       		.byte	0x1
 1563 02f6 3A       		.byte	0x3a
 1564 02f7 72060000 		.4byte	0x672
 1565 02fb 03       		.uleb128 0x3
 1566 02fc 91       		.byte	0x91
 1567 02fd EC7D     		.sleb128 -276
 1568 02ff 12       		.uleb128 0x12
 1569 0300 CE000000 		.4byte	.LASF47
 1570 0304 01       		.byte	0x1
 1571 0305 3B       		.byte	0x3b
 1572 0306 FE000000 		.4byte	0xfe
 1573 030a 03       		.uleb128 0x3
 1574 030b 91       		.byte	0x91
 1575 030c E87D     		.sleb128 -280
 1576 030e 12       		.uleb128 0x12
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 144


 1577 030f 7C000000 		.4byte	.LASF48
 1578 0313 01       		.byte	0x1
 1579 0314 3C       		.byte	0x3c
 1580 0315 FE000000 		.4byte	0xfe
 1581 0319 03       		.uleb128 0x3
 1582 031a 91       		.byte	0x91
 1583 031b E47D     		.sleb128 -284
 1584 031d 12       		.uleb128 0x12
 1585 031e 5D030000 		.4byte	.LASF49
 1586 0322 01       		.byte	0x1
 1587 0323 3D       		.byte	0x3d
 1588 0324 FE000000 		.4byte	0xfe
 1589 0328 03       		.uleb128 0x3
 1590 0329 91       		.byte	0x91
 1591 032a E07D     		.sleb128 -288
 1592 032c 12       		.uleb128 0x12
 1593 032d 97000000 		.4byte	.LASF50
 1594 0331 01       		.byte	0x1
 1595 0332 3E       		.byte	0x3e
 1596 0333 04010000 		.4byte	0x104
 1597 0337 02       		.uleb128 0x2
 1598 0338 91       		.byte	0x91
 1599 0339 00       		.sleb128 0
 1600 033a 12       		.uleb128 0x12
 1601 033b 2E030000 		.4byte	.LASF35
 1602 033f 01       		.byte	0x1
 1603 0340 3F       		.byte	0x3f
 1604 0341 B8000000 		.4byte	0xb8
 1605 0345 02       		.uleb128 0x2
 1606 0346 91       		.byte	0x91
 1607 0347 04       		.sleb128 4
 1608 0348 13       		.uleb128 0x13
 1609 0349 43020000 		.4byte	.LASF26
 1610 034d 01       		.byte	0x1
 1611 034e 42       		.byte	0x42
 1612 034f FE000000 		.4byte	0xfe
 1613 0353 02       		.uleb128 0x2
 1614 0354 91       		.byte	0x91
 1615 0355 54       		.sleb128 -44
 1616 0356 14       		.uleb128 0x14
 1617 0357 70496E00 		.ascii	"pIn\000"
 1618 035b 01       		.byte	0x1
 1619 035c 43       		.byte	0x43
 1620 035d FE000000 		.4byte	0xfe
 1621 0361 02       		.uleb128 0x2
 1622 0362 91       		.byte	0x91
 1623 0363 50       		.sleb128 -48
 1624 0364 13       		.uleb128 0x13
 1625 0365 4A020000 		.4byte	.LASF51
 1626 0369 01       		.byte	0x1
 1627 036a 44       		.byte	0x44
 1628 036b FE000000 		.4byte	0xfe
 1629 036f 02       		.uleb128 0x2
 1630 0370 91       		.byte	0x91
 1631 0371 74       		.sleb128 -12
 1632 0372 13       		.uleb128 0x13
 1633 0373 46030000 		.4byte	.LASF27
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 145


 1634 0377 01       		.byte	0x1
 1635 0378 45       		.byte	0x45
 1636 0379 FE000000 		.4byte	0xfe
 1637 037d 02       		.uleb128 0x2
 1638 037e 91       		.byte	0x91
 1639 037f 70       		.sleb128 -16
 1640 0380 14       		.uleb128 0x14
 1641 0381 707800   		.ascii	"px\000"
 1642 0384 01       		.byte	0x1
 1643 0385 46       		.byte	0x46
 1644 0386 FE000000 		.4byte	0xfe
 1645 038a 02       		.uleb128 0x2
 1646 038b 91       		.byte	0x91
 1647 038c 6C       		.sleb128 -20
 1648 038d 14       		.uleb128 0x14
 1649 038e 706200   		.ascii	"pb\000"
 1650 0391 01       		.byte	0x1
 1651 0392 47       		.byte	0x47
 1652 0393 FE000000 		.4byte	0xfe
 1653 0397 02       		.uleb128 0x2
 1654 0398 91       		.byte	0x91
 1655 0399 4C       		.sleb128 -52
 1656 039a 14       		.uleb128 0x14
 1657 039b 707900   		.ascii	"py\000"
 1658 039e 01       		.byte	0x1
 1659 039f 48       		.byte	0x48
 1660 03a0 FE000000 		.4byte	0xfe
 1661 03a4 02       		.uleb128 0x2
 1662 03a5 91       		.byte	0x91
 1663 03a6 48       		.sleb128 -56
 1664 03a7 13       		.uleb128 0x13
 1665 03a8 10020000 		.4byte	.LASF29
 1666 03ac 01       		.byte	0x1
 1667 03ad 49       		.byte	0x49
 1668 03ae 1B010000 		.4byte	0x11b
 1669 03b2 02       		.uleb128 0x2
 1670 03b3 91       		.byte	0x91
 1671 03b4 68       		.sleb128 -24
 1672 03b5 13       		.uleb128 0x13
 1673 03b6 68030000 		.4byte	.LASF52
 1674 03ba 01       		.byte	0x1
 1675 03bb 4A       		.byte	0x4a
 1676 03bc B8000000 		.4byte	0xb8
 1677 03c0 02       		.uleb128 0x2
 1678 03c1 91       		.byte	0x91
 1679 03c2 44       		.sleb128 -60
 1680 03c3 13       		.uleb128 0x13
 1681 03c4 CD020000 		.4byte	.LASF24
 1682 03c8 01       		.byte	0x1
 1683 03c9 4B       		.byte	0x4b
 1684 03ca A2000000 		.4byte	0xa2
 1685 03ce 02       		.uleb128 0x2
 1686 03cf 91       		.byte	0x91
 1687 03d0 42       		.sleb128 -62
 1688 03d1 13       		.uleb128 0x13
 1689 03d2 13030000 		.4byte	.LASF53
 1690 03d6 01       		.byte	0x1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 146


 1691 03d7 4C       		.byte	0x4c
 1692 03d8 AD000000 		.4byte	0xad
 1693 03dc 03       		.uleb128 0x3
 1694 03dd 91       		.byte	0x91
 1695 03de F47D     		.sleb128 -268
 1696 03e0 13       		.uleb128 0x13
 1697 03e1 D3000000 		.4byte	.LASF54
 1698 03e5 01       		.byte	0x1
 1699 03e6 4D       		.byte	0x4d
 1700 03e7 B8000000 		.4byte	0xb8
 1701 03eb 02       		.uleb128 0x2
 1702 03ec 91       		.byte	0x91
 1703 03ed 64       		.sleb128 -28
 1704 03ee 13       		.uleb128 0x13
 1705 03ef 3F000000 		.4byte	.LASF55
 1706 03f3 01       		.byte	0x1
 1707 03f4 4D       		.byte	0x4d
 1708 03f5 B8000000 		.4byte	0xb8
 1709 03f9 02       		.uleb128 0x2
 1710 03fa 91       		.byte	0x91
 1711 03fb 60       		.sleb128 -32
 1712 03fc 13       		.uleb128 0x13
 1713 03fd 1D030000 		.4byte	.LASF56
 1714 0401 01       		.byte	0x1
 1715 0402 4E       		.byte	0x4e
 1716 0403 E6000000 		.4byte	0xe6
 1717 0407 02       		.uleb128 0x2
 1718 0408 91       		.byte	0x91
 1719 0409 5E       		.sleb128 -34
 1720 040a 13       		.uleb128 0x13
 1721 040b 40030000 		.4byte	.LASF57
 1722 040f 01       		.byte	0x1
 1723 0410 4F       		.byte	0x4f
 1724 0411 04010000 		.4byte	0x104
 1725 0415 02       		.uleb128 0x2
 1726 0416 91       		.byte	0x91
 1727 0417 58       		.sleb128 -40
 1728 0418 15       		.uleb128 0x15
 1729 0419 85010000 		.4byte	0x185
 1730 041d EA000000 		.4byte	.LBB12
 1731 0421 B4000000 		.4byte	.LBE12-.LBB12
 1732 0425 01       		.byte	0x1
 1733 0426 4A01     		.2byte	0x14a
 1734 0428 88040000 		.4byte	0x488
 1735 042c 16       		.uleb128 0x16
 1736 042d D8010000 		.4byte	0x1d8
 1737 0431 03       		.uleb128 0x3
 1738 0432 91       		.byte	0x91
 1739 0433 A47F     		.sleb128 -92
 1740 0435 16       		.uleb128 0x16
 1741 0436 CC010000 		.4byte	0x1cc
 1742 043a 03       		.uleb128 0x3
 1743 043b 91       		.byte	0x91
 1744 043c A87F     		.sleb128 -88
 1745 043e 16       		.uleb128 0x16
 1746 043f C0010000 		.4byte	0x1c0
 1747 0443 03       		.uleb128 0x3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 147


 1748 0444 91       		.byte	0x91
 1749 0445 AC7F     		.sleb128 -84
 1750 0447 16       		.uleb128 0x16
 1751 0448 B4010000 		.4byte	0x1b4
 1752 044c 03       		.uleb128 0x3
 1753 044d 91       		.byte	0x91
 1754 044e B07F     		.sleb128 -80
 1755 0450 16       		.uleb128 0x16
 1756 0451 A8010000 		.4byte	0x1a8
 1757 0455 03       		.uleb128 0x3
 1758 0456 91       		.byte	0x91
 1759 0457 B47F     		.sleb128 -76
 1760 0459 16       		.uleb128 0x16
 1761 045a 9E010000 		.4byte	0x19e
 1762 045e 03       		.uleb128 0x3
 1763 045f 91       		.byte	0x91
 1764 0460 B87F     		.sleb128 -72
 1765 0462 16       		.uleb128 0x16
 1766 0463 92010000 		.4byte	0x192
 1767 0467 03       		.uleb128 0x3
 1768 0468 91       		.byte	0x91
 1769 0469 BC7F     		.sleb128 -68
 1770 046b 17       		.uleb128 0x17
 1771 046c EA000000 		.4byte	.LBB13
 1772 0470 B4000000 		.4byte	.LBE13-.LBB13
 1773 0474 18       		.uleb128 0x18
 1774 0475 E4010000 		.4byte	0x1e4
 1775 0479 03       		.uleb128 0x3
 1776 047a 91       		.byte	0x91
 1777 047b A07F     		.sleb128 -96
 1778 047d 18       		.uleb128 0x18
 1779 047e EE010000 		.4byte	0x1ee
 1780 0482 03       		.uleb128 0x3
 1781 0483 91       		.byte	0x91
 1782 0484 9C7F     		.sleb128 -100
 1783 0486 00       		.byte	0
 1784 0487 00       		.byte	0
 1785 0488 15       		.uleb128 0x15
 1786 0489 FB010000 		.4byte	0x1fb
 1787 048d 56020000 		.4byte	.LBB14
 1788 0491 E4000000 		.4byte	.LBE14-.LBB14
 1789 0495 01       		.byte	0x1
 1790 0496 5C01     		.2byte	0x15c
 1791 0498 13050000 		.4byte	0x513
 1792 049c 16       		.uleb128 0x16
 1793 049d 66020000 		.4byte	0x266
 1794 04a1 03       		.uleb128 0x3
 1795 04a2 91       		.byte	0x91
 1796 04a3 F87E     		.sleb128 -136
 1797 04a5 16       		.uleb128 0x16
 1798 04a6 5A020000 		.4byte	0x25a
 1799 04aa 03       		.uleb128 0x3
 1800 04ab 91       		.byte	0x91
 1801 04ac FC7E     		.sleb128 -132
 1802 04ae 16       		.uleb128 0x16
 1803 04af 4E020000 		.4byte	0x24e
 1804 04b3 03       		.uleb128 0x3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 148


 1805 04b4 91       		.byte	0x91
 1806 04b5 807F     		.sleb128 -128
 1807 04b7 16       		.uleb128 0x16
 1808 04b8 42020000 		.4byte	0x242
 1809 04bc 03       		.uleb128 0x3
 1810 04bd 91       		.byte	0x91
 1811 04be 847F     		.sleb128 -124
 1812 04c0 16       		.uleb128 0x16
 1813 04c1 36020000 		.4byte	0x236
 1814 04c5 03       		.uleb128 0x3
 1815 04c6 91       		.byte	0x91
 1816 04c7 887F     		.sleb128 -120
 1817 04c9 16       		.uleb128 0x16
 1818 04ca 2A020000 		.4byte	0x22a
 1819 04ce 03       		.uleb128 0x3
 1820 04cf 91       		.byte	0x91
 1821 04d0 8C7F     		.sleb128 -116
 1822 04d2 16       		.uleb128 0x16
 1823 04d3 1E020000 		.4byte	0x21e
 1824 04d7 03       		.uleb128 0x3
 1825 04d8 91       		.byte	0x91
 1826 04d9 907F     		.sleb128 -112
 1827 04db 16       		.uleb128 0x16
 1828 04dc 14020000 		.4byte	0x214
 1829 04e0 03       		.uleb128 0x3
 1830 04e1 91       		.byte	0x91
 1831 04e2 947F     		.sleb128 -108
 1832 04e4 16       		.uleb128 0x16
 1833 04e5 08020000 		.4byte	0x208
 1834 04e9 03       		.uleb128 0x3
 1835 04ea 91       		.byte	0x91
 1836 04eb 987F     		.sleb128 -104
 1837 04ed 17       		.uleb128 0x17
 1838 04ee 56020000 		.4byte	.LBB15
 1839 04f2 E4000000 		.4byte	.LBE15-.LBB15
 1840 04f6 18       		.uleb128 0x18
 1841 04f7 72020000 		.4byte	0x272
 1842 04fb 03       		.uleb128 0x3
 1843 04fc 91       		.byte	0x91
 1844 04fd F47E     		.sleb128 -140
 1845 04ff 18       		.uleb128 0x18
 1846 0500 7C020000 		.4byte	0x27c
 1847 0504 03       		.uleb128 0x3
 1848 0505 91       		.byte	0x91
 1849 0506 F07E     		.sleb128 -144
 1850 0508 18       		.uleb128 0x18
 1851 0509 88020000 		.4byte	0x288
 1852 050d 03       		.uleb128 0x3
 1853 050e 91       		.byte	0x91
 1854 050f EC7E     		.sleb128 -148
 1855 0511 00       		.byte	0
 1856 0512 00       		.byte	0
 1857 0513 15       		.uleb128 0x15
 1858 0514 FB010000 		.4byte	0x1fb
 1859 0518 70040000 		.4byte	.LBB16
 1860 051c 7C000000 		.4byte	.LBE16-.LBB16
 1861 0520 01       		.byte	0x1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 149


 1862 0521 8601     		.2byte	0x186
 1863 0523 9E050000 		.4byte	0x59e
 1864 0527 16       		.uleb128 0x16
 1865 0528 66020000 		.4byte	0x266
 1866 052c 03       		.uleb128 0x3
 1867 052d 91       		.byte	0x91
 1868 052e C87E     		.sleb128 -184
 1869 0530 16       		.uleb128 0x16
 1870 0531 5A020000 		.4byte	0x25a
 1871 0535 03       		.uleb128 0x3
 1872 0536 91       		.byte	0x91
 1873 0537 CC7E     		.sleb128 -180
 1874 0539 16       		.uleb128 0x16
 1875 053a 4E020000 		.4byte	0x24e
 1876 053e 03       		.uleb128 0x3
 1877 053f 91       		.byte	0x91
 1878 0540 D07E     		.sleb128 -176
 1879 0542 16       		.uleb128 0x16
 1880 0543 42020000 		.4byte	0x242
 1881 0547 03       		.uleb128 0x3
 1882 0548 91       		.byte	0x91
 1883 0549 D47E     		.sleb128 -172
 1884 054b 16       		.uleb128 0x16
 1885 054c 36020000 		.4byte	0x236
 1886 0550 03       		.uleb128 0x3
 1887 0551 91       		.byte	0x91
 1888 0552 D87E     		.sleb128 -168
 1889 0554 16       		.uleb128 0x16
 1890 0555 2A020000 		.4byte	0x22a
 1891 0559 03       		.uleb128 0x3
 1892 055a 91       		.byte	0x91
 1893 055b DC7E     		.sleb128 -164
 1894 055d 16       		.uleb128 0x16
 1895 055e 1E020000 		.4byte	0x21e
 1896 0562 03       		.uleb128 0x3
 1897 0563 91       		.byte	0x91
 1898 0564 E07E     		.sleb128 -160
 1899 0566 16       		.uleb128 0x16
 1900 0567 14020000 		.4byte	0x214
 1901 056b 03       		.uleb128 0x3
 1902 056c 91       		.byte	0x91
 1903 056d E47E     		.sleb128 -156
 1904 056f 16       		.uleb128 0x16
 1905 0570 08020000 		.4byte	0x208
 1906 0574 03       		.uleb128 0x3
 1907 0575 91       		.byte	0x91
 1908 0576 E87E     		.sleb128 -152
 1909 0578 17       		.uleb128 0x17
 1910 0579 70040000 		.4byte	.LBB17
 1911 057d 7C000000 		.4byte	.LBE17-.LBB17
 1912 0581 18       		.uleb128 0x18
 1913 0582 72020000 		.4byte	0x272
 1914 0586 03       		.uleb128 0x3
 1915 0587 91       		.byte	0x91
 1916 0588 C47E     		.sleb128 -188
 1917 058a 18       		.uleb128 0x18
 1918 058b 7C020000 		.4byte	0x27c
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 150


 1919 058f 03       		.uleb128 0x3
 1920 0590 91       		.byte	0x91
 1921 0591 C07E     		.sleb128 -192
 1922 0593 18       		.uleb128 0x18
 1923 0594 88020000 		.4byte	0x288
 1924 0598 03       		.uleb128 0x3
 1925 0599 91       		.byte	0x91
 1926 059a BC7E     		.sleb128 -196
 1927 059c 00       		.byte	0
 1928 059d 00       		.byte	0
 1929 059e 15       		.uleb128 0x15
 1930 059f FB010000 		.4byte	0x1fb
 1931 05a3 24060000 		.4byte	.LBB18
 1932 05a7 68000000 		.4byte	.LBE18-.LBB18
 1933 05ab 01       		.byte	0x1
 1934 05ac B101     		.2byte	0x1b1
 1935 05ae 29060000 		.4byte	0x629
 1936 05b2 16       		.uleb128 0x16
 1937 05b3 66020000 		.4byte	0x266
 1938 05b7 03       		.uleb128 0x3
 1939 05b8 91       		.byte	0x91
 1940 05b9 987E     		.sleb128 -232
 1941 05bb 16       		.uleb128 0x16
 1942 05bc 5A020000 		.4byte	0x25a
 1943 05c0 03       		.uleb128 0x3
 1944 05c1 91       		.byte	0x91
 1945 05c2 9C7E     		.sleb128 -228
 1946 05c4 16       		.uleb128 0x16
 1947 05c5 4E020000 		.4byte	0x24e
 1948 05c9 03       		.uleb128 0x3
 1949 05ca 91       		.byte	0x91
 1950 05cb A07E     		.sleb128 -224
 1951 05cd 16       		.uleb128 0x16
 1952 05ce 42020000 		.4byte	0x242
 1953 05d2 03       		.uleb128 0x3
 1954 05d3 91       		.byte	0x91
 1955 05d4 A47E     		.sleb128 -220
 1956 05d6 16       		.uleb128 0x16
 1957 05d7 36020000 		.4byte	0x236
 1958 05db 03       		.uleb128 0x3
 1959 05dc 91       		.byte	0x91
 1960 05dd A87E     		.sleb128 -216
 1961 05df 16       		.uleb128 0x16
 1962 05e0 2A020000 		.4byte	0x22a
 1963 05e4 03       		.uleb128 0x3
 1964 05e5 91       		.byte	0x91
 1965 05e6 AC7E     		.sleb128 -212
 1966 05e8 16       		.uleb128 0x16
 1967 05e9 1E020000 		.4byte	0x21e
 1968 05ed 03       		.uleb128 0x3
 1969 05ee 91       		.byte	0x91
 1970 05ef B07E     		.sleb128 -208
 1971 05f1 16       		.uleb128 0x16
 1972 05f2 14020000 		.4byte	0x214
 1973 05f6 03       		.uleb128 0x3
 1974 05f7 91       		.byte	0x91
 1975 05f8 B47E     		.sleb128 -204
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 151


 1976 05fa 16       		.uleb128 0x16
 1977 05fb 08020000 		.4byte	0x208
 1978 05ff 03       		.uleb128 0x3
 1979 0600 91       		.byte	0x91
 1980 0601 B87E     		.sleb128 -200
 1981 0603 17       		.uleb128 0x17
 1982 0604 24060000 		.4byte	.LBB19
 1983 0608 68000000 		.4byte	.LBE19-.LBB19
 1984 060c 18       		.uleb128 0x18
 1985 060d 72020000 		.4byte	0x272
 1986 0611 03       		.uleb128 0x3
 1987 0612 91       		.byte	0x91
 1988 0613 947E     		.sleb128 -236
 1989 0615 18       		.uleb128 0x18
 1990 0616 7C020000 		.4byte	0x27c
 1991 061a 03       		.uleb128 0x3
 1992 061b 91       		.byte	0x91
 1993 061c 907E     		.sleb128 -240
 1994 061e 18       		.uleb128 0x18
 1995 061f 88020000 		.4byte	0x288
 1996 0623 03       		.uleb128 0x3
 1997 0624 91       		.byte	0x91
 1998 0625 8C7E     		.sleb128 -244
 1999 0627 00       		.byte	0
 2000 0628 00       		.byte	0
 2001 0629 19       		.uleb128 0x19
 2002 062a 95020000 		.4byte	0x295
 2003 062e 42070000 		.4byte	.LBB20
 2004 0632 52000000 		.4byte	.LBE20-.LBB20
 2005 0636 01       		.byte	0x1
 2006 0637 CC01     		.2byte	0x1cc
 2007 0639 16       		.uleb128 0x16
 2008 063a B0020000 		.4byte	0x2b0
 2009 063e 03       		.uleb128 0x3
 2010 063f 91       		.byte	0x91
 2011 0640 847E     		.sleb128 -252
 2012 0642 16       		.uleb128 0x16
 2013 0643 A6020000 		.4byte	0x2a6
 2014 0647 03       		.uleb128 0x3
 2015 0648 91       		.byte	0x91
 2016 0649 887E     		.sleb128 -248
 2017 064b 17       		.uleb128 0x17
 2018 064c 42070000 		.4byte	.LBB21
 2019 0650 52000000 		.4byte	.LBE21-.LBB21
 2020 0654 18       		.uleb128 0x18
 2021 0655 BA020000 		.4byte	0x2ba
 2022 0659 03       		.uleb128 0x3
 2023 065a 91       		.byte	0x91
 2024 065b 807E     		.sleb128 -256
 2025 065d 18       		.uleb128 0x18
 2026 065e C6020000 		.4byte	0x2c6
 2027 0662 03       		.uleb128 0x3
 2028 0663 91       		.byte	0x91
 2029 0664 F87D     		.sleb128 -264
 2030 0666 18       		.uleb128 0x18
 2031 0667 D2020000 		.4byte	0x2d2
 2032 066b 03       		.uleb128 0x3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 152


 2033 066c 91       		.byte	0x91
 2034 066d FC7D     		.sleb128 -260
 2035 066f 00       		.byte	0
 2036 0670 00       		.byte	0
 2037 0671 00       		.byte	0
 2038 0672 06       		.uleb128 0x6
 2039 0673 04       		.byte	0x4
 2040 0674 79010000 		.4byte	0x179
 2041 0678 00       		.byte	0
 2042              		.section	.debug_abbrev,"",%progbits
 2043              	.Ldebug_abbrev0:
 2044 0000 01       		.uleb128 0x1
 2045 0001 11       		.uleb128 0x11
 2046 0002 01       		.byte	0x1
 2047 0003 25       		.uleb128 0x25
 2048 0004 0E       		.uleb128 0xe
 2049 0005 13       		.uleb128 0x13
 2050 0006 0B       		.uleb128 0xb
 2051 0007 03       		.uleb128 0x3
 2052 0008 0E       		.uleb128 0xe
 2053 0009 1B       		.uleb128 0x1b
 2054 000a 0E       		.uleb128 0xe
 2055 000b 55       		.uleb128 0x55
 2056 000c 17       		.uleb128 0x17
 2057 000d 11       		.uleb128 0x11
 2058 000e 01       		.uleb128 0x1
 2059 000f 10       		.uleb128 0x10
 2060 0010 17       		.uleb128 0x17
 2061 0011 00       		.byte	0
 2062 0012 00       		.byte	0
 2063 0013 02       		.uleb128 0x2
 2064 0014 24       		.uleb128 0x24
 2065 0015 00       		.byte	0
 2066 0016 0B       		.uleb128 0xb
 2067 0017 0B       		.uleb128 0xb
 2068 0018 3E       		.uleb128 0x3e
 2069 0019 0B       		.uleb128 0xb
 2070 001a 03       		.uleb128 0x3
 2071 001b 0E       		.uleb128 0xe
 2072 001c 00       		.byte	0
 2073 001d 00       		.byte	0
 2074 001e 03       		.uleb128 0x3
 2075 001f 16       		.uleb128 0x16
 2076 0020 00       		.byte	0
 2077 0021 03       		.uleb128 0x3
 2078 0022 0E       		.uleb128 0xe
 2079 0023 3A       		.uleb128 0x3a
 2080 0024 0B       		.uleb128 0xb
 2081 0025 3B       		.uleb128 0x3b
 2082 0026 0B       		.uleb128 0xb
 2083 0027 49       		.uleb128 0x49
 2084 0028 13       		.uleb128 0x13
 2085 0029 00       		.byte	0
 2086 002a 00       		.byte	0
 2087 002b 04       		.uleb128 0x4
 2088 002c 24       		.uleb128 0x24
 2089 002d 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 153


 2090 002e 0B       		.uleb128 0xb
 2091 002f 0B       		.uleb128 0xb
 2092 0030 3E       		.uleb128 0x3e
 2093 0031 0B       		.uleb128 0xb
 2094 0032 03       		.uleb128 0x3
 2095 0033 08       		.uleb128 0x8
 2096 0034 00       		.byte	0
 2097 0035 00       		.byte	0
 2098 0036 05       		.uleb128 0x5
 2099 0037 16       		.uleb128 0x16
 2100 0038 00       		.byte	0
 2101 0039 03       		.uleb128 0x3
 2102 003a 0E       		.uleb128 0xe
 2103 003b 3A       		.uleb128 0x3a
 2104 003c 0B       		.uleb128 0xb
 2105 003d 3B       		.uleb128 0x3b
 2106 003e 05       		.uleb128 0x5
 2107 003f 49       		.uleb128 0x49
 2108 0040 13       		.uleb128 0x13
 2109 0041 00       		.byte	0
 2110 0042 00       		.byte	0
 2111 0043 06       		.uleb128 0x6
 2112 0044 0F       		.uleb128 0xf
 2113 0045 00       		.byte	0
 2114 0046 0B       		.uleb128 0xb
 2115 0047 0B       		.uleb128 0xb
 2116 0048 49       		.uleb128 0x49
 2117 0049 13       		.uleb128 0x13
 2118 004a 00       		.byte	0
 2119 004b 00       		.byte	0
 2120 004c 07       		.uleb128 0x7
 2121 004d 26       		.uleb128 0x26
 2122 004e 00       		.byte	0
 2123 004f 49       		.uleb128 0x49
 2124 0050 13       		.uleb128 0x13
 2125 0051 00       		.byte	0
 2126 0052 00       		.byte	0
 2127 0053 08       		.uleb128 0x8
 2128 0054 13       		.uleb128 0x13
 2129 0055 01       		.byte	0x1
 2130 0056 0B       		.uleb128 0xb
 2131 0057 0B       		.uleb128 0xb
 2132 0058 3A       		.uleb128 0x3a
 2133 0059 0B       		.uleb128 0xb
 2134 005a 3B       		.uleb128 0x3b
 2135 005b 05       		.uleb128 0x5
 2136 005c 01       		.uleb128 0x1
 2137 005d 13       		.uleb128 0x13
 2138 005e 00       		.byte	0
 2139 005f 00       		.byte	0
 2140 0060 09       		.uleb128 0x9
 2141 0061 0D       		.uleb128 0xd
 2142 0062 00       		.byte	0
 2143 0063 03       		.uleb128 0x3
 2144 0064 0E       		.uleb128 0xe
 2145 0065 3A       		.uleb128 0x3a
 2146 0066 0B       		.uleb128 0xb
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 154


 2147 0067 3B       		.uleb128 0x3b
 2148 0068 05       		.uleb128 0x5
 2149 0069 49       		.uleb128 0x49
 2150 006a 13       		.uleb128 0x13
 2151 006b 38       		.uleb128 0x38
 2152 006c 0B       		.uleb128 0xb
 2153 006d 00       		.byte	0
 2154 006e 00       		.byte	0
 2155 006f 0A       		.uleb128 0xa
 2156 0070 2E       		.uleb128 0x2e
 2157 0071 01       		.byte	0x1
 2158 0072 03       		.uleb128 0x3
 2159 0073 0E       		.uleb128 0xe
 2160 0074 3A       		.uleb128 0x3a
 2161 0075 0B       		.uleb128 0xb
 2162 0076 3B       		.uleb128 0x3b
 2163 0077 05       		.uleb128 0x5
 2164 0078 27       		.uleb128 0x27
 2165 0079 19       		.uleb128 0x19
 2166 007a 20       		.uleb128 0x20
 2167 007b 0B       		.uleb128 0xb
 2168 007c 01       		.uleb128 0x1
 2169 007d 13       		.uleb128 0x13
 2170 007e 00       		.byte	0
 2171 007f 00       		.byte	0
 2172 0080 0B       		.uleb128 0xb
 2173 0081 05       		.uleb128 0x5
 2174 0082 00       		.byte	0
 2175 0083 03       		.uleb128 0x3
 2176 0084 0E       		.uleb128 0xe
 2177 0085 3A       		.uleb128 0x3a
 2178 0086 0B       		.uleb128 0xb
 2179 0087 3B       		.uleb128 0x3b
 2180 0088 05       		.uleb128 0x5
 2181 0089 49       		.uleb128 0x49
 2182 008a 13       		.uleb128 0x13
 2183 008b 00       		.byte	0
 2184 008c 00       		.byte	0
 2185 008d 0C       		.uleb128 0xc
 2186 008e 05       		.uleb128 0x5
 2187 008f 00       		.byte	0
 2188 0090 03       		.uleb128 0x3
 2189 0091 08       		.uleb128 0x8
 2190 0092 3A       		.uleb128 0x3a
 2191 0093 0B       		.uleb128 0xb
 2192 0094 3B       		.uleb128 0x3b
 2193 0095 05       		.uleb128 0x5
 2194 0096 49       		.uleb128 0x49
 2195 0097 13       		.uleb128 0x13
 2196 0098 00       		.byte	0
 2197 0099 00       		.byte	0
 2198 009a 0D       		.uleb128 0xd
 2199 009b 34       		.uleb128 0x34
 2200 009c 00       		.byte	0
 2201 009d 03       		.uleb128 0x3
 2202 009e 08       		.uleb128 0x8
 2203 009f 3A       		.uleb128 0x3a
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 155


 2204 00a0 0B       		.uleb128 0xb
 2205 00a1 3B       		.uleb128 0x3b
 2206 00a2 05       		.uleb128 0x5
 2207 00a3 49       		.uleb128 0x49
 2208 00a4 13       		.uleb128 0x13
 2209 00a5 00       		.byte	0
 2210 00a6 00       		.byte	0
 2211 00a7 0E       		.uleb128 0xe
 2212 00a8 34       		.uleb128 0x34
 2213 00a9 00       		.byte	0
 2214 00aa 03       		.uleb128 0x3
 2215 00ab 0E       		.uleb128 0xe
 2216 00ac 3A       		.uleb128 0x3a
 2217 00ad 0B       		.uleb128 0xb
 2218 00ae 3B       		.uleb128 0x3b
 2219 00af 05       		.uleb128 0x5
 2220 00b0 49       		.uleb128 0x49
 2221 00b1 13       		.uleb128 0x13
 2222 00b2 00       		.byte	0
 2223 00b3 00       		.byte	0
 2224 00b4 0F       		.uleb128 0xf
 2225 00b5 2E       		.uleb128 0x2e
 2226 00b6 01       		.byte	0x1
 2227 00b7 03       		.uleb128 0x3
 2228 00b8 0E       		.uleb128 0xe
 2229 00b9 3A       		.uleb128 0x3a
 2230 00ba 0B       		.uleb128 0xb
 2231 00bb 3B       		.uleb128 0x3b
 2232 00bc 05       		.uleb128 0x5
 2233 00bd 27       		.uleb128 0x27
 2234 00be 19       		.uleb128 0x19
 2235 00bf 49       		.uleb128 0x49
 2236 00c0 13       		.uleb128 0x13
 2237 00c1 20       		.uleb128 0x20
 2238 00c2 0B       		.uleb128 0xb
 2239 00c3 01       		.uleb128 0x1
 2240 00c4 13       		.uleb128 0x13
 2241 00c5 00       		.byte	0
 2242 00c6 00       		.byte	0
 2243 00c7 10       		.uleb128 0x10
 2244 00c8 2E       		.uleb128 0x2e
 2245 00c9 01       		.byte	0x1
 2246 00ca 3F       		.uleb128 0x3f
 2247 00cb 19       		.uleb128 0x19
 2248 00cc 03       		.uleb128 0x3
 2249 00cd 0E       		.uleb128 0xe
 2250 00ce 3A       		.uleb128 0x3a
 2251 00cf 0B       		.uleb128 0xb
 2252 00d0 3B       		.uleb128 0x3b
 2253 00d1 0B       		.uleb128 0xb
 2254 00d2 27       		.uleb128 0x27
 2255 00d3 19       		.uleb128 0x19
 2256 00d4 11       		.uleb128 0x11
 2257 00d5 01       		.uleb128 0x1
 2258 00d6 12       		.uleb128 0x12
 2259 00d7 06       		.uleb128 0x6
 2260 00d8 40       		.uleb128 0x40
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 156


 2261 00d9 18       		.uleb128 0x18
 2262 00da 9742     		.uleb128 0x2117
 2263 00dc 19       		.uleb128 0x19
 2264 00dd 01       		.uleb128 0x1
 2265 00de 13       		.uleb128 0x13
 2266 00df 00       		.byte	0
 2267 00e0 00       		.byte	0
 2268 00e1 11       		.uleb128 0x11
 2269 00e2 05       		.uleb128 0x5
 2270 00e3 00       		.byte	0
 2271 00e4 03       		.uleb128 0x3
 2272 00e5 08       		.uleb128 0x8
 2273 00e6 3A       		.uleb128 0x3a
 2274 00e7 0B       		.uleb128 0xb
 2275 00e8 3B       		.uleb128 0x3b
 2276 00e9 0B       		.uleb128 0xb
 2277 00ea 49       		.uleb128 0x49
 2278 00eb 13       		.uleb128 0x13
 2279 00ec 02       		.uleb128 0x2
 2280 00ed 18       		.uleb128 0x18
 2281 00ee 00       		.byte	0
 2282 00ef 00       		.byte	0
 2283 00f0 12       		.uleb128 0x12
 2284 00f1 05       		.uleb128 0x5
 2285 00f2 00       		.byte	0
 2286 00f3 03       		.uleb128 0x3
 2287 00f4 0E       		.uleb128 0xe
 2288 00f5 3A       		.uleb128 0x3a
 2289 00f6 0B       		.uleb128 0xb
 2290 00f7 3B       		.uleb128 0x3b
 2291 00f8 0B       		.uleb128 0xb
 2292 00f9 49       		.uleb128 0x49
 2293 00fa 13       		.uleb128 0x13
 2294 00fb 02       		.uleb128 0x2
 2295 00fc 18       		.uleb128 0x18
 2296 00fd 00       		.byte	0
 2297 00fe 00       		.byte	0
 2298 00ff 13       		.uleb128 0x13
 2299 0100 34       		.uleb128 0x34
 2300 0101 00       		.byte	0
 2301 0102 03       		.uleb128 0x3
 2302 0103 0E       		.uleb128 0xe
 2303 0104 3A       		.uleb128 0x3a
 2304 0105 0B       		.uleb128 0xb
 2305 0106 3B       		.uleb128 0x3b
 2306 0107 0B       		.uleb128 0xb
 2307 0108 49       		.uleb128 0x49
 2308 0109 13       		.uleb128 0x13
 2309 010a 02       		.uleb128 0x2
 2310 010b 18       		.uleb128 0x18
 2311 010c 00       		.byte	0
 2312 010d 00       		.byte	0
 2313 010e 14       		.uleb128 0x14
 2314 010f 34       		.uleb128 0x34
 2315 0110 00       		.byte	0
 2316 0111 03       		.uleb128 0x3
 2317 0112 08       		.uleb128 0x8
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 157


 2318 0113 3A       		.uleb128 0x3a
 2319 0114 0B       		.uleb128 0xb
 2320 0115 3B       		.uleb128 0x3b
 2321 0116 0B       		.uleb128 0xb
 2322 0117 49       		.uleb128 0x49
 2323 0118 13       		.uleb128 0x13
 2324 0119 02       		.uleb128 0x2
 2325 011a 18       		.uleb128 0x18
 2326 011b 00       		.byte	0
 2327 011c 00       		.byte	0
 2328 011d 15       		.uleb128 0x15
 2329 011e 1D       		.uleb128 0x1d
 2330 011f 01       		.byte	0x1
 2331 0120 31       		.uleb128 0x31
 2332 0121 13       		.uleb128 0x13
 2333 0122 11       		.uleb128 0x11
 2334 0123 01       		.uleb128 0x1
 2335 0124 12       		.uleb128 0x12
 2336 0125 06       		.uleb128 0x6
 2337 0126 58       		.uleb128 0x58
 2338 0127 0B       		.uleb128 0xb
 2339 0128 59       		.uleb128 0x59
 2340 0129 05       		.uleb128 0x5
 2341 012a 01       		.uleb128 0x1
 2342 012b 13       		.uleb128 0x13
 2343 012c 00       		.byte	0
 2344 012d 00       		.byte	0
 2345 012e 16       		.uleb128 0x16
 2346 012f 05       		.uleb128 0x5
 2347 0130 00       		.byte	0
 2348 0131 31       		.uleb128 0x31
 2349 0132 13       		.uleb128 0x13
 2350 0133 02       		.uleb128 0x2
 2351 0134 18       		.uleb128 0x18
 2352 0135 00       		.byte	0
 2353 0136 00       		.byte	0
 2354 0137 17       		.uleb128 0x17
 2355 0138 0B       		.uleb128 0xb
 2356 0139 01       		.byte	0x1
 2357 013a 11       		.uleb128 0x11
 2358 013b 01       		.uleb128 0x1
 2359 013c 12       		.uleb128 0x12
 2360 013d 06       		.uleb128 0x6
 2361 013e 00       		.byte	0
 2362 013f 00       		.byte	0
 2363 0140 18       		.uleb128 0x18
 2364 0141 34       		.uleb128 0x34
 2365 0142 00       		.byte	0
 2366 0143 31       		.uleb128 0x31
 2367 0144 13       		.uleb128 0x13
 2368 0145 02       		.uleb128 0x2
 2369 0146 18       		.uleb128 0x18
 2370 0147 00       		.byte	0
 2371 0148 00       		.byte	0
 2372 0149 19       		.uleb128 0x19
 2373 014a 1D       		.uleb128 0x1d
 2374 014b 01       		.byte	0x1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 158


 2375 014c 31       		.uleb128 0x31
 2376 014d 13       		.uleb128 0x13
 2377 014e 11       		.uleb128 0x11
 2378 014f 01       		.uleb128 0x1
 2379 0150 12       		.uleb128 0x12
 2380 0151 06       		.uleb128 0x6
 2381 0152 58       		.uleb128 0x58
 2382 0153 0B       		.uleb128 0xb
 2383 0154 59       		.uleb128 0x59
 2384 0155 05       		.uleb128 0x5
 2385 0156 00       		.byte	0
 2386 0157 00       		.byte	0
 2387 0158 00       		.byte	0
 2388              		.section	.debug_aranges,"",%progbits
 2389 0000 1C000000 		.4byte	0x1c
 2390 0004 0200     		.2byte	0x2
 2391 0006 00000000 		.4byte	.Ldebug_info0
 2392 000a 04       		.byte	0x4
 2393 000b 00       		.byte	0
 2394 000c 0000     		.2byte	0
 2395 000e 0000     		.2byte	0
 2396 0010 00000000 		.4byte	.LFB82
 2397 0014 B6070000 		.4byte	.LFE82-.LFB82
 2398 0018 00000000 		.4byte	0
 2399 001c 00000000 		.4byte	0
 2400              		.section	.debug_ranges,"",%progbits
 2401              	.Ldebug_ranges0:
 2402 0000 00000000 		.4byte	.LFB82
 2403 0004 B6070000 		.4byte	.LFE82
 2404 0008 00000000 		.4byte	0
 2405 000c 00000000 		.4byte	0
 2406              		.section	.debug_line,"",%progbits
 2407              	.Ldebug_line0:
 2408 0000 51020000 		.section	.debug_str,"MS",%progbits,1
 2408      02005501 
 2408      00000201 
 2408      FB0E0D00 
 2408      01010101 
 2409              	.LASF61:
 2410 0000 5F5F5353 		.ascii	"__SSAT\000"
 2410      415400
 2411              	.LASF46:
 2412 0007 6E65674D 		.ascii	"negMin\000"
 2412      696E00
 2413              	.LASF34:
 2414 000e 73726349 		.ascii	"srcInc\000"
 2414      6E6300
 2415              	.LASF62:
 2416 0015 61726D5F 		.ascii	"arm_fir_sparse_q15\000"
 2416      6669725F 
 2416      73706172 
 2416      73655F71 
 2416      313500
 2417              	.LASF11:
 2418 0028 6C6F6E67 		.ascii	"long long unsigned int\000"
 2418      206C6F6E 
 2418      6720756E 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 159


 2418      7369676E 
 2418      65642069 
 2419              	.LASF55:
 2420 003f 626C6B43 		.ascii	"blkCnt\000"
 2420      6E7400
 2421              	.LASF31:
 2422 0046 63697263 		.ascii	"circBuffer\000"
 2422      42756666 
 2422      657200
 2423              	.LASF13:
 2424 0051 696E7431 		.ascii	"int16_t\000"
 2424      365F7400 
 2425              	.LASF10:
 2426 0059 6C6F6E67 		.ascii	"long long int\000"
 2426      206C6F6E 
 2426      6720696E 
 2426      7400
 2427              	.LASF0:
 2428 0067 7369676E 		.ascii	"signed char\000"
 2428      65642063 
 2428      68617200 
 2429              	.LASF7:
 2430 0073 6C6F6E67 		.ascii	"long int\000"
 2430      20696E74 
 2430      00
 2431              	.LASF48:
 2432 007c 70447374 		.ascii	"pDst\000"
 2432      00
 2433              	.LASF22:
 2434 0081 7131355F 		.ascii	"q15_t\000"
 2434      7400
 2435              	.LASF14:
 2436 0087 75696E74 		.ascii	"uint16_t\000"
 2436      31365F74 
 2436      00
 2437              	.LASF19:
 2438 0090 646F7562 		.ascii	"double\000"
 2438      6C6500
 2439              	.LASF50:
 2440 0097 70536372 		.ascii	"pScratchOut\000"
 2440      61746368 
 2440      4F757400 
 2441              	.LASF8:
 2442 00a3 5F5F7569 		.ascii	"__uint32_t\000"
 2442      6E743332 
 2442      5F7400
 2443              	.LASF3:
 2444 00ae 5F5F696E 		.ascii	"__int16_t\000"
 2444      7431365F 
 2444      7400
 2445              	.LASF40:
 2446 00b8 6473745F 		.ascii	"dst_base\000"
 2446      62617365 
 2446      00
 2447              	.LASF12:
 2448 00c1 756E7369 		.ascii	"unsigned int\000"
 2448      676E6564 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 160


 2448      20696E74 
 2448      00
 2449              	.LASF47:
 2450 00ce 70537263 		.ascii	"pSrc\000"
 2450      00
 2451              	.LASF54:
 2452 00d3 74617043 		.ascii	"tapCnt\000"
 2452      6E7400
 2453              	.LASF39:
 2454 00da 72656164 		.ascii	"readOffset\000"
 2454      4F666673 
 2454      657400
 2455              	.LASF9:
 2456 00e5 6C6F6E67 		.ascii	"long unsigned int\000"
 2456      20756E73 
 2456      69676E65 
 2456      6420696E 
 2456      7400
 2457              	.LASF58:
 2458 00f7 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 2458      4320342E 
 2458      392E3320 
 2458      32303135 
 2458      30333033 
 2459 012a 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0plus -mthumb -"
 2459      20726576 
 2459      6973696F 
 2459      6E203232 
 2459      31323230 
 2460 015d 67202D4F 		.ascii	"g -O0 -ffunction-sections -ffat-lto-objects\000"
 2460      30202D66 
 2460      66756E63 
 2460      74696F6E 
 2460      2D736563 
 2461              	.LASF5:
 2462 0189 73686F72 		.ascii	"short unsigned int\000"
 2462      7420756E 
 2462      7369676E 
 2462      65642069 
 2462      6E7400
 2463              	.LASF43:
 2464 019c 724F6666 		.ascii	"rOffset\000"
 2464      73657400 
 2465              	.LASF2:
 2466 01a4 73686F72 		.ascii	"short int\000"
 2466      7420696E 
 2466      7400
 2467              	.LASF30:
 2468 01ae 61726D5F 		.ascii	"arm_fir_sparse_instance_q15\000"
 2468      6669725F 
 2468      73706172 
 2468      73655F69 
 2468      6E737461 
 2469              	.LASF33:
 2470 01ca 62756666 		.ascii	"bufferInc\000"
 2470      6572496E 
 2470      6300
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 161


 2471              	.LASF17:
 2472 01d4 73697A65 		.ascii	"sizetype\000"
 2472      74797065 
 2472      00
 2473              	.LASF21:
 2474 01dd 6C6F6E67 		.ascii	"long double\000"
 2474      20646F75 
 2474      626C6500 
 2475              	.LASF37:
 2476 01e9 61726D5F 		.ascii	"arm_circularWrite_q15\000"
 2476      63697263 
 2476      756C6172 
 2476      57726974 
 2476      655F7131 
 2477              	.LASF25:
 2478 01ff 73746174 		.ascii	"stateIndex\000"
 2478      65496E64 
 2478      657800
 2479              	.LASF20:
 2480 020a 666C6F61 		.ascii	"float\000"
 2480      7400
 2481              	.LASF29:
 2482 0210 70546170 		.ascii	"pTapDelay\000"
 2482      44656C61 
 2482      7900
 2483              	.LASF32:
 2484 021a 77726974 		.ascii	"writeOffset\000"
 2484      654F6666 
 2484      73657400 
 2485              	.LASF42:
 2486 0226 64737449 		.ascii	"dstInc\000"
 2486      6E6300
 2487              	.LASF15:
 2488 022d 696E7433 		.ascii	"int32_t\000"
 2488      325F7400 
 2489              	.LASF1:
 2490 0235 756E7369 		.ascii	"unsigned char\000"
 2490      676E6564 
 2490      20636861 
 2490      7200
 2491              	.LASF26:
 2492 0243 70537461 		.ascii	"pState\000"
 2492      746500
 2493              	.LASF51:
 2494 024a 704F7574 		.ascii	"pOut\000"
 2494      00
 2495              	.LASF59:
 2496 024f 536F7572 		.ascii	"Source\\FilteringFunctions\\arm_fir_sparse_q15.c\000"
 2496      63655C46 
 2496      696C7465 
 2496      72696E67 
 2496      46756E63 
 2497              	.LASF28:
 2498 027e 6D617844 		.ascii	"maxDelay\000"
 2498      656C6179 
 2498      00
 2499              	.LASF60:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 162


 2500 0287 433A5C55 		.ascii	"C:\\Users\\fneves\\Documents\\PSoC Creator\\wp_1\\e"
 2500      73657273 
 2500      5C666E65 
 2500      7665735C 
 2500      446F6375 
 2501 02b4 6E67696E 		.ascii	"ngine_speed_sensor.cydsn\000"
 2501      655F7370 
 2501      6565645F 
 2501      73656E73 
 2501      6F722E63 
 2502              	.LASF24:
 2503 02cd 6E756D54 		.ascii	"numTaps\000"
 2503      61707300 
 2504              	.LASF23:
 2505 02d5 7133315F 		.ascii	"q31_t\000"
 2505      7400
 2506              	.LASF16:
 2507 02db 75696E74 		.ascii	"uint32_t\000"
 2507      33325F74 
 2507      00
 2508              	.LASF38:
 2509 02e4 61726D5F 		.ascii	"arm_circularRead_q15\000"
 2509      63697263 
 2509      756C6172 
 2509      52656164 
 2509      5F713135 
 2510              	.LASF18:
 2511 02f9 63686172 		.ascii	"char\000"
 2511      00
 2512              	.LASF4:
 2513 02fe 5F5F7569 		.ascii	"__uint16_t\000"
 2513      6E743136 
 2513      5F7400
 2514              	.LASF6:
 2515 0309 5F5F696E 		.ascii	"__int32_t\000"
 2515      7433325F 
 2515      7400
 2516              	.LASF53:
 2517 0313 72656164 		.ascii	"readIndex\000"
 2517      496E6465 
 2517      7800
 2518              	.LASF56:
 2519 031d 636F6566 		.ascii	"coeff\000"
 2519      6600
 2520              	.LASF41:
 2521 0323 6473745F 		.ascii	"dst_length\000"
 2521      6C656E67 
 2521      746800
 2522              	.LASF35:
 2523 032e 626C6F63 		.ascii	"blockSize\000"
 2523      6B53697A 
 2523      6500
 2524              	.LASF44:
 2525 0338 6473745F 		.ascii	"dst_end\000"
 2525      656E6400 
 2526              	.LASF57:
 2527 0340 70536372 		.ascii	"pScr2\000"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\ccZJae5g.s 			page 163


 2527      3200
 2528              	.LASF27:
 2529 0346 70436F65 		.ascii	"pCoeffs\000"
 2529      66667300 
 2530              	.LASF45:
 2531 034e 706F734D 		.ascii	"posMax\000"
 2531      617800
 2532              	.LASF36:
 2533 0355 774F6666 		.ascii	"wOffset\000"
 2533      73657400 
 2534              	.LASF49:
 2535 035d 70536372 		.ascii	"pScratchIn\000"
 2535      61746368 
 2535      496E00
 2536              	.LASF52:
 2537 0368 64656C61 		.ascii	"delaySize\000"
 2537      7953697A 
 2537      6500
 2538              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
