ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 1


   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"arm_fir_sparse_f32.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_fmul
  18              		.global	__aeabi_fadd
  19              		.section	.text.arm_fir_sparse_f32,"ax",%progbits
  20              		.align	2
  21              		.global	arm_fir_sparse_f32
  22              		.code	16
  23              		.thumb_func
  24              		.type	arm_fir_sparse_f32, %function
  25              	arm_fir_sparse_f32:
  26              	.LFB82:
  27              		.file 1 "Source\\FilteringFunctions\\arm_fir_sparse_f32.c"
   1:Source\FilteringFunctions/arm_fir_sparse_f32.c **** /* ----------------------------------------------------------------------
   2:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Project:      CMSIS DSP Library
   3:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Title:        arm_fir_sparse_f32.c
   4:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Description:  Floating-point sparse FIR filter processing function
   5:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
   6:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * $Date:        27. January 2017
   7:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * $Revision:    V.1.5.1
   8:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
   9:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Target Processor: Cortex-M cores
  10:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * -------------------------------------------------------------------- */
  11:Source\FilteringFunctions/arm_fir_sparse_f32.c **** /*
  12:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  14:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * SPDX-License-Identifier: Apache-2.0
  15:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  16:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * not use this file except in compliance with the License.
  18:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * You may obtain a copy of the License at
  19:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  20:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  22:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Unless required by applicable law or agreed to in writing, software
  23:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * See the License for the specific language governing permissions and
  26:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * limitations under the License.
  27:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  */
  28:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
  29:Source\FilteringFunctions/arm_fir_sparse_f32.c **** #include "arm_math.h"
  30:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 2


  31:Source\FilteringFunctions/arm_fir_sparse_f32.c **** /**
  32:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @ingroup groupFilters
  33:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  */
  34:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
  35:Source\FilteringFunctions/arm_fir_sparse_f32.c **** /**
  36:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @defgroup FIR_Sparse Finite Impulse Response (FIR) Sparse Filters
  37:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  38:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * This group of functions implements sparse FIR filters.
  39:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Sparse FIR filters are equivalent to standard FIR filters except that most of the coefficients a
  40:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Sparse filters are used for simulating reflections in communications and audio applications.
  41:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  42:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * There are separate functions for Q7, Q15, Q31, and floating-point data types.
  43:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * The functions operate on blocks  of input and output data and each call to the function processe
  44:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <code>blockSize</code> samples through the filter.  <code>pSrc</code> and
  45:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <code>pDst</code> points to input and output arrays respectively containing <code>blockSize</cod
  46:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  47:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par Algorithm:
  48:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * The sparse filter instant structure contains an array of tap indices <code>pTapDelay</code> whic
  49:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * This is in addition to the coefficient array <code>b</code>.
  50:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * The implementation essentially skips the multiplications by zero and leads to an efficient reali
  51:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <pre>
  52:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *     y[n] = b[0] * x[n-pTapDelay[0]] + b[1] * x[n-pTapDelay[1]] + b[2] * x[n-pTapDelay[2]] + ...+
  53:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * </pre>
  54:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par
  55:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \image html FIRSparse.gif "Sparse FIR filter.  b[n] represents the filter coefficients"
  56:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par
  57:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <code>pCoeffs</code> points to a coefficient array of size <code>numTaps</code>;
  58:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <code>pTapDelay</code> points to an array of nonzero indices and is also of size <code>numTaps</
  59:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <code>pState</code> points to a state array of size <code>maxDelay + blockSize</code>, where
  60:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <code>maxDelay</code> is the largest offset value that is ever used in the <code>pTapDelay</code
  61:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Some of the processing functions also require temporary working buffers.
  62:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  63:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par Instance Structure
  64:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * The coefficients and state variables for a filter are stored together in an instance data struct
  65:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * A separate instance structure must be defined for each filter.
  66:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Coefficient and offset arrays may be shared among several instances while state variable arrays 
  67:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * There are separate instance structure declarations for each of the 4 supported data types.
  68:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  69:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par Initialization Functions
  70:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * There is also an associated initialization function for each data type.
  71:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * The initialization function performs the following operations:
  72:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * - Sets the values of the internal structure fields.
  73:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * - Zeros out the values in the state buffer.
  74:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * To do this manually without calling the init function, assign the follow subfields of the instan
  75:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * numTaps, pCoeffs, pTapDelay, maxDelay, stateIndex, pState. Also set all of the values in pState 
  76:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  77:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par
  78:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Use of the initialization function is optional.
  79:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * However, if the initialization function is used, then the instance structure cannot be placed in
  80:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * To place an instance structure into a const data section, the instance structure must be manuall
  81:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Set the values in the state buffer to zeros before static initialization.
  82:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * The code below statically initializes each of the 4 different data type filter instance structur
  83:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * <pre>
  84:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *arm_fir_sparse_instance_f32 S = {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};
  85:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *arm_fir_sparse_instance_q31 S = {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};
  86:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *arm_fir_sparse_instance_q15 S = {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};
  87:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *arm_fir_sparse_instance_q7 S =  {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 3


  88:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * </pre>
  89:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par
  90:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  *
  91:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * \par Fixed-Point Behavior
  92:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Care must be taken when using the fixed-point versions of the sparse FIR filter functions.
  93:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * In particular, the overflow and saturation behavior of the accumulator used in each function mus
  94:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * Refer to the function specific documentation below for usage guidelines.
  95:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  */
  96:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
  97:Source\FilteringFunctions/arm_fir_sparse_f32.c **** /**
  98:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @addtogroup FIR_Sparse
  99:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @{
 100:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  */
 101:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 102:Source\FilteringFunctions/arm_fir_sparse_f32.c **** /**
 103:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @brief Processing function for the floating-point sparse FIR filter.
 104:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @param[in]  *S          points to an instance of the floating-point sparse FIR structure.
 105:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @param[in]  *pSrc       points to the block of input data.
 106:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @param[out] *pDst       points to the block of output data
 107:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
 108:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @param[in]  blockSize   number of input samples to process per call.
 109:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  * @return none.
 110:Source\FilteringFunctions/arm_fir_sparse_f32.c ****  */
 111:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 112:Source\FilteringFunctions/arm_fir_sparse_f32.c **** void arm_fir_sparse_f32(
 113:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   arm_fir_sparse_instance_f32 * S,
 114:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t * pSrc,
 115:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t * pDst,
 116:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t * pScratchIn,
 117:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   uint32_t blockSize)
 118:Source\FilteringFunctions/arm_fir_sparse_f32.c **** {
  28              		.loc 1 118 0
  29              		.cfi_startproc
  30 0000 90B5     		push	{r4, r7, lr}
  31              		.cfi_def_cfa_offset 12
  32              		.cfi_offset 4, -12
  33              		.cfi_offset 7, -8
  34              		.cfi_offset 14, -4
  35 0002 BFB0     		sub	sp, sp, #252
  36              		.cfi_def_cfa_offset 264
  37 0004 00AF     		add	r7, sp, #0
  38              		.cfi_def_cfa_register 7
  39 0006 F860     		str	r0, [r7, #12]
  40 0008 B960     		str	r1, [r7, #8]
  41 000a 7A60     		str	r2, [r7, #4]
  42 000c 3B60     		str	r3, [r7]
 119:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 120:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t *pState = S->pState;                 /* State pointer */
  43              		.loc 1 120 0
  44 000e FB68     		ldr	r3, [r7, #12]
  45 0010 5B68     		ldr	r3, [r3, #4]
  46 0012 D822     		mov	r2, #216
  47 0014 BA18     		add	r2, r7, r2
  48 0016 1360     		str	r3, [r2]
 121:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
  49              		.loc 1 121 0
  50 0018 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 4


  51 001a 9B68     		ldr	r3, [r3, #8]
  52 001c F422     		mov	r2, #244
  53 001e BA18     		add	r2, r7, r2
  54 0020 1360     		str	r3, [r2]
 122:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t *px;                                 /* Scratch buffer pointer */
 123:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t *py = pState;                        /* Temporary pointers for state buffer */
  55              		.loc 1 123 0
  56 0022 D823     		mov	r3, #216
  57 0024 FB18     		add	r3, r7, r3
  58 0026 1B68     		ldr	r3, [r3]
  59 0028 D422     		mov	r2, #212
  60 002a BA18     		add	r2, r7, r2
  61 002c 1360     		str	r3, [r2]
 124:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t *pb = pScratchIn;                    /* Temporary pointers for scratch buffer */
  62              		.loc 1 124 0
  63 002e 3B68     		ldr	r3, [r7]
  64 0030 D022     		mov	r2, #208
  65 0032 BA18     		add	r2, r7, r2
  66 0034 1360     		str	r3, [r2]
 125:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t *pOut;                               /* Destination pointer */
 126:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the n
  67              		.loc 1 126 0
  68 0036 FB68     		ldr	r3, [r7, #12]
  69 0038 1B69     		ldr	r3, [r3, #16]
  70 003a E822     		mov	r2, #232
  71 003c BA18     		add	r2, r7, r2
  72 003e 1360     		str	r3, [r2]
 127:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
  73              		.loc 1 127 0
  74 0040 FB68     		ldr	r3, [r7, #12]
  75 0042 9B89     		ldrh	r3, [r3, #12]
  76 0044 1A1C     		mov	r2, r3
  77 0046 8423     		mov	r3, #132
  78 0048 5B00     		lsl	r3, r3, #1
  79 004a FB18     		add	r3, r7, r3
  80 004c 1B68     		ldr	r3, [r3]
  81 004e D318     		add	r3, r2, r3
  82 0050 CC22     		mov	r2, #204
  83 0052 BA18     		add	r2, r7, r2
  84 0054 1360     		str	r3, [r2]
 128:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   uint16_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter  */
  85              		.loc 1 128 0
  86 0056 CA23     		mov	r3, #202
  87 0058 FB18     		add	r3, r7, r3
  88 005a FA68     		ldr	r2, [r7, #12]
  89 005c 1288     		ldrh	r2, [r2]
  90 005e 1A80     		strh	r2, [r3]
 129:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   int32_t readIndex;                             /* Read index of the state buffer */
 130:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   uint32_t tapCnt, blkCnt;                       /* loop counters */
 131:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   float32_t coeff = *pCoeffs++;                  /* Read the first coefficient value */
  91              		.loc 1 131 0
  92 0060 F423     		mov	r3, #244
  93 0062 FB18     		add	r3, r7, r3
  94 0064 1B68     		ldr	r3, [r3]
  95 0066 1A1D     		add	r2, r3, #4
  96 0068 F421     		mov	r1, #244
  97 006a 7918     		add	r1, r7, r1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 5


  98 006c 0A60     		str	r2, [r1]
  99 006e 1B68     		ldr	r3, [r3]
 100 0070 DC22     		mov	r2, #220
 101 0072 BA18     		add	r2, r7, r2
 102 0074 1360     		str	r3, [r2]
 132:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 133:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 134:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 135:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* BlockSize of Input samples are copied into the state buffer */
 136:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* StateIndex points to the starting position to write in the state buffer */
 137:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,
 103              		.loc 1 137 0
 104 0076 CC23     		mov	r3, #204
 105 0078 FB18     		add	r3, r7, r3
 106 007a 1A68     		ldr	r2, [r3]
 107 007c FB68     		ldr	r3, [r7, #12]
 108 007e 0233     		add	r3, r3, #2
 109 0080 D421     		mov	r1, #212
 110 0082 7918     		add	r1, r7, r1
 111 0084 0968     		ldr	r1, [r1]
 112 0086 C420     		mov	r0, #196
 113 0088 3818     		add	r0, r7, r0
 114 008a 0160     		str	r1, [r0]
 115 008c C021     		mov	r1, #192
 116 008e 7918     		add	r1, r7, r1
 117 0090 0A60     		str	r2, [r1]
 118 0092 BC22     		mov	r2, #188
 119 0094 BA18     		add	r2, r7, r2
 120 0096 1360     		str	r3, [r2]
 121 0098 0123     		mov	r3, #1
 122 009a B822     		mov	r2, #184
 123 009c BA18     		add	r2, r7, r2
 124 009e 1360     		str	r3, [r2]
 125 00a0 BB68     		ldr	r3, [r7, #8]
 126 00a2 B422     		mov	r2, #180
 127 00a4 BA18     		add	r2, r7, r2
 128 00a6 1360     		str	r3, [r2]
 129 00a8 0123     		mov	r3, #1
 130 00aa B022     		mov	r2, #176
 131 00ac BA18     		add	r2, r7, r2
 132 00ae 1360     		str	r3, [r2]
 133 00b0 8423     		mov	r3, #132
 134 00b2 5B00     		lsl	r3, r3, #1
 135 00b4 FB18     		add	r3, r7, r3
 136 00b6 1B68     		ldr	r3, [r3]
 137 00b8 AC22     		mov	r2, #172
 138 00ba BA18     		add	r2, r7, r2
 139 00bc 1360     		str	r3, [r2]
 140              	.LBB10:
 141              	.LBB11:
 142              		.file 2 ".\\Include/arm_math.h"
   1:.\Include/arm_math.h **** /* ----------------------------------------------------------------------
   2:.\Include/arm_math.h ****  * Project:      CMSIS DSP Library
   3:.\Include/arm_math.h ****  * Title:        arm_math.h
   4:.\Include/arm_math.h ****  * Description:  Public header file for CMSIS DSP Library
   5:.\Include/arm_math.h ****  *
   6:.\Include/arm_math.h ****  * $Date:        27. January 2017
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 6


   7:.\Include/arm_math.h ****  * $Revision:    V.1.5.1
   8:.\Include/arm_math.h ****  *
   9:.\Include/arm_math.h ****  * Target Processor: Cortex-M cores
  10:.\Include/arm_math.h ****  * -------------------------------------------------------------------- */
  11:.\Include/arm_math.h **** /*
  12:.\Include/arm_math.h ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:.\Include/arm_math.h ****  *
  14:.\Include/arm_math.h ****  * SPDX-License-Identifier: Apache-2.0
  15:.\Include/arm_math.h ****  *
  16:.\Include/arm_math.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:.\Include/arm_math.h ****  * not use this file except in compliance with the License.
  18:.\Include/arm_math.h ****  * You may obtain a copy of the License at
  19:.\Include/arm_math.h ****  *
  20:.\Include/arm_math.h ****  * www.apache.org/licenses/LICENSE-2.0
  21:.\Include/arm_math.h ****  *
  22:.\Include/arm_math.h ****  * Unless required by applicable law or agreed to in writing, software
  23:.\Include/arm_math.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:.\Include/arm_math.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:.\Include/arm_math.h ****  * See the License for the specific language governing permissions and
  26:.\Include/arm_math.h ****  * limitations under the License.
  27:.\Include/arm_math.h ****  */
  28:.\Include/arm_math.h **** 
  29:.\Include/arm_math.h **** /**
  30:.\Include/arm_math.h ****    \mainpage CMSIS DSP Software Library
  31:.\Include/arm_math.h ****    *
  32:.\Include/arm_math.h ****    * Introduction
  33:.\Include/arm_math.h ****    * ------------
  34:.\Include/arm_math.h ****    *
  35:.\Include/arm_math.h ****    * This user manual describes the CMSIS DSP software library,
  36:.\Include/arm_math.h ****    * a suite of common signal processing functions for use on Cortex-M processor based devices.
  37:.\Include/arm_math.h ****    *
  38:.\Include/arm_math.h ****    * The library is divided into a number of functions each covering a specific category:
  39:.\Include/arm_math.h ****    * - Basic math functions
  40:.\Include/arm_math.h ****    * - Fast math functions
  41:.\Include/arm_math.h ****    * - Complex math functions
  42:.\Include/arm_math.h ****    * - Filters
  43:.\Include/arm_math.h ****    * - Matrix functions
  44:.\Include/arm_math.h ****    * - Transforms
  45:.\Include/arm_math.h ****    * - Motor control functions
  46:.\Include/arm_math.h ****    * - Statistical functions
  47:.\Include/arm_math.h ****    * - Support functions
  48:.\Include/arm_math.h ****    * - Interpolation functions
  49:.\Include/arm_math.h ****    *
  50:.\Include/arm_math.h ****    * The library has separate functions for operating on 8-bit integers, 16-bit integers,
  51:.\Include/arm_math.h ****    * 32-bit integer and 32-bit floating-point values.
  52:.\Include/arm_math.h ****    *
  53:.\Include/arm_math.h ****    * Using the Library
  54:.\Include/arm_math.h ****    * ------------
  55:.\Include/arm_math.h ****    *
  56:.\Include/arm_math.h ****    * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> fold
  57:.\Include/arm_math.h ****    * - arm_cortexM7lfdp_math.lib (Cortex-M7, Little endian, Double Precision Floating Point Unit)
  58:.\Include/arm_math.h ****    * - arm_cortexM7bfdp_math.lib (Cortex-M7, Big endian, Double Precision Floating Point Unit)
  59:.\Include/arm_math.h ****    * - arm_cortexM7lfsp_math.lib (Cortex-M7, Little endian, Single Precision Floating Point Unit)
  60:.\Include/arm_math.h ****    * - arm_cortexM7bfsp_math.lib (Cortex-M7, Big endian and Single Precision Floating Point Unit on
  61:.\Include/arm_math.h ****    * - arm_cortexM7l_math.lib (Cortex-M7, Little endian)
  62:.\Include/arm_math.h ****    * - arm_cortexM7b_math.lib (Cortex-M7, Big endian)
  63:.\Include/arm_math.h ****    * - arm_cortexM4lf_math.lib (Cortex-M4, Little endian, Floating Point Unit)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 7


  64:.\Include/arm_math.h ****    * - arm_cortexM4bf_math.lib (Cortex-M4, Big endian, Floating Point Unit)
  65:.\Include/arm_math.h ****    * - arm_cortexM4l_math.lib (Cortex-M4, Little endian)
  66:.\Include/arm_math.h ****    * - arm_cortexM4b_math.lib (Cortex-M4, Big endian)
  67:.\Include/arm_math.h ****    * - arm_cortexM3l_math.lib (Cortex-M3, Little endian)
  68:.\Include/arm_math.h ****    * - arm_cortexM3b_math.lib (Cortex-M3, Big endian)
  69:.\Include/arm_math.h ****    * - arm_cortexM0l_math.lib (Cortex-M0 / Cortex-M0+, Little endian)
  70:.\Include/arm_math.h ****    * - arm_cortexM0b_math.lib (Cortex-M0 / Cortex-M0+, Big endian)
  71:.\Include/arm_math.h ****    * - arm_ARMv8MBLl_math.lib (ARMv8M Baseline, Little endian)
  72:.\Include/arm_math.h ****    * - arm_ARMv8MMLl_math.lib (ARMv8M Mainline, Little endian)
  73:.\Include/arm_math.h ****    * - arm_ARMv8MMLlfsp_math.lib (ARMv8M Mainline, Little endian, Single Precision Floating Point U
  74:.\Include/arm_math.h ****    * - arm_ARMv8MMLld_math.lib (ARMv8M Mainline, Little endian, DSP instructions)
  75:.\Include/arm_math.h ****    * - arm_ARMv8MMLldfsp_math.lib (ARMv8M Mainline, Little endian, DSP instructions, Single Precisi
  76:.\Include/arm_math.h ****    *
  77:.\Include/arm_math.h ****    * The library functions are declared in the public file <code>arm_math.h</code> which is placed 
  78:.\Include/arm_math.h ****    * Simply include this file and link the appropriate library in the application and begin calling
  79:.\Include/arm_math.h ****    * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endi
  80:.\Include/arm_math.h ****    * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
  81:.\Include/arm_math.h ****    * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
  82:.\Include/arm_math.h ****    * For ARMv8M cores define pre processor MACRO ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
  83:.\Include/arm_math.h ****    * Set Pre processor MACRO __DSP_PRESENT if ARMv8M Mainline core supports DSP instructions.
  84:.\Include/arm_math.h ****    * 
  85:.\Include/arm_math.h ****    *
  86:.\Include/arm_math.h ****    * Examples
  87:.\Include/arm_math.h ****    * --------
  88:.\Include/arm_math.h ****    *
  89:.\Include/arm_math.h ****    * The library ships with a number of examples which demonstrate how to use the library functions
  90:.\Include/arm_math.h ****    *
  91:.\Include/arm_math.h ****    * Toolchain Support
  92:.\Include/arm_math.h ****    * ------------
  93:.\Include/arm_math.h ****    *
  94:.\Include/arm_math.h ****    * The library has been developed and tested with MDK-ARM version 5.14.0.0
  95:.\Include/arm_math.h ****    * The library is being tested in GCC and IAR toolchains and updates on this activity will be mad
  96:.\Include/arm_math.h ****    *
  97:.\Include/arm_math.h ****    * Building the Library
  98:.\Include/arm_math.h ****    * ------------
  99:.\Include/arm_math.h ****    *
 100:.\Include/arm_math.h ****    * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in t
 101:.\Include/arm_math.h ****    * - arm_cortexM_math.uvprojx
 102:.\Include/arm_math.h ****    *
 103:.\Include/arm_math.h ****    *
 104:.\Include/arm_math.h ****    * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecti
 105:.\Include/arm_math.h ****    *
 106:.\Include/arm_math.h ****    * Pre-processor Macros
 107:.\Include/arm_math.h ****    * ------------
 108:.\Include/arm_math.h ****    *
 109:.\Include/arm_math.h ****    * Each library project have differant pre-processor macros.
 110:.\Include/arm_math.h ****    *
 111:.\Include/arm_math.h ****    * - UNALIGNED_SUPPORT_DISABLE:
 112:.\Include/arm_math.h ****    *
 113:.\Include/arm_math.h ****    * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory acces
 114:.\Include/arm_math.h ****    *
 115:.\Include/arm_math.h ****    * - ARM_MATH_BIG_ENDIAN:
 116:.\Include/arm_math.h ****    *
 117:.\Include/arm_math.h ****    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default libra
 118:.\Include/arm_math.h ****    *
 119:.\Include/arm_math.h ****    * - ARM_MATH_MATRIX_CHECK:
 120:.\Include/arm_math.h ****    *
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 8


 121:.\Include/arm_math.h ****    * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
 122:.\Include/arm_math.h ****    *
 123:.\Include/arm_math.h ****    * - ARM_MATH_ROUNDING:
 124:.\Include/arm_math.h ****    *
 125:.\Include/arm_math.h ****    * Define macro ARM_MATH_ROUNDING for rounding on support functions
 126:.\Include/arm_math.h ****    *
 127:.\Include/arm_math.h ****    * - ARM_MATH_CMx:
 128:.\Include/arm_math.h ****    *
 129:.\Include/arm_math.h ****    * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for build
 130:.\Include/arm_math.h ****    * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building libra
 131:.\Include/arm_math.h ****    * ARM_MATH_CM7 for building the library on cortex-M7.
 132:.\Include/arm_math.h ****    *
 133:.\Include/arm_math.h ****    * - ARM_MATH_ARMV8MxL:
 134:.\Include/arm_math.h ****    *
 135:.\Include/arm_math.h ****    * Define macro ARM_MATH_ARMV8MBL for building the library on ARMv8M Baseline target, ARM_MATH_AR
 136:.\Include/arm_math.h ****    * on ARMv8M Mainline target.
 137:.\Include/arm_math.h ****    *
 138:.\Include/arm_math.h ****    * - __FPU_PRESENT:
 139:.\Include/arm_math.h ****    *
 140:.\Include/arm_math.h ****    * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro f
 141:.\Include/arm_math.h ****    *
 142:.\Include/arm_math.h ****    * - __DSP_PRESENT:
 143:.\Include/arm_math.h ****    *
 144:.\Include/arm_math.h ****    * Initialize macro __DSP_PRESENT = 1 when ARMv8M Mainline core supports DSP instructions.
 145:.\Include/arm_math.h ****    *
 146:.\Include/arm_math.h ****    * <hr>
 147:.\Include/arm_math.h ****    * CMSIS-DSP in ARM::CMSIS Pack
 148:.\Include/arm_math.h ****    * -----------------------------
 149:.\Include/arm_math.h ****    *
 150:.\Include/arm_math.h ****    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directorie
 151:.\Include/arm_math.h ****    * |File/Folder                   |Content                                                       
 152:.\Include/arm_math.h ****    * |------------------------------|--------------------------------------------------------------
 153:.\Include/arm_math.h ****    * |\b CMSIS\\Documentation\\DSP  | This documentation                                           
 154:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                     
 155:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library funct
 156:.\Include/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                      
 157:.\Include/arm_math.h ****    *
 158:.\Include/arm_math.h ****    * <hr>
 159:.\Include/arm_math.h ****    * Revision History of CMSIS-DSP
 160:.\Include/arm_math.h ****    * ------------
 161:.\Include/arm_math.h ****    * Please refer to \ref ChangeLog_pg.
 162:.\Include/arm_math.h ****    *
 163:.\Include/arm_math.h ****    * Copyright Notice
 164:.\Include/arm_math.h ****    * ------------
 165:.\Include/arm_math.h ****    *
 166:.\Include/arm_math.h ****    * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
 167:.\Include/arm_math.h ****    */
 168:.\Include/arm_math.h **** 
 169:.\Include/arm_math.h **** 
 170:.\Include/arm_math.h **** /**
 171:.\Include/arm_math.h ****  * @defgroup groupMath Basic Math Functions
 172:.\Include/arm_math.h ****  */
 173:.\Include/arm_math.h **** 
 174:.\Include/arm_math.h **** /**
 175:.\Include/arm_math.h ****  * @defgroup groupFastMath Fast Math Functions
 176:.\Include/arm_math.h ****  * This set of functions provides a fast approximation to sine, cosine, and square root.
 177:.\Include/arm_math.h ****  * As compared to most of the other functions in the CMSIS math library, the fast math functions
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 9


 178:.\Include/arm_math.h ****  * operate on individual values and not arrays.
 179:.\Include/arm_math.h ****  * There are separate functions for Q15, Q31, and floating-point data.
 180:.\Include/arm_math.h ****  *
 181:.\Include/arm_math.h ****  */
 182:.\Include/arm_math.h **** 
 183:.\Include/arm_math.h **** /**
 184:.\Include/arm_math.h ****  * @defgroup groupCmplxMath Complex Math Functions
 185:.\Include/arm_math.h ****  * This set of functions operates on complex data vectors.
 186:.\Include/arm_math.h ****  * The data in the complex arrays is stored in an interleaved fashion
 187:.\Include/arm_math.h ****  * (real, imag, real, imag, ...).
 188:.\Include/arm_math.h ****  * In the API functions, the number of samples in a complex array refers
 189:.\Include/arm_math.h ****  * to the number of complex values; the array contains twice this number of
 190:.\Include/arm_math.h ****  * real values.
 191:.\Include/arm_math.h ****  */
 192:.\Include/arm_math.h **** 
 193:.\Include/arm_math.h **** /**
 194:.\Include/arm_math.h ****  * @defgroup groupFilters Filtering Functions
 195:.\Include/arm_math.h ****  */
 196:.\Include/arm_math.h **** 
 197:.\Include/arm_math.h **** /**
 198:.\Include/arm_math.h ****  * @defgroup groupMatrix Matrix Functions
 199:.\Include/arm_math.h ****  *
 200:.\Include/arm_math.h ****  * This set of functions provides basic matrix math operations.
 201:.\Include/arm_math.h ****  * The functions operate on matrix data structures.  For example,
 202:.\Include/arm_math.h ****  * the type
 203:.\Include/arm_math.h ****  * definition for the floating-point matrix structure is shown
 204:.\Include/arm_math.h ****  * below:
 205:.\Include/arm_math.h ****  * <pre>
 206:.\Include/arm_math.h ****  *     typedef struct
 207:.\Include/arm_math.h ****  *     {
 208:.\Include/arm_math.h ****  *       uint16_t numRows;     // number of rows of the matrix.
 209:.\Include/arm_math.h ****  *       uint16_t numCols;     // number of columns of the matrix.
 210:.\Include/arm_math.h ****  *       float32_t *pData;     // points to the data of the matrix.
 211:.\Include/arm_math.h ****  *     } arm_matrix_instance_f32;
 212:.\Include/arm_math.h ****  * </pre>
 213:.\Include/arm_math.h ****  * There are similar definitions for Q15 and Q31 data types.
 214:.\Include/arm_math.h ****  *
 215:.\Include/arm_math.h ****  * The structure specifies the size of the matrix and then points to
 216:.\Include/arm_math.h ****  * an array of data.  The array is of size <code>numRows X numCols</code>
 217:.\Include/arm_math.h ****  * and the values are arranged in row order.  That is, the
 218:.\Include/arm_math.h ****  * matrix element (i, j) is stored at:
 219:.\Include/arm_math.h ****  * <pre>
 220:.\Include/arm_math.h ****  *     pData[i*numCols + j]
 221:.\Include/arm_math.h ****  * </pre>
 222:.\Include/arm_math.h ****  *
 223:.\Include/arm_math.h ****  * \par Init Functions
 224:.\Include/arm_math.h ****  * There is an associated initialization function for each type of matrix
 225:.\Include/arm_math.h ****  * data structure.
 226:.\Include/arm_math.h ****  * The initialization function sets the values of the internal structure fields.
 227:.\Include/arm_math.h ****  * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
 228:.\Include/arm_math.h ****  * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
 229:.\Include/arm_math.h ****  *
 230:.\Include/arm_math.h ****  * \par
 231:.\Include/arm_math.h ****  * Use of the initialization function is optional. However, if initialization function is used
 232:.\Include/arm_math.h ****  * then the instance structure cannot be placed into a const data section.
 233:.\Include/arm_math.h ****  * To place the instance structure in a const data
 234:.\Include/arm_math.h ****  * section, manually initialize the data structure.  For example:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 10


 235:.\Include/arm_math.h ****  * <pre>
 236:.\Include/arm_math.h ****  * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
 237:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
 238:.\Include/arm_math.h ****  * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
 239:.\Include/arm_math.h ****  * </pre>
 240:.\Include/arm_math.h ****  * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
 241:.\Include/arm_math.h ****  * specifies the number of columns, and <code>pData</code> points to the
 242:.\Include/arm_math.h ****  * data array.
 243:.\Include/arm_math.h ****  *
 244:.\Include/arm_math.h ****  * \par Size Checking
 245:.\Include/arm_math.h ****  * By default all of the matrix functions perform size checking on the input and
 246:.\Include/arm_math.h ****  * output matrices.  For example, the matrix addition function verifies that the
 247:.\Include/arm_math.h ****  * two input matrices and the output matrix all have the same number of rows and
 248:.\Include/arm_math.h ****  * columns.  If the size check fails the functions return:
 249:.\Include/arm_math.h ****  * <pre>
 250:.\Include/arm_math.h ****  *     ARM_MATH_SIZE_MISMATCH
 251:.\Include/arm_math.h ****  * </pre>
 252:.\Include/arm_math.h ****  * Otherwise the functions return
 253:.\Include/arm_math.h ****  * <pre>
 254:.\Include/arm_math.h ****  *     ARM_MATH_SUCCESS
 255:.\Include/arm_math.h ****  * </pre>
 256:.\Include/arm_math.h ****  * There is some overhead associated with this matrix size checking.
 257:.\Include/arm_math.h ****  * The matrix size checking is enabled via the \#define
 258:.\Include/arm_math.h ****  * <pre>
 259:.\Include/arm_math.h ****  *     ARM_MATH_MATRIX_CHECK
 260:.\Include/arm_math.h ****  * </pre>
 261:.\Include/arm_math.h ****  * within the library project settings.  By default this macro is defined
 262:.\Include/arm_math.h ****  * and size checking is enabled.  By changing the project settings and
 263:.\Include/arm_math.h ****  * undefining this macro size checking is eliminated and the functions
 264:.\Include/arm_math.h ****  * run a bit faster.  With size checking disabled the functions always
 265:.\Include/arm_math.h ****  * return <code>ARM_MATH_SUCCESS</code>.
 266:.\Include/arm_math.h ****  */
 267:.\Include/arm_math.h **** 
 268:.\Include/arm_math.h **** /**
 269:.\Include/arm_math.h ****  * @defgroup groupTransforms Transform Functions
 270:.\Include/arm_math.h ****  */
 271:.\Include/arm_math.h **** 
 272:.\Include/arm_math.h **** /**
 273:.\Include/arm_math.h ****  * @defgroup groupController Controller Functions
 274:.\Include/arm_math.h ****  */
 275:.\Include/arm_math.h **** 
 276:.\Include/arm_math.h **** /**
 277:.\Include/arm_math.h ****  * @defgroup groupStats Statistics Functions
 278:.\Include/arm_math.h ****  */
 279:.\Include/arm_math.h **** /**
 280:.\Include/arm_math.h ****  * @defgroup groupSupport Support Functions
 281:.\Include/arm_math.h ****  */
 282:.\Include/arm_math.h **** 
 283:.\Include/arm_math.h **** /**
 284:.\Include/arm_math.h ****  * @defgroup groupInterpolation Interpolation Functions
 285:.\Include/arm_math.h ****  * These functions perform 1- and 2-dimensional interpolation of data.
 286:.\Include/arm_math.h ****  * Linear interpolation is used for 1-dimensional data and
 287:.\Include/arm_math.h ****  * bilinear interpolation is used for 2-dimensional data.
 288:.\Include/arm_math.h ****  */
 289:.\Include/arm_math.h **** 
 290:.\Include/arm_math.h **** /**
 291:.\Include/arm_math.h ****  * @defgroup groupExamples Examples
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 11


 292:.\Include/arm_math.h ****  */
 293:.\Include/arm_math.h **** #ifndef _ARM_MATH_H
 294:.\Include/arm_math.h **** #define _ARM_MATH_H
 295:.\Include/arm_math.h **** 
 296:.\Include/arm_math.h **** /* ignore some GCC warnings */
 297:.\Include/arm_math.h **** #if defined ( __GNUC__ )
 298:.\Include/arm_math.h **** #pragma GCC diagnostic push
 299:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
 300:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wconversion"
 301:.\Include/arm_math.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
 302:.\Include/arm_math.h **** #endif
 303:.\Include/arm_math.h **** 
 304:.\Include/arm_math.h **** #define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
 305:.\Include/arm_math.h **** 
 306:.\Include/arm_math.h **** #if defined(ARM_MATH_CM7)
 307:.\Include/arm_math.h ****   #include "core_cm7.h"
 308:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 309:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM4)
 310:.\Include/arm_math.h ****   #include "core_cm4.h"
 311:.\Include/arm_math.h ****   #define ARM_MATH_DSP
 312:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM3)
 313:.\Include/arm_math.h ****   #include "core_cm3.h"
 314:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0)
 315:.\Include/arm_math.h ****   #include "core_cm0.h"
 316:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 317:.\Include/arm_math.h **** #elif defined (ARM_MATH_CM0PLUS)
 318:.\Include/arm_math.h ****   #include "core_cm0plus.h"
 319:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 320:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MBL)
 321:.\Include/arm_math.h ****   #include "core_armv8mbl.h"
 322:.\Include/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 323:.\Include/arm_math.h **** #elif defined (ARM_MATH_ARMV8MML)
 324:.\Include/arm_math.h ****   #include "core_armv8mml.h"
 325:.\Include/arm_math.h ****   #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
 326:.\Include/arm_math.h ****     #define ARM_MATH_DSP
 327:.\Include/arm_math.h ****   #endif
 328:.\Include/arm_math.h **** #else
 329:.\Include/arm_math.h ****   #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_
 330:.\Include/arm_math.h **** #endif
 331:.\Include/arm_math.h **** 
 332:.\Include/arm_math.h **** #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 333:.\Include/arm_math.h **** #include "string.h"
 334:.\Include/arm_math.h **** #include "math.h"
 335:.\Include/arm_math.h **** #ifdef   __cplusplus
 336:.\Include/arm_math.h **** extern "C"
 337:.\Include/arm_math.h **** {
 338:.\Include/arm_math.h **** #endif
 339:.\Include/arm_math.h **** 
 340:.\Include/arm_math.h **** 
 341:.\Include/arm_math.h ****   /**
 342:.\Include/arm_math.h ****    * @brief Macros required for reciprocal calculation in Normalized LMS
 343:.\Include/arm_math.h ****    */
 344:.\Include/arm_math.h **** 
 345:.\Include/arm_math.h **** #define DELTA_Q31          (0x100)
 346:.\Include/arm_math.h **** #define DELTA_Q15          0x5
 347:.\Include/arm_math.h **** #define INDEX_MASK         0x0000003F
 348:.\Include/arm_math.h **** #ifndef PI
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 12


 349:.\Include/arm_math.h ****   #define PI               3.14159265358979f
 350:.\Include/arm_math.h **** #endif
 351:.\Include/arm_math.h **** 
 352:.\Include/arm_math.h ****   /**
 353:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Fast math approximations
 354:.\Include/arm_math.h ****    */
 355:.\Include/arm_math.h **** 
 356:.\Include/arm_math.h **** #define FAST_MATH_TABLE_SIZE  512
 357:.\Include/arm_math.h **** #define FAST_MATH_Q31_SHIFT   (32 - 10)
 358:.\Include/arm_math.h **** #define FAST_MATH_Q15_SHIFT   (16 - 10)
 359:.\Include/arm_math.h **** #define CONTROLLER_Q31_SHIFT  (32 - 9)
 360:.\Include/arm_math.h **** #define TABLE_SPACING_Q31     0x400000
 361:.\Include/arm_math.h **** #define TABLE_SPACING_Q15     0x80
 362:.\Include/arm_math.h **** 
 363:.\Include/arm_math.h ****   /**
 364:.\Include/arm_math.h ****    * @brief Macros required for SINE and COSINE Controller functions
 365:.\Include/arm_math.h ****    */
 366:.\Include/arm_math.h ****   /* 1.31(q31) Fixed value of 2/360 */
 367:.\Include/arm_math.h ****   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 368:.\Include/arm_math.h **** #define INPUT_SPACING         0xB60B61
 369:.\Include/arm_math.h **** 
 370:.\Include/arm_math.h ****   /**
 371:.\Include/arm_math.h ****    * @brief Macro for Unaligned Support
 372:.\Include/arm_math.h ****    */
 373:.\Include/arm_math.h **** #ifndef UNALIGNED_SUPPORT_DISABLE
 374:.\Include/arm_math.h ****     #define ALIGN4
 375:.\Include/arm_math.h **** #else
 376:.\Include/arm_math.h ****   #if defined  (__GNUC__)
 377:.\Include/arm_math.h ****     #define ALIGN4 __attribute__((aligned(4)))
 378:.\Include/arm_math.h ****   #else
 379:.\Include/arm_math.h ****     #define ALIGN4 __align(4)
 380:.\Include/arm_math.h ****   #endif
 381:.\Include/arm_math.h **** #endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 382:.\Include/arm_math.h **** 
 383:.\Include/arm_math.h ****   /**
 384:.\Include/arm_math.h ****    * @brief Error status returned by some functions in the library.
 385:.\Include/arm_math.h ****    */
 386:.\Include/arm_math.h **** 
 387:.\Include/arm_math.h ****   typedef enum
 388:.\Include/arm_math.h ****   {
 389:.\Include/arm_math.h ****     ARM_MATH_SUCCESS = 0,                /**< No error */
 390:.\Include/arm_math.h ****     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
 391:.\Include/arm_math.h ****     ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
 392:.\Include/arm_math.h ****     ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation
 393:.\Include/arm_math.h ****     ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
 394:.\Include/arm_math.h ****     ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is 
 395:.\Include/arm_math.h ****     ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
 396:.\Include/arm_math.h ****   } arm_status;
 397:.\Include/arm_math.h **** 
 398:.\Include/arm_math.h ****   /**
 399:.\Include/arm_math.h ****    * @brief 8-bit fractional data type in 1.7 format.
 400:.\Include/arm_math.h ****    */
 401:.\Include/arm_math.h ****   typedef int8_t q7_t;
 402:.\Include/arm_math.h **** 
 403:.\Include/arm_math.h ****   /**
 404:.\Include/arm_math.h ****    * @brief 16-bit fractional data type in 1.15 format.
 405:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 13


 406:.\Include/arm_math.h ****   typedef int16_t q15_t;
 407:.\Include/arm_math.h **** 
 408:.\Include/arm_math.h ****   /**
 409:.\Include/arm_math.h ****    * @brief 32-bit fractional data type in 1.31 format.
 410:.\Include/arm_math.h ****    */
 411:.\Include/arm_math.h ****   typedef int32_t q31_t;
 412:.\Include/arm_math.h **** 
 413:.\Include/arm_math.h ****   /**
 414:.\Include/arm_math.h ****    * @brief 64-bit fractional data type in 1.63 format.
 415:.\Include/arm_math.h ****    */
 416:.\Include/arm_math.h ****   typedef int64_t q63_t;
 417:.\Include/arm_math.h **** 
 418:.\Include/arm_math.h ****   /**
 419:.\Include/arm_math.h ****    * @brief 32-bit floating-point type definition.
 420:.\Include/arm_math.h ****    */
 421:.\Include/arm_math.h ****   typedef float float32_t;
 422:.\Include/arm_math.h **** 
 423:.\Include/arm_math.h ****   /**
 424:.\Include/arm_math.h ****    * @brief 64-bit floating-point type definition.
 425:.\Include/arm_math.h ****    */
 426:.\Include/arm_math.h ****   typedef double float64_t;
 427:.\Include/arm_math.h **** 
 428:.\Include/arm_math.h ****   /**
 429:.\Include/arm_math.h ****    * @brief definition to read/write two 16 bit values.
 430:.\Include/arm_math.h ****    */
 431:.\Include/arm_math.h **** #if   defined ( __CC_ARM )
 432:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 433:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 434:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 435:.\Include/arm_math.h **** 
 436:.\Include/arm_math.h **** #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 437:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 438:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 439:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 440:.\Include/arm_math.h **** 
 441:.\Include/arm_math.h **** #elif defined ( __GNUC__ )
 442:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 443:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 444:.\Include/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 445:.\Include/arm_math.h **** 
 446:.\Include/arm_math.h **** #elif defined ( __ICCARM__ )
 447:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 448:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 449:.\Include/arm_math.h ****   #define CMSIS_INLINE
 450:.\Include/arm_math.h **** 
 451:.\Include/arm_math.h **** #elif defined ( __TI_ARM__ )
 452:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 453:.\Include/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 454:.\Include/arm_math.h ****   #define CMSIS_INLINE
 455:.\Include/arm_math.h **** 
 456:.\Include/arm_math.h **** #elif defined ( __CSMC__ )
 457:.\Include/arm_math.h ****   #define __SIMD32_TYPE int32_t
 458:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 459:.\Include/arm_math.h ****   #define CMSIS_INLINE
 460:.\Include/arm_math.h **** 
 461:.\Include/arm_math.h **** #elif defined ( __TASKING__ )
 462:.\Include/arm_math.h ****   #define __SIMD32_TYPE __unaligned int32_t
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 14


 463:.\Include/arm_math.h ****   #define CMSIS_UNUSED
 464:.\Include/arm_math.h ****   #define CMSIS_INLINE
 465:.\Include/arm_math.h **** 
 466:.\Include/arm_math.h **** #else
 467:.\Include/arm_math.h ****   #error Unknown compiler
 468:.\Include/arm_math.h **** #endif
 469:.\Include/arm_math.h **** 
 470:.\Include/arm_math.h **** #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
 471:.\Include/arm_math.h **** #define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
 472:.\Include/arm_math.h **** #define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
 473:.\Include/arm_math.h **** #define __SIMD64(addr)        (*(int64_t **) & (addr))
 474:.\Include/arm_math.h **** 
 475:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 476:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 477:.\Include/arm_math.h ****   /**
 478:.\Include/arm_math.h ****    * @brief definition to pack two 16 bit values.
 479:.\Include/arm_math.h ****    */
 480:.\Include/arm_math.h **** #define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
 481:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
 482:.\Include/arm_math.h **** #define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
 483:.\Include/arm_math.h ****                                     (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
 484:.\Include/arm_math.h **** 
 485:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 486:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
 487:.\Include/arm_math.h **** 
 488:.\Include/arm_math.h ****    /**
 489:.\Include/arm_math.h ****    * @brief definition to pack four 8 bit values.
 490:.\Include/arm_math.h ****    */
 491:.\Include/arm_math.h **** #ifndef ARM_MATH_BIG_ENDIAN
 492:.\Include/arm_math.h **** 
 493:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
 494:.\Include/arm_math.h ****                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
 495:.\Include/arm_math.h ****                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
 496:.\Include/arm_math.h ****                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 497:.\Include/arm_math.h **** #else
 498:.\Include/arm_math.h **** 
 499:.\Include/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
 500:.\Include/arm_math.h ****                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
 501:.\Include/arm_math.h ****                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
 502:.\Include/arm_math.h ****                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 503:.\Include/arm_math.h **** 
 504:.\Include/arm_math.h **** #endif
 505:.\Include/arm_math.h **** 
 506:.\Include/arm_math.h **** 
 507:.\Include/arm_math.h ****   /**
 508:.\Include/arm_math.h ****    * @brief Clips Q63 to Q31 values.
 509:.\Include/arm_math.h ****    */
 510:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
 511:.\Include/arm_math.h ****   q63_t x)
 512:.\Include/arm_math.h ****   {
 513:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 514:.\Include/arm_math.h ****       ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
 515:.\Include/arm_math.h ****   }
 516:.\Include/arm_math.h **** 
 517:.\Include/arm_math.h ****   /**
 518:.\Include/arm_math.h ****    * @brief Clips Q63 to Q15 values.
 519:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 15


 520:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
 521:.\Include/arm_math.h ****   q63_t x)
 522:.\Include/arm_math.h ****   {
 523:.\Include/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 524:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
 525:.\Include/arm_math.h ****   }
 526:.\Include/arm_math.h **** 
 527:.\Include/arm_math.h ****   /**
 528:.\Include/arm_math.h ****    * @brief Clips Q31 to Q7 values.
 529:.\Include/arm_math.h ****    */
 530:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
 531:.\Include/arm_math.h ****   q31_t x)
 532:.\Include/arm_math.h ****   {
 533:.\Include/arm_math.h ****     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
 534:.\Include/arm_math.h ****       ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
 535:.\Include/arm_math.h ****   }
 536:.\Include/arm_math.h **** 
 537:.\Include/arm_math.h ****   /**
 538:.\Include/arm_math.h ****    * @brief Clips Q31 to Q15 values.
 539:.\Include/arm_math.h ****    */
 540:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
 541:.\Include/arm_math.h ****   q31_t x)
 542:.\Include/arm_math.h ****   {
 543:.\Include/arm_math.h ****     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
 544:.\Include/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
 545:.\Include/arm_math.h ****   }
 546:.\Include/arm_math.h **** 
 547:.\Include/arm_math.h ****   /**
 548:.\Include/arm_math.h ****    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
 549:.\Include/arm_math.h ****    */
 550:.\Include/arm_math.h **** 
 551:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
 552:.\Include/arm_math.h ****   q63_t x,
 553:.\Include/arm_math.h ****   q31_t y)
 554:.\Include/arm_math.h ****   {
 555:.\Include/arm_math.h ****     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
 556:.\Include/arm_math.h ****             (((q63_t) (x >> 32) * y)));
 557:.\Include/arm_math.h ****   }
 558:.\Include/arm_math.h **** 
 559:.\Include/arm_math.h **** /*
 560:.\Include/arm_math.h ****   #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
 561:.\Include/arm_math.h ****   #define __CLZ __clz
 562:.\Include/arm_math.h ****   #endif
 563:.\Include/arm_math.h ****  */
 564:.\Include/arm_math.h **** /* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
 565:.\Include/arm_math.h **** #if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
 566:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 567:.\Include/arm_math.h ****   q31_t data);
 568:.\Include/arm_math.h **** 
 569:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __CLZ(
 570:.\Include/arm_math.h ****   q31_t data)
 571:.\Include/arm_math.h ****   {
 572:.\Include/arm_math.h ****     uint32_t count = 0;
 573:.\Include/arm_math.h ****     uint32_t mask = 0x80000000;
 574:.\Include/arm_math.h **** 
 575:.\Include/arm_math.h ****     while ((data & mask) == 0)
 576:.\Include/arm_math.h ****     {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 16


 577:.\Include/arm_math.h ****       count += 1u;
 578:.\Include/arm_math.h ****       mask = mask >> 1u;
 579:.\Include/arm_math.h ****     }
 580:.\Include/arm_math.h **** 
 581:.\Include/arm_math.h ****     return (count);
 582:.\Include/arm_math.h ****   }
 583:.\Include/arm_math.h **** #endif
 584:.\Include/arm_math.h **** 
 585:.\Include/arm_math.h ****   /**
 586:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
 587:.\Include/arm_math.h ****    */
 588:.\Include/arm_math.h **** 
 589:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
 590:.\Include/arm_math.h ****   q31_t in,
 591:.\Include/arm_math.h ****   q31_t * dst,
 592:.\Include/arm_math.h ****   q31_t * pRecipTable)
 593:.\Include/arm_math.h ****   {
 594:.\Include/arm_math.h ****     q31_t out;
 595:.\Include/arm_math.h ****     uint32_t tempVal;
 596:.\Include/arm_math.h ****     uint32_t index, i;
 597:.\Include/arm_math.h ****     uint32_t signBits;
 598:.\Include/arm_math.h **** 
 599:.\Include/arm_math.h ****     if (in > 0)
 600:.\Include/arm_math.h ****     {
 601:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ( in) - 1));
 602:.\Include/arm_math.h ****     }
 603:.\Include/arm_math.h ****     else
 604:.\Include/arm_math.h ****     {
 605:.\Include/arm_math.h ****       signBits = ((uint32_t) (__CLZ(-in) - 1));
 606:.\Include/arm_math.h ****     }
 607:.\Include/arm_math.h **** 
 608:.\Include/arm_math.h ****     /* Convert input sample to 1.31 format */
 609:.\Include/arm_math.h ****     in = (in << signBits);
 610:.\Include/arm_math.h **** 
 611:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 612:.\Include/arm_math.h ****     index = (uint32_t)(in >> 24);
 613:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 614:.\Include/arm_math.h **** 
 615:.\Include/arm_math.h ****     /* 1.31 with exp 1 */
 616:.\Include/arm_math.h ****     out = pRecipTable[index];
 617:.\Include/arm_math.h **** 
 618:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 619:.\Include/arm_math.h ****     /* running approximation for two iterations */
 620:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 621:.\Include/arm_math.h ****     {
 622:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q63_t) in * out) >> 31);
 623:.\Include/arm_math.h ****       tempVal = 0x7FFFFFFFu - tempVal;
 624:.\Include/arm_math.h ****       /*      1.31 with exp 1 */
 625:.\Include/arm_math.h ****       /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
 626:.\Include/arm_math.h ****       out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
 627:.\Include/arm_math.h ****     }
 628:.\Include/arm_math.h **** 
 629:.\Include/arm_math.h ****     /* write output */
 630:.\Include/arm_math.h ****     *dst = out;
 631:.\Include/arm_math.h **** 
 632:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 633:.\Include/arm_math.h ****     return (signBits + 1u);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 17


 634:.\Include/arm_math.h ****   }
 635:.\Include/arm_math.h **** 
 636:.\Include/arm_math.h **** 
 637:.\Include/arm_math.h ****   /**
 638:.\Include/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
 639:.\Include/arm_math.h ****    */
 640:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
 641:.\Include/arm_math.h ****   q15_t in,
 642:.\Include/arm_math.h ****   q15_t * dst,
 643:.\Include/arm_math.h ****   q15_t * pRecipTable)
 644:.\Include/arm_math.h ****   {
 645:.\Include/arm_math.h ****     q15_t out = 0;
 646:.\Include/arm_math.h ****     uint32_t tempVal = 0;
 647:.\Include/arm_math.h ****     uint32_t index = 0, i = 0;
 648:.\Include/arm_math.h ****     uint32_t signBits = 0;
 649:.\Include/arm_math.h **** 
 650:.\Include/arm_math.h ****     if (in > 0)
 651:.\Include/arm_math.h ****     {
 652:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ( in) - 17));
 653:.\Include/arm_math.h ****     }
 654:.\Include/arm_math.h ****     else
 655:.\Include/arm_math.h ****     {
 656:.\Include/arm_math.h ****       signBits = ((uint32_t)(__CLZ(-in) - 17));
 657:.\Include/arm_math.h ****     }
 658:.\Include/arm_math.h **** 
 659:.\Include/arm_math.h ****     /* Convert input sample to 1.15 format */
 660:.\Include/arm_math.h ****     in = (in << signBits);
 661:.\Include/arm_math.h **** 
 662:.\Include/arm_math.h ****     /* calculation of index for initial approximated Val */
 663:.\Include/arm_math.h ****     index = (uint32_t)(in >>  8);
 664:.\Include/arm_math.h ****     index = (index & INDEX_MASK);
 665:.\Include/arm_math.h **** 
 666:.\Include/arm_math.h ****     /*      1.15 with exp 1  */
 667:.\Include/arm_math.h ****     out = pRecipTable[index];
 668:.\Include/arm_math.h **** 
 669:.\Include/arm_math.h ****     /* calculation of reciprocal value */
 670:.\Include/arm_math.h ****     /* running approximation for two iterations */
 671:.\Include/arm_math.h ****     for (i = 0u; i < 2u; i++)
 672:.\Include/arm_math.h ****     {
 673:.\Include/arm_math.h ****       tempVal = (uint32_t) (((q31_t) in * out) >> 15);
 674:.\Include/arm_math.h ****       tempVal = 0x7FFFu - tempVal;
 675:.\Include/arm_math.h ****       /*      1.15 with exp 1 */
 676:.\Include/arm_math.h ****       out = (q15_t) (((q31_t) out * tempVal) >> 14);
 677:.\Include/arm_math.h ****       /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
 678:.\Include/arm_math.h ****     }
 679:.\Include/arm_math.h **** 
 680:.\Include/arm_math.h ****     /* write output */
 681:.\Include/arm_math.h ****     *dst = out;
 682:.\Include/arm_math.h **** 
 683:.\Include/arm_math.h ****     /* return num of signbits of out = 1/in value */
 684:.\Include/arm_math.h ****     return (signBits + 1);
 685:.\Include/arm_math.h ****   }
 686:.\Include/arm_math.h **** 
 687:.\Include/arm_math.h **** 
 688:.\Include/arm_math.h ****   /*
 689:.\Include/arm_math.h ****    * @brief C custom defined intrinisic function for only M0 processors
 690:.\Include/arm_math.h ****    */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 18


 691:.\Include/arm_math.h **** #if defined(ARM_MATH_CM0_FAMILY)
 692:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t __SSAT(
 693:.\Include/arm_math.h ****   q31_t x,
 694:.\Include/arm_math.h ****   uint32_t y)
 695:.\Include/arm_math.h ****   {
 696:.\Include/arm_math.h ****     int32_t posMax, negMin;
 697:.\Include/arm_math.h ****     uint32_t i;
 698:.\Include/arm_math.h **** 
 699:.\Include/arm_math.h ****     posMax = 1;
 700:.\Include/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 701:.\Include/arm_math.h ****     {
 702:.\Include/arm_math.h ****       posMax = posMax * 2;
 703:.\Include/arm_math.h ****     }
 704:.\Include/arm_math.h **** 
 705:.\Include/arm_math.h ****     if (x > 0)
 706:.\Include/arm_math.h ****     {
 707:.\Include/arm_math.h ****       posMax = (posMax - 1);
 708:.\Include/arm_math.h **** 
 709:.\Include/arm_math.h ****       if (x > posMax)
 710:.\Include/arm_math.h ****       {
 711:.\Include/arm_math.h ****         x = posMax;
 712:.\Include/arm_math.h ****       }
 713:.\Include/arm_math.h ****     }
 714:.\Include/arm_math.h ****     else
 715:.\Include/arm_math.h ****     {
 716:.\Include/arm_math.h ****       negMin = -posMax;
 717:.\Include/arm_math.h **** 
 718:.\Include/arm_math.h ****       if (x < negMin)
 719:.\Include/arm_math.h ****       {
 720:.\Include/arm_math.h ****         x = negMin;
 721:.\Include/arm_math.h ****       }
 722:.\Include/arm_math.h ****     }
 723:.\Include/arm_math.h ****     return (x);
 724:.\Include/arm_math.h ****   }
 725:.\Include/arm_math.h **** #endif /* end of ARM_MATH_CM0_FAMILY */
 726:.\Include/arm_math.h **** 
 727:.\Include/arm_math.h **** 
 728:.\Include/arm_math.h ****   /*
 729:.\Include/arm_math.h ****    * @brief C custom defined intrinsic function for M3 and M0 processors
 730:.\Include/arm_math.h ****    */
 731:.\Include/arm_math.h **** /* #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
 732:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
 733:.\Include/arm_math.h **** 
 734:.\Include/arm_math.h ****   /*
 735:.\Include/arm_math.h ****    * @brief C custom defined QADD8 for M3 and M0 processors
 736:.\Include/arm_math.h ****    */
 737:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
 738:.\Include/arm_math.h ****   uint32_t x,
 739:.\Include/arm_math.h ****   uint32_t y)
 740:.\Include/arm_math.h ****   {
 741:.\Include/arm_math.h ****     q31_t r, s, t, u;
 742:.\Include/arm_math.h **** 
 743:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 744:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 745:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 746:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 747:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 19


 748:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 749:.\Include/arm_math.h ****   }
 750:.\Include/arm_math.h **** 
 751:.\Include/arm_math.h **** 
 752:.\Include/arm_math.h ****   /*
 753:.\Include/arm_math.h ****    * @brief C custom defined QSUB8 for M3 and M0 processors
 754:.\Include/arm_math.h ****    */
 755:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
 756:.\Include/arm_math.h ****   uint32_t x,
 757:.\Include/arm_math.h ****   uint32_t y)
 758:.\Include/arm_math.h ****   {
 759:.\Include/arm_math.h ****     q31_t r, s, t, u;
 760:.\Include/arm_math.h **** 
 761:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 762:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 763:.\Include/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 764:.\Include/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 765:.\Include/arm_math.h **** 
 766:.\Include/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 767:.\Include/arm_math.h ****   }
 768:.\Include/arm_math.h **** 
 769:.\Include/arm_math.h **** 
 770:.\Include/arm_math.h ****   /*
 771:.\Include/arm_math.h ****    * @brief C custom defined QADD16 for M3 and M0 processors
 772:.\Include/arm_math.h ****    */
 773:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
 774:.\Include/arm_math.h ****   uint32_t x,
 775:.\Include/arm_math.h ****   uint32_t y)
 776:.\Include/arm_math.h ****   {
 777:.\Include/arm_math.h **** /*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass
 778:.\Include/arm_math.h ****     q31_t r = 0, s = 0;
 779:.\Include/arm_math.h **** 
 780:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 781:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 782:.\Include/arm_math.h **** 
 783:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 784:.\Include/arm_math.h ****   }
 785:.\Include/arm_math.h **** 
 786:.\Include/arm_math.h **** 
 787:.\Include/arm_math.h ****   /*
 788:.\Include/arm_math.h ****    * @brief C custom defined SHADD16 for M3 and M0 processors
 789:.\Include/arm_math.h ****    */
 790:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
 791:.\Include/arm_math.h ****   uint32_t x,
 792:.\Include/arm_math.h ****   uint32_t y)
 793:.\Include/arm_math.h ****   {
 794:.\Include/arm_math.h ****     q31_t r, s;
 795:.\Include/arm_math.h **** 
 796:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 797:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 798:.\Include/arm_math.h **** 
 799:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 800:.\Include/arm_math.h ****   }
 801:.\Include/arm_math.h **** 
 802:.\Include/arm_math.h **** 
 803:.\Include/arm_math.h ****   /*
 804:.\Include/arm_math.h ****    * @brief C custom defined QSUB16 for M3 and M0 processors
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 20


 805:.\Include/arm_math.h ****    */
 806:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
 807:.\Include/arm_math.h ****   uint32_t x,
 808:.\Include/arm_math.h ****   uint32_t y)
 809:.\Include/arm_math.h ****   {
 810:.\Include/arm_math.h ****     q31_t r, s;
 811:.\Include/arm_math.h **** 
 812:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 813:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 814:.\Include/arm_math.h **** 
 815:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 816:.\Include/arm_math.h ****   }
 817:.\Include/arm_math.h **** 
 818:.\Include/arm_math.h **** 
 819:.\Include/arm_math.h ****   /*
 820:.\Include/arm_math.h ****    * @brief C custom defined SHSUB16 for M3 and M0 processors
 821:.\Include/arm_math.h ****    */
 822:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
 823:.\Include/arm_math.h ****   uint32_t x,
 824:.\Include/arm_math.h ****   uint32_t y)
 825:.\Include/arm_math.h ****   {
 826:.\Include/arm_math.h ****     q31_t r, s;
 827:.\Include/arm_math.h **** 
 828:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 829:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 830:.\Include/arm_math.h **** 
 831:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 832:.\Include/arm_math.h ****   }
 833:.\Include/arm_math.h **** 
 834:.\Include/arm_math.h **** 
 835:.\Include/arm_math.h ****   /*
 836:.\Include/arm_math.h ****    * @brief C custom defined QASX for M3 and M0 processors
 837:.\Include/arm_math.h ****    */
 838:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
 839:.\Include/arm_math.h ****   uint32_t x,
 840:.\Include/arm_math.h ****   uint32_t y)
 841:.\Include/arm_math.h ****   {
 842:.\Include/arm_math.h ****     q31_t r, s;
 843:.\Include/arm_math.h **** 
 844:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 845:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 846:.\Include/arm_math.h **** 
 847:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 848:.\Include/arm_math.h ****   }
 849:.\Include/arm_math.h **** 
 850:.\Include/arm_math.h **** 
 851:.\Include/arm_math.h ****   /*
 852:.\Include/arm_math.h ****    * @brief C custom defined SHASX for M3 and M0 processors
 853:.\Include/arm_math.h ****    */
 854:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
 855:.\Include/arm_math.h ****   uint32_t x,
 856:.\Include/arm_math.h ****   uint32_t y)
 857:.\Include/arm_math.h ****   {
 858:.\Include/arm_math.h ****     q31_t r, s;
 859:.\Include/arm_math.h **** 
 860:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 861:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 21


 862:.\Include/arm_math.h **** 
 863:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 864:.\Include/arm_math.h ****   }
 865:.\Include/arm_math.h **** 
 866:.\Include/arm_math.h **** 
 867:.\Include/arm_math.h ****   /*
 868:.\Include/arm_math.h ****    * @brief C custom defined QSAX for M3 and M0 processors
 869:.\Include/arm_math.h ****    */
 870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
 871:.\Include/arm_math.h ****   uint32_t x,
 872:.\Include/arm_math.h ****   uint32_t y)
 873:.\Include/arm_math.h ****   {
 874:.\Include/arm_math.h ****     q31_t r, s;
 875:.\Include/arm_math.h **** 
 876:.\Include/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 877:.\Include/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 878:.\Include/arm_math.h **** 
 879:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 880:.\Include/arm_math.h ****   }
 881:.\Include/arm_math.h **** 
 882:.\Include/arm_math.h **** 
 883:.\Include/arm_math.h ****   /*
 884:.\Include/arm_math.h ****    * @brief C custom defined SHSAX for M3 and M0 processors
 885:.\Include/arm_math.h ****    */
 886:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
 887:.\Include/arm_math.h ****   uint32_t x,
 888:.\Include/arm_math.h ****   uint32_t y)
 889:.\Include/arm_math.h ****   {
 890:.\Include/arm_math.h ****     q31_t r, s;
 891:.\Include/arm_math.h **** 
 892:.\Include/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 893:.\Include/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 894:.\Include/arm_math.h **** 
 895:.\Include/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 896:.\Include/arm_math.h ****   }
 897:.\Include/arm_math.h **** 
 898:.\Include/arm_math.h **** 
 899:.\Include/arm_math.h ****   /*
 900:.\Include/arm_math.h ****    * @brief C custom defined SMUSDX for M3 and M0 processors
 901:.\Include/arm_math.h ****    */
 902:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
 903:.\Include/arm_math.h ****   uint32_t x,
 904:.\Include/arm_math.h ****   uint32_t y)
 905:.\Include/arm_math.h ****   {
 906:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 907:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 908:.\Include/arm_math.h ****   }
 909:.\Include/arm_math.h **** 
 910:.\Include/arm_math.h ****   /*
 911:.\Include/arm_math.h ****    * @brief C custom defined SMUADX for M3 and M0 processors
 912:.\Include/arm_math.h ****    */
 913:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
 914:.\Include/arm_math.h ****   uint32_t x,
 915:.\Include/arm_math.h ****   uint32_t y)
 916:.\Include/arm_math.h ****   {
 917:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 918:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 22


 919:.\Include/arm_math.h ****   }
 920:.\Include/arm_math.h **** 
 921:.\Include/arm_math.h **** 
 922:.\Include/arm_math.h ****   /*
 923:.\Include/arm_math.h ****    * @brief C custom defined QADD for M3 and M0 processors
 924:.\Include/arm_math.h ****    */
 925:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
 926:.\Include/arm_math.h ****   int32_t x,
 927:.\Include/arm_math.h ****   int32_t y)
 928:.\Include/arm_math.h ****   {
 929:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
 930:.\Include/arm_math.h ****   }
 931:.\Include/arm_math.h **** 
 932:.\Include/arm_math.h **** 
 933:.\Include/arm_math.h ****   /*
 934:.\Include/arm_math.h ****    * @brief C custom defined QSUB for M3 and M0 processors
 935:.\Include/arm_math.h ****    */
 936:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
 937:.\Include/arm_math.h ****   int32_t x,
 938:.\Include/arm_math.h ****   int32_t y)
 939:.\Include/arm_math.h ****   {
 940:.\Include/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
 941:.\Include/arm_math.h ****   }
 942:.\Include/arm_math.h **** 
 943:.\Include/arm_math.h **** 
 944:.\Include/arm_math.h ****   /*
 945:.\Include/arm_math.h ****    * @brief C custom defined SMLAD for M3 and M0 processors
 946:.\Include/arm_math.h ****    */
 947:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
 948:.\Include/arm_math.h ****   uint32_t x,
 949:.\Include/arm_math.h ****   uint32_t y,
 950:.\Include/arm_math.h ****   uint32_t sum)
 951:.\Include/arm_math.h ****   {
 952:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 953:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 954:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 955:.\Include/arm_math.h ****   }
 956:.\Include/arm_math.h **** 
 957:.\Include/arm_math.h **** 
 958:.\Include/arm_math.h ****   /*
 959:.\Include/arm_math.h ****    * @brief C custom defined SMLADX for M3 and M0 processors
 960:.\Include/arm_math.h ****    */
 961:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
 962:.\Include/arm_math.h ****   uint32_t x,
 963:.\Include/arm_math.h ****   uint32_t y,
 964:.\Include/arm_math.h ****   uint32_t sum)
 965:.\Include/arm_math.h ****   {
 966:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 967:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 968:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 969:.\Include/arm_math.h ****   }
 970:.\Include/arm_math.h **** 
 971:.\Include/arm_math.h **** 
 972:.\Include/arm_math.h ****   /*
 973:.\Include/arm_math.h ****    * @brief C custom defined SMLSDX for M3 and M0 processors
 974:.\Include/arm_math.h ****    */
 975:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 23


 976:.\Include/arm_math.h ****   uint32_t x,
 977:.\Include/arm_math.h ****   uint32_t y,
 978:.\Include/arm_math.h ****   uint32_t sum)
 979:.\Include/arm_math.h ****   {
 980:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 981:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 982:.\Include/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 983:.\Include/arm_math.h ****   }
 984:.\Include/arm_math.h **** 
 985:.\Include/arm_math.h **** 
 986:.\Include/arm_math.h ****   /*
 987:.\Include/arm_math.h ****    * @brief C custom defined SMLALD for M3 and M0 processors
 988:.\Include/arm_math.h ****    */
 989:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
 990:.\Include/arm_math.h ****   uint32_t x,
 991:.\Include/arm_math.h ****   uint32_t y,
 992:.\Include/arm_math.h ****   uint64_t sum)
 993:.\Include/arm_math.h ****   {
 994:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
 995:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 996:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 997:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 998:.\Include/arm_math.h ****   }
 999:.\Include/arm_math.h **** 
1000:.\Include/arm_math.h **** 
1001:.\Include/arm_math.h ****   /*
1002:.\Include/arm_math.h ****    * @brief C custom defined SMLALDX for M3 and M0 processors
1003:.\Include/arm_math.h ****    */
1004:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
1005:.\Include/arm_math.h ****   uint32_t x,
1006:.\Include/arm_math.h ****   uint32_t y,
1007:.\Include/arm_math.h ****   uint64_t sum)
1008:.\Include/arm_math.h ****   {
1009:.\Include/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
1010:.\Include/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
1011:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
1012:.\Include/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
1013:.\Include/arm_math.h ****   }
1014:.\Include/arm_math.h **** 
1015:.\Include/arm_math.h **** 
1016:.\Include/arm_math.h ****   /*
1017:.\Include/arm_math.h ****    * @brief C custom defined SMUAD for M3 and M0 processors
1018:.\Include/arm_math.h ****    */
1019:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
1020:.\Include/arm_math.h ****   uint32_t x,
1021:.\Include/arm_math.h ****   uint32_t y)
1022:.\Include/arm_math.h ****   {
1023:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
1024:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1025:.\Include/arm_math.h ****   }
1026:.\Include/arm_math.h **** 
1027:.\Include/arm_math.h **** 
1028:.\Include/arm_math.h ****   /*
1029:.\Include/arm_math.h ****    * @brief C custom defined SMUSD for M3 and M0 processors
1030:.\Include/arm_math.h ****    */
1031:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
1032:.\Include/arm_math.h ****   uint32_t x,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 24


1033:.\Include/arm_math.h ****   uint32_t y)
1034:.\Include/arm_math.h ****   {
1035:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
1036:.\Include/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1037:.\Include/arm_math.h ****   }
1038:.\Include/arm_math.h **** 
1039:.\Include/arm_math.h **** 
1040:.\Include/arm_math.h ****   /*
1041:.\Include/arm_math.h ****    * @brief C custom defined SXTB16 for M3 and M0 processors
1042:.\Include/arm_math.h ****    */
1043:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
1044:.\Include/arm_math.h ****   uint32_t x)
1045:.\Include/arm_math.h ****   {
1046:.\Include/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
1047:.\Include/arm_math.h ****                        ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
1048:.\Include/arm_math.h ****   }
1049:.\Include/arm_math.h **** 
1050:.\Include/arm_math.h ****   /*
1051:.\Include/arm_math.h ****    * @brief C custom defined SMMLA for M3 and M0 processors
1052:.\Include/arm_math.h ****    */
1053:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
1054:.\Include/arm_math.h ****   int32_t x,
1055:.\Include/arm_math.h ****   int32_t y,
1056:.\Include/arm_math.h ****   int32_t sum)
1057:.\Include/arm_math.h ****   {
1058:.\Include/arm_math.h ****     return (sum + (int32_t) (((int64_t) x * y) >> 32));
1059:.\Include/arm_math.h ****   }
1060:.\Include/arm_math.h **** 
1061:.\Include/arm_math.h **** #if 0
1062:.\Include/arm_math.h ****   /*
1063:.\Include/arm_math.h ****    * @brief C custom defined PKHBT for unavailable DSP extension
1064:.\Include/arm_math.h ****    */
1065:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHBT(
1066:.\Include/arm_math.h ****   uint32_t x,
1067:.\Include/arm_math.h ****   uint32_t y,
1068:.\Include/arm_math.h ****   uint32_t leftshift)
1069:.\Include/arm_math.h ****   {
1070:.\Include/arm_math.h ****     return ( ((x             ) & 0x0000FFFFUL) |
1071:.\Include/arm_math.h ****              ((y << leftshift) & 0xFFFF0000UL)  );
1072:.\Include/arm_math.h ****   }
1073:.\Include/arm_math.h **** 
1074:.\Include/arm_math.h ****   /*
1075:.\Include/arm_math.h ****    * @brief C custom defined PKHTB for unavailable DSP extension
1076:.\Include/arm_math.h ****    */
1077:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __PKHTB(
1078:.\Include/arm_math.h ****   uint32_t x,
1079:.\Include/arm_math.h ****   uint32_t y,
1080:.\Include/arm_math.h ****   uint32_t rightshift)
1081:.\Include/arm_math.h ****   {
1082:.\Include/arm_math.h ****     return ( ((x              ) & 0xFFFF0000UL) |
1083:.\Include/arm_math.h ****              ((y >> rightshift) & 0x0000FFFFUL)  );
1084:.\Include/arm_math.h ****   }
1085:.\Include/arm_math.h **** #endif
1086:.\Include/arm_math.h **** 
1087:.\Include/arm_math.h **** /* #endif // defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
1088:.\Include/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
1089:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 25


1090:.\Include/arm_math.h **** 
1091:.\Include/arm_math.h ****   /**
1092:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 FIR filter.
1093:.\Include/arm_math.h ****    */
1094:.\Include/arm_math.h ****   typedef struct
1095:.\Include/arm_math.h ****   {
1096:.\Include/arm_math.h ****     uint16_t numTaps;        /**< number of filter coefficients in the filter. */
1097:.\Include/arm_math.h ****     q7_t *pState;            /**< points to the state variable array. The array is of length numTap
1098:.\Include/arm_math.h ****     q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*
1099:.\Include/arm_math.h ****   } arm_fir_instance_q7;
1100:.\Include/arm_math.h **** 
1101:.\Include/arm_math.h ****   /**
1102:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR filter.
1103:.\Include/arm_math.h ****    */
1104:.\Include/arm_math.h ****   typedef struct
1105:.\Include/arm_math.h ****   {
1106:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1107:.\Include/arm_math.h ****     q15_t *pState;            /**< points to the state variable array. The array is of length numTa
1108:.\Include/arm_math.h ****     q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1109:.\Include/arm_math.h ****   } arm_fir_instance_q15;
1110:.\Include/arm_math.h **** 
1111:.\Include/arm_math.h ****   /**
1112:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR filter.
1113:.\Include/arm_math.h ****    */
1114:.\Include/arm_math.h ****   typedef struct
1115:.\Include/arm_math.h ****   {
1116:.\Include/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1117:.\Include/arm_math.h ****     q31_t *pState;            /**< points to the state variable array. The array is of length numTa
1118:.\Include/arm_math.h ****     q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1119:.\Include/arm_math.h ****   } arm_fir_instance_q31;
1120:.\Include/arm_math.h **** 
1121:.\Include/arm_math.h ****   /**
1122:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR filter.
1123:.\Include/arm_math.h ****    */
1124:.\Include/arm_math.h ****   typedef struct
1125:.\Include/arm_math.h ****   {
1126:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of filter coefficients in the filter. */
1127:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
1128:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
1129:.\Include/arm_math.h ****   } arm_fir_instance_f32;
1130:.\Include/arm_math.h **** 
1131:.\Include/arm_math.h **** 
1132:.\Include/arm_math.h ****   /**
1133:.\Include/arm_math.h ****    * @brief Processing function for the Q7 FIR filter.
1134:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
1135:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1136:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1137:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1138:.\Include/arm_math.h ****    */
1139:.\Include/arm_math.h ****   void arm_fir_q7(
1140:.\Include/arm_math.h ****   const arm_fir_instance_q7 * S,
1141:.\Include/arm_math.h ****   q7_t * pSrc,
1142:.\Include/arm_math.h ****   q7_t * pDst,
1143:.\Include/arm_math.h ****   uint32_t blockSize);
1144:.\Include/arm_math.h **** 
1145:.\Include/arm_math.h **** 
1146:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 26


1147:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 FIR filter.
1148:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 FIR structure.
1149:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1150:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1151:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1152:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed.
1153:.\Include/arm_math.h ****    */
1154:.\Include/arm_math.h ****   void arm_fir_init_q7(
1155:.\Include/arm_math.h ****   arm_fir_instance_q7 * S,
1156:.\Include/arm_math.h ****   uint16_t numTaps,
1157:.\Include/arm_math.h ****   q7_t * pCoeffs,
1158:.\Include/arm_math.h ****   q7_t * pState,
1159:.\Include/arm_math.h ****   uint32_t blockSize);
1160:.\Include/arm_math.h **** 
1161:.\Include/arm_math.h **** 
1162:.\Include/arm_math.h ****   /**
1163:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR filter.
1164:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR structure.
1165:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1166:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1167:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1168:.\Include/arm_math.h ****    */
1169:.\Include/arm_math.h ****   void arm_fir_q15(
1170:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1171:.\Include/arm_math.h ****   q15_t * pSrc,
1172:.\Include/arm_math.h ****   q15_t * pDst,
1173:.\Include/arm_math.h ****   uint32_t blockSize);
1174:.\Include/arm_math.h **** 
1175:.\Include/arm_math.h **** 
1176:.\Include/arm_math.h ****   /**
1177:.\Include/arm_math.h ****    * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
1178:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
1179:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1180:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1181:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1182:.\Include/arm_math.h ****    */
1183:.\Include/arm_math.h ****   void arm_fir_fast_q15(
1184:.\Include/arm_math.h ****   const arm_fir_instance_q15 * S,
1185:.\Include/arm_math.h ****   q15_t * pSrc,
1186:.\Include/arm_math.h ****   q15_t * pDst,
1187:.\Include/arm_math.h ****   uint32_t blockSize);
1188:.\Include/arm_math.h **** 
1189:.\Include/arm_math.h **** 
1190:.\Include/arm_math.h ****   /**
1191:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR filter.
1192:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
1193:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greate
1194:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1195:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1196:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1197:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARG
1198:.\Include/arm_math.h ****    * <code>numTaps</code> is not a supported value.
1199:.\Include/arm_math.h ****    */
1200:.\Include/arm_math.h ****   arm_status arm_fir_init_q15(
1201:.\Include/arm_math.h ****   arm_fir_instance_q15 * S,
1202:.\Include/arm_math.h ****   uint16_t numTaps,
1203:.\Include/arm_math.h ****   q15_t * pCoeffs,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 27


1204:.\Include/arm_math.h ****   q15_t * pState,
1205:.\Include/arm_math.h ****   uint32_t blockSize);
1206:.\Include/arm_math.h **** 
1207:.\Include/arm_math.h **** 
1208:.\Include/arm_math.h ****   /**
1209:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR filter.
1210:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR filter structure.
1211:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1212:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1213:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1214:.\Include/arm_math.h ****    */
1215:.\Include/arm_math.h ****   void arm_fir_q31(
1216:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1217:.\Include/arm_math.h ****   q31_t * pSrc,
1218:.\Include/arm_math.h ****   q31_t * pDst,
1219:.\Include/arm_math.h ****   uint32_t blockSize);
1220:.\Include/arm_math.h **** 
1221:.\Include/arm_math.h **** 
1222:.\Include/arm_math.h ****   /**
1223:.\Include/arm_math.h ****    * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
1224:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR structure.
1225:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1226:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1227:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1228:.\Include/arm_math.h ****    */
1229:.\Include/arm_math.h ****   void arm_fir_fast_q31(
1230:.\Include/arm_math.h ****   const arm_fir_instance_q31 * S,
1231:.\Include/arm_math.h ****   q31_t * pSrc,
1232:.\Include/arm_math.h ****   q31_t * pDst,
1233:.\Include/arm_math.h ****   uint32_t blockSize);
1234:.\Include/arm_math.h **** 
1235:.\Include/arm_math.h **** 
1236:.\Include/arm_math.h ****   /**
1237:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR filter.
1238:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR structure.
1239:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1240:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1241:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1242:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1243:.\Include/arm_math.h ****    */
1244:.\Include/arm_math.h ****   void arm_fir_init_q31(
1245:.\Include/arm_math.h ****   arm_fir_instance_q31 * S,
1246:.\Include/arm_math.h ****   uint16_t numTaps,
1247:.\Include/arm_math.h ****   q31_t * pCoeffs,
1248:.\Include/arm_math.h ****   q31_t * pState,
1249:.\Include/arm_math.h ****   uint32_t blockSize);
1250:.\Include/arm_math.h **** 
1251:.\Include/arm_math.h **** 
1252:.\Include/arm_math.h ****   /**
1253:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR filter.
1254:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR structure.
1255:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1256:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1257:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1258:.\Include/arm_math.h ****    */
1259:.\Include/arm_math.h ****   void arm_fir_f32(
1260:.\Include/arm_math.h ****   const arm_fir_instance_f32 * S,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 28


1261:.\Include/arm_math.h ****   float32_t * pSrc,
1262:.\Include/arm_math.h ****   float32_t * pDst,
1263:.\Include/arm_math.h ****   uint32_t blockSize);
1264:.\Include/arm_math.h **** 
1265:.\Include/arm_math.h **** 
1266:.\Include/arm_math.h ****   /**
1267:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR filter.
1268:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
1269:.\Include/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1270:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1271:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1272:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1273:.\Include/arm_math.h ****    */
1274:.\Include/arm_math.h ****   void arm_fir_init_f32(
1275:.\Include/arm_math.h ****   arm_fir_instance_f32 * S,
1276:.\Include/arm_math.h ****   uint16_t numTaps,
1277:.\Include/arm_math.h ****   float32_t * pCoeffs,
1278:.\Include/arm_math.h ****   float32_t * pState,
1279:.\Include/arm_math.h ****   uint32_t blockSize);
1280:.\Include/arm_math.h **** 
1281:.\Include/arm_math.h **** 
1282:.\Include/arm_math.h ****   /**
1283:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 Biquad cascade filter.
1284:.\Include/arm_math.h ****    */
1285:.\Include/arm_math.h ****   typedef struct
1286:.\Include/arm_math.h ****   {
1287:.\Include/arm_math.h ****     int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*num
1288:.\Include/arm_math.h ****     q15_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1289:.\Include/arm_math.h ****     q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1290:.\Include/arm_math.h ****     int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
1291:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q15;
1292:.\Include/arm_math.h **** 
1293:.\Include/arm_math.h ****   /**
1294:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 Biquad cascade filter.
1295:.\Include/arm_math.h ****    */
1296:.\Include/arm_math.h ****   typedef struct
1297:.\Include/arm_math.h ****   {
1298:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1299:.\Include/arm_math.h ****     q31_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1300:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1301:.\Include/arm_math.h ****     uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
1302:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_q31;
1303:.\Include/arm_math.h **** 
1304:.\Include/arm_math.h ****   /**
1305:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Biquad cascade filter.
1306:.\Include/arm_math.h ****    */
1307:.\Include/arm_math.h ****   typedef struct
1308:.\Include/arm_math.h ****   {
1309:.\Include/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1310:.\Include/arm_math.h ****     float32_t *pState;       /**< Points to the array of state coefficients.  The array is of lengt
1311:.\Include/arm_math.h ****     float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*nu
1312:.\Include/arm_math.h ****   } arm_biquad_casd_df1_inst_f32;
1313:.\Include/arm_math.h **** 
1314:.\Include/arm_math.h **** 
1315:.\Include/arm_math.h ****   /**
1316:.\Include/arm_math.h ****    * @brief Processing function for the Q15 Biquad cascade filter.
1317:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 29


1318:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1319:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1320:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1321:.\Include/arm_math.h ****    */
1322:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q15(
1323:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1324:.\Include/arm_math.h ****   q15_t * pSrc,
1325:.\Include/arm_math.h ****   q15_t * pDst,
1326:.\Include/arm_math.h ****   uint32_t blockSize);
1327:.\Include/arm_math.h **** 
1328:.\Include/arm_math.h **** 
1329:.\Include/arm_math.h ****   /**
1330:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 Biquad cascade filter.
1331:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
1332:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1333:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1334:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1335:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1336:.\Include/arm_math.h ****    */
1337:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q15(
1338:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q15 * S,
1339:.\Include/arm_math.h ****   uint8_t numStages,
1340:.\Include/arm_math.h ****   q15_t * pCoeffs,
1341:.\Include/arm_math.h ****   q15_t * pState,
1342:.\Include/arm_math.h ****   int8_t postShift);
1343:.\Include/arm_math.h **** 
1344:.\Include/arm_math.h **** 
1345:.\Include/arm_math.h ****   /**
1346:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-
1347:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1348:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1349:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1350:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1351:.\Include/arm_math.h ****    */
1352:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q15(
1353:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1354:.\Include/arm_math.h ****   q15_t * pSrc,
1355:.\Include/arm_math.h ****   q15_t * pDst,
1356:.\Include/arm_math.h ****   uint32_t blockSize);
1357:.\Include/arm_math.h **** 
1358:.\Include/arm_math.h **** 
1359:.\Include/arm_math.h ****   /**
1360:.\Include/arm_math.h ****    * @brief Processing function for the Q31 Biquad cascade filter
1361:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1362:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1363:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1364:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1365:.\Include/arm_math.h ****    */
1366:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_q31(
1367:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1368:.\Include/arm_math.h ****   q31_t * pSrc,
1369:.\Include/arm_math.h ****   q31_t * pDst,
1370:.\Include/arm_math.h ****   uint32_t blockSize);
1371:.\Include/arm_math.h **** 
1372:.\Include/arm_math.h **** 
1373:.\Include/arm_math.h ****   /**
1374:.\Include/arm_math.h ****    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 30


1375:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1376:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1377:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1378:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1379:.\Include/arm_math.h ****    */
1380:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_fast_q31(
1381:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1382:.\Include/arm_math.h ****   q31_t * pSrc,
1383:.\Include/arm_math.h ****   q31_t * pDst,
1384:.\Include/arm_math.h ****   uint32_t blockSize);
1385:.\Include/arm_math.h **** 
1386:.\Include/arm_math.h **** 
1387:.\Include/arm_math.h ****   /**
1388:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 Biquad cascade filter.
1389:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
1390:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1391:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1392:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1393:.\Include/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1394:.\Include/arm_math.h ****    */
1395:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_q31(
1396:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_q31 * S,
1397:.\Include/arm_math.h ****   uint8_t numStages,
1398:.\Include/arm_math.h ****   q31_t * pCoeffs,
1399:.\Include/arm_math.h ****   q31_t * pState,
1400:.\Include/arm_math.h ****   int8_t postShift);
1401:.\Include/arm_math.h **** 
1402:.\Include/arm_math.h **** 
1403:.\Include/arm_math.h ****   /**
1404:.\Include/arm_math.h ****    * @brief Processing function for the floating-point Biquad cascade filter.
1405:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
1406:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1407:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1408:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1409:.\Include/arm_math.h ****    */
1410:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_f32(
1411:.\Include/arm_math.h ****   const arm_biquad_casd_df1_inst_f32 * S,
1412:.\Include/arm_math.h ****   float32_t * pSrc,
1413:.\Include/arm_math.h ****   float32_t * pDst,
1414:.\Include/arm_math.h ****   uint32_t blockSize);
1415:.\Include/arm_math.h **** 
1416:.\Include/arm_math.h **** 
1417:.\Include/arm_math.h ****   /**
1418:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point Biquad cascade filter.
1419:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure
1420:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1421:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1422:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1423:.\Include/arm_math.h ****    */
1424:.\Include/arm_math.h ****   void arm_biquad_cascade_df1_init_f32(
1425:.\Include/arm_math.h ****   arm_biquad_casd_df1_inst_f32 * S,
1426:.\Include/arm_math.h ****   uint8_t numStages,
1427:.\Include/arm_math.h ****   float32_t * pCoeffs,
1428:.\Include/arm_math.h ****   float32_t * pState);
1429:.\Include/arm_math.h **** 
1430:.\Include/arm_math.h **** 
1431:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 31


1432:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1433:.\Include/arm_math.h ****    */
1434:.\Include/arm_math.h ****   typedef struct
1435:.\Include/arm_math.h ****   {
1436:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1437:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1438:.\Include/arm_math.h ****     float32_t *pData;     /**< points to the data of the matrix. */
1439:.\Include/arm_math.h ****   } arm_matrix_instance_f32;
1440:.\Include/arm_math.h **** 
1441:.\Include/arm_math.h **** 
1442:.\Include/arm_math.h ****   /**
1443:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1444:.\Include/arm_math.h ****    */
1445:.\Include/arm_math.h ****   typedef struct
1446:.\Include/arm_math.h ****   {
1447:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1448:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1449:.\Include/arm_math.h ****     float64_t *pData;     /**< points to the data of the matrix. */
1450:.\Include/arm_math.h ****   } arm_matrix_instance_f64;
1451:.\Include/arm_math.h **** 
1452:.\Include/arm_math.h ****   /**
1453:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 matrix structure.
1454:.\Include/arm_math.h ****    */
1455:.\Include/arm_math.h ****   typedef struct
1456:.\Include/arm_math.h ****   {
1457:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1458:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1459:.\Include/arm_math.h ****     q15_t *pData;         /**< points to the data of the matrix. */
1460:.\Include/arm_math.h ****   } arm_matrix_instance_q15;
1461:.\Include/arm_math.h **** 
1462:.\Include/arm_math.h ****   /**
1463:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 matrix structure.
1464:.\Include/arm_math.h ****    */
1465:.\Include/arm_math.h ****   typedef struct
1466:.\Include/arm_math.h ****   {
1467:.\Include/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1468:.\Include/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1469:.\Include/arm_math.h ****     q31_t *pData;         /**< points to the data of the matrix. */
1470:.\Include/arm_math.h ****   } arm_matrix_instance_q31;
1471:.\Include/arm_math.h **** 
1472:.\Include/arm_math.h **** 
1473:.\Include/arm_math.h ****   /**
1474:.\Include/arm_math.h ****    * @brief Floating-point matrix addition.
1475:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1476:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1477:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1478:.\Include/arm_math.h ****    * @return     The function returns either
1479:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1480:.\Include/arm_math.h ****    */
1481:.\Include/arm_math.h ****   arm_status arm_mat_add_f32(
1482:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1483:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1484:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1485:.\Include/arm_math.h **** 
1486:.\Include/arm_math.h **** 
1487:.\Include/arm_math.h ****   /**
1488:.\Include/arm_math.h ****    * @brief Q15 matrix addition.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 32


1489:.\Include/arm_math.h ****    * @param[in]   pSrcA  points to the first input matrix structure
1490:.\Include/arm_math.h ****    * @param[in]   pSrcB  points to the second input matrix structure
1491:.\Include/arm_math.h ****    * @param[out]  pDst   points to output matrix structure
1492:.\Include/arm_math.h ****    * @return     The function returns either
1493:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1494:.\Include/arm_math.h ****    */
1495:.\Include/arm_math.h ****   arm_status arm_mat_add_q15(
1496:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1497:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1498:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1499:.\Include/arm_math.h **** 
1500:.\Include/arm_math.h **** 
1501:.\Include/arm_math.h ****   /**
1502:.\Include/arm_math.h ****    * @brief Q31 matrix addition.
1503:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1504:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1505:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1506:.\Include/arm_math.h ****    * @return     The function returns either
1507:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1508:.\Include/arm_math.h ****    */
1509:.\Include/arm_math.h ****   arm_status arm_mat_add_q31(
1510:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1511:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1512:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1513:.\Include/arm_math.h **** 
1514:.\Include/arm_math.h **** 
1515:.\Include/arm_math.h ****   /**
1516:.\Include/arm_math.h ****    * @brief Floating-point, complex, matrix multiplication.
1517:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1518:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1519:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1520:.\Include/arm_math.h ****    * @return     The function returns either
1521:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1522:.\Include/arm_math.h ****    */
1523:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_f32(
1524:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1525:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1526:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1527:.\Include/arm_math.h **** 
1528:.\Include/arm_math.h **** 
1529:.\Include/arm_math.h ****   /**
1530:.\Include/arm_math.h ****    * @brief Q15, complex,  matrix multiplication.
1531:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1532:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1533:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1534:.\Include/arm_math.h ****    * @return     The function returns either
1535:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1536:.\Include/arm_math.h ****    */
1537:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q15(
1538:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1539:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1540:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1541:.\Include/arm_math.h ****   q15_t * pScratch);
1542:.\Include/arm_math.h **** 
1543:.\Include/arm_math.h **** 
1544:.\Include/arm_math.h ****   /**
1545:.\Include/arm_math.h ****    * @brief Q31, complex, matrix multiplication.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 33


1546:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1547:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1548:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1549:.\Include/arm_math.h ****    * @return     The function returns either
1550:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1551:.\Include/arm_math.h ****    */
1552:.\Include/arm_math.h ****   arm_status arm_mat_cmplx_mult_q31(
1553:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1554:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1555:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1556:.\Include/arm_math.h **** 
1557:.\Include/arm_math.h **** 
1558:.\Include/arm_math.h ****   /**
1559:.\Include/arm_math.h ****    * @brief Floating-point matrix transpose.
1560:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1561:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1562:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1563:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1564:.\Include/arm_math.h ****    */
1565:.\Include/arm_math.h ****   arm_status arm_mat_trans_f32(
1566:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1567:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1568:.\Include/arm_math.h **** 
1569:.\Include/arm_math.h **** 
1570:.\Include/arm_math.h ****   /**
1571:.\Include/arm_math.h ****    * @brief Q15 matrix transpose.
1572:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1573:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1574:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1575:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1576:.\Include/arm_math.h ****    */
1577:.\Include/arm_math.h ****   arm_status arm_mat_trans_q15(
1578:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1579:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1580:.\Include/arm_math.h **** 
1581:.\Include/arm_math.h **** 
1582:.\Include/arm_math.h ****   /**
1583:.\Include/arm_math.h ****    * @brief Q31 matrix transpose.
1584:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1585:.\Include/arm_math.h ****    * @param[out] pDst  points to the output matrix
1586:.\Include/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1587:.\Include/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1588:.\Include/arm_math.h ****    */
1589:.\Include/arm_math.h ****   arm_status arm_mat_trans_q31(
1590:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1591:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1592:.\Include/arm_math.h **** 
1593:.\Include/arm_math.h **** 
1594:.\Include/arm_math.h ****   /**
1595:.\Include/arm_math.h ****    * @brief Floating-point matrix multiplication
1596:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1597:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1598:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1599:.\Include/arm_math.h ****    * @return     The function returns either
1600:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1601:.\Include/arm_math.h ****    */
1602:.\Include/arm_math.h ****   arm_status arm_mat_mult_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 34


1603:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1604:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1605:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1606:.\Include/arm_math.h **** 
1607:.\Include/arm_math.h **** 
1608:.\Include/arm_math.h ****   /**
1609:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication
1610:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1611:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1612:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1613:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1614:.\Include/arm_math.h ****    * @return     The function returns either
1615:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1616:.\Include/arm_math.h ****    */
1617:.\Include/arm_math.h ****   arm_status arm_mat_mult_q15(
1618:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1619:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1620:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1621:.\Include/arm_math.h ****   q15_t * pState);
1622:.\Include/arm_math.h **** 
1623:.\Include/arm_math.h **** 
1624:.\Include/arm_math.h ****   /**
1625:.\Include/arm_math.h ****    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1626:.\Include/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1627:.\Include/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1628:.\Include/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1629:.\Include/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1630:.\Include/arm_math.h ****    * @return     The function returns either
1631:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1632:.\Include/arm_math.h ****    */
1633:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q15(
1634:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1635:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1636:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1637:.\Include/arm_math.h ****   q15_t * pState);
1638:.\Include/arm_math.h **** 
1639:.\Include/arm_math.h **** 
1640:.\Include/arm_math.h ****   /**
1641:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication
1642:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1643:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1644:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1645:.\Include/arm_math.h ****    * @return     The function returns either
1646:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1647:.\Include/arm_math.h ****    */
1648:.\Include/arm_math.h ****   arm_status arm_mat_mult_q31(
1649:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1650:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1651:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1652:.\Include/arm_math.h **** 
1653:.\Include/arm_math.h **** 
1654:.\Include/arm_math.h ****   /**
1655:.\Include/arm_math.h ****    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1656:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1657:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1658:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1659:.\Include/arm_math.h ****    * @return     The function returns either
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 35


1660:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1661:.\Include/arm_math.h ****    */
1662:.\Include/arm_math.h ****   arm_status arm_mat_mult_fast_q31(
1663:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1664:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1665:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1666:.\Include/arm_math.h **** 
1667:.\Include/arm_math.h **** 
1668:.\Include/arm_math.h ****   /**
1669:.\Include/arm_math.h ****    * @brief Floating-point matrix subtraction
1670:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1671:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1672:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1673:.\Include/arm_math.h ****    * @return     The function returns either
1674:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1675:.\Include/arm_math.h ****    */
1676:.\Include/arm_math.h ****   arm_status arm_mat_sub_f32(
1677:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1678:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1679:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1680:.\Include/arm_math.h **** 
1681:.\Include/arm_math.h **** 
1682:.\Include/arm_math.h ****   /**
1683:.\Include/arm_math.h ****    * @brief Q15 matrix subtraction
1684:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1685:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1686:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1687:.\Include/arm_math.h ****    * @return     The function returns either
1688:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1689:.\Include/arm_math.h ****    */
1690:.\Include/arm_math.h ****   arm_status arm_mat_sub_q15(
1691:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1692:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1693:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1694:.\Include/arm_math.h **** 
1695:.\Include/arm_math.h **** 
1696:.\Include/arm_math.h ****   /**
1697:.\Include/arm_math.h ****    * @brief Q31 matrix subtraction
1698:.\Include/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1699:.\Include/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1700:.\Include/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1701:.\Include/arm_math.h ****    * @return     The function returns either
1702:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1703:.\Include/arm_math.h ****    */
1704:.\Include/arm_math.h ****   arm_status arm_mat_sub_q31(
1705:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1706:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1707:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1708:.\Include/arm_math.h **** 
1709:.\Include/arm_math.h **** 
1710:.\Include/arm_math.h ****   /**
1711:.\Include/arm_math.h ****    * @brief Floating-point matrix scaling.
1712:.\Include/arm_math.h ****    * @param[in]  pSrc   points to the input matrix
1713:.\Include/arm_math.h ****    * @param[in]  scale  scale factor
1714:.\Include/arm_math.h ****    * @param[out] pDst   points to the output matrix
1715:.\Include/arm_math.h ****    * @return     The function returns either
1716:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 36


1717:.\Include/arm_math.h ****    */
1718:.\Include/arm_math.h ****   arm_status arm_mat_scale_f32(
1719:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1720:.\Include/arm_math.h ****   float32_t scale,
1721:.\Include/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1722:.\Include/arm_math.h **** 
1723:.\Include/arm_math.h **** 
1724:.\Include/arm_math.h ****   /**
1725:.\Include/arm_math.h ****    * @brief Q15 matrix scaling.
1726:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1727:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1728:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1729:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix
1730:.\Include/arm_math.h ****    * @return     The function returns either
1731:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1732:.\Include/arm_math.h ****    */
1733:.\Include/arm_math.h ****   arm_status arm_mat_scale_q15(
1734:.\Include/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1735:.\Include/arm_math.h ****   q15_t scaleFract,
1736:.\Include/arm_math.h ****   int32_t shift,
1737:.\Include/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1738:.\Include/arm_math.h **** 
1739:.\Include/arm_math.h **** 
1740:.\Include/arm_math.h ****   /**
1741:.\Include/arm_math.h ****    * @brief Q31 matrix scaling.
1742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1743:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1744:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1745:.\Include/arm_math.h ****    * @param[out] pDst        points to output matrix structure
1746:.\Include/arm_math.h ****    * @return     The function returns either
1747:.\Include/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1748:.\Include/arm_math.h ****    */
1749:.\Include/arm_math.h ****   arm_status arm_mat_scale_q31(
1750:.\Include/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1751:.\Include/arm_math.h ****   q31_t scaleFract,
1752:.\Include/arm_math.h ****   int32_t shift,
1753:.\Include/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1754:.\Include/arm_math.h **** 
1755:.\Include/arm_math.h **** 
1756:.\Include/arm_math.h ****   /**
1757:.\Include/arm_math.h ****    * @brief  Q31 matrix initialization.
1758:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1759:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1760:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1761:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1762:.\Include/arm_math.h ****    */
1763:.\Include/arm_math.h ****   void arm_mat_init_q31(
1764:.\Include/arm_math.h ****   arm_matrix_instance_q31 * S,
1765:.\Include/arm_math.h ****   uint16_t nRows,
1766:.\Include/arm_math.h ****   uint16_t nColumns,
1767:.\Include/arm_math.h ****   q31_t * pData);
1768:.\Include/arm_math.h **** 
1769:.\Include/arm_math.h **** 
1770:.\Include/arm_math.h ****   /**
1771:.\Include/arm_math.h ****    * @brief  Q15 matrix initialization.
1772:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1773:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 37


1774:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1775:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1776:.\Include/arm_math.h ****    */
1777:.\Include/arm_math.h ****   void arm_mat_init_q15(
1778:.\Include/arm_math.h ****   arm_matrix_instance_q15 * S,
1779:.\Include/arm_math.h ****   uint16_t nRows,
1780:.\Include/arm_math.h ****   uint16_t nColumns,
1781:.\Include/arm_math.h ****   q15_t * pData);
1782:.\Include/arm_math.h **** 
1783:.\Include/arm_math.h **** 
1784:.\Include/arm_math.h ****   /**
1785:.\Include/arm_math.h ****    * @brief  Floating-point matrix initialization.
1786:.\Include/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1787:.\Include/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1788:.\Include/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1789:.\Include/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1790:.\Include/arm_math.h ****    */
1791:.\Include/arm_math.h ****   void arm_mat_init_f32(
1792:.\Include/arm_math.h ****   arm_matrix_instance_f32 * S,
1793:.\Include/arm_math.h ****   uint16_t nRows,
1794:.\Include/arm_math.h ****   uint16_t nColumns,
1795:.\Include/arm_math.h ****   float32_t * pData);
1796:.\Include/arm_math.h **** 
1797:.\Include/arm_math.h **** 
1798:.\Include/arm_math.h **** 
1799:.\Include/arm_math.h ****   /**
1800:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 PID Control.
1801:.\Include/arm_math.h ****    */
1802:.\Include/arm_math.h ****   typedef struct
1803:.\Include/arm_math.h ****   {
1804:.\Include/arm_math.h ****     q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
1805:.\Include/arm_math.h **** #if !defined (ARM_MATH_DSP)
1806:.\Include/arm_math.h ****     q15_t A1;
1807:.\Include/arm_math.h ****     q15_t A2;
1808:.\Include/arm_math.h **** #else
1809:.\Include/arm_math.h ****     q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
1810:.\Include/arm_math.h **** #endif
1811:.\Include/arm_math.h ****     q15_t state[3];     /**< The state array of length 3. */
1812:.\Include/arm_math.h ****     q15_t Kp;           /**< The proportional gain. */
1813:.\Include/arm_math.h ****     q15_t Ki;           /**< The integral gain. */
1814:.\Include/arm_math.h ****     q15_t Kd;           /**< The derivative gain. */
1815:.\Include/arm_math.h ****   } arm_pid_instance_q15;
1816:.\Include/arm_math.h **** 
1817:.\Include/arm_math.h ****   /**
1818:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 PID Control.
1819:.\Include/arm_math.h ****    */
1820:.\Include/arm_math.h ****   typedef struct
1821:.\Include/arm_math.h ****   {
1822:.\Include/arm_math.h ****     q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
1823:.\Include/arm_math.h ****     q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
1824:.\Include/arm_math.h ****     q31_t A2;            /**< The derived gain, A2 = Kd . */
1825:.\Include/arm_math.h ****     q31_t state[3];      /**< The state array of length 3. */
1826:.\Include/arm_math.h ****     q31_t Kp;            /**< The proportional gain. */
1827:.\Include/arm_math.h ****     q31_t Ki;            /**< The integral gain. */
1828:.\Include/arm_math.h ****     q31_t Kd;            /**< The derivative gain. */
1829:.\Include/arm_math.h ****   } arm_pid_instance_q31;
1830:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 38


1831:.\Include/arm_math.h ****   /**
1832:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point PID Control.
1833:.\Include/arm_math.h ****    */
1834:.\Include/arm_math.h ****   typedef struct
1835:.\Include/arm_math.h ****   {
1836:.\Include/arm_math.h ****     float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
1837:.\Include/arm_math.h ****     float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
1838:.\Include/arm_math.h ****     float32_t A2;          /**< The derived gain, A2 = Kd . */
1839:.\Include/arm_math.h ****     float32_t state[3];    /**< The state array of length 3. */
1840:.\Include/arm_math.h ****     float32_t Kp;          /**< The proportional gain. */
1841:.\Include/arm_math.h ****     float32_t Ki;          /**< The integral gain. */
1842:.\Include/arm_math.h ****     float32_t Kd;          /**< The derivative gain. */
1843:.\Include/arm_math.h ****   } arm_pid_instance_f32;
1844:.\Include/arm_math.h **** 
1845:.\Include/arm_math.h **** 
1846:.\Include/arm_math.h **** 
1847:.\Include/arm_math.h ****   /**
1848:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point PID Control.
1849:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the PID structure.
1850:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1851:.\Include/arm_math.h ****    */
1852:.\Include/arm_math.h ****   void arm_pid_init_f32(
1853:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
1854:.\Include/arm_math.h ****   int32_t resetStateFlag);
1855:.\Include/arm_math.h **** 
1856:.\Include/arm_math.h **** 
1857:.\Include/arm_math.h ****   /**
1858:.\Include/arm_math.h ****    * @brief  Reset function for the floating-point PID Control.
1859:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point PID Control structure
1860:.\Include/arm_math.h ****    */
1861:.\Include/arm_math.h ****   void arm_pid_reset_f32(
1862:.\Include/arm_math.h ****   arm_pid_instance_f32 * S);
1863:.\Include/arm_math.h **** 
1864:.\Include/arm_math.h **** 
1865:.\Include/arm_math.h ****   /**
1866:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 PID Control.
1867:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1868:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1869:.\Include/arm_math.h ****    */
1870:.\Include/arm_math.h ****   void arm_pid_init_q31(
1871:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
1872:.\Include/arm_math.h ****   int32_t resetStateFlag);
1873:.\Include/arm_math.h **** 
1874:.\Include/arm_math.h **** 
1875:.\Include/arm_math.h ****   /**
1876:.\Include/arm_math.h ****    * @brief  Reset function for the Q31 PID Control.
1877:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q31 PID Control structure
1878:.\Include/arm_math.h ****    */
1879:.\Include/arm_math.h **** 
1880:.\Include/arm_math.h ****   void arm_pid_reset_q31(
1881:.\Include/arm_math.h ****   arm_pid_instance_q31 * S);
1882:.\Include/arm_math.h **** 
1883:.\Include/arm_math.h **** 
1884:.\Include/arm_math.h ****   /**
1885:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 PID Control.
1886:.\Include/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1887:.\Include/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 39


1888:.\Include/arm_math.h ****    */
1889:.\Include/arm_math.h ****   void arm_pid_init_q15(
1890:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
1891:.\Include/arm_math.h ****   int32_t resetStateFlag);
1892:.\Include/arm_math.h **** 
1893:.\Include/arm_math.h **** 
1894:.\Include/arm_math.h ****   /**
1895:.\Include/arm_math.h ****    * @brief  Reset function for the Q15 PID Control.
1896:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the q15 PID Control structure
1897:.\Include/arm_math.h ****    */
1898:.\Include/arm_math.h ****   void arm_pid_reset_q15(
1899:.\Include/arm_math.h ****   arm_pid_instance_q15 * S);
1900:.\Include/arm_math.h **** 
1901:.\Include/arm_math.h **** 
1902:.\Include/arm_math.h ****   /**
1903:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point Linear Interpolate function.
1904:.\Include/arm_math.h ****    */
1905:.\Include/arm_math.h ****   typedef struct
1906:.\Include/arm_math.h ****   {
1907:.\Include/arm_math.h ****     uint32_t nValues;           /**< nValues */
1908:.\Include/arm_math.h ****     float32_t x1;               /**< x1 */
1909:.\Include/arm_math.h ****     float32_t xSpacing;         /**< xSpacing */
1910:.\Include/arm_math.h ****     float32_t *pYData;          /**< pointer to the table of Y values */
1911:.\Include/arm_math.h ****   } arm_linear_interp_instance_f32;
1912:.\Include/arm_math.h **** 
1913:.\Include/arm_math.h ****   /**
1914:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point bilinear interpolation function.
1915:.\Include/arm_math.h ****    */
1916:.\Include/arm_math.h ****   typedef struct
1917:.\Include/arm_math.h ****   {
1918:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1919:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1920:.\Include/arm_math.h ****     float32_t *pData;   /**< points to the data table. */
1921:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_f32;
1922:.\Include/arm_math.h **** 
1923:.\Include/arm_math.h ****    /**
1924:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 bilinear interpolation function.
1925:.\Include/arm_math.h ****    */
1926:.\Include/arm_math.h ****   typedef struct
1927:.\Include/arm_math.h ****   {
1928:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1929:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1930:.\Include/arm_math.h ****     q31_t *pData;       /**< points to the data table. */
1931:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q31;
1932:.\Include/arm_math.h **** 
1933:.\Include/arm_math.h ****    /**
1934:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1935:.\Include/arm_math.h ****    */
1936:.\Include/arm_math.h ****   typedef struct
1937:.\Include/arm_math.h ****   {
1938:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1939:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1940:.\Include/arm_math.h ****     q15_t *pData;       /**< points to the data table. */
1941:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q15;
1942:.\Include/arm_math.h **** 
1943:.\Include/arm_math.h ****    /**
1944:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 40


1945:.\Include/arm_math.h ****    */
1946:.\Include/arm_math.h ****   typedef struct
1947:.\Include/arm_math.h ****   {
1948:.\Include/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1949:.\Include/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1950:.\Include/arm_math.h ****     q7_t *pData;        /**< points to the data table. */
1951:.\Include/arm_math.h ****   } arm_bilinear_interp_instance_q7;
1952:.\Include/arm_math.h **** 
1953:.\Include/arm_math.h **** 
1954:.\Include/arm_math.h ****   /**
1955:.\Include/arm_math.h ****    * @brief Q7 vector multiplication.
1956:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1957:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1958:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1959:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1960:.\Include/arm_math.h ****    */
1961:.\Include/arm_math.h ****   void arm_mult_q7(
1962:.\Include/arm_math.h ****   q7_t * pSrcA,
1963:.\Include/arm_math.h ****   q7_t * pSrcB,
1964:.\Include/arm_math.h ****   q7_t * pDst,
1965:.\Include/arm_math.h ****   uint32_t blockSize);
1966:.\Include/arm_math.h **** 
1967:.\Include/arm_math.h **** 
1968:.\Include/arm_math.h ****   /**
1969:.\Include/arm_math.h ****    * @brief Q15 vector multiplication.
1970:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1971:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1972:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1973:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1974:.\Include/arm_math.h ****    */
1975:.\Include/arm_math.h ****   void arm_mult_q15(
1976:.\Include/arm_math.h ****   q15_t * pSrcA,
1977:.\Include/arm_math.h ****   q15_t * pSrcB,
1978:.\Include/arm_math.h ****   q15_t * pDst,
1979:.\Include/arm_math.h ****   uint32_t blockSize);
1980:.\Include/arm_math.h **** 
1981:.\Include/arm_math.h **** 
1982:.\Include/arm_math.h ****   /**
1983:.\Include/arm_math.h ****    * @brief Q31 vector multiplication.
1984:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1985:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1986:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
1987:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1988:.\Include/arm_math.h ****    */
1989:.\Include/arm_math.h ****   void arm_mult_q31(
1990:.\Include/arm_math.h ****   q31_t * pSrcA,
1991:.\Include/arm_math.h ****   q31_t * pSrcB,
1992:.\Include/arm_math.h ****   q31_t * pDst,
1993:.\Include/arm_math.h ****   uint32_t blockSize);
1994:.\Include/arm_math.h **** 
1995:.\Include/arm_math.h **** 
1996:.\Include/arm_math.h ****   /**
1997:.\Include/arm_math.h ****    * @brief Floating-point vector multiplication.
1998:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1999:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2000:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2001:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 41


2002:.\Include/arm_math.h ****    */
2003:.\Include/arm_math.h ****   void arm_mult_f32(
2004:.\Include/arm_math.h ****   float32_t * pSrcA,
2005:.\Include/arm_math.h ****   float32_t * pSrcB,
2006:.\Include/arm_math.h ****   float32_t * pDst,
2007:.\Include/arm_math.h ****   uint32_t blockSize);
2008:.\Include/arm_math.h **** 
2009:.\Include/arm_math.h **** 
2010:.\Include/arm_math.h ****   /**
2011:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2012:.\Include/arm_math.h ****    */
2013:.\Include/arm_math.h ****   typedef struct
2014:.\Include/arm_math.h ****   {
2015:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2016:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2017:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2018:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
2019:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2020:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2021:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2022:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q15;
2023:.\Include/arm_math.h **** 
2024:.\Include/arm_math.h **** /* Deprecated */
2025:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q15(
2026:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q15 * S,
2027:.\Include/arm_math.h ****   uint16_t fftLen,
2028:.\Include/arm_math.h ****   uint8_t ifftFlag,
2029:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2030:.\Include/arm_math.h **** 
2031:.\Include/arm_math.h **** /* Deprecated */
2032:.\Include/arm_math.h ****   void arm_cfft_radix2_q15(
2033:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q15 * S,
2034:.\Include/arm_math.h ****   q15_t * pSrc);
2035:.\Include/arm_math.h **** 
2036:.\Include/arm_math.h **** 
2037:.\Include/arm_math.h ****   /**
2038:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
2039:.\Include/arm_math.h ****    */
2040:.\Include/arm_math.h ****   typedef struct
2041:.\Include/arm_math.h ****   {
2042:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2043:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2044:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2045:.\Include/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
2046:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2047:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2048:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2049:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q15;
2050:.\Include/arm_math.h **** 
2051:.\Include/arm_math.h **** /* Deprecated */
2052:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q15(
2053:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S,
2054:.\Include/arm_math.h ****   uint16_t fftLen,
2055:.\Include/arm_math.h ****   uint8_t ifftFlag,
2056:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2057:.\Include/arm_math.h **** 
2058:.\Include/arm_math.h **** /* Deprecated */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 42


2059:.\Include/arm_math.h ****   void arm_cfft_radix4_q15(
2060:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q15 * S,
2061:.\Include/arm_math.h ****   q15_t * pSrc);
2062:.\Include/arm_math.h **** 
2063:.\Include/arm_math.h ****   /**
2064:.\Include/arm_math.h ****    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
2065:.\Include/arm_math.h ****    */
2066:.\Include/arm_math.h ****   typedef struct
2067:.\Include/arm_math.h ****   {
2068:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2069:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2070:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2071:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
2072:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2073:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2074:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2075:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_q31;
2076:.\Include/arm_math.h **** 
2077:.\Include/arm_math.h **** /* Deprecated */
2078:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_q31(
2079:.\Include/arm_math.h ****   arm_cfft_radix2_instance_q31 * S,
2080:.\Include/arm_math.h ****   uint16_t fftLen,
2081:.\Include/arm_math.h ****   uint8_t ifftFlag,
2082:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2083:.\Include/arm_math.h **** 
2084:.\Include/arm_math.h **** /* Deprecated */
2085:.\Include/arm_math.h ****   void arm_cfft_radix2_q31(
2086:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_q31 * S,
2087:.\Include/arm_math.h ****   q31_t * pSrc);
2088:.\Include/arm_math.h **** 
2089:.\Include/arm_math.h ****   /**
2090:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 CFFT/CIFFT function.
2091:.\Include/arm_math.h ****    */
2092:.\Include/arm_math.h ****   typedef struct
2093:.\Include/arm_math.h ****   {
2094:.\Include/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2095:.\Include/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2096:.\Include/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2097:.\Include/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
2098:.\Include/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2099:.\Include/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2100:.\Include/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2101:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_q31;
2102:.\Include/arm_math.h **** 
2103:.\Include/arm_math.h **** /* Deprecated */
2104:.\Include/arm_math.h ****   void arm_cfft_radix4_q31(
2105:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_q31 * S,
2106:.\Include/arm_math.h ****   q31_t * pSrc);
2107:.\Include/arm_math.h **** 
2108:.\Include/arm_math.h **** /* Deprecated */
2109:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_q31(
2110:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S,
2111:.\Include/arm_math.h ****   uint16_t fftLen,
2112:.\Include/arm_math.h ****   uint8_t ifftFlag,
2113:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2114:.\Include/arm_math.h **** 
2115:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 43


2116:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2117:.\Include/arm_math.h ****    */
2118:.\Include/arm_math.h ****   typedef struct
2119:.\Include/arm_math.h ****   {
2120:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2121:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2122:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2123:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2124:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2125:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2126:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2127:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2128:.\Include/arm_math.h ****   } arm_cfft_radix2_instance_f32;
2129:.\Include/arm_math.h **** 
2130:.\Include/arm_math.h **** /* Deprecated */
2131:.\Include/arm_math.h ****   arm_status arm_cfft_radix2_init_f32(
2132:.\Include/arm_math.h ****   arm_cfft_radix2_instance_f32 * S,
2133:.\Include/arm_math.h ****   uint16_t fftLen,
2134:.\Include/arm_math.h ****   uint8_t ifftFlag,
2135:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2136:.\Include/arm_math.h **** 
2137:.\Include/arm_math.h **** /* Deprecated */
2138:.\Include/arm_math.h ****   void arm_cfft_radix2_f32(
2139:.\Include/arm_math.h ****   const arm_cfft_radix2_instance_f32 * S,
2140:.\Include/arm_math.h ****   float32_t * pSrc);
2141:.\Include/arm_math.h **** 
2142:.\Include/arm_math.h ****   /**
2143:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2144:.\Include/arm_math.h ****    */
2145:.\Include/arm_math.h ****   typedef struct
2146:.\Include/arm_math.h ****   {
2147:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2148:.\Include/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2149:.\Include/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2150:.\Include/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2151:.\Include/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2152:.\Include/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2153:.\Include/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2154:.\Include/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2155:.\Include/arm_math.h ****   } arm_cfft_radix4_instance_f32;
2156:.\Include/arm_math.h **** 
2157:.\Include/arm_math.h **** /* Deprecated */
2158:.\Include/arm_math.h ****   arm_status arm_cfft_radix4_init_f32(
2159:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S,
2160:.\Include/arm_math.h ****   uint16_t fftLen,
2161:.\Include/arm_math.h ****   uint8_t ifftFlag,
2162:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2163:.\Include/arm_math.h **** 
2164:.\Include/arm_math.h **** /* Deprecated */
2165:.\Include/arm_math.h ****   void arm_cfft_radix4_f32(
2166:.\Include/arm_math.h ****   const arm_cfft_radix4_instance_f32 * S,
2167:.\Include/arm_math.h ****   float32_t * pSrc);
2168:.\Include/arm_math.h **** 
2169:.\Include/arm_math.h ****   /**
2170:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2171:.\Include/arm_math.h ****    */
2172:.\Include/arm_math.h ****   typedef struct
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 44


2173:.\Include/arm_math.h ****   {
2174:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2175:.\Include/arm_math.h ****     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
2176:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2177:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2178:.\Include/arm_math.h ****   } arm_cfft_instance_q15;
2179:.\Include/arm_math.h **** 
2180:.\Include/arm_math.h **** void arm_cfft_q15(
2181:.\Include/arm_math.h ****     const arm_cfft_instance_q15 * S,
2182:.\Include/arm_math.h ****     q15_t * p1,
2183:.\Include/arm_math.h ****     uint8_t ifftFlag,
2184:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2185:.\Include/arm_math.h **** 
2186:.\Include/arm_math.h ****   /**
2187:.\Include/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2188:.\Include/arm_math.h ****    */
2189:.\Include/arm_math.h ****   typedef struct
2190:.\Include/arm_math.h ****   {
2191:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2192:.\Include/arm_math.h ****     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
2193:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2194:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2195:.\Include/arm_math.h ****   } arm_cfft_instance_q31;
2196:.\Include/arm_math.h **** 
2197:.\Include/arm_math.h **** void arm_cfft_q31(
2198:.\Include/arm_math.h ****     const arm_cfft_instance_q31 * S,
2199:.\Include/arm_math.h ****     q31_t * p1,
2200:.\Include/arm_math.h ****     uint8_t ifftFlag,
2201:.\Include/arm_math.h ****     uint8_t bitReverseFlag);
2202:.\Include/arm_math.h **** 
2203:.\Include/arm_math.h ****   /**
2204:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2205:.\Include/arm_math.h ****    */
2206:.\Include/arm_math.h ****   typedef struct
2207:.\Include/arm_math.h ****   {
2208:.\Include/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2209:.\Include/arm_math.h ****     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
2210:.\Include/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2211:.\Include/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2212:.\Include/arm_math.h ****   } arm_cfft_instance_f32;
2213:.\Include/arm_math.h **** 
2214:.\Include/arm_math.h ****   void arm_cfft_f32(
2215:.\Include/arm_math.h ****   const arm_cfft_instance_f32 * S,
2216:.\Include/arm_math.h ****   float32_t * p1,
2217:.\Include/arm_math.h ****   uint8_t ifftFlag,
2218:.\Include/arm_math.h ****   uint8_t bitReverseFlag);
2219:.\Include/arm_math.h **** 
2220:.\Include/arm_math.h ****   /**
2221:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 RFFT/RIFFT function.
2222:.\Include/arm_math.h ****    */
2223:.\Include/arm_math.h ****   typedef struct
2224:.\Include/arm_math.h ****   {
2225:.\Include/arm_math.h ****     uint32_t fftLenReal;                      /**< length of the real FFT. */
2226:.\Include/arm_math.h ****     uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inver
2227:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disable
2228:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports diffe
2229:.\Include/arm_math.h ****     q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 45


2230:.\Include/arm_math.h ****     q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
2231:.\Include/arm_math.h ****     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
2232:.\Include/arm_math.h ****   } arm_rfft_instance_q15;
2233:.\Include/arm_math.h **** 
2234:.\Include/arm_math.h ****   arm_status arm_rfft_init_q15(
2235:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S,
2236:.\Include/arm_math.h ****   uint32_t fftLenReal,
2237:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2238:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2239:.\Include/arm_math.h **** 
2240:.\Include/arm_math.h ****   void arm_rfft_q15(
2241:.\Include/arm_math.h ****   const arm_rfft_instance_q15 * S,
2242:.\Include/arm_math.h ****   q15_t * pSrc,
2243:.\Include/arm_math.h ****   q15_t * pDst);
2244:.\Include/arm_math.h **** 
2245:.\Include/arm_math.h ****   /**
2246:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 RFFT/RIFFT function.
2247:.\Include/arm_math.h ****    */
2248:.\Include/arm_math.h ****   typedef struct
2249:.\Include/arm_math.h ****   {
2250:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2251:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2252:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2253:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports dif
2254:.\Include/arm_math.h ****     q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
2255:.\Include/arm_math.h ****     q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
2256:.\Include/arm_math.h ****     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
2257:.\Include/arm_math.h ****   } arm_rfft_instance_q31;
2258:.\Include/arm_math.h **** 
2259:.\Include/arm_math.h ****   arm_status arm_rfft_init_q31(
2260:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S,
2261:.\Include/arm_math.h ****   uint32_t fftLenReal,
2262:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2263:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2264:.\Include/arm_math.h **** 
2265:.\Include/arm_math.h ****   void arm_rfft_q31(
2266:.\Include/arm_math.h ****   const arm_rfft_instance_q31 * S,
2267:.\Include/arm_math.h ****   q31_t * pSrc,
2268:.\Include/arm_math.h ****   q31_t * pDst);
2269:.\Include/arm_math.h **** 
2270:.\Include/arm_math.h ****   /**
2271:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2272:.\Include/arm_math.h ****    */
2273:.\Include/arm_math.h ****   typedef struct
2274:.\Include/arm_math.h ****   {
2275:.\Include/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2276:.\Include/arm_math.h ****     uint16_t fftLenBy2;                         /**< length of the complex FFT. */
2277:.\Include/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2278:.\Include/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2279:.\Include/arm_math.h ****     uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports
2280:.\Include/arm_math.h ****     float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
2281:.\Include/arm_math.h ****     float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
2282:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
2283:.\Include/arm_math.h ****   } arm_rfft_instance_f32;
2284:.\Include/arm_math.h **** 
2285:.\Include/arm_math.h ****   arm_status arm_rfft_init_f32(
2286:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 46


2287:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2288:.\Include/arm_math.h ****   uint32_t fftLenReal,
2289:.\Include/arm_math.h ****   uint32_t ifftFlagR,
2290:.\Include/arm_math.h ****   uint32_t bitReverseFlag);
2291:.\Include/arm_math.h **** 
2292:.\Include/arm_math.h ****   void arm_rfft_f32(
2293:.\Include/arm_math.h ****   const arm_rfft_instance_f32 * S,
2294:.\Include/arm_math.h ****   float32_t * pSrc,
2295:.\Include/arm_math.h ****   float32_t * pDst);
2296:.\Include/arm_math.h **** 
2297:.\Include/arm_math.h ****   /**
2298:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2299:.\Include/arm_math.h ****    */
2300:.\Include/arm_math.h **** typedef struct
2301:.\Include/arm_math.h ****   {
2302:.\Include/arm_math.h ****     arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
2303:.\Include/arm_math.h ****     uint16_t fftLenRFFT;             /**< length of the real sequence */
2304:.\Include/arm_math.h ****     float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
2305:.\Include/arm_math.h ****   } arm_rfft_fast_instance_f32 ;
2306:.\Include/arm_math.h **** 
2307:.\Include/arm_math.h **** arm_status arm_rfft_fast_init_f32 (
2308:.\Include/arm_math.h ****    arm_rfft_fast_instance_f32 * S,
2309:.\Include/arm_math.h ****    uint16_t fftLen);
2310:.\Include/arm_math.h **** 
2311:.\Include/arm_math.h **** void arm_rfft_fast_f32(
2312:.\Include/arm_math.h ****   arm_rfft_fast_instance_f32 * S,
2313:.\Include/arm_math.h ****   float32_t * p, float32_t * pOut,
2314:.\Include/arm_math.h ****   uint8_t ifftFlag);
2315:.\Include/arm_math.h **** 
2316:.\Include/arm_math.h ****   /**
2317:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
2318:.\Include/arm_math.h ****    */
2319:.\Include/arm_math.h ****   typedef struct
2320:.\Include/arm_math.h ****   {
2321:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2322:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2323:.\Include/arm_math.h ****     float32_t normalize;                 /**< normalizing factor. */
2324:.\Include/arm_math.h ****     float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
2325:.\Include/arm_math.h ****     float32_t *pCosFactor;               /**< points to the cosFactor table. */
2326:.\Include/arm_math.h ****     arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
2327:.\Include/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
2328:.\Include/arm_math.h ****   } arm_dct4_instance_f32;
2329:.\Include/arm_math.h **** 
2330:.\Include/arm_math.h **** 
2331:.\Include/arm_math.h ****   /**
2332:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point DCT4/IDCT4.
2333:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
2334:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
2335:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
2336:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2337:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2338:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2339:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2340:.\Include/arm_math.h ****    */
2341:.\Include/arm_math.h ****   arm_status arm_dct4_init_f32(
2342:.\Include/arm_math.h ****   arm_dct4_instance_f32 * S,
2343:.\Include/arm_math.h ****   arm_rfft_instance_f32 * S_RFFT,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 47


2344:.\Include/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2345:.\Include/arm_math.h ****   uint16_t N,
2346:.\Include/arm_math.h ****   uint16_t Nby2,
2347:.\Include/arm_math.h ****   float32_t normalize);
2348:.\Include/arm_math.h **** 
2349:.\Include/arm_math.h **** 
2350:.\Include/arm_math.h ****   /**
2351:.\Include/arm_math.h ****    * @brief Processing function for the floating-point DCT4/IDCT4.
2352:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure
2353:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2354:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2355:.\Include/arm_math.h ****    */
2356:.\Include/arm_math.h ****   void arm_dct4_f32(
2357:.\Include/arm_math.h ****   const arm_dct4_instance_f32 * S,
2358:.\Include/arm_math.h ****   float32_t * pState,
2359:.\Include/arm_math.h ****   float32_t * pInlineBuffer);
2360:.\Include/arm_math.h **** 
2361:.\Include/arm_math.h **** 
2362:.\Include/arm_math.h ****   /**
2363:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 DCT4/IDCT4 function.
2364:.\Include/arm_math.h ****    */
2365:.\Include/arm_math.h ****   typedef struct
2366:.\Include/arm_math.h ****   {
2367:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2368:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2369:.\Include/arm_math.h ****     q31_t normalize;                     /**< normalizing factor. */
2370:.\Include/arm_math.h ****     q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
2371:.\Include/arm_math.h ****     q31_t *pCosFactor;                   /**< points to the cosFactor table. */
2372:.\Include/arm_math.h ****     arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
2373:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
2374:.\Include/arm_math.h ****   } arm_dct4_instance_q31;
2375:.\Include/arm_math.h **** 
2376:.\Include/arm_math.h **** 
2377:.\Include/arm_math.h ****   /**
2378:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 DCT4/IDCT4.
2379:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
2380:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
2381:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
2382:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2383:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2384:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2385:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2386:.\Include/arm_math.h ****    */
2387:.\Include/arm_math.h ****   arm_status arm_dct4_init_q31(
2388:.\Include/arm_math.h ****   arm_dct4_instance_q31 * S,
2389:.\Include/arm_math.h ****   arm_rfft_instance_q31 * S_RFFT,
2390:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q31 * S_CFFT,
2391:.\Include/arm_math.h ****   uint16_t N,
2392:.\Include/arm_math.h ****   uint16_t Nby2,
2393:.\Include/arm_math.h ****   q31_t normalize);
2394:.\Include/arm_math.h **** 
2395:.\Include/arm_math.h **** 
2396:.\Include/arm_math.h ****   /**
2397:.\Include/arm_math.h ****    * @brief Processing function for the Q31 DCT4/IDCT4.
2398:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q31 DCT4 structure.
2399:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2400:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 48


2401:.\Include/arm_math.h ****    */
2402:.\Include/arm_math.h ****   void arm_dct4_q31(
2403:.\Include/arm_math.h ****   const arm_dct4_instance_q31 * S,
2404:.\Include/arm_math.h ****   q31_t * pState,
2405:.\Include/arm_math.h ****   q31_t * pInlineBuffer);
2406:.\Include/arm_math.h **** 
2407:.\Include/arm_math.h **** 
2408:.\Include/arm_math.h ****   /**
2409:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 DCT4/IDCT4 function.
2410:.\Include/arm_math.h ****    */
2411:.\Include/arm_math.h ****   typedef struct
2412:.\Include/arm_math.h ****   {
2413:.\Include/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2414:.\Include/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2415:.\Include/arm_math.h ****     q15_t normalize;                     /**< normalizing factor. */
2416:.\Include/arm_math.h ****     q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
2417:.\Include/arm_math.h ****     q15_t *pCosFactor;                   /**< points to the cosFactor table. */
2418:.\Include/arm_math.h ****     arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
2419:.\Include/arm_math.h ****     arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
2420:.\Include/arm_math.h ****   } arm_dct4_instance_q15;
2421:.\Include/arm_math.h **** 
2422:.\Include/arm_math.h **** 
2423:.\Include/arm_math.h ****   /**
2424:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 DCT4/IDCT4.
2425:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
2426:.\Include/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
2427:.\Include/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
2428:.\Include/arm_math.h ****    * @param[in]     N          length of the DCT4.
2429:.\Include/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2430:.\Include/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2431:.\Include/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2432:.\Include/arm_math.h ****    */
2433:.\Include/arm_math.h ****   arm_status arm_dct4_init_q15(
2434:.\Include/arm_math.h ****   arm_dct4_instance_q15 * S,
2435:.\Include/arm_math.h ****   arm_rfft_instance_q15 * S_RFFT,
2436:.\Include/arm_math.h ****   arm_cfft_radix4_instance_q15 * S_CFFT,
2437:.\Include/arm_math.h ****   uint16_t N,
2438:.\Include/arm_math.h ****   uint16_t Nby2,
2439:.\Include/arm_math.h ****   q15_t normalize);
2440:.\Include/arm_math.h **** 
2441:.\Include/arm_math.h **** 
2442:.\Include/arm_math.h ****   /**
2443:.\Include/arm_math.h ****    * @brief Processing function for the Q15 DCT4/IDCT4.
2444:.\Include/arm_math.h ****    * @param[in]     S              points to an instance of the Q15 DCT4 structure.
2445:.\Include/arm_math.h ****    * @param[in]     pState         points to state buffer.
2446:.\Include/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2447:.\Include/arm_math.h ****    */
2448:.\Include/arm_math.h ****   void arm_dct4_q15(
2449:.\Include/arm_math.h ****   const arm_dct4_instance_q15 * S,
2450:.\Include/arm_math.h ****   q15_t * pState,
2451:.\Include/arm_math.h ****   q15_t * pInlineBuffer);
2452:.\Include/arm_math.h **** 
2453:.\Include/arm_math.h **** 
2454:.\Include/arm_math.h ****   /**
2455:.\Include/arm_math.h ****    * @brief Floating-point vector addition.
2456:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2457:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 49


2458:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2459:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2460:.\Include/arm_math.h ****    */
2461:.\Include/arm_math.h ****   void arm_add_f32(
2462:.\Include/arm_math.h ****   float32_t * pSrcA,
2463:.\Include/arm_math.h ****   float32_t * pSrcB,
2464:.\Include/arm_math.h ****   float32_t * pDst,
2465:.\Include/arm_math.h ****   uint32_t blockSize);
2466:.\Include/arm_math.h **** 
2467:.\Include/arm_math.h **** 
2468:.\Include/arm_math.h ****   /**
2469:.\Include/arm_math.h ****    * @brief Q7 vector addition.
2470:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2471:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2472:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2473:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2474:.\Include/arm_math.h ****    */
2475:.\Include/arm_math.h ****   void arm_add_q7(
2476:.\Include/arm_math.h ****   q7_t * pSrcA,
2477:.\Include/arm_math.h ****   q7_t * pSrcB,
2478:.\Include/arm_math.h ****   q7_t * pDst,
2479:.\Include/arm_math.h ****   uint32_t blockSize);
2480:.\Include/arm_math.h **** 
2481:.\Include/arm_math.h **** 
2482:.\Include/arm_math.h ****   /**
2483:.\Include/arm_math.h ****    * @brief Q15 vector addition.
2484:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2485:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2486:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2487:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2488:.\Include/arm_math.h ****    */
2489:.\Include/arm_math.h ****   void arm_add_q15(
2490:.\Include/arm_math.h ****   q15_t * pSrcA,
2491:.\Include/arm_math.h ****   q15_t * pSrcB,
2492:.\Include/arm_math.h ****   q15_t * pDst,
2493:.\Include/arm_math.h ****   uint32_t blockSize);
2494:.\Include/arm_math.h **** 
2495:.\Include/arm_math.h **** 
2496:.\Include/arm_math.h ****   /**
2497:.\Include/arm_math.h ****    * @brief Q31 vector addition.
2498:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2499:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2500:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2501:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2502:.\Include/arm_math.h ****    */
2503:.\Include/arm_math.h ****   void arm_add_q31(
2504:.\Include/arm_math.h ****   q31_t * pSrcA,
2505:.\Include/arm_math.h ****   q31_t * pSrcB,
2506:.\Include/arm_math.h ****   q31_t * pDst,
2507:.\Include/arm_math.h ****   uint32_t blockSize);
2508:.\Include/arm_math.h **** 
2509:.\Include/arm_math.h **** 
2510:.\Include/arm_math.h ****   /**
2511:.\Include/arm_math.h ****    * @brief Floating-point vector subtraction.
2512:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2513:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2514:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 50


2515:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2516:.\Include/arm_math.h ****    */
2517:.\Include/arm_math.h ****   void arm_sub_f32(
2518:.\Include/arm_math.h ****   float32_t * pSrcA,
2519:.\Include/arm_math.h ****   float32_t * pSrcB,
2520:.\Include/arm_math.h ****   float32_t * pDst,
2521:.\Include/arm_math.h ****   uint32_t blockSize);
2522:.\Include/arm_math.h **** 
2523:.\Include/arm_math.h **** 
2524:.\Include/arm_math.h ****   /**
2525:.\Include/arm_math.h ****    * @brief Q7 vector subtraction.
2526:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2527:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2528:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2529:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2530:.\Include/arm_math.h ****    */
2531:.\Include/arm_math.h ****   void arm_sub_q7(
2532:.\Include/arm_math.h ****   q7_t * pSrcA,
2533:.\Include/arm_math.h ****   q7_t * pSrcB,
2534:.\Include/arm_math.h ****   q7_t * pDst,
2535:.\Include/arm_math.h ****   uint32_t blockSize);
2536:.\Include/arm_math.h **** 
2537:.\Include/arm_math.h **** 
2538:.\Include/arm_math.h ****   /**
2539:.\Include/arm_math.h ****    * @brief Q15 vector subtraction.
2540:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2541:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2542:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2543:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2544:.\Include/arm_math.h ****    */
2545:.\Include/arm_math.h ****   void arm_sub_q15(
2546:.\Include/arm_math.h ****   q15_t * pSrcA,
2547:.\Include/arm_math.h ****   q15_t * pSrcB,
2548:.\Include/arm_math.h ****   q15_t * pDst,
2549:.\Include/arm_math.h ****   uint32_t blockSize);
2550:.\Include/arm_math.h **** 
2551:.\Include/arm_math.h **** 
2552:.\Include/arm_math.h ****   /**
2553:.\Include/arm_math.h ****    * @brief Q31 vector subtraction.
2554:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2555:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2556:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2557:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2558:.\Include/arm_math.h ****    */
2559:.\Include/arm_math.h ****   void arm_sub_q31(
2560:.\Include/arm_math.h ****   q31_t * pSrcA,
2561:.\Include/arm_math.h ****   q31_t * pSrcB,
2562:.\Include/arm_math.h ****   q31_t * pDst,
2563:.\Include/arm_math.h ****   uint32_t blockSize);
2564:.\Include/arm_math.h **** 
2565:.\Include/arm_math.h **** 
2566:.\Include/arm_math.h ****   /**
2567:.\Include/arm_math.h ****    * @brief Multiplies a floating-point vector by a scalar.
2568:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2569:.\Include/arm_math.h ****    * @param[in]  scale      scale factor to be applied
2570:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2571:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 51


2572:.\Include/arm_math.h ****    */
2573:.\Include/arm_math.h ****   void arm_scale_f32(
2574:.\Include/arm_math.h ****   float32_t * pSrc,
2575:.\Include/arm_math.h ****   float32_t scale,
2576:.\Include/arm_math.h ****   float32_t * pDst,
2577:.\Include/arm_math.h ****   uint32_t blockSize);
2578:.\Include/arm_math.h **** 
2579:.\Include/arm_math.h **** 
2580:.\Include/arm_math.h ****   /**
2581:.\Include/arm_math.h ****    * @brief Multiplies a Q7 vector by a scalar.
2582:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2583:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2584:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2585:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2586:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2587:.\Include/arm_math.h ****    */
2588:.\Include/arm_math.h ****   void arm_scale_q7(
2589:.\Include/arm_math.h ****   q7_t * pSrc,
2590:.\Include/arm_math.h ****   q7_t scaleFract,
2591:.\Include/arm_math.h ****   int8_t shift,
2592:.\Include/arm_math.h ****   q7_t * pDst,
2593:.\Include/arm_math.h ****   uint32_t blockSize);
2594:.\Include/arm_math.h **** 
2595:.\Include/arm_math.h **** 
2596:.\Include/arm_math.h ****   /**
2597:.\Include/arm_math.h ****    * @brief Multiplies a Q15 vector by a scalar.
2598:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2599:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2600:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2601:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2602:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2603:.\Include/arm_math.h ****    */
2604:.\Include/arm_math.h ****   void arm_scale_q15(
2605:.\Include/arm_math.h ****   q15_t * pSrc,
2606:.\Include/arm_math.h ****   q15_t scaleFract,
2607:.\Include/arm_math.h ****   int8_t shift,
2608:.\Include/arm_math.h ****   q15_t * pDst,
2609:.\Include/arm_math.h ****   uint32_t blockSize);
2610:.\Include/arm_math.h **** 
2611:.\Include/arm_math.h **** 
2612:.\Include/arm_math.h ****   /**
2613:.\Include/arm_math.h ****    * @brief Multiplies a Q31 vector by a scalar.
2614:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2615:.\Include/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2616:.\Include/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2617:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
2618:.\Include/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2619:.\Include/arm_math.h ****    */
2620:.\Include/arm_math.h ****   void arm_scale_q31(
2621:.\Include/arm_math.h ****   q31_t * pSrc,
2622:.\Include/arm_math.h ****   q31_t scaleFract,
2623:.\Include/arm_math.h ****   int8_t shift,
2624:.\Include/arm_math.h ****   q31_t * pDst,
2625:.\Include/arm_math.h ****   uint32_t blockSize);
2626:.\Include/arm_math.h **** 
2627:.\Include/arm_math.h **** 
2628:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 52


2629:.\Include/arm_math.h ****    * @brief Q7 vector absolute value.
2630:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2631:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2632:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2633:.\Include/arm_math.h ****    */
2634:.\Include/arm_math.h ****   void arm_abs_q7(
2635:.\Include/arm_math.h ****   q7_t * pSrc,
2636:.\Include/arm_math.h ****   q7_t * pDst,
2637:.\Include/arm_math.h ****   uint32_t blockSize);
2638:.\Include/arm_math.h **** 
2639:.\Include/arm_math.h **** 
2640:.\Include/arm_math.h ****   /**
2641:.\Include/arm_math.h ****    * @brief Floating-point vector absolute value.
2642:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2643:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2644:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2645:.\Include/arm_math.h ****    */
2646:.\Include/arm_math.h ****   void arm_abs_f32(
2647:.\Include/arm_math.h ****   float32_t * pSrc,
2648:.\Include/arm_math.h ****   float32_t * pDst,
2649:.\Include/arm_math.h ****   uint32_t blockSize);
2650:.\Include/arm_math.h **** 
2651:.\Include/arm_math.h **** 
2652:.\Include/arm_math.h ****   /**
2653:.\Include/arm_math.h ****    * @brief Q15 vector absolute value.
2654:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2655:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2656:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2657:.\Include/arm_math.h ****    */
2658:.\Include/arm_math.h ****   void arm_abs_q15(
2659:.\Include/arm_math.h ****   q15_t * pSrc,
2660:.\Include/arm_math.h ****   q15_t * pDst,
2661:.\Include/arm_math.h ****   uint32_t blockSize);
2662:.\Include/arm_math.h **** 
2663:.\Include/arm_math.h **** 
2664:.\Include/arm_math.h ****   /**
2665:.\Include/arm_math.h ****    * @brief Q31 vector absolute value.
2666:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2667:.\Include/arm_math.h ****    * @param[out] pDst       points to the output buffer
2668:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2669:.\Include/arm_math.h ****    */
2670:.\Include/arm_math.h ****   void arm_abs_q31(
2671:.\Include/arm_math.h ****   q31_t * pSrc,
2672:.\Include/arm_math.h ****   q31_t * pDst,
2673:.\Include/arm_math.h ****   uint32_t blockSize);
2674:.\Include/arm_math.h **** 
2675:.\Include/arm_math.h **** 
2676:.\Include/arm_math.h ****   /**
2677:.\Include/arm_math.h ****    * @brief Dot product of floating-point vectors.
2678:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2679:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2680:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2681:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2682:.\Include/arm_math.h ****    */
2683:.\Include/arm_math.h ****   void arm_dot_prod_f32(
2684:.\Include/arm_math.h ****   float32_t * pSrcA,
2685:.\Include/arm_math.h ****   float32_t * pSrcB,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 53


2686:.\Include/arm_math.h ****   uint32_t blockSize,
2687:.\Include/arm_math.h ****   float32_t * result);
2688:.\Include/arm_math.h **** 
2689:.\Include/arm_math.h **** 
2690:.\Include/arm_math.h ****   /**
2691:.\Include/arm_math.h ****    * @brief Dot product of Q7 vectors.
2692:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2693:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2694:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2695:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2696:.\Include/arm_math.h ****    */
2697:.\Include/arm_math.h ****   void arm_dot_prod_q7(
2698:.\Include/arm_math.h ****   q7_t * pSrcA,
2699:.\Include/arm_math.h ****   q7_t * pSrcB,
2700:.\Include/arm_math.h ****   uint32_t blockSize,
2701:.\Include/arm_math.h ****   q31_t * result);
2702:.\Include/arm_math.h **** 
2703:.\Include/arm_math.h **** 
2704:.\Include/arm_math.h ****   /**
2705:.\Include/arm_math.h ****    * @brief Dot product of Q15 vectors.
2706:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2707:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2708:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2709:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2710:.\Include/arm_math.h ****    */
2711:.\Include/arm_math.h ****   void arm_dot_prod_q15(
2712:.\Include/arm_math.h ****   q15_t * pSrcA,
2713:.\Include/arm_math.h ****   q15_t * pSrcB,
2714:.\Include/arm_math.h ****   uint32_t blockSize,
2715:.\Include/arm_math.h ****   q63_t * result);
2716:.\Include/arm_math.h **** 
2717:.\Include/arm_math.h **** 
2718:.\Include/arm_math.h ****   /**
2719:.\Include/arm_math.h ****    * @brief Dot product of Q31 vectors.
2720:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2721:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2722:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2723:.\Include/arm_math.h ****    * @param[out] result     output result returned here
2724:.\Include/arm_math.h ****    */
2725:.\Include/arm_math.h ****   void arm_dot_prod_q31(
2726:.\Include/arm_math.h ****   q31_t * pSrcA,
2727:.\Include/arm_math.h ****   q31_t * pSrcB,
2728:.\Include/arm_math.h ****   uint32_t blockSize,
2729:.\Include/arm_math.h ****   q63_t * result);
2730:.\Include/arm_math.h **** 
2731:.\Include/arm_math.h **** 
2732:.\Include/arm_math.h ****   /**
2733:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q7 vector a specified number of bits.
2734:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2735:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2736:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2737:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2738:.\Include/arm_math.h ****    */
2739:.\Include/arm_math.h ****   void arm_shift_q7(
2740:.\Include/arm_math.h ****   q7_t * pSrc,
2741:.\Include/arm_math.h ****   int8_t shiftBits,
2742:.\Include/arm_math.h ****   q7_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 54


2743:.\Include/arm_math.h ****   uint32_t blockSize);
2744:.\Include/arm_math.h **** 
2745:.\Include/arm_math.h **** 
2746:.\Include/arm_math.h ****   /**
2747:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q15 vector a specified number of bits.
2748:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2749:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2750:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2751:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2752:.\Include/arm_math.h ****    */
2753:.\Include/arm_math.h ****   void arm_shift_q15(
2754:.\Include/arm_math.h ****   q15_t * pSrc,
2755:.\Include/arm_math.h ****   int8_t shiftBits,
2756:.\Include/arm_math.h ****   q15_t * pDst,
2757:.\Include/arm_math.h ****   uint32_t blockSize);
2758:.\Include/arm_math.h **** 
2759:.\Include/arm_math.h **** 
2760:.\Include/arm_math.h ****   /**
2761:.\Include/arm_math.h ****    * @brief  Shifts the elements of a Q31 vector a specified number of bits.
2762:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2763:.\Include/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2764:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2765:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2766:.\Include/arm_math.h ****    */
2767:.\Include/arm_math.h ****   void arm_shift_q31(
2768:.\Include/arm_math.h ****   q31_t * pSrc,
2769:.\Include/arm_math.h ****   int8_t shiftBits,
2770:.\Include/arm_math.h ****   q31_t * pDst,
2771:.\Include/arm_math.h ****   uint32_t blockSize);
2772:.\Include/arm_math.h **** 
2773:.\Include/arm_math.h **** 
2774:.\Include/arm_math.h ****   /**
2775:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a floating-point vector.
2776:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2777:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2778:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2779:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2780:.\Include/arm_math.h ****    */
2781:.\Include/arm_math.h ****   void arm_offset_f32(
2782:.\Include/arm_math.h ****   float32_t * pSrc,
2783:.\Include/arm_math.h ****   float32_t offset,
2784:.\Include/arm_math.h ****   float32_t * pDst,
2785:.\Include/arm_math.h ****   uint32_t blockSize);
2786:.\Include/arm_math.h **** 
2787:.\Include/arm_math.h **** 
2788:.\Include/arm_math.h ****   /**
2789:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q7 vector.
2790:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2791:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2792:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2793:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2794:.\Include/arm_math.h ****    */
2795:.\Include/arm_math.h ****   void arm_offset_q7(
2796:.\Include/arm_math.h ****   q7_t * pSrc,
2797:.\Include/arm_math.h ****   q7_t offset,
2798:.\Include/arm_math.h ****   q7_t * pDst,
2799:.\Include/arm_math.h ****   uint32_t blockSize);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 55


2800:.\Include/arm_math.h **** 
2801:.\Include/arm_math.h **** 
2802:.\Include/arm_math.h ****   /**
2803:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q15 vector.
2804:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2805:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2806:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2807:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2808:.\Include/arm_math.h ****    */
2809:.\Include/arm_math.h ****   void arm_offset_q15(
2810:.\Include/arm_math.h ****   q15_t * pSrc,
2811:.\Include/arm_math.h ****   q15_t offset,
2812:.\Include/arm_math.h ****   q15_t * pDst,
2813:.\Include/arm_math.h ****   uint32_t blockSize);
2814:.\Include/arm_math.h **** 
2815:.\Include/arm_math.h **** 
2816:.\Include/arm_math.h ****   /**
2817:.\Include/arm_math.h ****    * @brief  Adds a constant offset to a Q31 vector.
2818:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2819:.\Include/arm_math.h ****    * @param[in]  offset     is the offset to be added
2820:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2821:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2822:.\Include/arm_math.h ****    */
2823:.\Include/arm_math.h ****   void arm_offset_q31(
2824:.\Include/arm_math.h ****   q31_t * pSrc,
2825:.\Include/arm_math.h ****   q31_t offset,
2826:.\Include/arm_math.h ****   q31_t * pDst,
2827:.\Include/arm_math.h ****   uint32_t blockSize);
2828:.\Include/arm_math.h **** 
2829:.\Include/arm_math.h **** 
2830:.\Include/arm_math.h ****   /**
2831:.\Include/arm_math.h ****    * @brief  Negates the elements of a floating-point vector.
2832:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2833:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2834:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2835:.\Include/arm_math.h ****    */
2836:.\Include/arm_math.h ****   void arm_negate_f32(
2837:.\Include/arm_math.h ****   float32_t * pSrc,
2838:.\Include/arm_math.h ****   float32_t * pDst,
2839:.\Include/arm_math.h ****   uint32_t blockSize);
2840:.\Include/arm_math.h **** 
2841:.\Include/arm_math.h **** 
2842:.\Include/arm_math.h ****   /**
2843:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q7 vector.
2844:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2845:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2846:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2847:.\Include/arm_math.h ****    */
2848:.\Include/arm_math.h ****   void arm_negate_q7(
2849:.\Include/arm_math.h ****   q7_t * pSrc,
2850:.\Include/arm_math.h ****   q7_t * pDst,
2851:.\Include/arm_math.h ****   uint32_t blockSize);
2852:.\Include/arm_math.h **** 
2853:.\Include/arm_math.h **** 
2854:.\Include/arm_math.h ****   /**
2855:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q15 vector.
2856:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 56


2857:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2858:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2859:.\Include/arm_math.h ****    */
2860:.\Include/arm_math.h ****   void arm_negate_q15(
2861:.\Include/arm_math.h ****   q15_t * pSrc,
2862:.\Include/arm_math.h ****   q15_t * pDst,
2863:.\Include/arm_math.h ****   uint32_t blockSize);
2864:.\Include/arm_math.h **** 
2865:.\Include/arm_math.h **** 
2866:.\Include/arm_math.h ****   /**
2867:.\Include/arm_math.h ****    * @brief  Negates the elements of a Q31 vector.
2868:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2869:.\Include/arm_math.h ****    * @param[out] pDst       points to the output vector
2870:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2871:.\Include/arm_math.h ****    */
2872:.\Include/arm_math.h ****   void arm_negate_q31(
2873:.\Include/arm_math.h ****   q31_t * pSrc,
2874:.\Include/arm_math.h ****   q31_t * pDst,
2875:.\Include/arm_math.h ****   uint32_t blockSize);
2876:.\Include/arm_math.h **** 
2877:.\Include/arm_math.h **** 
2878:.\Include/arm_math.h ****   /**
2879:.\Include/arm_math.h ****    * @brief  Copies the elements of a floating-point vector.
2880:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2881:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2882:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2883:.\Include/arm_math.h ****    */
2884:.\Include/arm_math.h ****   void arm_copy_f32(
2885:.\Include/arm_math.h ****   float32_t * pSrc,
2886:.\Include/arm_math.h ****   float32_t * pDst,
2887:.\Include/arm_math.h ****   uint32_t blockSize);
2888:.\Include/arm_math.h **** 
2889:.\Include/arm_math.h **** 
2890:.\Include/arm_math.h ****   /**
2891:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q7 vector.
2892:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2893:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2894:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2895:.\Include/arm_math.h ****    */
2896:.\Include/arm_math.h ****   void arm_copy_q7(
2897:.\Include/arm_math.h ****   q7_t * pSrc,
2898:.\Include/arm_math.h ****   q7_t * pDst,
2899:.\Include/arm_math.h ****   uint32_t blockSize);
2900:.\Include/arm_math.h **** 
2901:.\Include/arm_math.h **** 
2902:.\Include/arm_math.h ****   /**
2903:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q15 vector.
2904:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2905:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2906:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2907:.\Include/arm_math.h ****    */
2908:.\Include/arm_math.h ****   void arm_copy_q15(
2909:.\Include/arm_math.h ****   q15_t * pSrc,
2910:.\Include/arm_math.h ****   q15_t * pDst,
2911:.\Include/arm_math.h ****   uint32_t blockSize);
2912:.\Include/arm_math.h **** 
2913:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 57


2914:.\Include/arm_math.h ****   /**
2915:.\Include/arm_math.h ****    * @brief  Copies the elements of a Q31 vector.
2916:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
2917:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2918:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2919:.\Include/arm_math.h ****    */
2920:.\Include/arm_math.h ****   void arm_copy_q31(
2921:.\Include/arm_math.h ****   q31_t * pSrc,
2922:.\Include/arm_math.h ****   q31_t * pDst,
2923:.\Include/arm_math.h ****   uint32_t blockSize);
2924:.\Include/arm_math.h **** 
2925:.\Include/arm_math.h **** 
2926:.\Include/arm_math.h ****   /**
2927:.\Include/arm_math.h ****    * @brief  Fills a constant value into a floating-point vector.
2928:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2929:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2930:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2931:.\Include/arm_math.h ****    */
2932:.\Include/arm_math.h ****   void arm_fill_f32(
2933:.\Include/arm_math.h ****   float32_t value,
2934:.\Include/arm_math.h ****   float32_t * pDst,
2935:.\Include/arm_math.h ****   uint32_t blockSize);
2936:.\Include/arm_math.h **** 
2937:.\Include/arm_math.h **** 
2938:.\Include/arm_math.h ****   /**
2939:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q7 vector.
2940:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2941:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2942:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2943:.\Include/arm_math.h ****    */
2944:.\Include/arm_math.h ****   void arm_fill_q7(
2945:.\Include/arm_math.h ****   q7_t value,
2946:.\Include/arm_math.h ****   q7_t * pDst,
2947:.\Include/arm_math.h ****   uint32_t blockSize);
2948:.\Include/arm_math.h **** 
2949:.\Include/arm_math.h **** 
2950:.\Include/arm_math.h ****   /**
2951:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q15 vector.
2952:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2953:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2954:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2955:.\Include/arm_math.h ****    */
2956:.\Include/arm_math.h ****   void arm_fill_q15(
2957:.\Include/arm_math.h ****   q15_t value,
2958:.\Include/arm_math.h ****   q15_t * pDst,
2959:.\Include/arm_math.h ****   uint32_t blockSize);
2960:.\Include/arm_math.h **** 
2961:.\Include/arm_math.h **** 
2962:.\Include/arm_math.h ****   /**
2963:.\Include/arm_math.h ****    * @brief  Fills a constant value into a Q31 vector.
2964:.\Include/arm_math.h ****    * @param[in]  value      input value to be filled
2965:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
2966:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2967:.\Include/arm_math.h ****    */
2968:.\Include/arm_math.h ****   void arm_fill_q31(
2969:.\Include/arm_math.h ****   q31_t value,
2970:.\Include/arm_math.h ****   q31_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 58


2971:.\Include/arm_math.h ****   uint32_t blockSize);
2972:.\Include/arm_math.h **** 
2973:.\Include/arm_math.h **** 
2974:.\Include/arm_math.h **** /**
2975:.\Include/arm_math.h ****  * @brief Convolution of floating-point sequences.
2976:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2977:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2978:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2979:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2980:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2981:.\Include/arm_math.h ****  */
2982:.\Include/arm_math.h ****   void arm_conv_f32(
2983:.\Include/arm_math.h ****   float32_t * pSrcA,
2984:.\Include/arm_math.h ****   uint32_t srcALen,
2985:.\Include/arm_math.h ****   float32_t * pSrcB,
2986:.\Include/arm_math.h ****   uint32_t srcBLen,
2987:.\Include/arm_math.h ****   float32_t * pDst);
2988:.\Include/arm_math.h **** 
2989:.\Include/arm_math.h **** 
2990:.\Include/arm_math.h ****   /**
2991:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences.
2992:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2993:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2994:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2995:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2996:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2997:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2998:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2999:.\Include/arm_math.h ****    */
3000:.\Include/arm_math.h ****   void arm_conv_opt_q15(
3001:.\Include/arm_math.h ****   q15_t * pSrcA,
3002:.\Include/arm_math.h ****   uint32_t srcALen,
3003:.\Include/arm_math.h ****   q15_t * pSrcB,
3004:.\Include/arm_math.h ****   uint32_t srcBLen,
3005:.\Include/arm_math.h ****   q15_t * pDst,
3006:.\Include/arm_math.h ****   q15_t * pScratch1,
3007:.\Include/arm_math.h ****   q15_t * pScratch2);
3008:.\Include/arm_math.h **** 
3009:.\Include/arm_math.h **** 
3010:.\Include/arm_math.h **** /**
3011:.\Include/arm_math.h ****  * @brief Convolution of Q15 sequences.
3012:.\Include/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
3013:.\Include/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
3014:.\Include/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
3015:.\Include/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
3016:.\Include/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
3017:.\Include/arm_math.h ****  */
3018:.\Include/arm_math.h ****   void arm_conv_q15(
3019:.\Include/arm_math.h ****   q15_t * pSrcA,
3020:.\Include/arm_math.h ****   uint32_t srcALen,
3021:.\Include/arm_math.h ****   q15_t * pSrcB,
3022:.\Include/arm_math.h ****   uint32_t srcBLen,
3023:.\Include/arm_math.h ****   q15_t * pDst);
3024:.\Include/arm_math.h **** 
3025:.\Include/arm_math.h **** 
3026:.\Include/arm_math.h ****   /**
3027:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 59


3028:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3029:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3030:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3031:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3032:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3033:.\Include/arm_math.h ****    */
3034:.\Include/arm_math.h ****   void arm_conv_fast_q15(
3035:.\Include/arm_math.h ****           q15_t * pSrcA,
3036:.\Include/arm_math.h ****           uint32_t srcALen,
3037:.\Include/arm_math.h ****           q15_t * pSrcB,
3038:.\Include/arm_math.h ****           uint32_t srcBLen,
3039:.\Include/arm_math.h ****           q15_t * pDst);
3040:.\Include/arm_math.h **** 
3041:.\Include/arm_math.h **** 
3042:.\Include/arm_math.h ****   /**
3043:.\Include/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3044:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3045:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3046:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3047:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3048:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3049:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
3050:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
3051:.\Include/arm_math.h ****    */
3052:.\Include/arm_math.h ****   void arm_conv_fast_opt_q15(
3053:.\Include/arm_math.h ****   q15_t * pSrcA,
3054:.\Include/arm_math.h ****   uint32_t srcALen,
3055:.\Include/arm_math.h ****   q15_t * pSrcB,
3056:.\Include/arm_math.h ****   uint32_t srcBLen,
3057:.\Include/arm_math.h ****   q15_t * pDst,
3058:.\Include/arm_math.h ****   q15_t * pScratch1,
3059:.\Include/arm_math.h ****   q15_t * pScratch2);
3060:.\Include/arm_math.h **** 
3061:.\Include/arm_math.h **** 
3062:.\Include/arm_math.h ****   /**
3063:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences.
3064:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3065:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3066:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3067:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3068:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3069:.\Include/arm_math.h ****    */
3070:.\Include/arm_math.h ****   void arm_conv_q31(
3071:.\Include/arm_math.h ****   q31_t * pSrcA,
3072:.\Include/arm_math.h ****   uint32_t srcALen,
3073:.\Include/arm_math.h ****   q31_t * pSrcB,
3074:.\Include/arm_math.h ****   uint32_t srcBLen,
3075:.\Include/arm_math.h ****   q31_t * pDst);
3076:.\Include/arm_math.h **** 
3077:.\Include/arm_math.h **** 
3078:.\Include/arm_math.h ****   /**
3079:.\Include/arm_math.h ****    * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3080:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3081:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3082:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3083:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3084:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 60


3085:.\Include/arm_math.h ****    */
3086:.\Include/arm_math.h ****   void arm_conv_fast_q31(
3087:.\Include/arm_math.h ****   q31_t * pSrcA,
3088:.\Include/arm_math.h ****   uint32_t srcALen,
3089:.\Include/arm_math.h ****   q31_t * pSrcB,
3090:.\Include/arm_math.h ****   uint32_t srcBLen,
3091:.\Include/arm_math.h ****   q31_t * pDst);
3092:.\Include/arm_math.h **** 
3093:.\Include/arm_math.h **** 
3094:.\Include/arm_math.h ****     /**
3095:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3096:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3097:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3098:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3099:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3100:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3101:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
3102:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
3103:.\Include/arm_math.h ****    */
3104:.\Include/arm_math.h ****   void arm_conv_opt_q7(
3105:.\Include/arm_math.h ****   q7_t * pSrcA,
3106:.\Include/arm_math.h ****   uint32_t srcALen,
3107:.\Include/arm_math.h ****   q7_t * pSrcB,
3108:.\Include/arm_math.h ****   uint32_t srcBLen,
3109:.\Include/arm_math.h ****   q7_t * pDst,
3110:.\Include/arm_math.h ****   q15_t * pScratch1,
3111:.\Include/arm_math.h ****   q15_t * pScratch2);
3112:.\Include/arm_math.h **** 
3113:.\Include/arm_math.h **** 
3114:.\Include/arm_math.h ****   /**
3115:.\Include/arm_math.h ****    * @brief Convolution of Q7 sequences.
3116:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3117:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3118:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3119:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3120:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3121:.\Include/arm_math.h ****    */
3122:.\Include/arm_math.h ****   void arm_conv_q7(
3123:.\Include/arm_math.h ****   q7_t * pSrcA,
3124:.\Include/arm_math.h ****   uint32_t srcALen,
3125:.\Include/arm_math.h ****   q7_t * pSrcB,
3126:.\Include/arm_math.h ****   uint32_t srcBLen,
3127:.\Include/arm_math.h ****   q7_t * pDst);
3128:.\Include/arm_math.h **** 
3129:.\Include/arm_math.h **** 
3130:.\Include/arm_math.h ****   /**
3131:.\Include/arm_math.h ****    * @brief Partial convolution of floating-point sequences.
3132:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3133:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3134:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3135:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3136:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3137:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3138:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3139:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3140:.\Include/arm_math.h ****    */
3141:.\Include/arm_math.h ****   arm_status arm_conv_partial_f32(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 61


3142:.\Include/arm_math.h ****   float32_t * pSrcA,
3143:.\Include/arm_math.h ****   uint32_t srcALen,
3144:.\Include/arm_math.h ****   float32_t * pSrcB,
3145:.\Include/arm_math.h ****   uint32_t srcBLen,
3146:.\Include/arm_math.h ****   float32_t * pDst,
3147:.\Include/arm_math.h ****   uint32_t firstIndex,
3148:.\Include/arm_math.h ****   uint32_t numPoints);
3149:.\Include/arm_math.h **** 
3150:.\Include/arm_math.h **** 
3151:.\Include/arm_math.h ****   /**
3152:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3153:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3154:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3155:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3156:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3157:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3158:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3159:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3160:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3161:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3162:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3163:.\Include/arm_math.h ****    */
3164:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q15(
3165:.\Include/arm_math.h ****   q15_t * pSrcA,
3166:.\Include/arm_math.h ****   uint32_t srcALen,
3167:.\Include/arm_math.h ****   q15_t * pSrcB,
3168:.\Include/arm_math.h ****   uint32_t srcBLen,
3169:.\Include/arm_math.h ****   q15_t * pDst,
3170:.\Include/arm_math.h ****   uint32_t firstIndex,
3171:.\Include/arm_math.h ****   uint32_t numPoints,
3172:.\Include/arm_math.h ****   q15_t * pScratch1,
3173:.\Include/arm_math.h ****   q15_t * pScratch2);
3174:.\Include/arm_math.h **** 
3175:.\Include/arm_math.h **** 
3176:.\Include/arm_math.h ****   /**
3177:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3178:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3179:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3180:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3181:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3182:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3183:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3184:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3185:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3186:.\Include/arm_math.h ****    */
3187:.\Include/arm_math.h ****   arm_status arm_conv_partial_q15(
3188:.\Include/arm_math.h ****   q15_t * pSrcA,
3189:.\Include/arm_math.h ****   uint32_t srcALen,
3190:.\Include/arm_math.h ****   q15_t * pSrcB,
3191:.\Include/arm_math.h ****   uint32_t srcBLen,
3192:.\Include/arm_math.h ****   q15_t * pDst,
3193:.\Include/arm_math.h ****   uint32_t firstIndex,
3194:.\Include/arm_math.h ****   uint32_t numPoints);
3195:.\Include/arm_math.h **** 
3196:.\Include/arm_math.h **** 
3197:.\Include/arm_math.h ****   /**
3198:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 62


3199:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3200:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3201:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3202:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3203:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3204:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3205:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3206:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3207:.\Include/arm_math.h ****    */
3208:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q15(
3209:.\Include/arm_math.h ****   q15_t * pSrcA,
3210:.\Include/arm_math.h ****   uint32_t srcALen,
3211:.\Include/arm_math.h ****   q15_t * pSrcB,
3212:.\Include/arm_math.h ****   uint32_t srcBLen,
3213:.\Include/arm_math.h ****   q15_t * pDst,
3214:.\Include/arm_math.h ****   uint32_t firstIndex,
3215:.\Include/arm_math.h ****   uint32_t numPoints);
3216:.\Include/arm_math.h **** 
3217:.\Include/arm_math.h **** 
3218:.\Include/arm_math.h ****   /**
3219:.\Include/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3220:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3221:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3222:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3223:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3224:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3225:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3226:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3227:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3228:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3229:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3230:.\Include/arm_math.h ****    */
3231:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_opt_q15(
3232:.\Include/arm_math.h ****   q15_t * pSrcA,
3233:.\Include/arm_math.h ****   uint32_t srcALen,
3234:.\Include/arm_math.h ****   q15_t * pSrcB,
3235:.\Include/arm_math.h ****   uint32_t srcBLen,
3236:.\Include/arm_math.h ****   q15_t * pDst,
3237:.\Include/arm_math.h ****   uint32_t firstIndex,
3238:.\Include/arm_math.h ****   uint32_t numPoints,
3239:.\Include/arm_math.h ****   q15_t * pScratch1,
3240:.\Include/arm_math.h ****   q15_t * pScratch2);
3241:.\Include/arm_math.h **** 
3242:.\Include/arm_math.h **** 
3243:.\Include/arm_math.h ****   /**
3244:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences.
3245:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3246:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3247:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3248:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3249:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3250:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3251:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3252:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3253:.\Include/arm_math.h ****    */
3254:.\Include/arm_math.h ****   arm_status arm_conv_partial_q31(
3255:.\Include/arm_math.h ****   q31_t * pSrcA,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 63


3256:.\Include/arm_math.h ****   uint32_t srcALen,
3257:.\Include/arm_math.h ****   q31_t * pSrcB,
3258:.\Include/arm_math.h ****   uint32_t srcBLen,
3259:.\Include/arm_math.h ****   q31_t * pDst,
3260:.\Include/arm_math.h ****   uint32_t firstIndex,
3261:.\Include/arm_math.h ****   uint32_t numPoints);
3262:.\Include/arm_math.h **** 
3263:.\Include/arm_math.h **** 
3264:.\Include/arm_math.h ****   /**
3265:.\Include/arm_math.h ****    * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3266:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3267:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3268:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3269:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3270:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3271:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3272:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3273:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3274:.\Include/arm_math.h ****    */
3275:.\Include/arm_math.h ****   arm_status arm_conv_partial_fast_q31(
3276:.\Include/arm_math.h ****   q31_t * pSrcA,
3277:.\Include/arm_math.h ****   uint32_t srcALen,
3278:.\Include/arm_math.h ****   q31_t * pSrcB,
3279:.\Include/arm_math.h ****   uint32_t srcBLen,
3280:.\Include/arm_math.h ****   q31_t * pDst,
3281:.\Include/arm_math.h ****   uint32_t firstIndex,
3282:.\Include/arm_math.h ****   uint32_t numPoints);
3283:.\Include/arm_math.h **** 
3284:.\Include/arm_math.h **** 
3285:.\Include/arm_math.h ****   /**
3286:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences
3287:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3288:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3289:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3290:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3291:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3292:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3293:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3294:.\Include/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) 
3295:.\Include/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)
3296:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3297:.\Include/arm_math.h ****    */
3298:.\Include/arm_math.h ****   arm_status arm_conv_partial_opt_q7(
3299:.\Include/arm_math.h ****   q7_t * pSrcA,
3300:.\Include/arm_math.h ****   uint32_t srcALen,
3301:.\Include/arm_math.h ****   q7_t * pSrcB,
3302:.\Include/arm_math.h ****   uint32_t srcBLen,
3303:.\Include/arm_math.h ****   q7_t * pDst,
3304:.\Include/arm_math.h ****   uint32_t firstIndex,
3305:.\Include/arm_math.h ****   uint32_t numPoints,
3306:.\Include/arm_math.h ****   q15_t * pScratch1,
3307:.\Include/arm_math.h ****   q15_t * pScratch2);
3308:.\Include/arm_math.h **** 
3309:.\Include/arm_math.h **** 
3310:.\Include/arm_math.h **** /**
3311:.\Include/arm_math.h ****    * @brief Partial convolution of Q7 sequences.
3312:.\Include/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 64


3313:.\Include/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3314:.\Include/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3315:.\Include/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3316:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
3317:.\Include/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3318:.\Include/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3319:.\Include/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3320:.\Include/arm_math.h ****    */
3321:.\Include/arm_math.h ****   arm_status arm_conv_partial_q7(
3322:.\Include/arm_math.h ****   q7_t * pSrcA,
3323:.\Include/arm_math.h ****   uint32_t srcALen,
3324:.\Include/arm_math.h ****   q7_t * pSrcB,
3325:.\Include/arm_math.h ****   uint32_t srcBLen,
3326:.\Include/arm_math.h ****   q7_t * pDst,
3327:.\Include/arm_math.h ****   uint32_t firstIndex,
3328:.\Include/arm_math.h ****   uint32_t numPoints);
3329:.\Include/arm_math.h **** 
3330:.\Include/arm_math.h **** 
3331:.\Include/arm_math.h ****   /**
3332:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR decimator.
3333:.\Include/arm_math.h ****    */
3334:.\Include/arm_math.h ****   typedef struct
3335:.\Include/arm_math.h ****   {
3336:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3337:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3338:.\Include/arm_math.h ****     q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3339:.\Include/arm_math.h ****     q15_t *pState;              /**< points to the state variable array. The array is of length num
3340:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q15;
3341:.\Include/arm_math.h **** 
3342:.\Include/arm_math.h ****   /**
3343:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR decimator.
3344:.\Include/arm_math.h ****    */
3345:.\Include/arm_math.h ****   typedef struct
3346:.\Include/arm_math.h ****   {
3347:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3348:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3349:.\Include/arm_math.h ****     q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3350:.\Include/arm_math.h ****     q31_t *pState;              /**< points to the state variable array. The array is of length num
3351:.\Include/arm_math.h ****   } arm_fir_decimate_instance_q31;
3352:.\Include/arm_math.h **** 
3353:.\Include/arm_math.h ****   /**
3354:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR decimator.
3355:.\Include/arm_math.h ****    */
3356:.\Include/arm_math.h ****   typedef struct
3357:.\Include/arm_math.h ****   {
3358:.\Include/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3359:.\Include/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3360:.\Include/arm_math.h ****     float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTap
3361:.\Include/arm_math.h ****     float32_t *pState;          /**< points to the state variable array. The array is of length num
3362:.\Include/arm_math.h ****   } arm_fir_decimate_instance_f32;
3363:.\Include/arm_math.h **** 
3364:.\Include/arm_math.h **** 
3365:.\Include/arm_math.h ****   /**
3366:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR decimator.
3367:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
3368:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3369:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 65


3370:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3371:.\Include/arm_math.h ****    */
3372:.\Include/arm_math.h ****   void arm_fir_decimate_f32(
3373:.\Include/arm_math.h ****   const arm_fir_decimate_instance_f32 * S,
3374:.\Include/arm_math.h ****   float32_t * pSrc,
3375:.\Include/arm_math.h ****   float32_t * pDst,
3376:.\Include/arm_math.h ****   uint32_t blockSize);
3377:.\Include/arm_math.h **** 
3378:.\Include/arm_math.h **** 
3379:.\Include/arm_math.h ****   /**
3380:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR decimator.
3381:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
3382:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3383:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3384:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3385:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3386:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3387:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3388:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3389:.\Include/arm_math.h ****    */
3390:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_f32(
3391:.\Include/arm_math.h ****   arm_fir_decimate_instance_f32 * S,
3392:.\Include/arm_math.h ****   uint16_t numTaps,
3393:.\Include/arm_math.h ****   uint8_t M,
3394:.\Include/arm_math.h ****   float32_t * pCoeffs,
3395:.\Include/arm_math.h ****   float32_t * pState,
3396:.\Include/arm_math.h ****   uint32_t blockSize);
3397:.\Include/arm_math.h **** 
3398:.\Include/arm_math.h **** 
3399:.\Include/arm_math.h ****   /**
3400:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator.
3401:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3402:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3403:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3404:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3405:.\Include/arm_math.h ****    */
3406:.\Include/arm_math.h ****   void arm_fir_decimate_q15(
3407:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3408:.\Include/arm_math.h ****   q15_t * pSrc,
3409:.\Include/arm_math.h ****   q15_t * pDst,
3410:.\Include/arm_math.h ****   uint32_t blockSize);
3411:.\Include/arm_math.h **** 
3412:.\Include/arm_math.h **** 
3413:.\Include/arm_math.h ****   /**
3414:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3415:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3416:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3417:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3418:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3419:.\Include/arm_math.h ****    */
3420:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q15(
3421:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3422:.\Include/arm_math.h ****   q15_t * pSrc,
3423:.\Include/arm_math.h ****   q15_t * pDst,
3424:.\Include/arm_math.h ****   uint32_t blockSize);
3425:.\Include/arm_math.h **** 
3426:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 66


3427:.\Include/arm_math.h ****   /**
3428:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR decimator.
3429:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
3430:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3431:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3432:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3433:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3434:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3435:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3436:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3437:.\Include/arm_math.h ****    */
3438:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q15(
3439:.\Include/arm_math.h ****   arm_fir_decimate_instance_q15 * S,
3440:.\Include/arm_math.h ****   uint16_t numTaps,
3441:.\Include/arm_math.h ****   uint8_t M,
3442:.\Include/arm_math.h ****   q15_t * pCoeffs,
3443:.\Include/arm_math.h ****   q15_t * pState,
3444:.\Include/arm_math.h ****   uint32_t blockSize);
3445:.\Include/arm_math.h **** 
3446:.\Include/arm_math.h **** 
3447:.\Include/arm_math.h ****   /**
3448:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator.
3449:.\Include/arm_math.h ****    * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
3450:.\Include/arm_math.h ****    * @param[in]  pSrc  points to the block of input data.
3451:.\Include/arm_math.h ****    * @param[out] pDst  points to the block of output data
3452:.\Include/arm_math.h ****    * @param[in] blockSize number of input samples to process per call.
3453:.\Include/arm_math.h ****    */
3454:.\Include/arm_math.h ****   void arm_fir_decimate_q31(
3455:.\Include/arm_math.h ****   const arm_fir_decimate_instance_q31 * S,
3456:.\Include/arm_math.h ****   q31_t * pSrc,
3457:.\Include/arm_math.h ****   q31_t * pDst,
3458:.\Include/arm_math.h ****   uint32_t blockSize);
3459:.\Include/arm_math.h **** 
3460:.\Include/arm_math.h ****   /**
3461:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3462:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
3463:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3464:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3465:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3466:.\Include/arm_math.h ****    */
3467:.\Include/arm_math.h ****   void arm_fir_decimate_fast_q31(
3468:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3469:.\Include/arm_math.h ****   q31_t * pSrc,
3470:.\Include/arm_math.h ****   q31_t * pDst,
3471:.\Include/arm_math.h ****   uint32_t blockSize);
3472:.\Include/arm_math.h **** 
3473:.\Include/arm_math.h **** 
3474:.\Include/arm_math.h ****   /**
3475:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR decimator.
3476:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
3477:.\Include/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3478:.\Include/arm_math.h ****    * @param[in]     M          decimation factor.
3479:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3480:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3481:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3482:.\Include/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3483:.\Include/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 67


3484:.\Include/arm_math.h ****    */
3485:.\Include/arm_math.h ****   arm_status arm_fir_decimate_init_q31(
3486:.\Include/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3487:.\Include/arm_math.h ****   uint16_t numTaps,
3488:.\Include/arm_math.h ****   uint8_t M,
3489:.\Include/arm_math.h ****   q31_t * pCoeffs,
3490:.\Include/arm_math.h ****   q31_t * pState,
3491:.\Include/arm_math.h ****   uint32_t blockSize);
3492:.\Include/arm_math.h **** 
3493:.\Include/arm_math.h **** 
3494:.\Include/arm_math.h ****   /**
3495:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR interpolator.
3496:.\Include/arm_math.h ****    */
3497:.\Include/arm_math.h ****   typedef struct
3498:.\Include/arm_math.h ****   {
3499:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3500:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3501:.\Include/arm_math.h ****     q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3502:.\Include/arm_math.h ****     q15_t *pState;                  /**< points to the state variable array. The array is of length
3503:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q15;
3504:.\Include/arm_math.h **** 
3505:.\Include/arm_math.h ****   /**
3506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR interpolator.
3507:.\Include/arm_math.h ****    */
3508:.\Include/arm_math.h ****   typedef struct
3509:.\Include/arm_math.h ****   {
3510:.\Include/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3511:.\Include/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3512:.\Include/arm_math.h ****     q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3513:.\Include/arm_math.h ****     q31_t *pState;                  /**< points to the state variable array. The array is of length
3514:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_q31;
3515:.\Include/arm_math.h **** 
3516:.\Include/arm_math.h ****   /**
3517:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR interpolator.
3518:.\Include/arm_math.h ****    */
3519:.\Include/arm_math.h ****   typedef struct
3520:.\Include/arm_math.h ****   {
3521:.\Include/arm_math.h ****     uint8_t L;                     /**< upsample factor. */
3522:.\Include/arm_math.h ****     uint16_t phaseLength;          /**< length of each polyphase filter component. */
3523:.\Include/arm_math.h ****     float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*p
3524:.\Include/arm_math.h ****     float32_t *pState;             /**< points to the state variable array. The array is of length 
3525:.\Include/arm_math.h ****   } arm_fir_interpolate_instance_f32;
3526:.\Include/arm_math.h **** 
3527:.\Include/arm_math.h **** 
3528:.\Include/arm_math.h ****   /**
3529:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR interpolator.
3530:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3531:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3532:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3533:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3534:.\Include/arm_math.h ****    */
3535:.\Include/arm_math.h ****   void arm_fir_interpolate_q15(
3536:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q15 * S,
3537:.\Include/arm_math.h ****   q15_t * pSrc,
3538:.\Include/arm_math.h ****   q15_t * pDst,
3539:.\Include/arm_math.h ****   uint32_t blockSize);
3540:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 68


3541:.\Include/arm_math.h **** 
3542:.\Include/arm_math.h ****   /**
3543:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 FIR interpolator.
3544:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
3545:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3546:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3547:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3548:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3549:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3550:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3551:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3552:.\Include/arm_math.h ****    */
3553:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q15(
3554:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q15 * S,
3555:.\Include/arm_math.h ****   uint8_t L,
3556:.\Include/arm_math.h ****   uint16_t numTaps,
3557:.\Include/arm_math.h ****   q15_t * pCoeffs,
3558:.\Include/arm_math.h ****   q15_t * pState,
3559:.\Include/arm_math.h ****   uint32_t blockSize);
3560:.\Include/arm_math.h **** 
3561:.\Include/arm_math.h **** 
3562:.\Include/arm_math.h ****   /**
3563:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR interpolator.
3564:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3565:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3566:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3567:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3568:.\Include/arm_math.h ****    */
3569:.\Include/arm_math.h ****   void arm_fir_interpolate_q31(
3570:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_q31 * S,
3571:.\Include/arm_math.h ****   q31_t * pSrc,
3572:.\Include/arm_math.h ****   q31_t * pDst,
3573:.\Include/arm_math.h ****   uint32_t blockSize);
3574:.\Include/arm_math.h **** 
3575:.\Include/arm_math.h **** 
3576:.\Include/arm_math.h ****   /**
3577:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 FIR interpolator.
3578:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
3579:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3580:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3581:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3582:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3583:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3584:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3585:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3586:.\Include/arm_math.h ****    */
3587:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_q31(
3588:.\Include/arm_math.h ****   arm_fir_interpolate_instance_q31 * S,
3589:.\Include/arm_math.h ****   uint8_t L,
3590:.\Include/arm_math.h ****   uint16_t numTaps,
3591:.\Include/arm_math.h ****   q31_t * pCoeffs,
3592:.\Include/arm_math.h ****   q31_t * pState,
3593:.\Include/arm_math.h ****   uint32_t blockSize);
3594:.\Include/arm_math.h **** 
3595:.\Include/arm_math.h **** 
3596:.\Include/arm_math.h ****   /**
3597:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR interpolator.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 69


3598:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
3599:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3600:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3601:.\Include/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3602:.\Include/arm_math.h ****    */
3603:.\Include/arm_math.h ****   void arm_fir_interpolate_f32(
3604:.\Include/arm_math.h ****   const arm_fir_interpolate_instance_f32 * S,
3605:.\Include/arm_math.h ****   float32_t * pSrc,
3606:.\Include/arm_math.h ****   float32_t * pDst,
3607:.\Include/arm_math.h ****   uint32_t blockSize);
3608:.\Include/arm_math.h **** 
3609:.\Include/arm_math.h **** 
3610:.\Include/arm_math.h ****   /**
3611:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point FIR interpolator.
3612:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR interpolator structu
3613:.\Include/arm_math.h ****    * @param[in]     L          upsample factor.
3614:.\Include/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3615:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3616:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3617:.\Include/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3618:.\Include/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3619:.\Include/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3620:.\Include/arm_math.h ****    */
3621:.\Include/arm_math.h ****   arm_status arm_fir_interpolate_init_f32(
3622:.\Include/arm_math.h ****   arm_fir_interpolate_instance_f32 * S,
3623:.\Include/arm_math.h ****   uint8_t L,
3624:.\Include/arm_math.h ****   uint16_t numTaps,
3625:.\Include/arm_math.h ****   float32_t * pCoeffs,
3626:.\Include/arm_math.h ****   float32_t * pState,
3627:.\Include/arm_math.h ****   uint32_t blockSize);
3628:.\Include/arm_math.h **** 
3629:.\Include/arm_math.h **** 
3630:.\Include/arm_math.h ****   /**
3631:.\Include/arm_math.h ****    * @brief Instance structure for the high precision Q31 Biquad cascade filter.
3632:.\Include/arm_math.h ****    */
3633:.\Include/arm_math.h ****   typedef struct
3634:.\Include/arm_math.h ****   {
3635:.\Include/arm_math.h ****     uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*num
3636:.\Include/arm_math.h ****     q63_t *pState;           /**< points to the array of state coefficients.  The array is of lengt
3637:.\Include/arm_math.h ****     q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*nu
3638:.\Include/arm_math.h ****     uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
3639:.\Include/arm_math.h ****   } arm_biquad_cas_df1_32x64_ins_q31;
3640:.\Include/arm_math.h **** 
3641:.\Include/arm_math.h **** 
3642:.\Include/arm_math.h ****   /**
3643:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter s
3644:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3645:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3646:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3647:.\Include/arm_math.h ****    */
3648:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_q31(
3649:.\Include/arm_math.h ****   const arm_biquad_cas_df1_32x64_ins_q31 * S,
3650:.\Include/arm_math.h ****   q31_t * pSrc,
3651:.\Include/arm_math.h ****   q31_t * pDst,
3652:.\Include/arm_math.h ****   uint32_t blockSize);
3653:.\Include/arm_math.h **** 
3654:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 70


3655:.\Include/arm_math.h ****   /**
3656:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filte
3657:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3658:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3659:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3660:.\Include/arm_math.h ****    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficie
3661:.\Include/arm_math.h ****    */
3662:.\Include/arm_math.h ****   void arm_biquad_cas_df1_32x64_init_q31(
3663:.\Include/arm_math.h ****   arm_biquad_cas_df1_32x64_ins_q31 * S,
3664:.\Include/arm_math.h ****   uint8_t numStages,
3665:.\Include/arm_math.h ****   q31_t * pCoeffs,
3666:.\Include/arm_math.h ****   q63_t * pState,
3667:.\Include/arm_math.h ****   uint8_t postShift);
3668:.\Include/arm_math.h **** 
3669:.\Include/arm_math.h **** 
3670:.\Include/arm_math.h ****   /**
3671:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3672:.\Include/arm_math.h ****    */
3673:.\Include/arm_math.h ****   typedef struct
3674:.\Include/arm_math.h ****   {
3675:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3676:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3677:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3678:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f32;
3679:.\Include/arm_math.h **** 
3680:.\Include/arm_math.h ****   /**
3681:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3682:.\Include/arm_math.h ****    */
3683:.\Include/arm_math.h ****   typedef struct
3684:.\Include/arm_math.h ****   {
3685:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3686:.\Include/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3687:.\Include/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3688:.\Include/arm_math.h ****   } arm_biquad_cascade_stereo_df2T_instance_f32;
3689:.\Include/arm_math.h **** 
3690:.\Include/arm_math.h ****   /**
3691:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3692:.\Include/arm_math.h ****    */
3693:.\Include/arm_math.h ****   typedef struct
3694:.\Include/arm_math.h ****   {
3695:.\Include/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3696:.\Include/arm_math.h ****     float64_t *pState;         /**< points to the array of state coefficients.  The array is of len
3697:.\Include/arm_math.h ****     float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3698:.\Include/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f64;
3699:.\Include/arm_math.h **** 
3700:.\Include/arm_math.h **** 
3701:.\Include/arm_math.h ****   /**
3702:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3703:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3704:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3705:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3706:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3707:.\Include/arm_math.h ****    */
3708:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f32(
3709:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f32 * S,
3710:.\Include/arm_math.h ****   float32_t * pSrc,
3711:.\Include/arm_math.h ****   float32_t * pDst,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 71


3712:.\Include/arm_math.h ****   uint32_t blockSize);
3713:.\Include/arm_math.h **** 
3714:.\Include/arm_math.h **** 
3715:.\Include/arm_math.h ****   /**
3716:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3717:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3718:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3719:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3720:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3721:.\Include/arm_math.h ****    */
3722:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_f32(
3723:.\Include/arm_math.h ****   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3724:.\Include/arm_math.h ****   float32_t * pSrc,
3725:.\Include/arm_math.h ****   float32_t * pDst,
3726:.\Include/arm_math.h ****   uint32_t blockSize);
3727:.\Include/arm_math.h **** 
3728:.\Include/arm_math.h **** 
3729:.\Include/arm_math.h ****   /**
3730:.\Include/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3731:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3732:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3733:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3734:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3735:.\Include/arm_math.h ****    */
3736:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_f64(
3737:.\Include/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f64 * S,
3738:.\Include/arm_math.h ****   float64_t * pSrc,
3739:.\Include/arm_math.h ****   float64_t * pDst,
3740:.\Include/arm_math.h ****   uint32_t blockSize);
3741:.\Include/arm_math.h **** 
3742:.\Include/arm_math.h **** 
3743:.\Include/arm_math.h ****   /**
3744:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3745:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3746:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3747:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3748:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3749:.\Include/arm_math.h ****    */
3750:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f32(
3751:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f32 * S,
3752:.\Include/arm_math.h ****   uint8_t numStages,
3753:.\Include/arm_math.h ****   float32_t * pCoeffs,
3754:.\Include/arm_math.h ****   float32_t * pState);
3755:.\Include/arm_math.h **** 
3756:.\Include/arm_math.h **** 
3757:.\Include/arm_math.h ****   /**
3758:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3759:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3760:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3761:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3762:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3763:.\Include/arm_math.h ****    */
3764:.\Include/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_init_f32(
3765:.\Include/arm_math.h ****   arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3766:.\Include/arm_math.h ****   uint8_t numStages,
3767:.\Include/arm_math.h ****   float32_t * pCoeffs,
3768:.\Include/arm_math.h ****   float32_t * pState);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 72


3769:.\Include/arm_math.h **** 
3770:.\Include/arm_math.h **** 
3771:.\Include/arm_math.h ****   /**
3772:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3773:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3774:.\Include/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3775:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3776:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3777:.\Include/arm_math.h ****    */
3778:.\Include/arm_math.h ****   void arm_biquad_cascade_df2T_init_f64(
3779:.\Include/arm_math.h ****   arm_biquad_cascade_df2T_instance_f64 * S,
3780:.\Include/arm_math.h ****   uint8_t numStages,
3781:.\Include/arm_math.h ****   float64_t * pCoeffs,
3782:.\Include/arm_math.h ****   float64_t * pState);
3783:.\Include/arm_math.h **** 
3784:.\Include/arm_math.h **** 
3785:.\Include/arm_math.h ****   /**
3786:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 FIR lattice filter.
3787:.\Include/arm_math.h ****    */
3788:.\Include/arm_math.h ****   typedef struct
3789:.\Include/arm_math.h ****   {
3790:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3791:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3792:.\Include/arm_math.h ****     q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3793:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q15;
3794:.\Include/arm_math.h **** 
3795:.\Include/arm_math.h ****   /**
3796:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 FIR lattice filter.
3797:.\Include/arm_math.h ****    */
3798:.\Include/arm_math.h ****   typedef struct
3799:.\Include/arm_math.h ****   {
3800:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3801:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3802:.\Include/arm_math.h ****     q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3803:.\Include/arm_math.h ****   } arm_fir_lattice_instance_q31;
3804:.\Include/arm_math.h **** 
3805:.\Include/arm_math.h ****   /**
3806:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point FIR lattice filter.
3807:.\Include/arm_math.h ****    */
3808:.\Include/arm_math.h ****   typedef struct
3809:.\Include/arm_math.h ****   {
3810:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3811:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3812:.\Include/arm_math.h ****     float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of leng
3813:.\Include/arm_math.h ****   } arm_fir_lattice_instance_f32;
3814:.\Include/arm_math.h **** 
3815:.\Include/arm_math.h **** 
3816:.\Include/arm_math.h ****   /**
3817:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 FIR lattice filter.
3818:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 FIR lattice structure.
3819:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3820:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3821:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages.
3822:.\Include/arm_math.h ****    */
3823:.\Include/arm_math.h ****   void arm_fir_lattice_init_q15(
3824:.\Include/arm_math.h ****   arm_fir_lattice_instance_q15 * S,
3825:.\Include/arm_math.h ****   uint16_t numStages,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 73


3826:.\Include/arm_math.h ****   q15_t * pCoeffs,
3827:.\Include/arm_math.h ****   q15_t * pState);
3828:.\Include/arm_math.h **** 
3829:.\Include/arm_math.h **** 
3830:.\Include/arm_math.h ****   /**
3831:.\Include/arm_math.h ****    * @brief Processing function for the Q15 FIR lattice filter.
3832:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
3833:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3834:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3835:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3836:.\Include/arm_math.h ****    */
3837:.\Include/arm_math.h ****   void arm_fir_lattice_q15(
3838:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q15 * S,
3839:.\Include/arm_math.h ****   q15_t * pSrc,
3840:.\Include/arm_math.h ****   q15_t * pDst,
3841:.\Include/arm_math.h ****   uint32_t blockSize);
3842:.\Include/arm_math.h **** 
3843:.\Include/arm_math.h **** 
3844:.\Include/arm_math.h ****   /**
3845:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 FIR lattice filter.
3846:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 FIR lattice structure.
3847:.\Include/arm_math.h ****    * @param[in] numStages  number of filter stages.
3848:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3849:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.   The array is of length numStages.
3850:.\Include/arm_math.h ****    */
3851:.\Include/arm_math.h ****   void arm_fir_lattice_init_q31(
3852:.\Include/arm_math.h ****   arm_fir_lattice_instance_q31 * S,
3853:.\Include/arm_math.h ****   uint16_t numStages,
3854:.\Include/arm_math.h ****   q31_t * pCoeffs,
3855:.\Include/arm_math.h ****   q31_t * pState);
3856:.\Include/arm_math.h **** 
3857:.\Include/arm_math.h **** 
3858:.\Include/arm_math.h ****   /**
3859:.\Include/arm_math.h ****    * @brief Processing function for the Q31 FIR lattice filter.
3860:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
3861:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3862:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3863:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3864:.\Include/arm_math.h ****    */
3865:.\Include/arm_math.h ****   void arm_fir_lattice_q31(
3866:.\Include/arm_math.h ****   const arm_fir_lattice_instance_q31 * S,
3867:.\Include/arm_math.h ****   q31_t * pSrc,
3868:.\Include/arm_math.h ****   q31_t * pDst,
3869:.\Include/arm_math.h ****   uint32_t blockSize);
3870:.\Include/arm_math.h **** 
3871:.\Include/arm_math.h **** 
3872:.\Include/arm_math.h **** /**
3873:.\Include/arm_math.h ****  * @brief Initialization function for the floating-point FIR lattice filter.
3874:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the floating-point FIR lattice structure.
3875:.\Include/arm_math.h ****  * @param[in] numStages  number of filter stages.
3876:.\Include/arm_math.h ****  * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3877:.\Include/arm_math.h ****  * @param[in] pState     points to the state buffer.  The array is of length numStages.
3878:.\Include/arm_math.h ****  */
3879:.\Include/arm_math.h ****   void arm_fir_lattice_init_f32(
3880:.\Include/arm_math.h ****   arm_fir_lattice_instance_f32 * S,
3881:.\Include/arm_math.h ****   uint16_t numStages,
3882:.\Include/arm_math.h ****   float32_t * pCoeffs,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 74


3883:.\Include/arm_math.h ****   float32_t * pState);
3884:.\Include/arm_math.h **** 
3885:.\Include/arm_math.h **** 
3886:.\Include/arm_math.h ****   /**
3887:.\Include/arm_math.h ****    * @brief Processing function for the floating-point FIR lattice filter.
3888:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
3889:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3890:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data
3891:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3892:.\Include/arm_math.h ****    */
3893:.\Include/arm_math.h ****   void arm_fir_lattice_f32(
3894:.\Include/arm_math.h ****   const arm_fir_lattice_instance_f32 * S,
3895:.\Include/arm_math.h ****   float32_t * pSrc,
3896:.\Include/arm_math.h ****   float32_t * pDst,
3897:.\Include/arm_math.h ****   uint32_t blockSize);
3898:.\Include/arm_math.h **** 
3899:.\Include/arm_math.h **** 
3900:.\Include/arm_math.h ****   /**
3901:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 IIR lattice filter.
3902:.\Include/arm_math.h ****    */
3903:.\Include/arm_math.h ****   typedef struct
3904:.\Include/arm_math.h ****   {
3905:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3906:.\Include/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3907:.\Include/arm_math.h ****     q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3908:.\Include/arm_math.h ****     q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3909:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q15;
3910:.\Include/arm_math.h **** 
3911:.\Include/arm_math.h ****   /**
3912:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 IIR lattice filter.
3913:.\Include/arm_math.h ****    */
3914:.\Include/arm_math.h ****   typedef struct
3915:.\Include/arm_math.h ****   {
3916:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3917:.\Include/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3918:.\Include/arm_math.h ****     q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3919:.\Include/arm_math.h ****     q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3920:.\Include/arm_math.h ****   } arm_iir_lattice_instance_q31;
3921:.\Include/arm_math.h **** 
3922:.\Include/arm_math.h ****   /**
3923:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point IIR lattice filter.
3924:.\Include/arm_math.h ****    */
3925:.\Include/arm_math.h ****   typedef struct
3926:.\Include/arm_math.h ****   {
3927:.\Include/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3928:.\Include/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3929:.\Include/arm_math.h ****     float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array
3930:.\Include/arm_math.h ****     float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is 
3931:.\Include/arm_math.h ****   } arm_iir_lattice_instance_f32;
3932:.\Include/arm_math.h **** 
3933:.\Include/arm_math.h **** 
3934:.\Include/arm_math.h ****   /**
3935:.\Include/arm_math.h ****    * @brief Processing function for the floating-point IIR lattice filter.
3936:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
3937:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3938:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3939:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 75


3940:.\Include/arm_math.h ****    */
3941:.\Include/arm_math.h ****   void arm_iir_lattice_f32(
3942:.\Include/arm_math.h ****   const arm_iir_lattice_instance_f32 * S,
3943:.\Include/arm_math.h ****   float32_t * pSrc,
3944:.\Include/arm_math.h ****   float32_t * pDst,
3945:.\Include/arm_math.h ****   uint32_t blockSize);
3946:.\Include/arm_math.h **** 
3947:.\Include/arm_math.h **** 
3948:.\Include/arm_math.h ****   /**
3949:.\Include/arm_math.h ****    * @brief Initialization function for the floating-point IIR lattice filter.
3950:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point IIR lattice structure.
3951:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3952:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3953:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3954:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-
3955:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3956:.\Include/arm_math.h ****    */
3957:.\Include/arm_math.h ****   void arm_iir_lattice_init_f32(
3958:.\Include/arm_math.h ****   arm_iir_lattice_instance_f32 * S,
3959:.\Include/arm_math.h ****   uint16_t numStages,
3960:.\Include/arm_math.h ****   float32_t * pkCoeffs,
3961:.\Include/arm_math.h ****   float32_t * pvCoeffs,
3962:.\Include/arm_math.h ****   float32_t * pState,
3963:.\Include/arm_math.h ****   uint32_t blockSize);
3964:.\Include/arm_math.h **** 
3965:.\Include/arm_math.h **** 
3966:.\Include/arm_math.h ****   /**
3967:.\Include/arm_math.h ****    * @brief Processing function for the Q31 IIR lattice filter.
3968:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
3969:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3970:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3971:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3972:.\Include/arm_math.h ****    */
3973:.\Include/arm_math.h ****   void arm_iir_lattice_q31(
3974:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q31 * S,
3975:.\Include/arm_math.h ****   q31_t * pSrc,
3976:.\Include/arm_math.h ****   q31_t * pDst,
3977:.\Include/arm_math.h ****   uint32_t blockSize);
3978:.\Include/arm_math.h **** 
3979:.\Include/arm_math.h **** 
3980:.\Include/arm_math.h ****   /**
3981:.\Include/arm_math.h ****    * @brief Initialization function for the Q31 IIR lattice filter.
3982:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 IIR lattice structure.
3983:.\Include/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3984:.\Include/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3985:.\Include/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3986:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
3987:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3988:.\Include/arm_math.h ****    */
3989:.\Include/arm_math.h ****   void arm_iir_lattice_init_q31(
3990:.\Include/arm_math.h ****   arm_iir_lattice_instance_q31 * S,
3991:.\Include/arm_math.h ****   uint16_t numStages,
3992:.\Include/arm_math.h ****   q31_t * pkCoeffs,
3993:.\Include/arm_math.h ****   q31_t * pvCoeffs,
3994:.\Include/arm_math.h ****   q31_t * pState,
3995:.\Include/arm_math.h ****   uint32_t blockSize);
3996:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 76


3997:.\Include/arm_math.h **** 
3998:.\Include/arm_math.h ****   /**
3999:.\Include/arm_math.h ****    * @brief Processing function for the Q15 IIR lattice filter.
4000:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
4001:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4002:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data.
4003:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4004:.\Include/arm_math.h ****    */
4005:.\Include/arm_math.h ****   void arm_iir_lattice_q15(
4006:.\Include/arm_math.h ****   const arm_iir_lattice_instance_q15 * S,
4007:.\Include/arm_math.h ****   q15_t * pSrc,
4008:.\Include/arm_math.h ****   q15_t * pDst,
4009:.\Include/arm_math.h ****   uint32_t blockSize);
4010:.\Include/arm_math.h **** 
4011:.\Include/arm_math.h **** 
4012:.\Include/arm_math.h **** /**
4013:.\Include/arm_math.h ****  * @brief Initialization function for the Q15 IIR lattice filter.
4014:.\Include/arm_math.h ****  * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
4015:.\Include/arm_math.h ****  * @param[in] numStages  number of stages in the filter.
4016:.\Include/arm_math.h ****  * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages
4017:.\Include/arm_math.h ****  * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
4018:.\Include/arm_math.h ****  * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
4019:.\Include/arm_math.h ****  * @param[in] blockSize  number of samples to process per call.
4020:.\Include/arm_math.h ****  */
4021:.\Include/arm_math.h ****   void arm_iir_lattice_init_q15(
4022:.\Include/arm_math.h ****   arm_iir_lattice_instance_q15 * S,
4023:.\Include/arm_math.h ****   uint16_t numStages,
4024:.\Include/arm_math.h ****   q15_t * pkCoeffs,
4025:.\Include/arm_math.h ****   q15_t * pvCoeffs,
4026:.\Include/arm_math.h ****   q15_t * pState,
4027:.\Include/arm_math.h ****   uint32_t blockSize);
4028:.\Include/arm_math.h **** 
4029:.\Include/arm_math.h **** 
4030:.\Include/arm_math.h ****   /**
4031:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point LMS filter.
4032:.\Include/arm_math.h ****    */
4033:.\Include/arm_math.h ****   typedef struct
4034:.\Include/arm_math.h ****   {
4035:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4036:.\Include/arm_math.h ****     float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+bl
4037:.\Include/arm_math.h ****     float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
4038:.\Include/arm_math.h ****     float32_t mu;        /**< step size that controls filter coefficient updates. */
4039:.\Include/arm_math.h ****   } arm_lms_instance_f32;
4040:.\Include/arm_math.h **** 
4041:.\Include/arm_math.h **** 
4042:.\Include/arm_math.h ****   /**
4043:.\Include/arm_math.h ****    * @brief Processing function for floating-point LMS filter.
4044:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point LMS filter structure.
4045:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4046:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4047:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4048:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4049:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4050:.\Include/arm_math.h ****    */
4051:.\Include/arm_math.h ****   void arm_lms_f32(
4052:.\Include/arm_math.h ****   const arm_lms_instance_f32 * S,
4053:.\Include/arm_math.h ****   float32_t * pSrc,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 77


4054:.\Include/arm_math.h ****   float32_t * pRef,
4055:.\Include/arm_math.h ****   float32_t * pOut,
4056:.\Include/arm_math.h ****   float32_t * pErr,
4057:.\Include/arm_math.h ****   uint32_t blockSize);
4058:.\Include/arm_math.h **** 
4059:.\Include/arm_math.h **** 
4060:.\Include/arm_math.h ****   /**
4061:.\Include/arm_math.h ****    * @brief Initialization function for floating-point LMS filter.
4062:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4063:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4064:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4065:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4066:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4067:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4068:.\Include/arm_math.h ****    */
4069:.\Include/arm_math.h ****   void arm_lms_init_f32(
4070:.\Include/arm_math.h ****   arm_lms_instance_f32 * S,
4071:.\Include/arm_math.h ****   uint16_t numTaps,
4072:.\Include/arm_math.h ****   float32_t * pCoeffs,
4073:.\Include/arm_math.h ****   float32_t * pState,
4074:.\Include/arm_math.h ****   float32_t mu,
4075:.\Include/arm_math.h ****   uint32_t blockSize);
4076:.\Include/arm_math.h **** 
4077:.\Include/arm_math.h **** 
4078:.\Include/arm_math.h ****   /**
4079:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 LMS filter.
4080:.\Include/arm_math.h ****    */
4081:.\Include/arm_math.h ****   typedef struct
4082:.\Include/arm_math.h ****   {
4083:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4084:.\Include/arm_math.h ****     q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4085:.\Include/arm_math.h ****     q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4086:.\Include/arm_math.h ****     q15_t mu;            /**< step size that controls filter coefficient updates. */
4087:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4088:.\Include/arm_math.h ****   } arm_lms_instance_q15;
4089:.\Include/arm_math.h **** 
4090:.\Include/arm_math.h **** 
4091:.\Include/arm_math.h ****   /**
4092:.\Include/arm_math.h ****    * @brief Initialization function for the Q15 LMS filter.
4093:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 LMS filter structure.
4094:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4095:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4096:.\Include/arm_math.h ****    * @param[in] pState     points to the state buffer.
4097:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4098:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4099:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4100:.\Include/arm_math.h ****    */
4101:.\Include/arm_math.h ****   void arm_lms_init_q15(
4102:.\Include/arm_math.h ****   arm_lms_instance_q15 * S,
4103:.\Include/arm_math.h ****   uint16_t numTaps,
4104:.\Include/arm_math.h ****   q15_t * pCoeffs,
4105:.\Include/arm_math.h ****   q15_t * pState,
4106:.\Include/arm_math.h ****   q15_t mu,
4107:.\Include/arm_math.h ****   uint32_t blockSize,
4108:.\Include/arm_math.h ****   uint32_t postShift);
4109:.\Include/arm_math.h **** 
4110:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 78


4111:.\Include/arm_math.h ****   /**
4112:.\Include/arm_math.h ****    * @brief Processing function for Q15 LMS filter.
4113:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4114:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4115:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4116:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4117:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4118:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4119:.\Include/arm_math.h ****    */
4120:.\Include/arm_math.h ****   void arm_lms_q15(
4121:.\Include/arm_math.h ****   const arm_lms_instance_q15 * S,
4122:.\Include/arm_math.h ****   q15_t * pSrc,
4123:.\Include/arm_math.h ****   q15_t * pRef,
4124:.\Include/arm_math.h ****   q15_t * pOut,
4125:.\Include/arm_math.h ****   q15_t * pErr,
4126:.\Include/arm_math.h ****   uint32_t blockSize);
4127:.\Include/arm_math.h **** 
4128:.\Include/arm_math.h **** 
4129:.\Include/arm_math.h ****   /**
4130:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 LMS filter.
4131:.\Include/arm_math.h ****    */
4132:.\Include/arm_math.h ****   typedef struct
4133:.\Include/arm_math.h ****   {
4134:.\Include/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4135:.\Include/arm_math.h ****     q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4136:.\Include/arm_math.h ****     q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4137:.\Include/arm_math.h ****     q31_t mu;            /**< step size that controls filter coefficient updates. */
4138:.\Include/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4139:.\Include/arm_math.h ****   } arm_lms_instance_q31;
4140:.\Include/arm_math.h **** 
4141:.\Include/arm_math.h **** 
4142:.\Include/arm_math.h ****   /**
4143:.\Include/arm_math.h ****    * @brief Processing function for Q31 LMS filter.
4144:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4145:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4146:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4147:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4148:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4149:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4150:.\Include/arm_math.h ****    */
4151:.\Include/arm_math.h ****   void arm_lms_q31(
4152:.\Include/arm_math.h ****   const arm_lms_instance_q31 * S,
4153:.\Include/arm_math.h ****   q31_t * pSrc,
4154:.\Include/arm_math.h ****   q31_t * pRef,
4155:.\Include/arm_math.h ****   q31_t * pOut,
4156:.\Include/arm_math.h ****   q31_t * pErr,
4157:.\Include/arm_math.h ****   uint32_t blockSize);
4158:.\Include/arm_math.h **** 
4159:.\Include/arm_math.h **** 
4160:.\Include/arm_math.h ****   /**
4161:.\Include/arm_math.h ****    * @brief Initialization function for Q31 LMS filter.
4162:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 LMS filter structure.
4163:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4164:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4165:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4166:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4167:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 79


4168:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4169:.\Include/arm_math.h ****    */
4170:.\Include/arm_math.h ****   void arm_lms_init_q31(
4171:.\Include/arm_math.h ****   arm_lms_instance_q31 * S,
4172:.\Include/arm_math.h ****   uint16_t numTaps,
4173:.\Include/arm_math.h ****   q31_t * pCoeffs,
4174:.\Include/arm_math.h ****   q31_t * pState,
4175:.\Include/arm_math.h ****   q31_t mu,
4176:.\Include/arm_math.h ****   uint32_t blockSize,
4177:.\Include/arm_math.h ****   uint32_t postShift);
4178:.\Include/arm_math.h **** 
4179:.\Include/arm_math.h **** 
4180:.\Include/arm_math.h ****   /**
4181:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point normalized LMS filter.
4182:.\Include/arm_math.h ****    */
4183:.\Include/arm_math.h ****   typedef struct
4184:.\Include/arm_math.h ****   {
4185:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4186:.\Include/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
4187:.\Include/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
4188:.\Include/arm_math.h ****     float32_t mu;         /**< step size that control filter coefficient updates. */
4189:.\Include/arm_math.h ****     float32_t energy;     /**< saves previous frame energy. */
4190:.\Include/arm_math.h ****     float32_t x0;         /**< saves previous input sample. */
4191:.\Include/arm_math.h ****   } arm_lms_norm_instance_f32;
4192:.\Include/arm_math.h **** 
4193:.\Include/arm_math.h **** 
4194:.\Include/arm_math.h ****   /**
4195:.\Include/arm_math.h ****    * @brief Processing function for floating-point normalized LMS filter.
4196:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point normalized LMS filter struc
4197:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4198:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4199:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4200:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4201:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4202:.\Include/arm_math.h ****    */
4203:.\Include/arm_math.h ****   void arm_lms_norm_f32(
4204:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4205:.\Include/arm_math.h ****   float32_t * pSrc,
4206:.\Include/arm_math.h ****   float32_t * pRef,
4207:.\Include/arm_math.h ****   float32_t * pOut,
4208:.\Include/arm_math.h ****   float32_t * pErr,
4209:.\Include/arm_math.h ****   uint32_t blockSize);
4210:.\Include/arm_math.h **** 
4211:.\Include/arm_math.h **** 
4212:.\Include/arm_math.h ****   /**
4213:.\Include/arm_math.h ****    * @brief Initialization function for floating-point normalized LMS filter.
4214:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4215:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4216:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4217:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4218:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4219:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4220:.\Include/arm_math.h ****    */
4221:.\Include/arm_math.h ****   void arm_lms_norm_init_f32(
4222:.\Include/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4223:.\Include/arm_math.h ****   uint16_t numTaps,
4224:.\Include/arm_math.h ****   float32_t * pCoeffs,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 80


4225:.\Include/arm_math.h ****   float32_t * pState,
4226:.\Include/arm_math.h ****   float32_t mu,
4227:.\Include/arm_math.h ****   uint32_t blockSize);
4228:.\Include/arm_math.h **** 
4229:.\Include/arm_math.h **** 
4230:.\Include/arm_math.h ****   /**
4231:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 normalized LMS filter.
4232:.\Include/arm_math.h ****    */
4233:.\Include/arm_math.h ****   typedef struct
4234:.\Include/arm_math.h ****   {
4235:.\Include/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4236:.\Include/arm_math.h ****     q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4237:.\Include/arm_math.h ****     q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4238:.\Include/arm_math.h ****     q31_t mu;             /**< step size that controls filter coefficient updates. */
4239:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4240:.\Include/arm_math.h ****     q31_t *recipTable;    /**< points to the reciprocal initial value table. */
4241:.\Include/arm_math.h ****     q31_t energy;         /**< saves previous frame energy. */
4242:.\Include/arm_math.h ****     q31_t x0;             /**< saves previous input sample. */
4243:.\Include/arm_math.h ****   } arm_lms_norm_instance_q31;
4244:.\Include/arm_math.h **** 
4245:.\Include/arm_math.h **** 
4246:.\Include/arm_math.h ****   /**
4247:.\Include/arm_math.h ****    * @brief Processing function for Q31 normalized LMS filter.
4248:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
4249:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4250:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4251:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4252:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4253:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4254:.\Include/arm_math.h ****    */
4255:.\Include/arm_math.h ****   void arm_lms_norm_q31(
4256:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4257:.\Include/arm_math.h ****   q31_t * pSrc,
4258:.\Include/arm_math.h ****   q31_t * pRef,
4259:.\Include/arm_math.h ****   q31_t * pOut,
4260:.\Include/arm_math.h ****   q31_t * pErr,
4261:.\Include/arm_math.h ****   uint32_t blockSize);
4262:.\Include/arm_math.h **** 
4263:.\Include/arm_math.h **** 
4264:.\Include/arm_math.h ****   /**
4265:.\Include/arm_math.h ****    * @brief Initialization function for Q31 normalized LMS filter.
4266:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
4267:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4268:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4269:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4270:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4271:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4272:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4273:.\Include/arm_math.h ****    */
4274:.\Include/arm_math.h ****   void arm_lms_norm_init_q31(
4275:.\Include/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4276:.\Include/arm_math.h ****   uint16_t numTaps,
4277:.\Include/arm_math.h ****   q31_t * pCoeffs,
4278:.\Include/arm_math.h ****   q31_t * pState,
4279:.\Include/arm_math.h ****   q31_t mu,
4280:.\Include/arm_math.h ****   uint32_t blockSize,
4281:.\Include/arm_math.h ****   uint8_t postShift);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 81


4282:.\Include/arm_math.h **** 
4283:.\Include/arm_math.h **** 
4284:.\Include/arm_math.h ****   /**
4285:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 normalized LMS filter.
4286:.\Include/arm_math.h ****    */
4287:.\Include/arm_math.h ****   typedef struct
4288:.\Include/arm_math.h ****   {
4289:.\Include/arm_math.h ****     uint16_t numTaps;     /**< Number of coefficients in the filter. */
4290:.\Include/arm_math.h ****     q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4291:.\Include/arm_math.h ****     q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4292:.\Include/arm_math.h ****     q15_t mu;             /**< step size that controls filter coefficient updates. */
4293:.\Include/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4294:.\Include/arm_math.h ****     q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
4295:.\Include/arm_math.h ****     q15_t energy;         /**< saves previous frame energy. */
4296:.\Include/arm_math.h ****     q15_t x0;             /**< saves previous input sample. */
4297:.\Include/arm_math.h ****   } arm_lms_norm_instance_q15;
4298:.\Include/arm_math.h **** 
4299:.\Include/arm_math.h **** 
4300:.\Include/arm_math.h ****   /**
4301:.\Include/arm_math.h ****    * @brief Processing function for Q15 normalized LMS filter.
4302:.\Include/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
4303:.\Include/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4304:.\Include/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4305:.\Include/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4306:.\Include/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4307:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4308:.\Include/arm_math.h ****    */
4309:.\Include/arm_math.h ****   void arm_lms_norm_q15(
4310:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4311:.\Include/arm_math.h ****   q15_t * pSrc,
4312:.\Include/arm_math.h ****   q15_t * pRef,
4313:.\Include/arm_math.h ****   q15_t * pOut,
4314:.\Include/arm_math.h ****   q15_t * pErr,
4315:.\Include/arm_math.h ****   uint32_t blockSize);
4316:.\Include/arm_math.h **** 
4317:.\Include/arm_math.h **** 
4318:.\Include/arm_math.h ****   /**
4319:.\Include/arm_math.h ****    * @brief Initialization function for Q15 normalized LMS filter.
4320:.\Include/arm_math.h ****    * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
4321:.\Include/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4322:.\Include/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4323:.\Include/arm_math.h ****    * @param[in] pState     points to state buffer.
4324:.\Include/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4325:.\Include/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4326:.\Include/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4327:.\Include/arm_math.h ****    */
4328:.\Include/arm_math.h ****   void arm_lms_norm_init_q15(
4329:.\Include/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4330:.\Include/arm_math.h ****   uint16_t numTaps,
4331:.\Include/arm_math.h ****   q15_t * pCoeffs,
4332:.\Include/arm_math.h ****   q15_t * pState,
4333:.\Include/arm_math.h ****   q15_t mu,
4334:.\Include/arm_math.h ****   uint32_t blockSize,
4335:.\Include/arm_math.h ****   uint8_t postShift);
4336:.\Include/arm_math.h **** 
4337:.\Include/arm_math.h **** 
4338:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 82


4339:.\Include/arm_math.h ****    * @brief Correlation of floating-point sequences.
4340:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4341:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4342:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4343:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4344:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4345:.\Include/arm_math.h ****    */
4346:.\Include/arm_math.h ****   void arm_correlate_f32(
4347:.\Include/arm_math.h ****   float32_t * pSrcA,
4348:.\Include/arm_math.h ****   uint32_t srcALen,
4349:.\Include/arm_math.h ****   float32_t * pSrcB,
4350:.\Include/arm_math.h ****   uint32_t srcBLen,
4351:.\Include/arm_math.h ****   float32_t * pDst);
4352:.\Include/arm_math.h **** 
4353:.\Include/arm_math.h **** 
4354:.\Include/arm_math.h ****    /**
4355:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences
4356:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4357:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4358:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4359:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4360:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4361:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4362:.\Include/arm_math.h ****    */
4363:.\Include/arm_math.h ****   void arm_correlate_opt_q15(
4364:.\Include/arm_math.h ****   q15_t * pSrcA,
4365:.\Include/arm_math.h ****   uint32_t srcALen,
4366:.\Include/arm_math.h ****   q15_t * pSrcB,
4367:.\Include/arm_math.h ****   uint32_t srcBLen,
4368:.\Include/arm_math.h ****   q15_t * pDst,
4369:.\Include/arm_math.h ****   q15_t * pScratch);
4370:.\Include/arm_math.h **** 
4371:.\Include/arm_math.h **** 
4372:.\Include/arm_math.h ****   /**
4373:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences.
4374:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4375:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4376:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4377:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4378:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4379:.\Include/arm_math.h ****    */
4380:.\Include/arm_math.h **** 
4381:.\Include/arm_math.h ****   void arm_correlate_q15(
4382:.\Include/arm_math.h ****   q15_t * pSrcA,
4383:.\Include/arm_math.h ****   uint32_t srcALen,
4384:.\Include/arm_math.h ****   q15_t * pSrcB,
4385:.\Include/arm_math.h ****   uint32_t srcBLen,
4386:.\Include/arm_math.h ****   q15_t * pDst);
4387:.\Include/arm_math.h **** 
4388:.\Include/arm_math.h **** 
4389:.\Include/arm_math.h ****   /**
4390:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4391:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4392:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4393:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4394:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4395:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 83


4396:.\Include/arm_math.h ****    */
4397:.\Include/arm_math.h **** 
4398:.\Include/arm_math.h ****   void arm_correlate_fast_q15(
4399:.\Include/arm_math.h ****   q15_t * pSrcA,
4400:.\Include/arm_math.h ****   uint32_t srcALen,
4401:.\Include/arm_math.h ****   q15_t * pSrcB,
4402:.\Include/arm_math.h ****   uint32_t srcBLen,
4403:.\Include/arm_math.h ****   q15_t * pDst);
4404:.\Include/arm_math.h **** 
4405:.\Include/arm_math.h **** 
4406:.\Include/arm_math.h ****   /**
4407:.\Include/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4408:.\Include/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4409:.\Include/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4410:.\Include/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4411:.\Include/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4412:.\Include/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4413:.\Include/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4414:.\Include/arm_math.h ****    */
4415:.\Include/arm_math.h ****   void arm_correlate_fast_opt_q15(
4416:.\Include/arm_math.h ****   q15_t * pSrcA,
4417:.\Include/arm_math.h ****   uint32_t srcALen,
4418:.\Include/arm_math.h ****   q15_t * pSrcB,
4419:.\Include/arm_math.h ****   uint32_t srcBLen,
4420:.\Include/arm_math.h ****   q15_t * pDst,
4421:.\Include/arm_math.h ****   q15_t * pScratch);
4422:.\Include/arm_math.h **** 
4423:.\Include/arm_math.h **** 
4424:.\Include/arm_math.h ****   /**
4425:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences.
4426:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4427:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4428:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4429:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4430:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4431:.\Include/arm_math.h ****    */
4432:.\Include/arm_math.h ****   void arm_correlate_q31(
4433:.\Include/arm_math.h ****   q31_t * pSrcA,
4434:.\Include/arm_math.h ****   uint32_t srcALen,
4435:.\Include/arm_math.h ****   q31_t * pSrcB,
4436:.\Include/arm_math.h ****   uint32_t srcBLen,
4437:.\Include/arm_math.h ****   q31_t * pDst);
4438:.\Include/arm_math.h **** 
4439:.\Include/arm_math.h **** 
4440:.\Include/arm_math.h ****   /**
4441:.\Include/arm_math.h ****    * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
4442:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4443:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4444:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4445:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4446:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4447:.\Include/arm_math.h ****    */
4448:.\Include/arm_math.h ****   void arm_correlate_fast_q31(
4449:.\Include/arm_math.h ****   q31_t * pSrcA,
4450:.\Include/arm_math.h ****   uint32_t srcALen,
4451:.\Include/arm_math.h ****   q31_t * pSrcB,
4452:.\Include/arm_math.h ****   uint32_t srcBLen,
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 84


4453:.\Include/arm_math.h ****   q31_t * pDst);
4454:.\Include/arm_math.h **** 
4455:.\Include/arm_math.h **** 
4456:.\Include/arm_math.h ****  /**
4457:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4458:.\Include/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
4459:.\Include/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
4460:.\Include/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
4461:.\Include/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
4462:.\Include/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 
4463:.\Include/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
4464:.\Include/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
4465:.\Include/arm_math.h ****    */
4466:.\Include/arm_math.h ****   void arm_correlate_opt_q7(
4467:.\Include/arm_math.h ****   q7_t * pSrcA,
4468:.\Include/arm_math.h ****   uint32_t srcALen,
4469:.\Include/arm_math.h ****   q7_t * pSrcB,
4470:.\Include/arm_math.h ****   uint32_t srcBLen,
4471:.\Include/arm_math.h ****   q7_t * pDst,
4472:.\Include/arm_math.h ****   q15_t * pScratch1,
4473:.\Include/arm_math.h ****   q15_t * pScratch2);
4474:.\Include/arm_math.h **** 
4475:.\Include/arm_math.h **** 
4476:.\Include/arm_math.h ****   /**
4477:.\Include/arm_math.h ****    * @brief Correlation of Q7 sequences.
4478:.\Include/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4479:.\Include/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4480:.\Include/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4481:.\Include/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4482:.\Include/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4483:.\Include/arm_math.h ****    */
4484:.\Include/arm_math.h ****   void arm_correlate_q7(
4485:.\Include/arm_math.h ****   q7_t * pSrcA,
4486:.\Include/arm_math.h ****   uint32_t srcALen,
4487:.\Include/arm_math.h ****   q7_t * pSrcB,
4488:.\Include/arm_math.h ****   uint32_t srcBLen,
4489:.\Include/arm_math.h ****   q7_t * pDst);
4490:.\Include/arm_math.h **** 
4491:.\Include/arm_math.h **** 
4492:.\Include/arm_math.h ****   /**
4493:.\Include/arm_math.h ****    * @brief Instance structure for the floating-point sparse FIR filter.
4494:.\Include/arm_math.h ****    */
4495:.\Include/arm_math.h ****   typedef struct
4496:.\Include/arm_math.h ****   {
4497:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4498:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4499:.\Include/arm_math.h ****     float32_t *pState;            /**< points to the state buffer array. The array is of length max
4500:.\Include/arm_math.h ****     float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numT
4501:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4502:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4503:.\Include/arm_math.h ****   } arm_fir_sparse_instance_f32;
4504:.\Include/arm_math.h **** 
4505:.\Include/arm_math.h ****   /**
4506:.\Include/arm_math.h ****    * @brief Instance structure for the Q31 sparse FIR filter.
4507:.\Include/arm_math.h ****    */
4508:.\Include/arm_math.h ****   typedef struct
4509:.\Include/arm_math.h ****   {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 85


4510:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4511:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4512:.\Include/arm_math.h ****     q31_t *pState;                /**< points to the state buffer array. The array is of length max
4513:.\Include/arm_math.h ****     q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4514:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4515:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4516:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q31;
4517:.\Include/arm_math.h **** 
4518:.\Include/arm_math.h ****   /**
4519:.\Include/arm_math.h ****    * @brief Instance structure for the Q15 sparse FIR filter.
4520:.\Include/arm_math.h ****    */
4521:.\Include/arm_math.h ****   typedef struct
4522:.\Include/arm_math.h ****   {
4523:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4524:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4525:.\Include/arm_math.h ****     q15_t *pState;                /**< points to the state buffer array. The array is of length max
4526:.\Include/arm_math.h ****     q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4527:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4528:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4529:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q15;
4530:.\Include/arm_math.h **** 
4531:.\Include/arm_math.h ****   /**
4532:.\Include/arm_math.h ****    * @brief Instance structure for the Q7 sparse FIR filter.
4533:.\Include/arm_math.h ****    */
4534:.\Include/arm_math.h ****   typedef struct
4535:.\Include/arm_math.h ****   {
4536:.\Include/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4537:.\Include/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4538:.\Include/arm_math.h ****     q7_t *pState;                 /**< points to the state buffer array. The array is of length max
4539:.\Include/arm_math.h ****     q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numT
4540:.\Include/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4541:.\Include/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4542:.\Include/arm_math.h ****   } arm_fir_sparse_instance_q7;
4543:.\Include/arm_math.h **** 
4544:.\Include/arm_math.h **** 
4545:.\Include/arm_math.h ****   /**
4546:.\Include/arm_math.h ****    * @brief Processing function for the floating-point sparse FIR filter.
4547:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
4548:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4549:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4550:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4551:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4552:.\Include/arm_math.h ****    */
4553:.\Include/arm_math.h ****   void arm_fir_sparse_f32(
4554:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4555:.\Include/arm_math.h ****   float32_t * pSrc,
4556:.\Include/arm_math.h ****   float32_t * pDst,
4557:.\Include/arm_math.h ****   float32_t * pScratchIn,
4558:.\Include/arm_math.h ****   uint32_t blockSize);
4559:.\Include/arm_math.h **** 
4560:.\Include/arm_math.h **** 
4561:.\Include/arm_math.h ****   /**
4562:.\Include/arm_math.h ****    * @brief  Initialization function for the floating-point sparse FIR filter.
4563:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
4564:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4565:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4566:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 86


4567:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4568:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4569:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4570:.\Include/arm_math.h ****    */
4571:.\Include/arm_math.h ****   void arm_fir_sparse_init_f32(
4572:.\Include/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4573:.\Include/arm_math.h ****   uint16_t numTaps,
4574:.\Include/arm_math.h ****   float32_t * pCoeffs,
4575:.\Include/arm_math.h ****   float32_t * pState,
4576:.\Include/arm_math.h ****   int32_t * pTapDelay,
4577:.\Include/arm_math.h ****   uint16_t maxDelay,
4578:.\Include/arm_math.h ****   uint32_t blockSize);
4579:.\Include/arm_math.h **** 
4580:.\Include/arm_math.h **** 
4581:.\Include/arm_math.h ****   /**
4582:.\Include/arm_math.h ****    * @brief Processing function for the Q31 sparse FIR filter.
4583:.\Include/arm_math.h ****    * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
4584:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4585:.\Include/arm_math.h ****    * @param[out] pDst        points to the block of output data
4586:.\Include/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4587:.\Include/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4588:.\Include/arm_math.h ****    */
4589:.\Include/arm_math.h ****   void arm_fir_sparse_q31(
4590:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4591:.\Include/arm_math.h ****   q31_t * pSrc,
4592:.\Include/arm_math.h ****   q31_t * pDst,
4593:.\Include/arm_math.h ****   q31_t * pScratchIn,
4594:.\Include/arm_math.h ****   uint32_t blockSize);
4595:.\Include/arm_math.h **** 
4596:.\Include/arm_math.h **** 
4597:.\Include/arm_math.h ****   /**
4598:.\Include/arm_math.h ****    * @brief  Initialization function for the Q31 sparse FIR filter.
4599:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
4600:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4601:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4602:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4603:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4604:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4605:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4606:.\Include/arm_math.h ****    */
4607:.\Include/arm_math.h ****   void arm_fir_sparse_init_q31(
4608:.\Include/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4609:.\Include/arm_math.h ****   uint16_t numTaps,
4610:.\Include/arm_math.h ****   q31_t * pCoeffs,
4611:.\Include/arm_math.h ****   q31_t * pState,
4612:.\Include/arm_math.h ****   int32_t * pTapDelay,
4613:.\Include/arm_math.h ****   uint16_t maxDelay,
4614:.\Include/arm_math.h ****   uint32_t blockSize);
4615:.\Include/arm_math.h **** 
4616:.\Include/arm_math.h **** 
4617:.\Include/arm_math.h ****   /**
4618:.\Include/arm_math.h ****    * @brief Processing function for the Q15 sparse FIR filter.
4619:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
4620:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4621:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4622:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4623:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 87


4624:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4625:.\Include/arm_math.h ****    */
4626:.\Include/arm_math.h ****   void arm_fir_sparse_q15(
4627:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4628:.\Include/arm_math.h ****   q15_t * pSrc,
4629:.\Include/arm_math.h ****   q15_t * pDst,
4630:.\Include/arm_math.h ****   q15_t * pScratchIn,
4631:.\Include/arm_math.h ****   q31_t * pScratchOut,
4632:.\Include/arm_math.h ****   uint32_t blockSize);
4633:.\Include/arm_math.h **** 
4634:.\Include/arm_math.h **** 
4635:.\Include/arm_math.h ****   /**
4636:.\Include/arm_math.h ****    * @brief  Initialization function for the Q15 sparse FIR filter.
4637:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
4638:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4639:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4640:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4641:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4642:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4643:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4644:.\Include/arm_math.h ****    */
4645:.\Include/arm_math.h ****   void arm_fir_sparse_init_q15(
4646:.\Include/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4647:.\Include/arm_math.h ****   uint16_t numTaps,
4648:.\Include/arm_math.h ****   q15_t * pCoeffs,
4649:.\Include/arm_math.h ****   q15_t * pState,
4650:.\Include/arm_math.h ****   int32_t * pTapDelay,
4651:.\Include/arm_math.h ****   uint16_t maxDelay,
4652:.\Include/arm_math.h ****   uint32_t blockSize);
4653:.\Include/arm_math.h **** 
4654:.\Include/arm_math.h **** 
4655:.\Include/arm_math.h ****   /**
4656:.\Include/arm_math.h ****    * @brief Processing function for the Q7 sparse FIR filter.
4657:.\Include/arm_math.h ****    * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
4658:.\Include/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4659:.\Include/arm_math.h ****    * @param[out] pDst         points to the block of output data
4660:.\Include/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4661:.\Include/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4662:.\Include/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4663:.\Include/arm_math.h ****    */
4664:.\Include/arm_math.h ****   void arm_fir_sparse_q7(
4665:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4666:.\Include/arm_math.h ****   q7_t * pSrc,
4667:.\Include/arm_math.h ****   q7_t * pDst,
4668:.\Include/arm_math.h ****   q7_t * pScratchIn,
4669:.\Include/arm_math.h ****   q31_t * pScratchOut,
4670:.\Include/arm_math.h ****   uint32_t blockSize);
4671:.\Include/arm_math.h **** 
4672:.\Include/arm_math.h **** 
4673:.\Include/arm_math.h ****   /**
4674:.\Include/arm_math.h ****    * @brief  Initialization function for the Q7 sparse FIR filter.
4675:.\Include/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
4676:.\Include/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4677:.\Include/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4678:.\Include/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4679:.\Include/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4680:.\Include/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 88


4681:.\Include/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4682:.\Include/arm_math.h ****    */
4683:.\Include/arm_math.h ****   void arm_fir_sparse_init_q7(
4684:.\Include/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4685:.\Include/arm_math.h ****   uint16_t numTaps,
4686:.\Include/arm_math.h ****   q7_t * pCoeffs,
4687:.\Include/arm_math.h ****   q7_t * pState,
4688:.\Include/arm_math.h ****   int32_t * pTapDelay,
4689:.\Include/arm_math.h ****   uint16_t maxDelay,
4690:.\Include/arm_math.h ****   uint32_t blockSize);
4691:.\Include/arm_math.h **** 
4692:.\Include/arm_math.h **** 
4693:.\Include/arm_math.h ****   /**
4694:.\Include/arm_math.h ****    * @brief  Floating-point sin_cos function.
4695:.\Include/arm_math.h ****    * @param[in]  theta   input value in degrees
4696:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4697:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cos output.
4698:.\Include/arm_math.h ****    */
4699:.\Include/arm_math.h ****   void arm_sin_cos_f32(
4700:.\Include/arm_math.h ****   float32_t theta,
4701:.\Include/arm_math.h ****   float32_t * pSinVal,
4702:.\Include/arm_math.h ****   float32_t * pCosVal);
4703:.\Include/arm_math.h **** 
4704:.\Include/arm_math.h **** 
4705:.\Include/arm_math.h ****   /**
4706:.\Include/arm_math.h ****    * @brief  Q31 sin_cos function.
4707:.\Include/arm_math.h ****    * @param[in]  theta    scaled input value in degrees
4708:.\Include/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4709:.\Include/arm_math.h ****    * @param[out] pCosVal  points to the processed cosine output.
4710:.\Include/arm_math.h ****    */
4711:.\Include/arm_math.h ****   void arm_sin_cos_q31(
4712:.\Include/arm_math.h ****   q31_t theta,
4713:.\Include/arm_math.h ****   q31_t * pSinVal,
4714:.\Include/arm_math.h ****   q31_t * pCosVal);
4715:.\Include/arm_math.h **** 
4716:.\Include/arm_math.h **** 
4717:.\Include/arm_math.h ****   /**
4718:.\Include/arm_math.h ****    * @brief  Floating-point complex conjugate.
4719:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4720:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4721:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4722:.\Include/arm_math.h ****    */
4723:.\Include/arm_math.h ****   void arm_cmplx_conj_f32(
4724:.\Include/arm_math.h ****   float32_t * pSrc,
4725:.\Include/arm_math.h ****   float32_t * pDst,
4726:.\Include/arm_math.h ****   uint32_t numSamples);
4727:.\Include/arm_math.h **** 
4728:.\Include/arm_math.h ****   /**
4729:.\Include/arm_math.h ****    * @brief  Q31 complex conjugate.
4730:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4731:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4732:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4733:.\Include/arm_math.h ****    */
4734:.\Include/arm_math.h ****   void arm_cmplx_conj_q31(
4735:.\Include/arm_math.h ****   q31_t * pSrc,
4736:.\Include/arm_math.h ****   q31_t * pDst,
4737:.\Include/arm_math.h ****   uint32_t numSamples);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 89


4738:.\Include/arm_math.h **** 
4739:.\Include/arm_math.h **** 
4740:.\Include/arm_math.h ****   /**
4741:.\Include/arm_math.h ****    * @brief  Q15 complex conjugate.
4742:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4743:.\Include/arm_math.h ****    * @param[out] pDst        points to the output vector
4744:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4745:.\Include/arm_math.h ****    */
4746:.\Include/arm_math.h ****   void arm_cmplx_conj_q15(
4747:.\Include/arm_math.h ****   q15_t * pSrc,
4748:.\Include/arm_math.h ****   q15_t * pDst,
4749:.\Include/arm_math.h ****   uint32_t numSamples);
4750:.\Include/arm_math.h **** 
4751:.\Include/arm_math.h **** 
4752:.\Include/arm_math.h ****   /**
4753:.\Include/arm_math.h ****    * @brief  Floating-point complex magnitude squared
4754:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4755:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4756:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4757:.\Include/arm_math.h ****    */
4758:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_f32(
4759:.\Include/arm_math.h ****   float32_t * pSrc,
4760:.\Include/arm_math.h ****   float32_t * pDst,
4761:.\Include/arm_math.h ****   uint32_t numSamples);
4762:.\Include/arm_math.h **** 
4763:.\Include/arm_math.h **** 
4764:.\Include/arm_math.h ****   /**
4765:.\Include/arm_math.h ****    * @brief  Q31 complex magnitude squared
4766:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4767:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4768:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4769:.\Include/arm_math.h ****    */
4770:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q31(
4771:.\Include/arm_math.h ****   q31_t * pSrc,
4772:.\Include/arm_math.h ****   q31_t * pDst,
4773:.\Include/arm_math.h ****   uint32_t numSamples);
4774:.\Include/arm_math.h **** 
4775:.\Include/arm_math.h **** 
4776:.\Include/arm_math.h ****   /**
4777:.\Include/arm_math.h ****    * @brief  Q15 complex magnitude squared
4778:.\Include/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4779:.\Include/arm_math.h ****    * @param[out] pDst        points to the real output vector
4780:.\Include/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4781:.\Include/arm_math.h ****    */
4782:.\Include/arm_math.h ****   void arm_cmplx_mag_squared_q15(
4783:.\Include/arm_math.h ****   q15_t * pSrc,
4784:.\Include/arm_math.h ****   q15_t * pDst,
4785:.\Include/arm_math.h ****   uint32_t numSamples);
4786:.\Include/arm_math.h **** 
4787:.\Include/arm_math.h **** 
4788:.\Include/arm_math.h ****  /**
4789:.\Include/arm_math.h ****    * @ingroup groupController
4790:.\Include/arm_math.h ****    */
4791:.\Include/arm_math.h **** 
4792:.\Include/arm_math.h ****   /**
4793:.\Include/arm_math.h ****    * @defgroup PID PID Motor Control
4794:.\Include/arm_math.h ****    *
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 90


4795:.\Include/arm_math.h ****    * A Proportional Integral Derivative (PID) controller is a generic feedback control
4796:.\Include/arm_math.h ****    * loop mechanism widely used in industrial control systems.
4797:.\Include/arm_math.h ****    * A PID controller is the most commonly used type of feedback controller.
4798:.\Include/arm_math.h ****    *
4799:.\Include/arm_math.h ****    * This set of functions implements (PID) controllers
4800:.\Include/arm_math.h ****    * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
4801:.\Include/arm_math.h ****    * of data and each call to the function returns a single processed value.
4802:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
4803:.\Include/arm_math.h ****    * is the input sample value. The functions return the output value.
4804:.\Include/arm_math.h ****    *
4805:.\Include/arm_math.h ****    * \par Algorithm:
4806:.\Include/arm_math.h ****    * <pre>
4807:.\Include/arm_math.h ****    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
4808:.\Include/arm_math.h ****    *    A0 = Kp + Ki + Kd
4809:.\Include/arm_math.h ****    *    A1 = (-Kp ) - (2 * Kd )
4810:.\Include/arm_math.h ****    *    A2 = Kd  </pre>
4811:.\Include/arm_math.h ****    *
4812:.\Include/arm_math.h ****    * \par
4813:.\Include/arm_math.h ****    * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative const
4814:.\Include/arm_math.h ****    *
4815:.\Include/arm_math.h ****    * \par
4816:.\Include/arm_math.h ****    * \image html PID.gif "Proportional Integral Derivative Controller"
4817:.\Include/arm_math.h ****    *
4818:.\Include/arm_math.h ****    * \par
4819:.\Include/arm_math.h ****    * The PID controller calculates an "error" value as the difference between
4820:.\Include/arm_math.h ****    * the measured output and the reference input.
4821:.\Include/arm_math.h ****    * The controller attempts to minimize the error by adjusting the process control inputs.
4822:.\Include/arm_math.h ****    * The proportional value determines the reaction to the current error,
4823:.\Include/arm_math.h ****    * the integral value determines the reaction based on the sum of recent errors,
4824:.\Include/arm_math.h ****    * and the derivative value determines the reaction based on the rate at which the error has been
4825:.\Include/arm_math.h ****    *
4826:.\Include/arm_math.h ****    * \par Instance Structure
4827:.\Include/arm_math.h ****    * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instan
4828:.\Include/arm_math.h ****    * A separate instance structure must be defined for each PID Controller.
4829:.\Include/arm_math.h ****    * There are separate instance structure declarations for each of the 3 supported data types.
4830:.\Include/arm_math.h ****    *
4831:.\Include/arm_math.h ****    * \par Reset Functions
4832:.\Include/arm_math.h ****    * There is also an associated reset function for each data type which clears the state array.
4833:.\Include/arm_math.h ****    *
4834:.\Include/arm_math.h ****    * \par Initialization Functions
4835:.\Include/arm_math.h ****    * There is also an associated initialization function for each data type.
4836:.\Include/arm_math.h ****    * The initialization function performs the following operations:
4837:.\Include/arm_math.h ****    * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
4838:.\Include/arm_math.h ****    * - Zeros out the values in the state buffer.
4839:.\Include/arm_math.h ****    *
4840:.\Include/arm_math.h ****    * \par
4841:.\Include/arm_math.h ****    * Instance structure cannot be placed into a const data section and it is recommended to use the
4842:.\Include/arm_math.h ****    *
4843:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
4844:.\Include/arm_math.h ****    * Care must be taken when using the fixed-point versions of the PID Controller functions.
4845:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used in each function m
4846:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4847:.\Include/arm_math.h ****    */
4848:.\Include/arm_math.h **** 
4849:.\Include/arm_math.h ****   /**
4850:.\Include/arm_math.h ****    * @addtogroup PID
4851:.\Include/arm_math.h ****    * @{
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 91


4852:.\Include/arm_math.h ****    */
4853:.\Include/arm_math.h **** 
4854:.\Include/arm_math.h ****   /**
4855:.\Include/arm_math.h ****    * @brief  Process function for the floating-point PID Control.
4856:.\Include/arm_math.h ****    * @param[in,out] S   is an instance of the floating-point PID Control structure
4857:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4858:.\Include/arm_math.h ****    * @return out processed output sample.
4859:.\Include/arm_math.h ****    */
4860:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_pid_f32(
4861:.\Include/arm_math.h ****   arm_pid_instance_f32 * S,
4862:.\Include/arm_math.h ****   float32_t in)
4863:.\Include/arm_math.h ****   {
4864:.\Include/arm_math.h ****     float32_t out;
4865:.\Include/arm_math.h **** 
4866:.\Include/arm_math.h ****     /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
4867:.\Include/arm_math.h ****     out = (S->A0 * in) +
4868:.\Include/arm_math.h ****       (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
4869:.\Include/arm_math.h **** 
4870:.\Include/arm_math.h ****     /* Update state */
4871:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4872:.\Include/arm_math.h ****     S->state[0] = in;
4873:.\Include/arm_math.h ****     S->state[2] = out;
4874:.\Include/arm_math.h **** 
4875:.\Include/arm_math.h ****     /* return to application */
4876:.\Include/arm_math.h ****     return (out);
4877:.\Include/arm_math.h **** 
4878:.\Include/arm_math.h ****   }
4879:.\Include/arm_math.h **** 
4880:.\Include/arm_math.h ****   /**
4881:.\Include/arm_math.h ****    * @brief  Process function for the Q31 PID Control.
4882:.\Include/arm_math.h ****    * @param[in,out] S  points to an instance of the Q31 PID Control structure
4883:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4884:.\Include/arm_math.h ****    * @return out processed output sample.
4885:.\Include/arm_math.h ****    *
4886:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4887:.\Include/arm_math.h ****    * \par
4888:.\Include/arm_math.h ****    * The function is implemented using an internal 64-bit accumulator.
4889:.\Include/arm_math.h ****    * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplicat
4890:.\Include/arm_math.h ****    * Thus, if the accumulator result overflows it wraps around rather than clip.
4891:.\Include/arm_math.h ****    * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there
4892:.\Include/arm_math.h ****    * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format
4893:.\Include/arm_math.h ****    */
4894:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_pid_q31(
4895:.\Include/arm_math.h ****   arm_pid_instance_q31 * S,
4896:.\Include/arm_math.h ****   q31_t in)
4897:.\Include/arm_math.h ****   {
4898:.\Include/arm_math.h ****     q63_t acc;
4899:.\Include/arm_math.h ****     q31_t out;
4900:.\Include/arm_math.h **** 
4901:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4902:.\Include/arm_math.h ****     acc = (q63_t) S->A0 * in;
4903:.\Include/arm_math.h **** 
4904:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] */
4905:.\Include/arm_math.h ****     acc += (q63_t) S->A1 * S->state[0];
4906:.\Include/arm_math.h **** 
4907:.\Include/arm_math.h ****     /* acc += A2 * x[n-2]  */
4908:.\Include/arm_math.h ****     acc += (q63_t) S->A2 * S->state[1];
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 92


4909:.\Include/arm_math.h **** 
4910:.\Include/arm_math.h ****     /* convert output to 1.31 format to add y[n-1] */
4911:.\Include/arm_math.h ****     out = (q31_t) (acc >> 31u);
4912:.\Include/arm_math.h **** 
4913:.\Include/arm_math.h ****     /* out += y[n-1] */
4914:.\Include/arm_math.h ****     out += S->state[2];
4915:.\Include/arm_math.h **** 
4916:.\Include/arm_math.h ****     /* Update state */
4917:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4918:.\Include/arm_math.h ****     S->state[0] = in;
4919:.\Include/arm_math.h ****     S->state[2] = out;
4920:.\Include/arm_math.h **** 
4921:.\Include/arm_math.h ****     /* return to application */
4922:.\Include/arm_math.h ****     return (out);
4923:.\Include/arm_math.h ****   }
4924:.\Include/arm_math.h **** 
4925:.\Include/arm_math.h **** 
4926:.\Include/arm_math.h ****   /**
4927:.\Include/arm_math.h ****    * @brief  Process function for the Q15 PID Control.
4928:.\Include/arm_math.h ****    * @param[in,out] S   points to an instance of the Q15 PID Control structure
4929:.\Include/arm_math.h ****    * @param[in]     in  input sample to process
4930:.\Include/arm_math.h ****    * @return out processed output sample.
4931:.\Include/arm_math.h ****    *
4932:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4933:.\Include/arm_math.h ****    * \par
4934:.\Include/arm_math.h ****    * The function is implemented using a 64-bit internal accumulator.
4935:.\Include/arm_math.h ****    * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30
4936:.\Include/arm_math.h ****    * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
4937:.\Include/arm_math.h ****    * There is no risk of internal overflow with this approach and the full precision of intermediat
4938:.\Include/arm_math.h ****    * After all additions have been performed, the accumulator is truncated to 34.15 format by disca
4939:.\Include/arm_math.h ****    * Lastly, the accumulator is saturated to yield a result in 1.15 format.
4940:.\Include/arm_math.h ****    */
4941:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_pid_q15(
4942:.\Include/arm_math.h ****   arm_pid_instance_q15 * S,
4943:.\Include/arm_math.h ****   q15_t in)
4944:.\Include/arm_math.h ****   {
4945:.\Include/arm_math.h ****     q63_t acc;
4946:.\Include/arm_math.h ****     q15_t out;
4947:.\Include/arm_math.h **** 
4948:.\Include/arm_math.h **** #if defined (ARM_MATH_DSP)
4949:.\Include/arm_math.h ****     __SIMD32_TYPE *vstate;
4950:.\Include/arm_math.h **** 
4951:.\Include/arm_math.h ****     /* Implementation of PID controller */
4952:.\Include/arm_math.h **** 
4953:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4954:.\Include/arm_math.h ****     acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
4955:.\Include/arm_math.h **** 
4956:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4957:.\Include/arm_math.h ****     vstate = __SIMD32_CONST(S->state);
4958:.\Include/arm_math.h ****     acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
4959:.\Include/arm_math.h **** #else
4960:.\Include/arm_math.h ****     /* acc = A0 * x[n]  */
4961:.\Include/arm_math.h ****     acc = ((q31_t) S->A0) * in;
4962:.\Include/arm_math.h **** 
4963:.\Include/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4964:.\Include/arm_math.h ****     acc += (q31_t) S->A1 * S->state[0];
4965:.\Include/arm_math.h ****     acc += (q31_t) S->A2 * S->state[1];
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 93


4966:.\Include/arm_math.h **** #endif
4967:.\Include/arm_math.h **** 
4968:.\Include/arm_math.h ****     /* acc += y[n-1] */
4969:.\Include/arm_math.h ****     acc += (q31_t) S->state[2] << 15;
4970:.\Include/arm_math.h **** 
4971:.\Include/arm_math.h ****     /* saturate the output */
4972:.\Include/arm_math.h ****     out = (q15_t) (__SSAT((acc >> 15), 16));
4973:.\Include/arm_math.h **** 
4974:.\Include/arm_math.h ****     /* Update state */
4975:.\Include/arm_math.h ****     S->state[1] = S->state[0];
4976:.\Include/arm_math.h ****     S->state[0] = in;
4977:.\Include/arm_math.h ****     S->state[2] = out;
4978:.\Include/arm_math.h **** 
4979:.\Include/arm_math.h ****     /* return to application */
4980:.\Include/arm_math.h ****     return (out);
4981:.\Include/arm_math.h ****   }
4982:.\Include/arm_math.h **** 
4983:.\Include/arm_math.h ****   /**
4984:.\Include/arm_math.h ****    * @} end of PID group
4985:.\Include/arm_math.h ****    */
4986:.\Include/arm_math.h **** 
4987:.\Include/arm_math.h **** 
4988:.\Include/arm_math.h ****   /**
4989:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
4990:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4991:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4992:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4993:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4994:.\Include/arm_math.h ****    */
4995:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f32(
4996:.\Include/arm_math.h ****   const arm_matrix_instance_f32 * src,
4997:.\Include/arm_math.h ****   arm_matrix_instance_f32 * dst);
4998:.\Include/arm_math.h **** 
4999:.\Include/arm_math.h **** 
5000:.\Include/arm_math.h ****   /**
5001:.\Include/arm_math.h ****    * @brief Floating-point matrix inverse.
5002:.\Include/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
5003:.\Include/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
5004:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
5005:.\Include/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
5006:.\Include/arm_math.h ****    */
5007:.\Include/arm_math.h ****   arm_status arm_mat_inverse_f64(
5008:.\Include/arm_math.h ****   const arm_matrix_instance_f64 * src,
5009:.\Include/arm_math.h ****   arm_matrix_instance_f64 * dst);
5010:.\Include/arm_math.h **** 
5011:.\Include/arm_math.h **** 
5012:.\Include/arm_math.h **** 
5013:.\Include/arm_math.h ****   /**
5014:.\Include/arm_math.h ****    * @ingroup groupController
5015:.\Include/arm_math.h ****    */
5016:.\Include/arm_math.h **** 
5017:.\Include/arm_math.h ****   /**
5018:.\Include/arm_math.h ****    * @defgroup clarke Vector Clarke Transform
5019:.\Include/arm_math.h ****    * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time i
5020:.\Include/arm_math.h ****    * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calcula
5021:.\Include/arm_math.h ****    * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
5022:.\Include/arm_math.h ****    * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 94


5023:.\Include/arm_math.h ****    * \image html clarke.gif Stator current space vector and its components in (a,b).
5024:.\Include/arm_math.h ****    * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code
5025:.\Include/arm_math.h ****    * can be calculated using only <code>Ia</code> and <code>Ib</code>.
5026:.\Include/arm_math.h ****    *
5027:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5028:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5029:.\Include/arm_math.h ****    * \par Algorithm
5030:.\Include/arm_math.h ****    * \image html clarkeFormula.gif
5031:.\Include/arm_math.h ****    * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
5032:.\Include/arm_math.h ****    * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
5033:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5034:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5035:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5036:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5037:.\Include/arm_math.h ****    */
5038:.\Include/arm_math.h **** 
5039:.\Include/arm_math.h ****   /**
5040:.\Include/arm_math.h ****    * @addtogroup clarke
5041:.\Include/arm_math.h ****    * @{
5042:.\Include/arm_math.h ****    */
5043:.\Include/arm_math.h **** 
5044:.\Include/arm_math.h ****   /**
5045:.\Include/arm_math.h ****    *
5046:.\Include/arm_math.h ****    * @brief  Floating-point Clarke transform
5047:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5048:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5049:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5050:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5051:.\Include/arm_math.h ****    */
5052:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_f32(
5053:.\Include/arm_math.h ****   float32_t Ia,
5054:.\Include/arm_math.h ****   float32_t Ib,
5055:.\Include/arm_math.h ****   float32_t * pIalpha,
5056:.\Include/arm_math.h ****   float32_t * pIbeta)
5057:.\Include/arm_math.h ****   {
5058:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Ia */
5059:.\Include/arm_math.h ****     *pIalpha = Ia;
5060:.\Include/arm_math.h **** 
5061:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
5062:.\Include/arm_math.h ****     *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
5063:.\Include/arm_math.h ****   }
5064:.\Include/arm_math.h **** 
5065:.\Include/arm_math.h **** 
5066:.\Include/arm_math.h ****   /**
5067:.\Include/arm_math.h ****    * @brief  Clarke transform for Q31 version
5068:.\Include/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5069:.\Include/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5070:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5071:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5072:.\Include/arm_math.h ****    *
5073:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5074:.\Include/arm_math.h ****    * \par
5075:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5076:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5077:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5078:.\Include/arm_math.h ****    */
5079:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_q31(
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 95


5080:.\Include/arm_math.h ****   q31_t Ia,
5081:.\Include/arm_math.h ****   q31_t Ib,
5082:.\Include/arm_math.h ****   q31_t * pIalpha,
5083:.\Include/arm_math.h ****   q31_t * pIbeta)
5084:.\Include/arm_math.h ****   {
5085:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5086:.\Include/arm_math.h **** 
5087:.\Include/arm_math.h ****     /* Calculating pIalpha from Ia by equation pIalpha = Ia */
5088:.\Include/arm_math.h ****     *pIalpha = Ia;
5089:.\Include/arm_math.h **** 
5090:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
5091:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
5092:.\Include/arm_math.h **** 
5093:.\Include/arm_math.h ****     /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
5094:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
5095:.\Include/arm_math.h **** 
5096:.\Include/arm_math.h ****     /* pIbeta is calculated by adding the intermediate products */
5097:.\Include/arm_math.h ****     *pIbeta = __QADD(product1, product2);
5098:.\Include/arm_math.h ****   }
5099:.\Include/arm_math.h **** 
5100:.\Include/arm_math.h ****   /**
5101:.\Include/arm_math.h ****    * @} end of clarke group
5102:.\Include/arm_math.h ****    */
5103:.\Include/arm_math.h **** 
5104:.\Include/arm_math.h ****   /**
5105:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q31 vector.
5106:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5107:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5108:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5109:.\Include/arm_math.h ****    */
5110:.\Include/arm_math.h ****   void arm_q7_to_q31(
5111:.\Include/arm_math.h ****   q7_t * pSrc,
5112:.\Include/arm_math.h ****   q31_t * pDst,
5113:.\Include/arm_math.h ****   uint32_t blockSize);
5114:.\Include/arm_math.h **** 
5115:.\Include/arm_math.h **** 
5116:.\Include/arm_math.h **** 
5117:.\Include/arm_math.h ****   /**
5118:.\Include/arm_math.h ****    * @ingroup groupController
5119:.\Include/arm_math.h ****    */
5120:.\Include/arm_math.h **** 
5121:.\Include/arm_math.h ****   /**
5122:.\Include/arm_math.h ****    * @defgroup inv_clarke Vector Inverse Clarke Transform
5123:.\Include/arm_math.h ****    * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous 
5124:.\Include/arm_math.h ****    *
5125:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5126:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5127:.\Include/arm_math.h ****    * \par Algorithm
5128:.\Include/arm_math.h ****    * \image html clarkeInvFormula.gif
5129:.\Include/arm_math.h ****    * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
5130:.\Include/arm_math.h ****    * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
5131:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5132:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5133:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5134:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5135:.\Include/arm_math.h ****    */
5136:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 96


5137:.\Include/arm_math.h ****   /**
5138:.\Include/arm_math.h ****    * @addtogroup inv_clarke
5139:.\Include/arm_math.h ****    * @{
5140:.\Include/arm_math.h ****    */
5141:.\Include/arm_math.h **** 
5142:.\Include/arm_math.h ****    /**
5143:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Clarke transform
5144:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5145:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5146:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5147:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5148:.\Include/arm_math.h ****    */
5149:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_f32(
5150:.\Include/arm_math.h ****   float32_t Ialpha,
5151:.\Include/arm_math.h ****   float32_t Ibeta,
5152:.\Include/arm_math.h ****   float32_t * pIa,
5153:.\Include/arm_math.h ****   float32_t * pIb)
5154:.\Include/arm_math.h ****   {
5155:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5156:.\Include/arm_math.h ****     *pIa = Ialpha;
5157:.\Include/arm_math.h **** 
5158:.\Include/arm_math.h ****     /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibet
5159:.\Include/arm_math.h ****     *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
5160:.\Include/arm_math.h ****   }
5161:.\Include/arm_math.h **** 
5162:.\Include/arm_math.h **** 
5163:.\Include/arm_math.h ****   /**
5164:.\Include/arm_math.h ****    * @brief  Inverse Clarke transform for Q31 version
5165:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5166:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5167:.\Include/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5168:.\Include/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5169:.\Include/arm_math.h ****    *
5170:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5171:.\Include/arm_math.h ****    * \par
5172:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5173:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5174:.\Include/arm_math.h ****    * There is saturation on the subtraction, hence there is no risk of overflow.
5175:.\Include/arm_math.h ****    */
5176:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_q31(
5177:.\Include/arm_math.h ****   q31_t Ialpha,
5178:.\Include/arm_math.h ****   q31_t Ibeta,
5179:.\Include/arm_math.h ****   q31_t * pIa,
5180:.\Include/arm_math.h ****   q31_t * pIb)
5181:.\Include/arm_math.h ****   {
5182:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5183:.\Include/arm_math.h **** 
5184:.\Include/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5185:.\Include/arm_math.h ****     *pIa = Ialpha;
5186:.\Include/arm_math.h **** 
5187:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
5188:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
5189:.\Include/arm_math.h **** 
5190:.\Include/arm_math.h ****     /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
5191:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
5192:.\Include/arm_math.h **** 
5193:.\Include/arm_math.h ****     /* pIb is calculated by subtracting the products */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 97


5194:.\Include/arm_math.h ****     *pIb = __QSUB(product2, product1);
5195:.\Include/arm_math.h ****   }
5196:.\Include/arm_math.h **** 
5197:.\Include/arm_math.h ****   /**
5198:.\Include/arm_math.h ****    * @} end of inv_clarke group
5199:.\Include/arm_math.h ****    */
5200:.\Include/arm_math.h **** 
5201:.\Include/arm_math.h ****   /**
5202:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q15 vector.
5203:.\Include/arm_math.h ****    * @param[in]  pSrc       input pointer
5204:.\Include/arm_math.h ****    * @param[out] pDst       output pointer
5205:.\Include/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5206:.\Include/arm_math.h ****    */
5207:.\Include/arm_math.h ****   void arm_q7_to_q15(
5208:.\Include/arm_math.h ****   q7_t * pSrc,
5209:.\Include/arm_math.h ****   q15_t * pDst,
5210:.\Include/arm_math.h ****   uint32_t blockSize);
5211:.\Include/arm_math.h **** 
5212:.\Include/arm_math.h **** 
5213:.\Include/arm_math.h **** 
5214:.\Include/arm_math.h ****   /**
5215:.\Include/arm_math.h ****    * @ingroup groupController
5216:.\Include/arm_math.h ****    */
5217:.\Include/arm_math.h **** 
5218:.\Include/arm_math.h ****   /**
5219:.\Include/arm_math.h ****    * @defgroup park Vector Park Transform
5220:.\Include/arm_math.h ****    *
5221:.\Include/arm_math.h ****    * Forward Park transform converts the input two-coordinate vector to flux and torque components.
5222:.\Include/arm_math.h ****    * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and th
5223:.\Include/arm_math.h ****    * from the stationary to the moving reference frame and control the spatial relationship between
5224:.\Include/arm_math.h ****    * the stator vector current and rotor flux vector.
5225:.\Include/arm_math.h ****    * If we consider the d axis aligned with the rotor flux, the diagram below shows the
5226:.\Include/arm_math.h ****    * current vector and the relationship from the two reference frames:
5227:.\Include/arm_math.h ****    * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q ro
5228:.\Include/arm_math.h ****    *
5229:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5230:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5231:.\Include/arm_math.h ****    * \par Algorithm
5232:.\Include/arm_math.h ****    * \image html parkFormula.gif
5233:.\Include/arm_math.h ****    * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
5234:.\Include/arm_math.h ****    * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and 
5235:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5236:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5237:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5238:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5239:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5240:.\Include/arm_math.h ****    */
5241:.\Include/arm_math.h **** 
5242:.\Include/arm_math.h ****   /**
5243:.\Include/arm_math.h ****    * @addtogroup park
5244:.\Include/arm_math.h ****    * @{
5245:.\Include/arm_math.h ****    */
5246:.\Include/arm_math.h **** 
5247:.\Include/arm_math.h ****   /**
5248:.\Include/arm_math.h ****    * @brief Floating-point Park transform
5249:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5250:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 98


5251:.\Include/arm_math.h ****    * @param[out] pId     points to output   rotor reference frame d
5252:.\Include/arm_math.h ****    * @param[out] pIq     points to output   rotor reference frame q
5253:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5254:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5255:.\Include/arm_math.h ****    *
5256:.\Include/arm_math.h ****    * The function implements the forward Park transform.
5257:.\Include/arm_math.h ****    *
5258:.\Include/arm_math.h ****    */
5259:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_f32(
5260:.\Include/arm_math.h ****   float32_t Ialpha,
5261:.\Include/arm_math.h ****   float32_t Ibeta,
5262:.\Include/arm_math.h ****   float32_t * pId,
5263:.\Include/arm_math.h ****   float32_t * pIq,
5264:.\Include/arm_math.h ****   float32_t sinVal,
5265:.\Include/arm_math.h ****   float32_t cosVal)
5266:.\Include/arm_math.h ****   {
5267:.\Include/arm_math.h ****     /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
5268:.\Include/arm_math.h ****     *pId = Ialpha * cosVal + Ibeta * sinVal;
5269:.\Include/arm_math.h **** 
5270:.\Include/arm_math.h ****     /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
5271:.\Include/arm_math.h ****     *pIq = -Ialpha * sinVal + Ibeta * cosVal;
5272:.\Include/arm_math.h ****   }
5273:.\Include/arm_math.h **** 
5274:.\Include/arm_math.h **** 
5275:.\Include/arm_math.h ****   /**
5276:.\Include/arm_math.h ****    * @brief  Park transform for Q31 version
5277:.\Include/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5278:.\Include/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5279:.\Include/arm_math.h ****    * @param[out] pId     points to output rotor reference frame d
5280:.\Include/arm_math.h ****    * @param[out] pIq     points to output rotor reference frame q
5281:.\Include/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5282:.\Include/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5283:.\Include/arm_math.h ****    *
5284:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5285:.\Include/arm_math.h ****    * \par
5286:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5287:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5288:.\Include/arm_math.h ****    * There is saturation on the addition and subtraction, hence there is no risk of overflow.
5289:.\Include/arm_math.h ****    */
5290:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_q31(
5291:.\Include/arm_math.h ****   q31_t Ialpha,
5292:.\Include/arm_math.h ****   q31_t Ibeta,
5293:.\Include/arm_math.h ****   q31_t * pId,
5294:.\Include/arm_math.h ****   q31_t * pIq,
5295:.\Include/arm_math.h ****   q31_t sinVal,
5296:.\Include/arm_math.h ****   q31_t cosVal)
5297:.\Include/arm_math.h ****   {
5298:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5299:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5300:.\Include/arm_math.h **** 
5301:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * cosVal) */
5302:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
5303:.\Include/arm_math.h **** 
5304:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * sinVal) */
5305:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
5306:.\Include/arm_math.h **** 
5307:.\Include/arm_math.h **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 99


5308:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * sinVal) */
5309:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
5310:.\Include/arm_math.h **** 
5311:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * cosVal) */
5312:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
5313:.\Include/arm_math.h **** 
5314:.\Include/arm_math.h ****     /* Calculate pId by adding the two intermediate products 1 and 2 */
5315:.\Include/arm_math.h ****     *pId = __QADD(product1, product2);
5316:.\Include/arm_math.h **** 
5317:.\Include/arm_math.h ****     /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
5318:.\Include/arm_math.h ****     *pIq = __QSUB(product4, product3);
5319:.\Include/arm_math.h ****   }
5320:.\Include/arm_math.h **** 
5321:.\Include/arm_math.h ****   /**
5322:.\Include/arm_math.h ****    * @} end of park group
5323:.\Include/arm_math.h ****    */
5324:.\Include/arm_math.h **** 
5325:.\Include/arm_math.h ****   /**
5326:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to floating-point vector.
5327:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5328:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5329:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5330:.\Include/arm_math.h ****    */
5331:.\Include/arm_math.h ****   void arm_q7_to_float(
5332:.\Include/arm_math.h ****   q7_t * pSrc,
5333:.\Include/arm_math.h ****   float32_t * pDst,
5334:.\Include/arm_math.h ****   uint32_t blockSize);
5335:.\Include/arm_math.h **** 
5336:.\Include/arm_math.h **** 
5337:.\Include/arm_math.h ****   /**
5338:.\Include/arm_math.h ****    * @ingroup groupController
5339:.\Include/arm_math.h ****    */
5340:.\Include/arm_math.h **** 
5341:.\Include/arm_math.h ****   /**
5342:.\Include/arm_math.h ****    * @defgroup inv_park Vector Inverse Park transform
5343:.\Include/arm_math.h ****    * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
5344:.\Include/arm_math.h ****    *
5345:.\Include/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5346:.\Include/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5347:.\Include/arm_math.h ****    * \par Algorithm
5348:.\Include/arm_math.h ****    * \image html parkInvFormula.gif
5349:.\Include/arm_math.h ****    * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
5350:.\Include/arm_math.h ****    * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <c
5351:.\Include/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5352:.\Include/arm_math.h ****    * \par Fixed-Point Behavior
5353:.\Include/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5354:.\Include/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5355:.\Include/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5356:.\Include/arm_math.h ****    */
5357:.\Include/arm_math.h **** 
5358:.\Include/arm_math.h ****   /**
5359:.\Include/arm_math.h ****    * @addtogroup inv_park
5360:.\Include/arm_math.h ****    * @{
5361:.\Include/arm_math.h ****    */
5362:.\Include/arm_math.h **** 
5363:.\Include/arm_math.h ****    /**
5364:.\Include/arm_math.h ****    * @brief  Floating-point Inverse Park transform
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 100


5365:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5366:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5367:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5368:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5369:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5370:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5371:.\Include/arm_math.h ****    */
5372:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_f32(
5373:.\Include/arm_math.h ****   float32_t Id,
5374:.\Include/arm_math.h ****   float32_t Iq,
5375:.\Include/arm_math.h ****   float32_t * pIalpha,
5376:.\Include/arm_math.h ****   float32_t * pIbeta,
5377:.\Include/arm_math.h ****   float32_t sinVal,
5378:.\Include/arm_math.h ****   float32_t cosVal)
5379:.\Include/arm_math.h ****   {
5380:.\Include/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
5381:.\Include/arm_math.h ****     *pIalpha = Id * cosVal - Iq * sinVal;
5382:.\Include/arm_math.h **** 
5383:.\Include/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
5384:.\Include/arm_math.h ****     *pIbeta = Id * sinVal + Iq * cosVal;
5385:.\Include/arm_math.h ****   }
5386:.\Include/arm_math.h **** 
5387:.\Include/arm_math.h **** 
5388:.\Include/arm_math.h ****   /**
5389:.\Include/arm_math.h ****    * @brief  Inverse Park transform for   Q31 version
5390:.\Include/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5391:.\Include/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5392:.\Include/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5393:.\Include/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5394:.\Include/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5395:.\Include/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5396:.\Include/arm_math.h ****    *
5397:.\Include/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5398:.\Include/arm_math.h ****    * \par
5399:.\Include/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5400:.\Include/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5401:.\Include/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5402:.\Include/arm_math.h ****    */
5403:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_q31(
5404:.\Include/arm_math.h ****   q31_t Id,
5405:.\Include/arm_math.h ****   q31_t Iq,
5406:.\Include/arm_math.h ****   q31_t * pIalpha,
5407:.\Include/arm_math.h ****   q31_t * pIbeta,
5408:.\Include/arm_math.h ****   q31_t sinVal,
5409:.\Include/arm_math.h ****   q31_t cosVal)
5410:.\Include/arm_math.h ****   {
5411:.\Include/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5412:.\Include/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5413:.\Include/arm_math.h **** 
5414:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * cosVal) */
5415:.\Include/arm_math.h ****     product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
5416:.\Include/arm_math.h **** 
5417:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * sinVal) */
5418:.\Include/arm_math.h ****     product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
5419:.\Include/arm_math.h **** 
5420:.\Include/arm_math.h **** 
5421:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Id * sinVal) */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 101


5422:.\Include/arm_math.h ****     product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
5423:.\Include/arm_math.h **** 
5424:.\Include/arm_math.h ****     /* Intermediate product is calculated by (Iq * cosVal) */
5425:.\Include/arm_math.h ****     product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
5426:.\Include/arm_math.h **** 
5427:.\Include/arm_math.h ****     /* Calculate pIalpha by using the two intermediate products 1 and 2 */
5428:.\Include/arm_math.h ****     *pIalpha = __QSUB(product1, product2);
5429:.\Include/arm_math.h **** 
5430:.\Include/arm_math.h ****     /* Calculate pIbeta by using the two intermediate products 3 and 4 */
5431:.\Include/arm_math.h ****     *pIbeta = __QADD(product4, product3);
5432:.\Include/arm_math.h ****   }
5433:.\Include/arm_math.h **** 
5434:.\Include/arm_math.h ****   /**
5435:.\Include/arm_math.h ****    * @} end of Inverse park group
5436:.\Include/arm_math.h ****    */
5437:.\Include/arm_math.h **** 
5438:.\Include/arm_math.h **** 
5439:.\Include/arm_math.h ****   /**
5440:.\Include/arm_math.h ****    * @brief  Converts the elements of the Q31 vector to floating-point vector.
5441:.\Include/arm_math.h ****    * @param[in]  pSrc       is input pointer
5442:.\Include/arm_math.h ****    * @param[out] pDst       is output pointer
5443:.\Include/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5444:.\Include/arm_math.h ****    */
5445:.\Include/arm_math.h ****   void arm_q31_to_float(
5446:.\Include/arm_math.h ****   q31_t * pSrc,
5447:.\Include/arm_math.h ****   float32_t * pDst,
5448:.\Include/arm_math.h ****   uint32_t blockSize);
5449:.\Include/arm_math.h **** 
5450:.\Include/arm_math.h ****   /**
5451:.\Include/arm_math.h ****    * @ingroup groupInterpolation
5452:.\Include/arm_math.h ****    */
5453:.\Include/arm_math.h **** 
5454:.\Include/arm_math.h ****   /**
5455:.\Include/arm_math.h ****    * @defgroup LinearInterpolate Linear Interpolation
5456:.\Include/arm_math.h ****    *
5457:.\Include/arm_math.h ****    * Linear interpolation is a method of curve fitting using linear polynomials.
5458:.\Include/arm_math.h ****    * Linear interpolation works by effectively drawing a straight line between two neighboring samp
5459:.\Include/arm_math.h ****    *
5460:.\Include/arm_math.h ****    * \par
5461:.\Include/arm_math.h ****    * \image html LinearInterp.gif "Linear interpolation"
5462:.\Include/arm_math.h ****    *
5463:.\Include/arm_math.h ****    * \par
5464:.\Include/arm_math.h ****    * A  Linear Interpolate function calculates an output value(y), for the input(x)
5465:.\Include/arm_math.h ****    * using linear interpolation of the input values x0, x1( nearest input values) and the output va
5466:.\Include/arm_math.h ****    *
5467:.\Include/arm_math.h ****    * \par Algorithm:
5468:.\Include/arm_math.h ****    * <pre>
5469:.\Include/arm_math.h ****    *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
5470:.\Include/arm_math.h ****    *       where x0, x1 are nearest values of input x
5471:.\Include/arm_math.h ****    *             y0, y1 are nearest values to output y
5472:.\Include/arm_math.h ****    * </pre>
5473:.\Include/arm_math.h ****    *
5474:.\Include/arm_math.h ****    * \par
5475:.\Include/arm_math.h ****    * This set of functions implements Linear interpolation process
5476:.\Include/arm_math.h ****    * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
5477:.\Include/arm_math.h ****    * sample of data and each call to the function returns a single processed value.
5478:.\Include/arm_math.h ****    * <code>S</code> points to an instance of the Linear Interpolate function data structure.
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 102


5479:.\Include/arm_math.h ****    * <code>x</code> is the input sample value. The functions returns the output value.
5480:.\Include/arm_math.h ****    *
5481:.\Include/arm_math.h ****    * \par
5482:.\Include/arm_math.h ****    * if x is outside of the table boundary, Linear interpolation returns first value of the table
5483:.\Include/arm_math.h ****    * if x is below input range and returns last value of table if x is above range.
5484:.\Include/arm_math.h ****    */
5485:.\Include/arm_math.h **** 
5486:.\Include/arm_math.h ****   /**
5487:.\Include/arm_math.h ****    * @addtogroup LinearInterpolate
5488:.\Include/arm_math.h ****    * @{
5489:.\Include/arm_math.h ****    */
5490:.\Include/arm_math.h **** 
5491:.\Include/arm_math.h ****   /**
5492:.\Include/arm_math.h ****    * @brief  Process function for the floating-point Linear Interpolation Function.
5493:.\Include/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
5494:.\Include/arm_math.h ****    * @param[in]     x  input sample to process
5495:.\Include/arm_math.h ****    * @return y processed output sample.
5496:.\Include/arm_math.h ****    *
5497:.\Include/arm_math.h ****    */
5498:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_linear_interp_f32(
5499:.\Include/arm_math.h ****   arm_linear_interp_instance_f32 * S,
5500:.\Include/arm_math.h ****   float32_t x)
5501:.\Include/arm_math.h ****   {
5502:.\Include/arm_math.h ****     float32_t y;
5503:.\Include/arm_math.h ****     float32_t x0, x1;                            /* Nearest input values */
5504:.\Include/arm_math.h ****     float32_t y0, y1;                            /* Nearest output values */
5505:.\Include/arm_math.h ****     float32_t xSpacing = S->xSpacing;            /* spacing between input values */
5506:.\Include/arm_math.h ****     int32_t i;                                   /* Index variable */
5507:.\Include/arm_math.h ****     float32_t *pYData = S->pYData;               /* pointer to output table */
5508:.\Include/arm_math.h **** 
5509:.\Include/arm_math.h ****     /* Calculation of index */
5510:.\Include/arm_math.h ****     i = (int32_t) ((x - S->x1) / xSpacing);
5511:.\Include/arm_math.h **** 
5512:.\Include/arm_math.h ****     if (i < 0)
5513:.\Include/arm_math.h ****     {
5514:.\Include/arm_math.h ****       /* Iniatilize output for below specified range as least output value of table */
5515:.\Include/arm_math.h ****       y = pYData[0];
5516:.\Include/arm_math.h ****     }
5517:.\Include/arm_math.h ****     else if ((uint32_t)i >= S->nValues)
5518:.\Include/arm_math.h ****     {
5519:.\Include/arm_math.h ****       /* Iniatilize output for above specified range as last output value of table */
5520:.\Include/arm_math.h ****       y = pYData[S->nValues - 1];
5521:.\Include/arm_math.h ****     }
5522:.\Include/arm_math.h ****     else
5523:.\Include/arm_math.h ****     {
5524:.\Include/arm_math.h ****       /* Calculation of nearest input values */
5525:.\Include/arm_math.h ****       x0 = S->x1 +  i      * xSpacing;
5526:.\Include/arm_math.h ****       x1 = S->x1 + (i + 1) * xSpacing;
5527:.\Include/arm_math.h **** 
5528:.\Include/arm_math.h ****       /* Read of nearest output values */
5529:.\Include/arm_math.h ****       y0 = pYData[i];
5530:.\Include/arm_math.h ****       y1 = pYData[i + 1];
5531:.\Include/arm_math.h **** 
5532:.\Include/arm_math.h ****       /* Calculation of output */
5533:.\Include/arm_math.h ****       y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
5534:.\Include/arm_math.h **** 
5535:.\Include/arm_math.h ****     }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 103


5536:.\Include/arm_math.h **** 
5537:.\Include/arm_math.h ****     /* returns output value */
5538:.\Include/arm_math.h ****     return (y);
5539:.\Include/arm_math.h ****   }
5540:.\Include/arm_math.h **** 
5541:.\Include/arm_math.h **** 
5542:.\Include/arm_math.h ****    /**
5543:.\Include/arm_math.h ****    *
5544:.\Include/arm_math.h ****    * @brief  Process function for the Q31 Linear Interpolation Function.
5545:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q31 Linear Interpolation table
5546:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5547:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5548:.\Include/arm_math.h ****    * @return y processed output sample.
5549:.\Include/arm_math.h ****    *
5550:.\Include/arm_math.h ****    * \par
5551:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5552:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5553:.\Include/arm_math.h ****    *
5554:.\Include/arm_math.h ****    */
5555:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_linear_interp_q31(
5556:.\Include/arm_math.h ****   q31_t * pYData,
5557:.\Include/arm_math.h ****   q31_t x,
5558:.\Include/arm_math.h ****   uint32_t nValues)
5559:.\Include/arm_math.h ****   {
5560:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5561:.\Include/arm_math.h ****     q31_t y0, y1;                                /* Nearest output values */
5562:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5563:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5564:.\Include/arm_math.h **** 
5565:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5566:.\Include/arm_math.h ****     /* 12 bits for the table index */
5567:.\Include/arm_math.h ****     /* Index value calculation */
5568:.\Include/arm_math.h ****     index = ((x & (q31_t)0xFFF00000) >> 20);
5569:.\Include/arm_math.h **** 
5570:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5571:.\Include/arm_math.h ****     {
5572:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5573:.\Include/arm_math.h ****     }
5574:.\Include/arm_math.h ****     else if (index < 0)
5575:.\Include/arm_math.h ****     {
5576:.\Include/arm_math.h ****       return (pYData[0]);
5577:.\Include/arm_math.h ****     }
5578:.\Include/arm_math.h ****     else
5579:.\Include/arm_math.h ****     {
5580:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5581:.\Include/arm_math.h ****       /* shift left by 11 to keep fract in 1.31 format */
5582:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF) << 11;
5583:.\Include/arm_math.h **** 
5584:.\Include/arm_math.h ****       /* Read two nearest output values from the index in 1.31(q31) format */
5585:.\Include/arm_math.h ****       y0 = pYData[index];
5586:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5587:.\Include/arm_math.h **** 
5588:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 2.30 format */
5589:.\Include/arm_math.h ****       y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
5590:.\Include/arm_math.h **** 
5591:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
5592:.\Include/arm_math.h ****       y += ((q31_t) (((q63_t) y1 * fract) >> 32));
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 104


5593:.\Include/arm_math.h **** 
5594:.\Include/arm_math.h ****       /* Convert y to 1.31 format */
5595:.\Include/arm_math.h ****       return (y << 1u);
5596:.\Include/arm_math.h ****     }
5597:.\Include/arm_math.h ****   }
5598:.\Include/arm_math.h **** 
5599:.\Include/arm_math.h **** 
5600:.\Include/arm_math.h ****   /**
5601:.\Include/arm_math.h ****    *
5602:.\Include/arm_math.h ****    * @brief  Process function for the Q15 Linear Interpolation Function.
5603:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q15 Linear Interpolation table
5604:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5605:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5606:.\Include/arm_math.h ****    * @return y processed output sample.
5607:.\Include/arm_math.h ****    *
5608:.\Include/arm_math.h ****    * \par
5609:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5610:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5611:.\Include/arm_math.h ****    *
5612:.\Include/arm_math.h ****    */
5613:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_linear_interp_q15(
5614:.\Include/arm_math.h ****   q15_t * pYData,
5615:.\Include/arm_math.h ****   q31_t x,
5616:.\Include/arm_math.h ****   uint32_t nValues)
5617:.\Include/arm_math.h ****   {
5618:.\Include/arm_math.h ****     q63_t y;                                     /* output */
5619:.\Include/arm_math.h ****     q15_t y0, y1;                                /* Nearest output values */
5620:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5621:.\Include/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5622:.\Include/arm_math.h **** 
5623:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5624:.\Include/arm_math.h ****     /* 12 bits for the table index */
5625:.\Include/arm_math.h ****     /* Index value calculation */
5626:.\Include/arm_math.h ****     index = ((x & (int32_t)0xFFF00000) >> 20);
5627:.\Include/arm_math.h **** 
5628:.\Include/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5629:.\Include/arm_math.h ****     {
5630:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5631:.\Include/arm_math.h ****     }
5632:.\Include/arm_math.h ****     else if (index < 0)
5633:.\Include/arm_math.h ****     {
5634:.\Include/arm_math.h ****       return (pYData[0]);
5635:.\Include/arm_math.h ****     }
5636:.\Include/arm_math.h ****     else
5637:.\Include/arm_math.h ****     {
5638:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5639:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5640:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5641:.\Include/arm_math.h **** 
5642:.\Include/arm_math.h ****       /* Read two nearest output values from the index */
5643:.\Include/arm_math.h ****       y0 = pYData[index];
5644:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5645:.\Include/arm_math.h **** 
5646:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 13.35 format */
5647:.\Include/arm_math.h ****       y = ((q63_t) y0 * (0xFFFFF - fract));
5648:.\Include/arm_math.h **** 
5649:.\Include/arm_math.h ****       /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 105


5650:.\Include/arm_math.h ****       y += ((q63_t) y1 * (fract));
5651:.\Include/arm_math.h **** 
5652:.\Include/arm_math.h ****       /* convert y to 1.15 format */
5653:.\Include/arm_math.h ****       return (q15_t) (y >> 20);
5654:.\Include/arm_math.h ****     }
5655:.\Include/arm_math.h ****   }
5656:.\Include/arm_math.h **** 
5657:.\Include/arm_math.h **** 
5658:.\Include/arm_math.h ****   /**
5659:.\Include/arm_math.h ****    *
5660:.\Include/arm_math.h ****    * @brief  Process function for the Q7 Linear Interpolation Function.
5661:.\Include/arm_math.h ****    * @param[in] pYData   pointer to Q7 Linear Interpolation table
5662:.\Include/arm_math.h ****    * @param[in] x        input sample to process
5663:.\Include/arm_math.h ****    * @param[in] nValues  number of table values
5664:.\Include/arm_math.h ****    * @return y processed output sample.
5665:.\Include/arm_math.h ****    *
5666:.\Include/arm_math.h ****    * \par
5667:.\Include/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5668:.\Include/arm_math.h ****    * This function can support maximum of table size 2^12.
5669:.\Include/arm_math.h ****    */
5670:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t arm_linear_interp_q7(
5671:.\Include/arm_math.h ****   q7_t * pYData,
5672:.\Include/arm_math.h ****   q31_t x,
5673:.\Include/arm_math.h ****   uint32_t nValues)
5674:.\Include/arm_math.h ****   {
5675:.\Include/arm_math.h ****     q31_t y;                                     /* output */
5676:.\Include/arm_math.h ****     q7_t y0, y1;                                 /* Nearest output values */
5677:.\Include/arm_math.h ****     q31_t fract;                                 /* fractional part */
5678:.\Include/arm_math.h ****     uint32_t index;                              /* Index to read nearest output values */
5679:.\Include/arm_math.h **** 
5680:.\Include/arm_math.h ****     /* Input is in 12.20 format */
5681:.\Include/arm_math.h ****     /* 12 bits for the table index */
5682:.\Include/arm_math.h ****     /* Index value calculation */
5683:.\Include/arm_math.h ****     if (x < 0)
5684:.\Include/arm_math.h ****     {
5685:.\Include/arm_math.h ****       return (pYData[0]);
5686:.\Include/arm_math.h ****     }
5687:.\Include/arm_math.h ****     index = (x >> 20) & 0xfff;
5688:.\Include/arm_math.h **** 
5689:.\Include/arm_math.h ****     if (index >= (nValues - 1))
5690:.\Include/arm_math.h ****     {
5691:.\Include/arm_math.h ****       return (pYData[nValues - 1]);
5692:.\Include/arm_math.h ****     }
5693:.\Include/arm_math.h ****     else
5694:.\Include/arm_math.h ****     {
5695:.\Include/arm_math.h ****       /* 20 bits for the fractional part */
5696:.\Include/arm_math.h ****       /* fract is in 12.20 format */
5697:.\Include/arm_math.h ****       fract = (x & 0x000FFFFF);
5698:.\Include/arm_math.h **** 
5699:.\Include/arm_math.h ****       /* Read two nearest output values from the index and are in 1.7(q7) format */
5700:.\Include/arm_math.h ****       y0 = pYData[index];
5701:.\Include/arm_math.h ****       y1 = pYData[index + 1];
5702:.\Include/arm_math.h **** 
5703:.\Include/arm_math.h ****       /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
5704:.\Include/arm_math.h ****       y = ((y0 * (0xFFFFF - fract)));
5705:.\Include/arm_math.h **** 
5706:.\Include/arm_math.h ****       /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 106


5707:.\Include/arm_math.h ****       y += (y1 * fract);
5708:.\Include/arm_math.h **** 
5709:.\Include/arm_math.h ****       /* convert y to 1.7(q7) format */
5710:.\Include/arm_math.h ****       return (q7_t) (y >> 20);
5711:.\Include/arm_math.h ****      }
5712:.\Include/arm_math.h ****   }
5713:.\Include/arm_math.h **** 
5714:.\Include/arm_math.h ****   /**
5715:.\Include/arm_math.h ****    * @} end of LinearInterpolate group
5716:.\Include/arm_math.h ****    */
5717:.\Include/arm_math.h **** 
5718:.\Include/arm_math.h ****   /**
5719:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for floating-point data.
5720:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5721:.\Include/arm_math.h ****    * @return  sin(x).
5722:.\Include/arm_math.h ****    */
5723:.\Include/arm_math.h ****   float32_t arm_sin_f32(
5724:.\Include/arm_math.h ****   float32_t x);
5725:.\Include/arm_math.h **** 
5726:.\Include/arm_math.h **** 
5727:.\Include/arm_math.h ****   /**
5728:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q31 data.
5729:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5730:.\Include/arm_math.h ****    * @return  sin(x).
5731:.\Include/arm_math.h ****    */
5732:.\Include/arm_math.h ****   q31_t arm_sin_q31(
5733:.\Include/arm_math.h ****   q31_t x);
5734:.\Include/arm_math.h **** 
5735:.\Include/arm_math.h **** 
5736:.\Include/arm_math.h ****   /**
5737:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q15 data.
5738:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5739:.\Include/arm_math.h ****    * @return  sin(x).
5740:.\Include/arm_math.h ****    */
5741:.\Include/arm_math.h ****   q15_t arm_sin_q15(
5742:.\Include/arm_math.h ****   q15_t x);
5743:.\Include/arm_math.h **** 
5744:.\Include/arm_math.h **** 
5745:.\Include/arm_math.h ****   /**
5746:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
5747:.\Include/arm_math.h ****    * @param[in] x  input value in radians.
5748:.\Include/arm_math.h ****    * @return  cos(x).
5749:.\Include/arm_math.h ****    */
5750:.\Include/arm_math.h ****   float32_t arm_cos_f32(
5751:.\Include/arm_math.h ****   float32_t x);
5752:.\Include/arm_math.h **** 
5753:.\Include/arm_math.h **** 
5754:.\Include/arm_math.h ****   /**
5755:.\Include/arm_math.h ****    * @brief Fast approximation to the trigonometric cosine function for Q31 data.
5756:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5757:.\Include/arm_math.h ****    * @return  cos(x).
5758:.\Include/arm_math.h ****    */
5759:.\Include/arm_math.h ****   q31_t arm_cos_q31(
5760:.\Include/arm_math.h ****   q31_t x);
5761:.\Include/arm_math.h **** 
5762:.\Include/arm_math.h **** 
5763:.\Include/arm_math.h ****   /**
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 107


5764:.\Include/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
5765:.\Include/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5766:.\Include/arm_math.h ****    * @return  cos(x).
5767:.\Include/arm_math.h ****    */
5768:.\Include/arm_math.h ****   q15_t arm_cos_q15(
5769:.\Include/arm_math.h ****   q15_t x);
5770:.\Include/arm_math.h **** 
5771:.\Include/arm_math.h **** 
5772:.\Include/arm_math.h ****   /**
5773:.\Include/arm_math.h ****    * @ingroup groupFastMath
5774:.\Include/arm_math.h ****    */
5775:.\Include/arm_math.h **** 
5776:.\Include/arm_math.h **** 
5777:.\Include/arm_math.h ****   /**
5778:.\Include/arm_math.h ****    * @defgroup SQRT Square Root
5779:.\Include/arm_math.h ****    *
5780:.\Include/arm_math.h ****    * Computes the square root of a number.
5781:.\Include/arm_math.h ****    * There are separate functions for Q15, Q31, and floating-point data types.
5782:.\Include/arm_math.h ****    * The square root function is computed using the Newton-Raphson algorithm.
5783:.\Include/arm_math.h ****    * This is an iterative algorithm of the form:
5784:.\Include/arm_math.h ****    * <pre>
5785:.\Include/arm_math.h ****    *      x1 = x0 - f(x0)/f'(x0)
5786:.\Include/arm_math.h ****    * </pre>
5787:.\Include/arm_math.h ****    * where <code>x1</code> is the current estimate,
5788:.\Include/arm_math.h ****    * <code>x0</code> is the previous estimate, and
5789:.\Include/arm_math.h ****    * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
5790:.\Include/arm_math.h ****    * For the square root function, the algorithm reduces to:
5791:.\Include/arm_math.h ****    * <pre>
5792:.\Include/arm_math.h ****    *     x0 = in/2                         [initial guess]
5793:.\Include/arm_math.h ****    *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
5794:.\Include/arm_math.h ****    * </pre>
5795:.\Include/arm_math.h ****    */
5796:.\Include/arm_math.h **** 
5797:.\Include/arm_math.h **** 
5798:.\Include/arm_math.h ****   /**
5799:.\Include/arm_math.h ****    * @addtogroup SQRT
5800:.\Include/arm_math.h ****    * @{
5801:.\Include/arm_math.h ****    */
5802:.\Include/arm_math.h **** 
5803:.\Include/arm_math.h ****   /**
5804:.\Include/arm_math.h ****    * @brief  Floating-point square root function.
5805:.\Include/arm_math.h ****    * @param[in]  in    input value.
5806:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5807:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5808:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5809:.\Include/arm_math.h ****    */
5810:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
5811:.\Include/arm_math.h ****   float32_t in,
5812:.\Include/arm_math.h ****   float32_t * pOut)
5813:.\Include/arm_math.h ****   {
5814:.\Include/arm_math.h ****     if (in >= 0.0f)
5815:.\Include/arm_math.h ****     {
5816:.\Include/arm_math.h **** 
5817:.\Include/arm_math.h **** #if   (__FPU_USED == 1) && defined ( __CC_ARM   )
5818:.\Include/arm_math.h ****       *pOut = __sqrtf(in);
5819:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
5820:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 108


5821:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined(__GNUC__)
5822:.\Include/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5823:.\Include/arm_math.h **** #elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
5824:.\Include/arm_math.h ****       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
5825:.\Include/arm_math.h **** #else
5826:.\Include/arm_math.h ****       *pOut = sqrtf(in);
5827:.\Include/arm_math.h **** #endif
5828:.\Include/arm_math.h **** 
5829:.\Include/arm_math.h ****       return (ARM_MATH_SUCCESS);
5830:.\Include/arm_math.h ****     }
5831:.\Include/arm_math.h ****     else
5832:.\Include/arm_math.h ****     {
5833:.\Include/arm_math.h ****       *pOut = 0.0f;
5834:.\Include/arm_math.h ****       return (ARM_MATH_ARGUMENT_ERROR);
5835:.\Include/arm_math.h ****     }
5836:.\Include/arm_math.h ****   }
5837:.\Include/arm_math.h **** 
5838:.\Include/arm_math.h **** 
5839:.\Include/arm_math.h ****   /**
5840:.\Include/arm_math.h ****    * @brief Q31 square root function.
5841:.\Include/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFF
5842:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5843:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5844:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5845:.\Include/arm_math.h ****    */
5846:.\Include/arm_math.h ****   arm_status arm_sqrt_q31(
5847:.\Include/arm_math.h ****   q31_t in,
5848:.\Include/arm_math.h ****   q31_t * pOut);
5849:.\Include/arm_math.h **** 
5850:.\Include/arm_math.h **** 
5851:.\Include/arm_math.h ****   /**
5852:.\Include/arm_math.h ****    * @brief  Q15 square root function.
5853:.\Include/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
5854:.\Include/arm_math.h ****    * @param[out] pOut  square root of input value.
5855:.\Include/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5856:.\Include/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5857:.\Include/arm_math.h ****    */
5858:.\Include/arm_math.h ****   arm_status arm_sqrt_q15(
5859:.\Include/arm_math.h ****   q15_t in,
5860:.\Include/arm_math.h ****   q15_t * pOut);
5861:.\Include/arm_math.h **** 
5862:.\Include/arm_math.h ****   /**
5863:.\Include/arm_math.h ****    * @} end of SQRT group
5864:.\Include/arm_math.h ****    */
5865:.\Include/arm_math.h **** 
5866:.\Include/arm_math.h **** 
5867:.\Include/arm_math.h ****   /**
5868:.\Include/arm_math.h ****    * @brief floating-point Circular write function.
5869:.\Include/arm_math.h ****    */
5870:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_f32(
5871:.\Include/arm_math.h ****   int32_t * circBuffer,
5872:.\Include/arm_math.h ****   int32_t L,
5873:.\Include/arm_math.h ****   uint16_t * writeOffset,
5874:.\Include/arm_math.h ****   int32_t bufferInc,
5875:.\Include/arm_math.h ****   const int32_t * src,
5876:.\Include/arm_math.h ****   int32_t srcInc,
5877:.\Include/arm_math.h ****   uint32_t blockSize)
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 109


5878:.\Include/arm_math.h ****   {
5879:.\Include/arm_math.h ****     uint32_t i = 0u;
 143              		.loc 2 5879 0
 144 00be 0023     		mov	r3, #0
 145 00c0 A822     		mov	r2, #168
 146 00c2 BA18     		add	r2, r7, r2
 147 00c4 1360     		str	r3, [r2]
5880:.\Include/arm_math.h ****     int32_t wOffset;
5881:.\Include/arm_math.h **** 
5882:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5883:.\Include/arm_math.h ****      * to the current location where the input samples to be copied */
5884:.\Include/arm_math.h ****     wOffset = *writeOffset;
 148              		.loc 2 5884 0
 149 00c6 BC23     		mov	r3, #188
 150 00c8 FB18     		add	r3, r7, r3
 151 00ca 1B68     		ldr	r3, [r3]
 152 00cc 1B88     		ldrh	r3, [r3]
 153 00ce A422     		mov	r2, #164
 154 00d0 BA18     		add	r2, r7, r2
 155 00d2 1360     		str	r3, [r2]
5885:.\Include/arm_math.h **** 
5886:.\Include/arm_math.h ****     /* Loop over the blockSize */
5887:.\Include/arm_math.h ****     i = blockSize;
 156              		.loc 2 5887 0
 157 00d4 AC23     		mov	r3, #172
 158 00d6 FB18     		add	r3, r7, r3
 159 00d8 1B68     		ldr	r3, [r3]
 160 00da A822     		mov	r2, #168
 161 00dc BA18     		add	r2, r7, r2
 162 00de 1360     		str	r3, [r2]
 163 00e0 3AE0     		b	.L2
 164              	.L4:
5888:.\Include/arm_math.h **** 
5889:.\Include/arm_math.h ****     while (i > 0u)
5890:.\Include/arm_math.h ****     {
5891:.\Include/arm_math.h ****       /* copy the input sample to the circular buffer */
5892:.\Include/arm_math.h ****       circBuffer[wOffset] = *src;
 165              		.loc 2 5892 0
 166 00e2 A423     		mov	r3, #164
 167 00e4 FB18     		add	r3, r7, r3
 168 00e6 1B68     		ldr	r3, [r3]
 169 00e8 9B00     		lsl	r3, r3, #2
 170 00ea C422     		mov	r2, #196
 171 00ec BA18     		add	r2, r7, r2
 172 00ee 1268     		ldr	r2, [r2]
 173 00f0 D318     		add	r3, r2, r3
 174 00f2 B422     		mov	r2, #180
 175 00f4 BA18     		add	r2, r7, r2
 176 00f6 1268     		ldr	r2, [r2]
 177 00f8 1268     		ldr	r2, [r2]
 178 00fa 1A60     		str	r2, [r3]
5893:.\Include/arm_math.h **** 
5894:.\Include/arm_math.h ****       /* Update the input pointer */
5895:.\Include/arm_math.h ****       src += srcInc;
 179              		.loc 2 5895 0
 180 00fc B023     		mov	r3, #176
 181 00fe FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 110


 182 0100 1B68     		ldr	r3, [r3]
 183 0102 9B00     		lsl	r3, r3, #2
 184 0104 B422     		mov	r2, #180
 185 0106 BA18     		add	r2, r7, r2
 186 0108 1268     		ldr	r2, [r2]
 187 010a D318     		add	r3, r2, r3
 188 010c B422     		mov	r2, #180
 189 010e BA18     		add	r2, r7, r2
 190 0110 1360     		str	r3, [r2]
5896:.\Include/arm_math.h **** 
5897:.\Include/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
5898:.\Include/arm_math.h ****       wOffset += bufferInc;
 191              		.loc 2 5898 0
 192 0112 A423     		mov	r3, #164
 193 0114 FB18     		add	r3, r7, r3
 194 0116 1A68     		ldr	r2, [r3]
 195 0118 B823     		mov	r3, #184
 196 011a FB18     		add	r3, r7, r3
 197 011c 1B68     		ldr	r3, [r3]
 198 011e D318     		add	r3, r2, r3
 199 0120 A422     		mov	r2, #164
 200 0122 BA18     		add	r2, r7, r2
 201 0124 1360     		str	r3, [r2]
5899:.\Include/arm_math.h ****       if (wOffset >= L)
 202              		.loc 2 5899 0
 203 0126 C023     		mov	r3, #192
 204 0128 FB18     		add	r3, r7, r3
 205 012a 1A68     		ldr	r2, [r3]
 206 012c A423     		mov	r3, #164
 207 012e FB18     		add	r3, r7, r3
 208 0130 1B68     		ldr	r3, [r3]
 209 0132 9A42     		cmp	r2, r3
 210 0134 09DC     		bgt	.L3
5900:.\Include/arm_math.h ****         wOffset -= L;
 211              		.loc 2 5900 0
 212 0136 A423     		mov	r3, #164
 213 0138 FB18     		add	r3, r7, r3
 214 013a 1A68     		ldr	r2, [r3]
 215 013c C023     		mov	r3, #192
 216 013e FB18     		add	r3, r7, r3
 217 0140 1B68     		ldr	r3, [r3]
 218 0142 D31A     		sub	r3, r2, r3
 219 0144 A422     		mov	r2, #164
 220 0146 BA18     		add	r2, r7, r2
 221 0148 1360     		str	r3, [r2]
 222              	.L3:
5901:.\Include/arm_math.h **** 
5902:.\Include/arm_math.h ****       /* Decrement the loop counter */
5903:.\Include/arm_math.h ****       i--;
 223              		.loc 2 5903 0
 224 014a A823     		mov	r3, #168
 225 014c FB18     		add	r3, r7, r3
 226 014e 1B68     		ldr	r3, [r3]
 227 0150 013B     		sub	r3, r3, #1
 228 0152 A822     		mov	r2, #168
 229 0154 BA18     		add	r2, r7, r2
 230 0156 1360     		str	r3, [r2]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 111


 231              	.L2:
5889:.\Include/arm_math.h ****     {
 232              		.loc 2 5889 0
 233 0158 A823     		mov	r3, #168
 234 015a FB18     		add	r3, r7, r3
 235 015c 1B68     		ldr	r3, [r3]
 236 015e 002B     		cmp	r3, #0
 237 0160 BFD1     		bne	.L4
5904:.\Include/arm_math.h ****     }
5905:.\Include/arm_math.h **** 
5906:.\Include/arm_math.h ****     /* Update the index pointer */
5907:.\Include/arm_math.h ****     *writeOffset = (uint16_t)wOffset;
 238              		.loc 2 5907 0
 239 0162 A423     		mov	r3, #164
 240 0164 FB18     		add	r3, r7, r3
 241 0166 1B68     		ldr	r3, [r3]
 242 0168 9AB2     		uxth	r2, r3
 243 016a BC23     		mov	r3, #188
 244 016c FB18     		add	r3, r7, r3
 245 016e 1B68     		ldr	r3, [r3]
 246 0170 1A80     		strh	r2, [r3]
 247              	.LBE11:
 248              	.LBE10:
 138:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                         (int32_t *) pSrc, 1, blockSize);
 139:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 140:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 141:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 142:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 249              		.loc 1 142 0
 250 0172 FB68     		ldr	r3, [r7, #12]
 251 0174 5B88     		ldrh	r3, [r3, #2]
 252 0176 1A1C     		mov	r2, r3
 253 0178 8423     		mov	r3, #132
 254 017a 5B00     		lsl	r3, r3, #1
 255 017c FB18     		add	r3, r7, r3
 256 017e 1B68     		ldr	r3, [r3]
 257 0180 D21A     		sub	r2, r2, r3
 258 0182 E823     		mov	r3, #232
 259 0184 FB18     		add	r3, r7, r3
 260 0186 1B68     		ldr	r3, [r3]
 261 0188 191D     		add	r1, r3, #4
 262 018a E820     		mov	r0, #232
 263 018c 3818     		add	r0, r7, r0
 264 018e 0160     		str	r1, [r0]
 265 0190 1B68     		ldr	r3, [r3]
 266 0192 D31A     		sub	r3, r2, r3
 267 0194 3B61     		str	r3, [r7, #16]
 143:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 144:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Wraparound of readIndex */
 145:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   if (readIndex < 0)
 268              		.loc 1 145 0
 269 0196 3B69     		ldr	r3, [r7, #16]
 270 0198 002B     		cmp	r3, #0
 271 019a 05DA     		bge	.L5
 146:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 147:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     readIndex += (int32_t) delaySize;
 272              		.loc 1 147 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 112


 273 019c 3A69     		ldr	r2, [r7, #16]
 274 019e CC23     		mov	r3, #204
 275 01a0 FB18     		add	r3, r7, r3
 276 01a2 1B68     		ldr	r3, [r3]
 277 01a4 D318     		add	r3, r2, r3
 278 01a6 3B61     		str	r3, [r7, #16]
 279              	.L5:
 148:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
 149:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 150:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Working pointer for state buffer is updated */
 151:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   py = pState;
 280              		.loc 1 151 0
 281 01a8 D823     		mov	r3, #216
 282 01aa FB18     		add	r3, r7, r3
 283 01ac 1B68     		ldr	r3, [r3]
 284 01ae D422     		mov	r2, #212
 285 01b0 BA18     		add	r2, r7, r2
 286 01b2 1360     		str	r3, [r2]
 152:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 153:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* blockSize samples are read from the state buffer */
 154:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 287              		.loc 1 154 0
 288 01b4 CC23     		mov	r3, #204
 289 01b6 FB18     		add	r3, r7, r3
 290 01b8 1A68     		ldr	r2, [r3]
 291 01ba 8423     		mov	r3, #132
 292 01bc 5B00     		lsl	r3, r3, #1
 293 01be FB18     		add	r3, r7, r3
 294 01c0 1B68     		ldr	r3, [r3]
 295 01c2 D421     		mov	r1, #212
 296 01c4 7918     		add	r1, r7, r1
 297 01c6 0968     		ldr	r1, [r1]
 298 01c8 A020     		mov	r0, #160
 299 01ca 3818     		add	r0, r7, r0
 300 01cc 0160     		str	r1, [r0]
 301 01ce 9C21     		mov	r1, #156
 302 01d0 7918     		add	r1, r7, r1
 303 01d2 0A60     		str	r2, [r1]
 304 01d4 1022     		mov	r2, #16
 305 01d6 BA18     		add	r2, r7, r2
 306 01d8 9821     		mov	r1, #152
 307 01da 7918     		add	r1, r7, r1
 308 01dc 0A60     		str	r2, [r1]
 309 01de 0122     		mov	r2, #1
 310 01e0 9421     		mov	r1, #148
 311 01e2 7918     		add	r1, r7, r1
 312 01e4 0A60     		str	r2, [r1]
 313 01e6 D022     		mov	r2, #208
 314 01e8 BA18     		add	r2, r7, r2
 315 01ea 1268     		ldr	r2, [r2]
 316 01ec 9021     		mov	r1, #144
 317 01ee 7918     		add	r1, r7, r1
 318 01f0 0A60     		str	r2, [r1]
 319 01f2 D022     		mov	r2, #208
 320 01f4 BA18     		add	r2, r7, r2
 321 01f6 1268     		ldr	r2, [r2]
 322 01f8 8C21     		mov	r1, #140
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 113


 323 01fa 7918     		add	r1, r7, r1
 324 01fc 0A60     		str	r2, [r1]
 325 01fe 8822     		mov	r2, #136
 326 0200 BA18     		add	r2, r7, r2
 327 0202 1360     		str	r3, [r2]
 328 0204 0123     		mov	r3, #1
 329 0206 8422     		mov	r2, #132
 330 0208 BA18     		add	r2, r7, r2
 331 020a 1360     		str	r3, [r2]
 332 020c 8423     		mov	r3, #132
 333 020e 5B00     		lsl	r3, r3, #1
 334 0210 FB18     		add	r3, r7, r3
 335 0212 1B68     		ldr	r3, [r3]
 336 0214 8022     		mov	r2, #128
 337 0216 BA18     		add	r2, r7, r2
 338 0218 1360     		str	r3, [r2]
 339              	.LBB12:
 340              	.LBB13:
5908:.\Include/arm_math.h ****   }
5909:.\Include/arm_math.h **** 
5910:.\Include/arm_math.h **** 
5911:.\Include/arm_math.h **** 
5912:.\Include/arm_math.h ****   /**
5913:.\Include/arm_math.h ****    * @brief floating-point Circular Read function.
5914:.\Include/arm_math.h ****    */
5915:.\Include/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularRead_f32(
5916:.\Include/arm_math.h ****   int32_t * circBuffer,
5917:.\Include/arm_math.h ****   int32_t L,
5918:.\Include/arm_math.h ****   int32_t * readOffset,
5919:.\Include/arm_math.h ****   int32_t bufferInc,
5920:.\Include/arm_math.h ****   int32_t * dst,
5921:.\Include/arm_math.h ****   int32_t * dst_base,
5922:.\Include/arm_math.h ****   int32_t dst_length,
5923:.\Include/arm_math.h ****   int32_t dstInc,
5924:.\Include/arm_math.h ****   uint32_t blockSize)
5925:.\Include/arm_math.h ****   {
5926:.\Include/arm_math.h ****     uint32_t i = 0u;
 341              		.loc 2 5926 0
 342 021a 0023     		mov	r3, #0
 343 021c FB67     		str	r3, [r7, #124]
5927:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
5928:.\Include/arm_math.h **** 
5929:.\Include/arm_math.h ****     /* Copy the value of Index pointer that points
5930:.\Include/arm_math.h ****      * to the current location from where the input samples to be read */
5931:.\Include/arm_math.h ****     rOffset = *readOffset;
 344              		.loc 2 5931 0
 345 021e 9823     		mov	r3, #152
 346 0220 FB18     		add	r3, r7, r3
 347 0222 1B68     		ldr	r3, [r3]
 348 0224 1B68     		ldr	r3, [r3]
 349 0226 BB67     		str	r3, [r7, #120]
5932:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
 350              		.loc 2 5932 0
 351 0228 8823     		mov	r3, #136
 352 022a FB18     		add	r3, r7, r3
 353 022c 1B68     		ldr	r3, [r3]
 354 022e 9B00     		lsl	r3, r3, #2
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 114


 355 0230 8C22     		mov	r2, #140
 356 0232 BA18     		add	r2, r7, r2
 357 0234 1268     		ldr	r2, [r2]
 358 0236 D318     		add	r3, r2, r3
 359 0238 7B67     		str	r3, [r7, #116]
5933:.\Include/arm_math.h **** 
5934:.\Include/arm_math.h ****     /* Loop over the blockSize */
5935:.\Include/arm_math.h ****     i = blockSize;
 360              		.loc 2 5935 0
 361 023a 8023     		mov	r3, #128
 362 023c FB18     		add	r3, r7, r3
 363 023e 1B68     		ldr	r3, [r3]
 364 0240 FB67     		str	r3, [r7, #124]
 365 0242 36E0     		b	.L6
 366              	.L9:
5936:.\Include/arm_math.h **** 
5937:.\Include/arm_math.h ****     while (i > 0u)
5938:.\Include/arm_math.h ****     {
5939:.\Include/arm_math.h ****       /* copy the sample from the circular buffer to the destination buffer */
5940:.\Include/arm_math.h ****       *dst = circBuffer[rOffset];
 367              		.loc 2 5940 0
 368 0244 BB6F     		ldr	r3, [r7, #120]
 369 0246 9B00     		lsl	r3, r3, #2
 370 0248 A022     		mov	r2, #160
 371 024a BA18     		add	r2, r7, r2
 372 024c 1268     		ldr	r2, [r2]
 373 024e D318     		add	r3, r2, r3
 374 0250 1A68     		ldr	r2, [r3]
 375 0252 9023     		mov	r3, #144
 376 0254 FB18     		add	r3, r7, r3
 377 0256 1B68     		ldr	r3, [r3]
 378 0258 1A60     		str	r2, [r3]
5941:.\Include/arm_math.h **** 
5942:.\Include/arm_math.h ****       /* Update the input pointer */
5943:.\Include/arm_math.h ****       dst += dstInc;
 379              		.loc 2 5943 0
 380 025a 8423     		mov	r3, #132
 381 025c FB18     		add	r3, r7, r3
 382 025e 1B68     		ldr	r3, [r3]
 383 0260 9B00     		lsl	r3, r3, #2
 384 0262 9022     		mov	r2, #144
 385 0264 BA18     		add	r2, r7, r2
 386 0266 1268     		ldr	r2, [r2]
 387 0268 D318     		add	r3, r2, r3
 388 026a 9022     		mov	r2, #144
 389 026c BA18     		add	r2, r7, r2
 390 026e 1360     		str	r3, [r2]
5944:.\Include/arm_math.h **** 
5945:.\Include/arm_math.h ****       if (dst == (int32_t *) dst_end)
 391              		.loc 2 5945 0
 392 0270 7B6F     		ldr	r3, [r7, #116]
 393 0272 9022     		mov	r2, #144
 394 0274 BA18     		add	r2, r7, r2
 395 0276 1268     		ldr	r2, [r2]
 396 0278 9A42     		cmp	r2, r3
 397 027a 05D1     		bne	.L7
5946:.\Include/arm_math.h ****       {
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 115


5947:.\Include/arm_math.h ****         dst = dst_base;
 398              		.loc 2 5947 0
 399 027c 8C23     		mov	r3, #140
 400 027e FB18     		add	r3, r7, r3
 401 0280 1B68     		ldr	r3, [r3]
 402 0282 9022     		mov	r2, #144
 403 0284 BA18     		add	r2, r7, r2
 404 0286 1360     		str	r3, [r2]
 405              	.L7:
5948:.\Include/arm_math.h ****       }
5949:.\Include/arm_math.h **** 
5950:.\Include/arm_math.h ****       /* Circularly update rOffset.  Watch out for positive and negative value  */
5951:.\Include/arm_math.h ****       rOffset += bufferInc;
 406              		.loc 2 5951 0
 407 0288 BA6F     		ldr	r2, [r7, #120]
 408 028a 9423     		mov	r3, #148
 409 028c FB18     		add	r3, r7, r3
 410 028e 1B68     		ldr	r3, [r3]
 411 0290 D318     		add	r3, r2, r3
 412 0292 BB67     		str	r3, [r7, #120]
5952:.\Include/arm_math.h **** 
5953:.\Include/arm_math.h ****       if (rOffset >= L)
 413              		.loc 2 5953 0
 414 0294 9C23     		mov	r3, #156
 415 0296 FB18     		add	r3, r7, r3
 416 0298 1A68     		ldr	r2, [r3]
 417 029a BB6F     		ldr	r3, [r7, #120]
 418 029c 9A42     		cmp	r2, r3
 419 029e 05DC     		bgt	.L8
5954:.\Include/arm_math.h ****       {
5955:.\Include/arm_math.h ****         rOffset -= L;
 420              		.loc 2 5955 0
 421 02a0 BA6F     		ldr	r2, [r7, #120]
 422 02a2 9C23     		mov	r3, #156
 423 02a4 FB18     		add	r3, r7, r3
 424 02a6 1B68     		ldr	r3, [r3]
 425 02a8 D31A     		sub	r3, r2, r3
 426 02aa BB67     		str	r3, [r7, #120]
 427              	.L8:
5956:.\Include/arm_math.h ****       }
5957:.\Include/arm_math.h **** 
5958:.\Include/arm_math.h ****       /* Decrement the loop counter */
5959:.\Include/arm_math.h ****       i--;
 428              		.loc 2 5959 0
 429 02ac FB6F     		ldr	r3, [r7, #124]
 430 02ae 013B     		sub	r3, r3, #1
 431 02b0 FB67     		str	r3, [r7, #124]
 432              	.L6:
5937:.\Include/arm_math.h ****     {
 433              		.loc 2 5937 0
 434 02b2 FB6F     		ldr	r3, [r7, #124]
 435 02b4 002B     		cmp	r3, #0
 436 02b6 C5D1     		bne	.L9
5960:.\Include/arm_math.h ****     }
5961:.\Include/arm_math.h **** 
5962:.\Include/arm_math.h ****     /* Update the index pointer */
5963:.\Include/arm_math.h ****     *readOffset = rOffset;
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 116


 437              		.loc 2 5963 0
 438 02b8 9823     		mov	r3, #152
 439 02ba FB18     		add	r3, r7, r3
 440 02bc 1B68     		ldr	r3, [r3]
 441 02be BA6F     		ldr	r2, [r7, #120]
 442 02c0 1A60     		str	r2, [r3]
 443              	.LBE13:
 444              	.LBE12:
 155:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                        (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 156:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                        blockSize);
 157:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 158:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Working pointer for the scratch buffer */
 159:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   px = pb;
 445              		.loc 1 159 0
 446 02c2 D023     		mov	r3, #208
 447 02c4 FB18     		add	r3, r7, r3
 448 02c6 1B68     		ldr	r3, [r3]
 449 02c8 F022     		mov	r2, #240
 450 02ca BA18     		add	r2, r7, r2
 451 02cc 1360     		str	r3, [r2]
 160:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 161:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Working pointer for destination buffer */
 162:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   pOut = pDst;
 452              		.loc 1 162 0
 453 02ce 7B68     		ldr	r3, [r7, #4]
 454 02d0 EC22     		mov	r2, #236
 455 02d2 BA18     		add	r2, r7, r2
 456 02d4 1360     		str	r3, [r2]
 163:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 164:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 165:Source\FilteringFunctions/arm_fir_sparse_f32.c **** #if defined (ARM_MATH_DSP)
 166:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 167:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
 168:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 169:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Loop over the blockSize. Unroll by a factor of 4.
 170:Source\FilteringFunctions/arm_fir_sparse_f32.c ****    * Compute 4 Multiplications at a time. */
 171:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   blkCnt = blockSize >> 2u;
 172:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 173:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   while (blkCnt > 0u)
 174:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 175:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Perform Multiplications and store in destination buffer */
 176:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     *pOut++ = *px++ * coeff;
 177:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     *pOut++ = *px++ * coeff;
 178:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     *pOut++ = *px++ * coeff;
 179:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     *pOut++ = *px++ * coeff;
 180:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 181:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Decrement the loop counter */
 182:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     blkCnt--;
 183:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
 184:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 185:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* If the blockSize is not a multiple of 4,
 186:Source\FilteringFunctions/arm_fir_sparse_f32.c ****    * compute the remaining samples */
 187:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   blkCnt = blockSize % 0x4u;
 188:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 189:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   while (blkCnt > 0u)
 190:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 191:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Perform Multiplications and store in destination buffer */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 117


 192:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     *pOut++ = *px++ * coeff;
 193:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 194:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Decrement the loop counter */
 195:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     blkCnt--;
 196:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
 197:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 198:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Load the coefficient value and
 199:Source\FilteringFunctions/arm_fir_sparse_f32.c ****    * increment the coefficient buffer for the next set of state values */
 200:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   coeff = *pCoeffs++;
 201:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 202:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 203:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 204:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 205:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Wraparound of readIndex */
 206:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   if (readIndex < 0)
 207:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 208:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     readIndex += (int32_t) delaySize;
 209:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
 210:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 211:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Loop over the number of taps. */
 212:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   tapCnt = (uint32_t) numTaps - 2u;
 213:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 214:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   while (tapCnt > 0u)
 215:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 216:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 217:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Working pointer for state buffer is updated */
 218:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     py = pState;
 219:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 220:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* blockSize samples are read from the state buffer */
 221:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 222:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                          (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 223:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                          blockSize);
 224:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 225:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Working pointer for the scratch buffer */
 226:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     px = pb;
 227:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 228:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Working pointer for destination buffer */
 229:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     pOut = pDst;
 230:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 231:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Loop over the blockSize. Unroll by a factor of 4.
 232:Source\FilteringFunctions/arm_fir_sparse_f32.c ****      * Compute 4 MACS at a time. */
 233:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     blkCnt = blockSize >> 2u;
 234:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 235:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     while (blkCnt > 0u)
 236:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     {
 237:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       /* Perform Multiply-Accumulate */
 238:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       *pOut++ += *px++ * coeff;
 239:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       *pOut++ += *px++ * coeff;
 240:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       *pOut++ += *px++ * coeff;
 241:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       *pOut++ += *px++ * coeff;
 242:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 243:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       /* Decrement the loop counter */
 244:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       blkCnt--;
 245:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     }
 246:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 247:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* If the blockSize is not a multiple of 4,
 248:Source\FilteringFunctions/arm_fir_sparse_f32.c ****      * compute the remaining samples */
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 118


 249:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     blkCnt = blockSize % 0x4u;
 250:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 251:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     while (blkCnt > 0u)
 252:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     {
 253:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       /* Perform Multiply-Accumulate */
 254:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       *pOut++ += *px++ * coeff;
 255:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 256:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       /* Decrement the loop counter */
 257:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       blkCnt--;
 258:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     }
 259:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 260:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Load the coefficient value and
 261:Source\FilteringFunctions/arm_fir_sparse_f32.c ****      * increment the coefficient buffer for the next set of state values */
 262:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     coeff = *pCoeffs++;
 263:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 264:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 265:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     readIndex = ((int32_t) S->stateIndex -
 266:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                  (int32_t) blockSize) - *pTapDelay++;
 267:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 268:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Wraparound of readIndex */
 269:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     if (readIndex < 0)
 270:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     {
 271:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       readIndex += (int32_t) delaySize;
 272:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     }
 273:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 274:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Decrement the tap loop counter */
 275:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     tapCnt--;
 276:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
 277:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 278:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Compute last tap without the final read of pTapDelay */
 279:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 280:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Working pointer for state buffer is updated */
 281:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	py = pState;
 282:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 283:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* blockSize samples are read from the state buffer */
 284:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 285:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 286:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 											 blockSize);
 287:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 288:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Working pointer for the scratch buffer */
 289:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	px = pb;
 290:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 291:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Working pointer for destination buffer */
 292:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	pOut = pDst;
 293:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 294:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Loop over the blockSize. Unroll by a factor of 4.
 295:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	 * Compute 4 MACS at a time. */
 296:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	blkCnt = blockSize >> 2u;
 297:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 298:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	while (blkCnt > 0u)
 299:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	{
 300:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		/* Perform Multiply-Accumulate */
 301:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		*pOut++ += *px++ * coeff;
 302:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		*pOut++ += *px++ * coeff;
 303:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		*pOut++ += *px++ * coeff;
 304:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		*pOut++ += *px++ * coeff;
 305:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 119


 306:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		/* Decrement the loop counter */
 307:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		blkCnt--;
 308:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	}
 309:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 310:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* If the blockSize is not a multiple of 4,
 311:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	 * compute the remaining samples */
 312:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	blkCnt = blockSize % 0x4u;
 313:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 314:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	while (blkCnt > 0u)
 315:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	{
 316:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		/* Perform Multiply-Accumulate */
 317:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		*pOut++ += *px++ * coeff;
 318:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 319:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		/* Decrement the loop counter */
 320:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		blkCnt--;
 321:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	}
 322:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 323:Source\FilteringFunctions/arm_fir_sparse_f32.c **** #else
 324:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 325:Source\FilteringFunctions/arm_fir_sparse_f32.c **** /* Run the below code for Cortex-M0 */
 326:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 327:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   blkCnt = blockSize;
 457              		.loc 1 327 0
 458 02d6 8423     		mov	r3, #132
 459 02d8 5B00     		lsl	r3, r3, #1
 460 02da FB18     		add	r3, r7, r3
 461 02dc 1B68     		ldr	r3, [r3]
 462 02de E022     		mov	r2, #224
 463 02e0 BA18     		add	r2, r7, r2
 464 02e2 1360     		str	r3, [r2]
 328:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 329:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   while (blkCnt > 0u)
 465              		.loc 1 329 0
 466 02e4 1DE0     		b	.L10
 467              	.L11:
 330:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 331:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Perform Multiplications and store in destination buffer */
 332:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     *pOut++ = *px++ * coeff;
 468              		.loc 1 332 0
 469 02e6 EC23     		mov	r3, #236
 470 02e8 FB18     		add	r3, r7, r3
 471 02ea 1C68     		ldr	r4, [r3]
 472 02ec 231D     		add	r3, r4, #4
 473 02ee EC22     		mov	r2, #236
 474 02f0 BA18     		add	r2, r7, r2
 475 02f2 1360     		str	r3, [r2]
 476 02f4 F023     		mov	r3, #240
 477 02f6 FB18     		add	r3, r7, r3
 478 02f8 1B68     		ldr	r3, [r3]
 479 02fa 1A1D     		add	r2, r3, #4
 480 02fc F021     		mov	r1, #240
 481 02fe 7918     		add	r1, r7, r1
 482 0300 0A60     		str	r2, [r1]
 483 0302 1B68     		ldr	r3, [r3]
 484 0304 181C     		add	r0, r3, #0
 485 0306 DC23     		mov	r3, #220
 486 0308 FB18     		add	r3, r7, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 120


 487 030a 1968     		ldr	r1, [r3]
 488 030c FFF7FEFF 		bl	__aeabi_fmul
 489 0310 031C     		add	r3, r0, #0
 490 0312 2360     		str	r3, [r4]
 333:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 334:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Decrement the loop counter */
 335:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     blkCnt--;
 491              		.loc 1 335 0
 492 0314 E023     		mov	r3, #224
 493 0316 FB18     		add	r3, r7, r3
 494 0318 1B68     		ldr	r3, [r3]
 495 031a 013B     		sub	r3, r3, #1
 496 031c E022     		mov	r2, #224
 497 031e BA18     		add	r2, r7, r2
 498 0320 1360     		str	r3, [r2]
 499              	.L10:
 329:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 500              		.loc 1 329 0
 501 0322 E023     		mov	r3, #224
 502 0324 FB18     		add	r3, r7, r3
 503 0326 1B68     		ldr	r3, [r3]
 504 0328 002B     		cmp	r3, #0
 505 032a DCD1     		bne	.L11
 336:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
 337:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 338:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Load the coefficient value and
 339:Source\FilteringFunctions/arm_fir_sparse_f32.c ****    * increment the coefficient buffer for the next set of state values */
 340:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   coeff = *pCoeffs++;
 506              		.loc 1 340 0
 507 032c F423     		mov	r3, #244
 508 032e FB18     		add	r3, r7, r3
 509 0330 1B68     		ldr	r3, [r3]
 510 0332 1A1D     		add	r2, r3, #4
 511 0334 F421     		mov	r1, #244
 512 0336 7918     		add	r1, r7, r1
 513 0338 0A60     		str	r2, [r1]
 514 033a 1B68     		ldr	r3, [r3]
 515 033c DC22     		mov	r2, #220
 516 033e BA18     		add	r2, r7, r2
 517 0340 1360     		str	r3, [r2]
 341:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 342:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 343:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 518              		.loc 1 343 0
 519 0342 FB68     		ldr	r3, [r7, #12]
 520 0344 5B88     		ldrh	r3, [r3, #2]
 521 0346 1A1C     		mov	r2, r3
 522 0348 8423     		mov	r3, #132
 523 034a 5B00     		lsl	r3, r3, #1
 524 034c FB18     		add	r3, r7, r3
 525 034e 1B68     		ldr	r3, [r3]
 526 0350 D21A     		sub	r2, r2, r3
 527 0352 E823     		mov	r3, #232
 528 0354 FB18     		add	r3, r7, r3
 529 0356 1B68     		ldr	r3, [r3]
 530 0358 191D     		add	r1, r3, #4
 531 035a E820     		mov	r0, #232
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 121


 532 035c 3818     		add	r0, r7, r0
 533 035e 0160     		str	r1, [r0]
 534 0360 1B68     		ldr	r3, [r3]
 535 0362 D31A     		sub	r3, r2, r3
 536 0364 3B61     		str	r3, [r7, #16]
 344:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 345:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Wraparound of readIndex */
 346:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   if (readIndex < 0)
 537              		.loc 1 346 0
 538 0366 3B69     		ldr	r3, [r7, #16]
 539 0368 002B     		cmp	r3, #0
 540 036a 05DA     		bge	.L12
 347:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 348:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     readIndex += (int32_t) delaySize;
 541              		.loc 1 348 0
 542 036c 3A69     		ldr	r2, [r7, #16]
 543 036e CC23     		mov	r3, #204
 544 0370 FB18     		add	r3, r7, r3
 545 0372 1B68     		ldr	r3, [r3]
 546 0374 D318     		add	r3, r2, r3
 547 0376 3B61     		str	r3, [r7, #16]
 548              	.L12:
 349:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
 350:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 351:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   /* Loop over the number of taps. */
 352:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   tapCnt = (uint32_t) numTaps - 2u;
 549              		.loc 1 352 0
 550 0378 CA23     		mov	r3, #202
 551 037a FB18     		add	r3, r7, r3
 552 037c 1B88     		ldrh	r3, [r3]
 553 037e 023B     		sub	r3, r3, #2
 554 0380 E422     		mov	r2, #228
 555 0382 BA18     		add	r2, r7, r2
 556 0384 1360     		str	r3, [r2]
 353:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 354:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   while (tapCnt > 0u)
 557              		.loc 1 354 0
 558 0386 C3E0     		b	.L13
 559              	.L21:
 355:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 356:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 357:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Working pointer for state buffer is updated */
 358:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     py = pState;
 560              		.loc 1 358 0
 561 0388 D823     		mov	r3, #216
 562 038a FB18     		add	r3, r7, r3
 563 038c 1B68     		ldr	r3, [r3]
 564 038e D422     		mov	r2, #212
 565 0390 BA18     		add	r2, r7, r2
 566 0392 1360     		str	r3, [r2]
 359:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 360:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* blockSize samples are read from the state buffer */
 361:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 567              		.loc 1 361 0
 568 0394 CC23     		mov	r3, #204
 569 0396 FB18     		add	r3, r7, r3
 570 0398 1A68     		ldr	r2, [r3]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 122


 571 039a 8423     		mov	r3, #132
 572 039c 5B00     		lsl	r3, r3, #1
 573 039e FB18     		add	r3, r7, r3
 574 03a0 1B68     		ldr	r3, [r3]
 575 03a2 D421     		mov	r1, #212
 576 03a4 7918     		add	r1, r7, r1
 577 03a6 0968     		ldr	r1, [r1]
 578 03a8 3967     		str	r1, [r7, #112]
 579 03aa FA66     		str	r2, [r7, #108]
 580 03ac 1022     		mov	r2, #16
 581 03ae BA18     		add	r2, r7, r2
 582 03b0 BA66     		str	r2, [r7, #104]
 583 03b2 0122     		mov	r2, #1
 584 03b4 7A66     		str	r2, [r7, #100]
 585 03b6 D022     		mov	r2, #208
 586 03b8 BA18     		add	r2, r7, r2
 587 03ba 1268     		ldr	r2, [r2]
 588 03bc 3A66     		str	r2, [r7, #96]
 589 03be D022     		mov	r2, #208
 590 03c0 BA18     		add	r2, r7, r2
 591 03c2 1268     		ldr	r2, [r2]
 592 03c4 FA65     		str	r2, [r7, #92]
 593 03c6 BB65     		str	r3, [r7, #88]
 594 03c8 0123     		mov	r3, #1
 595 03ca 7B65     		str	r3, [r7, #84]
 596 03cc 8423     		mov	r3, #132
 597 03ce 5B00     		lsl	r3, r3, #1
 598 03d0 FB18     		add	r3, r7, r3
 599 03d2 1B68     		ldr	r3, [r3]
 600 03d4 3B65     		str	r3, [r7, #80]
 601              	.LBB14:
 602              	.LBB15:
5926:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
 603              		.loc 2 5926 0
 604 03d6 0023     		mov	r3, #0
 605 03d8 FB64     		str	r3, [r7, #76]
5931:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
 606              		.loc 2 5931 0
 607 03da BB6E     		ldr	r3, [r7, #104]
 608 03dc 1B68     		ldr	r3, [r3]
 609 03de BB64     		str	r3, [r7, #72]
5932:.\Include/arm_math.h **** 
 610              		.loc 2 5932 0
 611 03e0 BB6D     		ldr	r3, [r7, #88]
 612 03e2 9B00     		lsl	r3, r3, #2
 613 03e4 FA6D     		ldr	r2, [r7, #92]
 614 03e6 D318     		add	r3, r2, r3
 615 03e8 7B64     		str	r3, [r7, #68]
5935:.\Include/arm_math.h **** 
 616              		.loc 2 5935 0
 617 03ea 3B6D     		ldr	r3, [r7, #80]
 618 03ec FB64     		str	r3, [r7, #76]
 619 03ee 20E0     		b	.L14
 620              	.L17:
5940:.\Include/arm_math.h **** 
 621              		.loc 2 5940 0
 622 03f0 BB6C     		ldr	r3, [r7, #72]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 123


 623 03f2 9B00     		lsl	r3, r3, #2
 624 03f4 3A6F     		ldr	r2, [r7, #112]
 625 03f6 D318     		add	r3, r2, r3
 626 03f8 1A68     		ldr	r2, [r3]
 627 03fa 3B6E     		ldr	r3, [r7, #96]
 628 03fc 1A60     		str	r2, [r3]
5943:.\Include/arm_math.h **** 
 629              		.loc 2 5943 0
 630 03fe 7B6D     		ldr	r3, [r7, #84]
 631 0400 9B00     		lsl	r3, r3, #2
 632 0402 3A6E     		ldr	r2, [r7, #96]
 633 0404 D318     		add	r3, r2, r3
 634 0406 3B66     		str	r3, [r7, #96]
5945:.\Include/arm_math.h ****       {
 635              		.loc 2 5945 0
 636 0408 7B6C     		ldr	r3, [r7, #68]
 637 040a 3A6E     		ldr	r2, [r7, #96]
 638 040c 9A42     		cmp	r2, r3
 639 040e 01D1     		bne	.L15
5947:.\Include/arm_math.h ****       }
 640              		.loc 2 5947 0
 641 0410 FB6D     		ldr	r3, [r7, #92]
 642 0412 3B66     		str	r3, [r7, #96]
 643              	.L15:
5951:.\Include/arm_math.h **** 
 644              		.loc 2 5951 0
 645 0414 BA6C     		ldr	r2, [r7, #72]
 646 0416 7B6E     		ldr	r3, [r7, #100]
 647 0418 D318     		add	r3, r2, r3
 648 041a BB64     		str	r3, [r7, #72]
5953:.\Include/arm_math.h ****       {
 649              		.loc 2 5953 0
 650 041c FA6E     		ldr	r2, [r7, #108]
 651 041e BB6C     		ldr	r3, [r7, #72]
 652 0420 9A42     		cmp	r2, r3
 653 0422 03DC     		bgt	.L16
5955:.\Include/arm_math.h ****       }
 654              		.loc 2 5955 0
 655 0424 BA6C     		ldr	r2, [r7, #72]
 656 0426 FB6E     		ldr	r3, [r7, #108]
 657 0428 D31A     		sub	r3, r2, r3
 658 042a BB64     		str	r3, [r7, #72]
 659              	.L16:
5959:.\Include/arm_math.h ****     }
 660              		.loc 2 5959 0
 661 042c FB6C     		ldr	r3, [r7, #76]
 662 042e 013B     		sub	r3, r3, #1
 663 0430 FB64     		str	r3, [r7, #76]
 664              	.L14:
5937:.\Include/arm_math.h ****     {
 665              		.loc 2 5937 0
 666 0432 FB6C     		ldr	r3, [r7, #76]
 667 0434 002B     		cmp	r3, #0
 668 0436 DBD1     		bne	.L17
 669              		.loc 2 5963 0
 670 0438 BB6E     		ldr	r3, [r7, #104]
 671 043a BA6C     		ldr	r2, [r7, #72]
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 124


 672 043c 1A60     		str	r2, [r3]
 673              	.LBE15:
 674              	.LBE14:
 362:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                          (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 363:Source\FilteringFunctions/arm_fir_sparse_f32.c ****                          blockSize);
 364:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 365:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Working pointer for the scratch buffer */
 366:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     px = pb;
 675              		.loc 1 366 0
 676 043e D023     		mov	r3, #208
 677 0440 FB18     		add	r3, r7, r3
 678 0442 1B68     		ldr	r3, [r3]
 679 0444 F022     		mov	r2, #240
 680 0446 BA18     		add	r2, r7, r2
 681 0448 1360     		str	r3, [r2]
 367:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 368:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Working pointer for destination buffer */
 369:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     pOut = pDst;
 682              		.loc 1 369 0
 683 044a 7B68     		ldr	r3, [r7, #4]
 684 044c EC22     		mov	r2, #236
 685 044e BA18     		add	r2, r7, r2
 686 0450 1360     		str	r3, [r2]
 370:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 371:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     blkCnt = blockSize;
 687              		.loc 1 371 0
 688 0452 8423     		mov	r3, #132
 689 0454 5B00     		lsl	r3, r3, #1
 690 0456 FB18     		add	r3, r7, r3
 691 0458 1B68     		ldr	r3, [r3]
 692 045a E022     		mov	r2, #224
 693 045c BA18     		add	r2, r7, r2
 694 045e 1360     		str	r3, [r2]
 372:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 373:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     while (blkCnt > 0u)
 695              		.loc 1 373 0
 696 0460 24E0     		b	.L18
 697              	.L19:
 374:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     {
 375:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       /* Perform Multiply-Accumulate */
 376:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       *pOut++ += *px++ * coeff;
 698              		.loc 1 376 0
 699 0462 F023     		mov	r3, #240
 700 0464 FB18     		add	r3, r7, r3
 701 0466 1B68     		ldr	r3, [r3]
 702 0468 1A1D     		add	r2, r3, #4
 703 046a F021     		mov	r1, #240
 704 046c 7918     		add	r1, r7, r1
 705 046e 0A60     		str	r2, [r1]
 706 0470 1B68     		ldr	r3, [r3]
 707 0472 181C     		add	r0, r3, #0
 708 0474 DC23     		mov	r3, #220
 709 0476 FB18     		add	r3, r7, r3
 710 0478 1968     		ldr	r1, [r3]
 711 047a FFF7FEFF 		bl	__aeabi_fmul
 712 047e 031C     		add	r3, r0, #0
 713 0480 1A1C     		add	r2, r3, #0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 125


 714 0482 EC23     		mov	r3, #236
 715 0484 FB18     		add	r3, r7, r3
 716 0486 1C68     		ldr	r4, [r3]
 717 0488 231D     		add	r3, r4, #4
 718 048a EC21     		mov	r1, #236
 719 048c 7918     		add	r1, r7, r1
 720 048e 0B60     		str	r3, [r1]
 721 0490 2368     		ldr	r3, [r4]
 722 0492 181C     		add	r0, r3, #0
 723 0494 111C     		add	r1, r2, #0
 724 0496 FFF7FEFF 		bl	__aeabi_fadd
 725 049a 031C     		add	r3, r0, #0
 726 049c 2360     		str	r3, [r4]
 377:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 378:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       /* Decrement the loop counter */
 379:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       blkCnt--;
 727              		.loc 1 379 0
 728 049e E023     		mov	r3, #224
 729 04a0 FB18     		add	r3, r7, r3
 730 04a2 1B68     		ldr	r3, [r3]
 731 04a4 013B     		sub	r3, r3, #1
 732 04a6 E022     		mov	r2, #224
 733 04a8 BA18     		add	r2, r7, r2
 734 04aa 1360     		str	r3, [r2]
 735              	.L18:
 373:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     {
 736              		.loc 1 373 0
 737 04ac E023     		mov	r3, #224
 738 04ae FB18     		add	r3, r7, r3
 739 04b0 1B68     		ldr	r3, [r3]
 740 04b2 002B     		cmp	r3, #0
 741 04b4 D5D1     		bne	.L19
 380:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     }
 381:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 382:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Load the coefficient value and
 383:Source\FilteringFunctions/arm_fir_sparse_f32.c ****      * increment the coefficient buffer for the next set of state values */
 384:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     coeff = *pCoeffs++;
 742              		.loc 1 384 0
 743 04b6 F423     		mov	r3, #244
 744 04b8 FB18     		add	r3, r7, r3
 745 04ba 1B68     		ldr	r3, [r3]
 746 04bc 1A1D     		add	r2, r3, #4
 747 04be F421     		mov	r1, #244
 748 04c0 7918     		add	r1, r7, r1
 749 04c2 0A60     		str	r2, [r1]
 750 04c4 1B68     		ldr	r3, [r3]
 751 04c6 DC22     		mov	r2, #220
 752 04c8 BA18     		add	r2, r7, r2
 753 04ca 1360     		str	r3, [r2]
 385:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 386:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 387:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     readIndex =
 388:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 754              		.loc 1 388 0
 755 04cc FB68     		ldr	r3, [r7, #12]
 756 04ce 5B88     		ldrh	r3, [r3, #2]
 757 04d0 1A1C     		mov	r2, r3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 126


 758 04d2 8423     		mov	r3, #132
 759 04d4 5B00     		lsl	r3, r3, #1
 760 04d6 FB18     		add	r3, r7, r3
 761 04d8 1B68     		ldr	r3, [r3]
 762 04da D21A     		sub	r2, r2, r3
 763 04dc E823     		mov	r3, #232
 764 04de FB18     		add	r3, r7, r3
 765 04e0 1B68     		ldr	r3, [r3]
 766 04e2 191D     		add	r1, r3, #4
 767 04e4 E820     		mov	r0, #232
 768 04e6 3818     		add	r0, r7, r0
 769 04e8 0160     		str	r1, [r0]
 770 04ea 1B68     		ldr	r3, [r3]
 771 04ec D31A     		sub	r3, r2, r3
 387:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
 772              		.loc 1 387 0
 773 04ee 3B61     		str	r3, [r7, #16]
 389:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 390:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Wraparound of readIndex */
 391:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     if (readIndex < 0)
 774              		.loc 1 391 0
 775 04f0 3B69     		ldr	r3, [r7, #16]
 776 04f2 002B     		cmp	r3, #0
 777 04f4 05DA     		bge	.L20
 392:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     {
 393:Source\FilteringFunctions/arm_fir_sparse_f32.c ****       readIndex += (int32_t) delaySize;
 778              		.loc 1 393 0
 779 04f6 3A69     		ldr	r2, [r7, #16]
 780 04f8 CC23     		mov	r3, #204
 781 04fa FB18     		add	r3, r7, r3
 782 04fc 1B68     		ldr	r3, [r3]
 783 04fe D318     		add	r3, r2, r3
 784 0500 3B61     		str	r3, [r7, #16]
 785              	.L20:
 394:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     }
 395:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 396:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     /* Decrement the tap loop counter */
 397:Source\FilteringFunctions/arm_fir_sparse_f32.c ****     tapCnt--;
 786              		.loc 1 397 0
 787 0502 E423     		mov	r3, #228
 788 0504 FB18     		add	r3, r7, r3
 789 0506 1B68     		ldr	r3, [r3]
 790 0508 013B     		sub	r3, r3, #1
 791 050a E422     		mov	r2, #228
 792 050c BA18     		add	r2, r7, r2
 793 050e 1360     		str	r3, [r2]
 794              	.L13:
 354:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   {
 795              		.loc 1 354 0
 796 0510 E423     		mov	r3, #228
 797 0512 FB18     		add	r3, r7, r3
 798 0514 1B68     		ldr	r3, [r3]
 799 0516 002B     		cmp	r3, #0
 800 0518 00D0     		beq	.LCB717
 801 051a 35E7     		b	.L21	@long jump
 802              	.LCB717:
 398:Source\FilteringFunctions/arm_fir_sparse_f32.c ****   }
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 127


 399:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 400:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Compute last tap without the final read of pTapDelay */
 401:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 402:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Working pointer for state buffer is updated */
 403:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	py = pState;
 803              		.loc 1 403 0
 804 051c D823     		mov	r3, #216
 805 051e FB18     		add	r3, r7, r3
 806 0520 1B68     		ldr	r3, [r3]
 807 0522 D422     		mov	r2, #212
 808 0524 BA18     		add	r2, r7, r2
 809 0526 1360     		str	r3, [r2]
 404:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 405:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* blockSize samples are read from the state buffer */
 406:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 810              		.loc 1 406 0
 811 0528 CC23     		mov	r3, #204
 812 052a FB18     		add	r3, r7, r3
 813 052c 1A68     		ldr	r2, [r3]
 814 052e 8423     		mov	r3, #132
 815 0530 5B00     		lsl	r3, r3, #1
 816 0532 FB18     		add	r3, r7, r3
 817 0534 1B68     		ldr	r3, [r3]
 818 0536 D421     		mov	r1, #212
 819 0538 7918     		add	r1, r7, r1
 820 053a 0968     		ldr	r1, [r1]
 821 053c 3964     		str	r1, [r7, #64]
 822 053e FA63     		str	r2, [r7, #60]
 823 0540 1022     		mov	r2, #16
 824 0542 BA18     		add	r2, r7, r2
 825 0544 BA63     		str	r2, [r7, #56]
 826 0546 0122     		mov	r2, #1
 827 0548 7A63     		str	r2, [r7, #52]
 828 054a D022     		mov	r2, #208
 829 054c BA18     		add	r2, r7, r2
 830 054e 1268     		ldr	r2, [r2]
 831 0550 3A63     		str	r2, [r7, #48]
 832 0552 D022     		mov	r2, #208
 833 0554 BA18     		add	r2, r7, r2
 834 0556 1268     		ldr	r2, [r2]
 835 0558 FA62     		str	r2, [r7, #44]
 836 055a BB62     		str	r3, [r7, #40]
 837 055c 0123     		mov	r3, #1
 838 055e 7B62     		str	r3, [r7, #36]
 839 0560 8423     		mov	r3, #132
 840 0562 5B00     		lsl	r3, r3, #1
 841 0564 FB18     		add	r3, r7, r3
 842 0566 1B68     		ldr	r3, [r3]
 843 0568 3B62     		str	r3, [r7, #32]
 844              	.LBB16:
 845              	.LBB17:
5926:.\Include/arm_math.h ****     int32_t rOffset, dst_end;
 846              		.loc 2 5926 0
 847 056a 0023     		mov	r3, #0
 848 056c FB61     		str	r3, [r7, #28]
5931:.\Include/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
 849              		.loc 2 5931 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 128


 850 056e BB6B     		ldr	r3, [r7, #56]
 851 0570 1B68     		ldr	r3, [r3]
 852 0572 BB61     		str	r3, [r7, #24]
5932:.\Include/arm_math.h **** 
 853              		.loc 2 5932 0
 854 0574 BB6A     		ldr	r3, [r7, #40]
 855 0576 9B00     		lsl	r3, r3, #2
 856 0578 FA6A     		ldr	r2, [r7, #44]
 857 057a D318     		add	r3, r2, r3
 858 057c 7B61     		str	r3, [r7, #20]
5935:.\Include/arm_math.h **** 
 859              		.loc 2 5935 0
 860 057e 3B6A     		ldr	r3, [r7, #32]
 861 0580 FB61     		str	r3, [r7, #28]
 862 0582 20E0     		b	.L22
 863              	.L25:
5940:.\Include/arm_math.h **** 
 864              		.loc 2 5940 0
 865 0584 BB69     		ldr	r3, [r7, #24]
 866 0586 9B00     		lsl	r3, r3, #2
 867 0588 3A6C     		ldr	r2, [r7, #64]
 868 058a D318     		add	r3, r2, r3
 869 058c 1A68     		ldr	r2, [r3]
 870 058e 3B6B     		ldr	r3, [r7, #48]
 871 0590 1A60     		str	r2, [r3]
5943:.\Include/arm_math.h **** 
 872              		.loc 2 5943 0
 873 0592 7B6A     		ldr	r3, [r7, #36]
 874 0594 9B00     		lsl	r3, r3, #2
 875 0596 3A6B     		ldr	r2, [r7, #48]
 876 0598 D318     		add	r3, r2, r3
 877 059a 3B63     		str	r3, [r7, #48]
5945:.\Include/arm_math.h ****       {
 878              		.loc 2 5945 0
 879 059c 7B69     		ldr	r3, [r7, #20]
 880 059e 3A6B     		ldr	r2, [r7, #48]
 881 05a0 9A42     		cmp	r2, r3
 882 05a2 01D1     		bne	.L23
5947:.\Include/arm_math.h ****       }
 883              		.loc 2 5947 0
 884 05a4 FB6A     		ldr	r3, [r7, #44]
 885 05a6 3B63     		str	r3, [r7, #48]
 886              	.L23:
5951:.\Include/arm_math.h **** 
 887              		.loc 2 5951 0
 888 05a8 BA69     		ldr	r2, [r7, #24]
 889 05aa 7B6B     		ldr	r3, [r7, #52]
 890 05ac D318     		add	r3, r2, r3
 891 05ae BB61     		str	r3, [r7, #24]
5953:.\Include/arm_math.h ****       {
 892              		.loc 2 5953 0
 893 05b0 FA6B     		ldr	r2, [r7, #60]
 894 05b2 BB69     		ldr	r3, [r7, #24]
 895 05b4 9A42     		cmp	r2, r3
 896 05b6 03DC     		bgt	.L24
5955:.\Include/arm_math.h ****       }
 897              		.loc 2 5955 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 129


 898 05b8 BA69     		ldr	r2, [r7, #24]
 899 05ba FB6B     		ldr	r3, [r7, #60]
 900 05bc D31A     		sub	r3, r2, r3
 901 05be BB61     		str	r3, [r7, #24]
 902              	.L24:
5959:.\Include/arm_math.h ****     }
 903              		.loc 2 5959 0
 904 05c0 FB69     		ldr	r3, [r7, #28]
 905 05c2 013B     		sub	r3, r3, #1
 906 05c4 FB61     		str	r3, [r7, #28]
 907              	.L22:
5937:.\Include/arm_math.h ****     {
 908              		.loc 2 5937 0
 909 05c6 FB69     		ldr	r3, [r7, #28]
 910 05c8 002B     		cmp	r3, #0
 911 05ca DBD1     		bne	.L25
 912              		.loc 2 5963 0
 913 05cc BB6B     		ldr	r3, [r7, #56]
 914 05ce BA69     		ldr	r2, [r7, #24]
 915 05d0 1A60     		str	r2, [r3]
 916              	.LBE17:
 917              	.LBE16:
 407:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 408:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 											 blockSize);
 409:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 410:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Working pointer for the scratch buffer */
 411:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	px = pb;
 918              		.loc 1 411 0
 919 05d2 D023     		mov	r3, #208
 920 05d4 FB18     		add	r3, r7, r3
 921 05d6 1B68     		ldr	r3, [r3]
 922 05d8 F022     		mov	r2, #240
 923 05da BA18     		add	r2, r7, r2
 924 05dc 1360     		str	r3, [r2]
 412:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 413:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	/* Working pointer for destination buffer */
 414:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	pOut = pDst;
 925              		.loc 1 414 0
 926 05de 7B68     		ldr	r3, [r7, #4]
 927 05e0 EC22     		mov	r2, #236
 928 05e2 BA18     		add	r2, r7, r2
 929 05e4 1360     		str	r3, [r2]
 415:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 416:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	blkCnt = blockSize;
 930              		.loc 1 416 0
 931 05e6 8423     		mov	r3, #132
 932 05e8 5B00     		lsl	r3, r3, #1
 933 05ea FB18     		add	r3, r7, r3
 934 05ec 1B68     		ldr	r3, [r3]
 935 05ee E022     		mov	r2, #224
 936 05f0 BA18     		add	r2, r7, r2
 937 05f2 1360     		str	r3, [r2]
 417:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 418:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	while (blkCnt > 0u)
 938              		.loc 1 418 0
 939 05f4 24E0     		b	.L26
 940              	.L27:
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 130


 419:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	{
 420:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		/* Perform Multiply-Accumulate */
 421:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		*pOut++ += *px++ * coeff;
 941              		.loc 1 421 0
 942 05f6 F023     		mov	r3, #240
 943 05f8 FB18     		add	r3, r7, r3
 944 05fa 1B68     		ldr	r3, [r3]
 945 05fc 1A1D     		add	r2, r3, #4
 946 05fe F021     		mov	r1, #240
 947 0600 7918     		add	r1, r7, r1
 948 0602 0A60     		str	r2, [r1]
 949 0604 1B68     		ldr	r3, [r3]
 950 0606 181C     		add	r0, r3, #0
 951 0608 DC23     		mov	r3, #220
 952 060a FB18     		add	r3, r7, r3
 953 060c 1968     		ldr	r1, [r3]
 954 060e FFF7FEFF 		bl	__aeabi_fmul
 955 0612 031C     		add	r3, r0, #0
 956 0614 1A1C     		add	r2, r3, #0
 957 0616 EC23     		mov	r3, #236
 958 0618 FB18     		add	r3, r7, r3
 959 061a 1C68     		ldr	r4, [r3]
 960 061c 231D     		add	r3, r4, #4
 961 061e EC21     		mov	r1, #236
 962 0620 7918     		add	r1, r7, r1
 963 0622 0B60     		str	r3, [r1]
 964 0624 2368     		ldr	r3, [r4]
 965 0626 181C     		add	r0, r3, #0
 966 0628 111C     		add	r1, r2, #0
 967 062a FFF7FEFF 		bl	__aeabi_fadd
 968 062e 031C     		add	r3, r0, #0
 969 0630 2360     		str	r3, [r4]
 422:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 423:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		/* Decrement the loop counter */
 424:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 		blkCnt--;
 970              		.loc 1 424 0
 971 0632 E023     		mov	r3, #224
 972 0634 FB18     		add	r3, r7, r3
 973 0636 1B68     		ldr	r3, [r3]
 974 0638 013B     		sub	r3, r3, #1
 975 063a E022     		mov	r2, #224
 976 063c BA18     		add	r2, r7, r2
 977 063e 1360     		str	r3, [r2]
 978              	.L26:
 418:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	{
 979              		.loc 1 418 0
 980 0640 E023     		mov	r3, #224
 981 0642 FB18     		add	r3, r7, r3
 982 0644 1B68     		ldr	r3, [r3]
 983 0646 002B     		cmp	r3, #0
 984 0648 D5D1     		bne	.L27
 425:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 	}
 426:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 427:Source\FilteringFunctions/arm_fir_sparse_f32.c **** #endif /*   #if defined (ARM_MATH_DSP)        */
 428:Source\FilteringFunctions/arm_fir_sparse_f32.c **** 
 429:Source\FilteringFunctions/arm_fir_sparse_f32.c **** }
 985              		.loc 1 429 0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 131


 986 064a BD46     		mov	sp, r7
 987 064c 3FB0     		add	sp, sp, #252
 988              		@ sp needed
 989 064e 90BD     		pop	{r4, r7, pc}
 990              		.cfi_endproc
 991              	.LFE82:
 992              		.size	arm_fir_sparse_f32, .-arm_fir_sparse_f32
 993              		.text
 994              	.Letext0:
 995              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 996              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 997              		.section	.debug_info,"",%progbits
 998              	.Ldebug_info0:
 999 0000 8D050000 		.4byte	0x58d
 1000 0004 0400     		.2byte	0x4
 1001 0006 00000000 		.4byte	.Ldebug_abbrev0
 1002 000a 04       		.byte	0x4
 1003 000b 01       		.uleb128 0x1
 1004 000c F4000000 		.4byte	.LASF51
 1005 0010 01       		.byte	0x1
 1006 0011 00000000 		.4byte	.LASF52
 1007 0015 23020000 		.4byte	.LASF53
 1008 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1009 001d 00000000 		.4byte	0
 1010 0021 00000000 		.4byte	.Ldebug_line0
 1011 0025 02       		.uleb128 0x2
 1012 0026 01       		.byte	0x1
 1013 0027 06       		.byte	0x6
 1014 0028 66000000 		.4byte	.LASF0
 1015 002c 02       		.uleb128 0x2
 1016 002d 01       		.byte	0x1
 1017 002e 08       		.byte	0x8
 1018 002f FB010000 		.4byte	.LASF1
 1019 0033 02       		.uleb128 0x2
 1020 0034 02       		.byte	0x2
 1021 0035 05       		.byte	0x5
 1022 0036 10020000 		.4byte	.LASF2
 1023 003a 03       		.uleb128 0x3
 1024 003b B1020000 		.4byte	.LASF4
 1025 003f 03       		.byte	0x3
 1026 0040 2B       		.byte	0x2b
 1027 0041 45000000 		.4byte	0x45
 1028 0045 02       		.uleb128 0x2
 1029 0046 02       		.byte	0x2
 1030 0047 07       		.byte	0x7
 1031 0048 86010000 		.4byte	.LASF3
 1032 004c 03       		.uleb128 0x3
 1033 004d BC020000 		.4byte	.LASF5
 1034 0051 03       		.byte	0x3
 1035 0052 3F       		.byte	0x3f
 1036 0053 57000000 		.4byte	0x57
 1037 0057 02       		.uleb128 0x2
 1038 0058 04       		.byte	0x4
 1039 0059 05       		.byte	0x5
 1040 005a 72000000 		.4byte	.LASF6
 1041 005e 03       		.uleb128 0x3
 1042 005f 97000000 		.4byte	.LASF7
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 132


 1043 0063 03       		.byte	0x3
 1044 0064 41       		.byte	0x41
 1045 0065 69000000 		.4byte	0x69
 1046 0069 02       		.uleb128 0x2
 1047 006a 04       		.byte	0x4
 1048 006b 07       		.byte	0x7
 1049 006c E2000000 		.4byte	.LASF8
 1050 0070 02       		.uleb128 0x2
 1051 0071 08       		.byte	0x8
 1052 0072 05       		.byte	0x5
 1053 0073 58000000 		.4byte	.LASF9
 1054 0077 02       		.uleb128 0x2
 1055 0078 08       		.byte	0x8
 1056 0079 07       		.byte	0x7
 1057 007a 2F000000 		.4byte	.LASF10
 1058 007e 04       		.uleb128 0x4
 1059 007f 04       		.byte	0x4
 1060 0080 05       		.byte	0x5
 1061 0081 696E7400 		.ascii	"int\000"
 1062 0085 02       		.uleb128 0x2
 1063 0086 04       		.byte	0x4
 1064 0087 07       		.byte	0x7
 1065 0088 AB000000 		.4byte	.LASF11
 1066 008c 03       		.uleb128 0x3
 1067 008d 87000000 		.4byte	.LASF12
 1068 0091 04       		.byte	0x4
 1069 0092 21       		.byte	0x21
 1070 0093 3A000000 		.4byte	0x3a
 1071 0097 03       		.uleb128 0x3
 1072 0098 F3010000 		.4byte	.LASF13
 1073 009c 04       		.byte	0x4
 1074 009d 2C       		.byte	0x2c
 1075 009e 4C000000 		.4byte	0x4c
 1076 00a2 03       		.uleb128 0x3
 1077 00a3 8D020000 		.4byte	.LASF14
 1078 00a7 04       		.byte	0x4
 1079 00a8 2D       		.byte	0x2d
 1080 00a9 5E000000 		.4byte	0x5e
 1081 00ad 02       		.uleb128 0x2
 1082 00ae 04       		.byte	0x4
 1083 00af 07       		.byte	0x7
 1084 00b0 B0010000 		.4byte	.LASF15
 1085 00b4 02       		.uleb128 0x2
 1086 00b5 01       		.byte	0x1
 1087 00b6 08       		.byte	0x8
 1088 00b7 96020000 		.4byte	.LASF16
 1089 00bb 02       		.uleb128 0x2
 1090 00bc 08       		.byte	0x8
 1091 00bd 04       		.byte	0x4
 1092 00be 90000000 		.4byte	.LASF17
 1093 00c2 02       		.uleb128 0x2
 1094 00c3 04       		.byte	0x4
 1095 00c4 04       		.byte	0x4
 1096 00c5 D0010000 		.4byte	.LASF18
 1097 00c9 02       		.uleb128 0x2
 1098 00ca 08       		.byte	0x8
 1099 00cb 04       		.byte	0x4
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 133


 1100 00cc B9010000 		.4byte	.LASF19
 1101 00d0 05       		.uleb128 0x5
 1102 00d1 C6020000 		.4byte	.LASF20
 1103 00d5 02       		.byte	0x2
 1104 00d6 A501     		.2byte	0x1a5
 1105 00d8 C2000000 		.4byte	0xc2
 1106 00dc 06       		.uleb128 0x6
 1107 00dd 04       		.byte	0x4
 1108 00de D0000000 		.4byte	0xd0
 1109 00e2 06       		.uleb128 0x6
 1110 00e3 04       		.byte	0x4
 1111 00e4 8C000000 		.4byte	0x8c
 1112 00e8 07       		.uleb128 0x7
 1113 00e9 14       		.byte	0x14
 1114 00ea 02       		.byte	0x2
 1115 00eb 8F11     		.2byte	0x118f
 1116 00ed 40010000 		.4byte	0x140
 1117 00f1 08       		.uleb128 0x8
 1118 00f2 69020000 		.4byte	.LASF21
 1119 00f6 02       		.byte	0x2
 1120 00f7 9111     		.2byte	0x1191
 1121 00f9 8C000000 		.4byte	0x8c
 1122 00fd 00       		.byte	0
 1123 00fe 08       		.uleb128 0x8
 1124 00ff C5010000 		.4byte	.LASF22
 1125 0103 02       		.byte	0x2
 1126 0104 9211     		.2byte	0x1192
 1127 0106 8C000000 		.4byte	0x8c
 1128 010a 02       		.byte	0x2
 1129 010b 08       		.uleb128 0x8
 1130 010c 09020000 		.4byte	.LASF23
 1131 0110 02       		.byte	0x2
 1132 0111 9311     		.2byte	0x1193
 1133 0113 DC000000 		.4byte	0xdc
 1134 0117 04       		.byte	0x4
 1135 0118 08       		.uleb128 0x8
 1136 0119 FD020000 		.4byte	.LASF24
 1137 011d 02       		.byte	0x2
 1138 011e 9411     		.2byte	0x1194
 1139 0120 DC000000 		.4byte	0xdc
 1140 0124 08       		.byte	0x8
 1141 0125 08       		.uleb128 0x8
 1142 0126 1A020000 		.4byte	.LASF25
 1143 012a 02       		.byte	0x2
 1144 012b 9511     		.2byte	0x1195
 1145 012d 8C000000 		.4byte	0x8c
 1146 0131 0C       		.byte	0xc
 1147 0132 08       		.uleb128 0x8
 1148 0133 D6010000 		.4byte	.LASF26
 1149 0137 02       		.byte	0x2
 1150 0138 9611     		.2byte	0x1196
 1151 013a 40010000 		.4byte	0x140
 1152 013e 10       		.byte	0x10
 1153 013f 00       		.byte	0
 1154 0140 06       		.uleb128 0x6
 1155 0141 04       		.byte	0x4
 1156 0142 97000000 		.4byte	0x97
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 134


 1157 0146 05       		.uleb128 0x5
 1158 0147 71020000 		.4byte	.LASF27
 1159 014b 02       		.byte	0x2
 1160 014c 9711     		.2byte	0x1197
 1161 014e E8000000 		.4byte	0xe8
 1162 0152 09       		.uleb128 0x9
 1163 0153 9B020000 		.4byte	.LASF34
 1164 0157 02       		.byte	0x2
 1165 0158 EE16     		.2byte	0x16ee
 1166 015a 03       		.byte	0x3
 1167 015b C8010000 		.4byte	0x1c8
 1168 015f 0A       		.uleb128 0xa
 1169 0160 4D000000 		.4byte	.LASF28
 1170 0164 02       		.byte	0x2
 1171 0165 EF16     		.2byte	0x16ef
 1172 0167 40010000 		.4byte	0x140
 1173 016b 0B       		.uleb128 0xb
 1174 016c 4C00     		.ascii	"L\000"
 1175 016e 02       		.byte	0x2
 1176 016f F016     		.2byte	0x16f0
 1177 0171 97000000 		.4byte	0x97
 1178 0175 0A       		.uleb128 0xa
 1179 0176 E0010000 		.4byte	.LASF29
 1180 017a 02       		.byte	0x2
 1181 017b F116     		.2byte	0x16f1
 1182 017d E2000000 		.4byte	0xe2
 1183 0181 0A       		.uleb128 0xa
 1184 0182 A6010000 		.4byte	.LASF30
 1185 0186 02       		.byte	0x2
 1186 0187 F216     		.2byte	0x16f2
 1187 0189 97000000 		.4byte	0x97
 1188 018d 0B       		.uleb128 0xb
 1189 018e 73726300 		.ascii	"src\000"
 1190 0192 02       		.byte	0x2
 1191 0193 F316     		.2byte	0x16f3
 1192 0195 C8010000 		.4byte	0x1c8
 1193 0199 0A       		.uleb128 0xa
 1194 019a 80000000 		.4byte	.LASF31
 1195 019e 02       		.byte	0x2
 1196 019f F416     		.2byte	0x16f4
 1197 01a1 97000000 		.4byte	0x97
 1198 01a5 0A       		.uleb128 0xa
 1199 01a6 EB020000 		.4byte	.LASF32
 1200 01aa 02       		.byte	0x2
 1201 01ab F516     		.2byte	0x16f5
 1202 01ad A2000000 		.4byte	0xa2
 1203 01b1 0C       		.uleb128 0xc
 1204 01b2 6900     		.ascii	"i\000"
 1205 01b4 02       		.byte	0x2
 1206 01b5 F716     		.2byte	0x16f7
 1207 01b7 A2000000 		.4byte	0xa2
 1208 01bb 0D       		.uleb128 0xd
 1209 01bc 05030000 		.4byte	.LASF33
 1210 01c0 02       		.byte	0x2
 1211 01c1 F816     		.2byte	0x16f8
 1212 01c3 97000000 		.4byte	0x97
 1213 01c7 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 135


 1214 01c8 06       		.uleb128 0x6
 1215 01c9 04       		.byte	0x4
 1216 01ca CE010000 		.4byte	0x1ce
 1217 01ce 0E       		.uleb128 0xe
 1218 01cf 97000000 		.4byte	0x97
 1219 01d3 09       		.uleb128 0x9
 1220 01d4 22030000 		.4byte	.LASF35
 1221 01d8 02       		.byte	0x2
 1222 01d9 1B17     		.2byte	0x171b
 1223 01db 03       		.byte	0x3
 1224 01dc 6D020000 		.4byte	0x26d
 1225 01e0 0A       		.uleb128 0xa
 1226 01e1 4D000000 		.4byte	.LASF28
 1227 01e5 02       		.byte	0x2
 1228 01e6 1C17     		.2byte	0x171c
 1229 01e8 40010000 		.4byte	0x140
 1230 01ec 0B       		.uleb128 0xb
 1231 01ed 4C00     		.ascii	"L\000"
 1232 01ef 02       		.byte	0x2
 1233 01f0 1D17     		.2byte	0x171d
 1234 01f2 97000000 		.4byte	0x97
 1235 01f6 0A       		.uleb128 0xa
 1236 01f7 D7000000 		.4byte	.LASF36
 1237 01fb 02       		.byte	0x2
 1238 01fc 1E17     		.2byte	0x171e
 1239 01fe 40010000 		.4byte	0x140
 1240 0202 0A       		.uleb128 0xa
 1241 0203 A6010000 		.4byte	.LASF30
 1242 0207 02       		.byte	0x2
 1243 0208 1F17     		.2byte	0x171f
 1244 020a 97000000 		.4byte	0x97
 1245 020e 0B       		.uleb128 0xb
 1246 020f 64737400 		.ascii	"dst\000"
 1247 0213 02       		.byte	0x2
 1248 0214 2017     		.2byte	0x1720
 1249 0216 40010000 		.4byte	0x140
 1250 021a 0A       		.uleb128 0xa
 1251 021b A2000000 		.4byte	.LASF37
 1252 021f 02       		.byte	0x2
 1253 0220 2117     		.2byte	0x1721
 1254 0222 40010000 		.4byte	0x140
 1255 0226 0A       		.uleb128 0xa
 1256 0227 E0020000 		.4byte	.LASF38
 1257 022b 02       		.byte	0x2
 1258 022c 2217     		.2byte	0x1722
 1259 022e 97000000 		.4byte	0x97
 1260 0232 0A       		.uleb128 0xa
 1261 0233 EC010000 		.4byte	.LASF39
 1262 0237 02       		.byte	0x2
 1263 0238 2317     		.2byte	0x1723
 1264 023a 97000000 		.4byte	0x97
 1265 023e 0A       		.uleb128 0xa
 1266 023f EB020000 		.4byte	.LASF32
 1267 0243 02       		.byte	0x2
 1268 0244 2417     		.2byte	0x1724
 1269 0246 A2000000 		.4byte	0xa2
 1270 024a 0C       		.uleb128 0xc
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 136


 1271 024b 6900     		.ascii	"i\000"
 1272 024d 02       		.byte	0x2
 1273 024e 2617     		.2byte	0x1726
 1274 0250 A2000000 		.4byte	0xa2
 1275 0254 0D       		.uleb128 0xd
 1276 0255 99010000 		.4byte	.LASF40
 1277 0259 02       		.byte	0x2
 1278 025a 2717     		.2byte	0x1727
 1279 025c 97000000 		.4byte	0x97
 1280 0260 0D       		.uleb128 0xd
 1281 0261 F5020000 		.4byte	.LASF41
 1282 0265 02       		.byte	0x2
 1283 0266 2717     		.2byte	0x1727
 1284 0268 97000000 		.4byte	0x97
 1285 026c 00       		.byte	0
 1286 026d 0F       		.uleb128 0xf
 1287 026e B8000000 		.4byte	.LASF54
 1288 0272 01       		.byte	0x1
 1289 0273 70       		.byte	0x70
 1290 0274 00000000 		.4byte	.LFB82
 1291 0278 50060000 		.4byte	.LFE82-.LFB82
 1292 027c 01       		.uleb128 0x1
 1293 027d 9C       		.byte	0x9c
 1294 027e 8A050000 		.4byte	0x58a
 1295 0282 10       		.uleb128 0x10
 1296 0283 5300     		.ascii	"S\000"
 1297 0285 01       		.byte	0x1
 1298 0286 71       		.byte	0x71
 1299 0287 8A050000 		.4byte	0x58a
 1300 028b 03       		.uleb128 0x3
 1301 028c 91       		.byte	0x91
 1302 028d 847E     		.sleb128 -252
 1303 028f 11       		.uleb128 0x11
 1304 0290 CB000000 		.4byte	.LASF42
 1305 0294 01       		.byte	0x1
 1306 0295 72       		.byte	0x72
 1307 0296 DC000000 		.4byte	0xdc
 1308 029a 03       		.uleb128 0x3
 1309 029b 91       		.byte	0x91
 1310 029c 807E     		.sleb128 -256
 1311 029e 11       		.uleb128 0x11
 1312 029f 7B000000 		.4byte	.LASF43
 1313 02a3 01       		.byte	0x1
 1314 02a4 73       		.byte	0x73
 1315 02a5 DC000000 		.4byte	0xdc
 1316 02a9 03       		.uleb128 0x3
 1317 02aa 91       		.byte	0x91
 1318 02ab FC7D     		.sleb128 -260
 1319 02ad 11       		.uleb128 0x11
 1320 02ae 0D030000 		.4byte	.LASF44
 1321 02b2 01       		.byte	0x1
 1322 02b3 74       		.byte	0x74
 1323 02b4 DC000000 		.4byte	0xdc
 1324 02b8 03       		.uleb128 0x3
 1325 02b9 91       		.byte	0x91
 1326 02ba F87D     		.sleb128 -264
 1327 02bc 11       		.uleb128 0x11
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 137


 1328 02bd EB020000 		.4byte	.LASF32
 1329 02c1 01       		.byte	0x1
 1330 02c2 75       		.byte	0x75
 1331 02c3 A2000000 		.4byte	0xa2
 1332 02c7 02       		.uleb128 0x2
 1333 02c8 91       		.byte	0x91
 1334 02c9 00       		.sleb128 0
 1335 02ca 12       		.uleb128 0x12
 1336 02cb 09020000 		.4byte	.LASF23
 1337 02cf 01       		.byte	0x1
 1338 02d0 78       		.byte	0x78
 1339 02d1 DC000000 		.4byte	0xdc
 1340 02d5 02       		.uleb128 0x2
 1341 02d6 91       		.byte	0x91
 1342 02d7 50       		.sleb128 -48
 1343 02d8 12       		.uleb128 0x12
 1344 02d9 FD020000 		.4byte	.LASF24
 1345 02dd 01       		.byte	0x1
 1346 02de 79       		.byte	0x79
 1347 02df DC000000 		.4byte	0xdc
 1348 02e3 02       		.uleb128 0x2
 1349 02e4 91       		.byte	0x91
 1350 02e5 6C       		.sleb128 -20
 1351 02e6 13       		.uleb128 0x13
 1352 02e7 707800   		.ascii	"px\000"
 1353 02ea 01       		.byte	0x1
 1354 02eb 7A       		.byte	0x7a
 1355 02ec DC000000 		.4byte	0xdc
 1356 02f0 02       		.uleb128 0x2
 1357 02f1 91       		.byte	0x91
 1358 02f2 68       		.sleb128 -24
 1359 02f3 13       		.uleb128 0x13
 1360 02f4 707900   		.ascii	"py\000"
 1361 02f7 01       		.byte	0x1
 1362 02f8 7B       		.byte	0x7b
 1363 02f9 DC000000 		.4byte	0xdc
 1364 02fd 02       		.uleb128 0x2
 1365 02fe 91       		.byte	0x91
 1366 02ff 4C       		.sleb128 -52
 1367 0300 13       		.uleb128 0x13
 1368 0301 706200   		.ascii	"pb\000"
 1369 0304 01       		.byte	0x1
 1370 0305 7C       		.byte	0x7c
 1371 0306 DC000000 		.4byte	0xdc
 1372 030a 02       		.uleb128 0x2
 1373 030b 91       		.byte	0x91
 1374 030c 48       		.sleb128 -56
 1375 030d 12       		.uleb128 0x12
 1376 030e A1010000 		.4byte	.LASF45
 1377 0312 01       		.byte	0x1
 1378 0313 7D       		.byte	0x7d
 1379 0314 DC000000 		.4byte	0xdc
 1380 0318 02       		.uleb128 0x2
 1381 0319 91       		.byte	0x91
 1382 031a 64       		.sleb128 -28
 1383 031b 12       		.uleb128 0x12
 1384 031c D6010000 		.4byte	.LASF26
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 138


 1385 0320 01       		.byte	0x1
 1386 0321 7E       		.byte	0x7e
 1387 0322 40010000 		.4byte	0x140
 1388 0326 02       		.uleb128 0x2
 1389 0327 91       		.byte	0x91
 1390 0328 60       		.sleb128 -32
 1391 0329 12       		.uleb128 0x12
 1392 032a 18030000 		.4byte	.LASF46
 1393 032e 01       		.byte	0x1
 1394 032f 7F       		.byte	0x7f
 1395 0330 A2000000 		.4byte	0xa2
 1396 0334 02       		.uleb128 0x2
 1397 0335 91       		.byte	0x91
 1398 0336 44       		.sleb128 -60
 1399 0337 12       		.uleb128 0x12
 1400 0338 69020000 		.4byte	.LASF21
 1401 033c 01       		.byte	0x1
 1402 033d 80       		.byte	0x80
 1403 033e 8C000000 		.4byte	0x8c
 1404 0342 02       		.uleb128 0x2
 1405 0343 91       		.byte	0x91
 1406 0344 42       		.sleb128 -62
 1407 0345 12       		.uleb128 0x12
 1408 0346 D0020000 		.4byte	.LASF47
 1409 034a 01       		.byte	0x1
 1410 034b 81       		.byte	0x81
 1411 034c 97000000 		.4byte	0x97
 1412 0350 03       		.uleb128 0x3
 1413 0351 91       		.byte	0x91
 1414 0352 887E     		.sleb128 -248
 1415 0354 12       		.uleb128 0x12
 1416 0355 D0000000 		.4byte	.LASF48
 1417 0359 01       		.byte	0x1
 1418 035a 82       		.byte	0x82
 1419 035b A2000000 		.4byte	0xa2
 1420 035f 02       		.uleb128 0x2
 1421 0360 91       		.byte	0x91
 1422 0361 5C       		.sleb128 -36
 1423 0362 12       		.uleb128 0x12
 1424 0363 46000000 		.4byte	.LASF49
 1425 0367 01       		.byte	0x1
 1426 0368 82       		.byte	0x82
 1427 0369 A2000000 		.4byte	0xa2
 1428 036d 02       		.uleb128 0x2
 1429 036e 91       		.byte	0x91
 1430 036f 58       		.sleb128 -40
 1431 0370 12       		.uleb128 0x12
 1432 0371 DA020000 		.4byte	.LASF50
 1433 0375 01       		.byte	0x1
 1434 0376 83       		.byte	0x83
 1435 0377 D0000000 		.4byte	0xd0
 1436 037b 02       		.uleb128 0x2
 1437 037c 91       		.byte	0x91
 1438 037d 54       		.sleb128 -44
 1439 037e 14       		.uleb128 0x14
 1440 037f 52010000 		.4byte	0x152
 1441 0383 BE000000 		.4byte	.LBB10
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 139


 1442 0387 B4000000 		.4byte	.LBE10-.LBB10
 1443 038b 01       		.byte	0x1
 1444 038c 89       		.byte	0x89
 1445 038d ED030000 		.4byte	0x3ed
 1446 0391 15       		.uleb128 0x15
 1447 0392 A5010000 		.4byte	0x1a5
 1448 0396 03       		.uleb128 0x3
 1449 0397 91       		.byte	0x91
 1450 0398 A47F     		.sleb128 -92
 1451 039a 15       		.uleb128 0x15
 1452 039b 99010000 		.4byte	0x199
 1453 039f 03       		.uleb128 0x3
 1454 03a0 91       		.byte	0x91
 1455 03a1 A87F     		.sleb128 -88
 1456 03a3 15       		.uleb128 0x15
 1457 03a4 8D010000 		.4byte	0x18d
 1458 03a8 03       		.uleb128 0x3
 1459 03a9 91       		.byte	0x91
 1460 03aa AC7F     		.sleb128 -84
 1461 03ac 15       		.uleb128 0x15
 1462 03ad 81010000 		.4byte	0x181
 1463 03b1 03       		.uleb128 0x3
 1464 03b2 91       		.byte	0x91
 1465 03b3 B07F     		.sleb128 -80
 1466 03b5 15       		.uleb128 0x15
 1467 03b6 75010000 		.4byte	0x175
 1468 03ba 03       		.uleb128 0x3
 1469 03bb 91       		.byte	0x91
 1470 03bc B47F     		.sleb128 -76
 1471 03be 15       		.uleb128 0x15
 1472 03bf 6B010000 		.4byte	0x16b
 1473 03c3 03       		.uleb128 0x3
 1474 03c4 91       		.byte	0x91
 1475 03c5 B87F     		.sleb128 -72
 1476 03c7 15       		.uleb128 0x15
 1477 03c8 5F010000 		.4byte	0x15f
 1478 03cc 03       		.uleb128 0x3
 1479 03cd 91       		.byte	0x91
 1480 03ce BC7F     		.sleb128 -68
 1481 03d0 16       		.uleb128 0x16
 1482 03d1 BE000000 		.4byte	.LBB11
 1483 03d5 B4000000 		.4byte	.LBE11-.LBB11
 1484 03d9 17       		.uleb128 0x17
 1485 03da B1010000 		.4byte	0x1b1
 1486 03de 03       		.uleb128 0x3
 1487 03df 91       		.byte	0x91
 1488 03e0 A07F     		.sleb128 -96
 1489 03e2 17       		.uleb128 0x17
 1490 03e3 BB010000 		.4byte	0x1bb
 1491 03e7 03       		.uleb128 0x3
 1492 03e8 91       		.byte	0x91
 1493 03e9 9C7F     		.sleb128 -100
 1494 03eb 00       		.byte	0
 1495 03ec 00       		.byte	0
 1496 03ed 14       		.uleb128 0x14
 1497 03ee D3010000 		.4byte	0x1d3
 1498 03f2 1A020000 		.4byte	.LBB12
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 140


 1499 03f6 A8000000 		.4byte	.LBE12-.LBB12
 1500 03fa 01       		.byte	0x1
 1501 03fb 9A       		.byte	0x9a
 1502 03fc 77040000 		.4byte	0x477
 1503 0400 15       		.uleb128 0x15
 1504 0401 3E020000 		.4byte	0x23e
 1505 0405 03       		.uleb128 0x3
 1506 0406 91       		.byte	0x91
 1507 0407 F87E     		.sleb128 -136
 1508 0409 15       		.uleb128 0x15
 1509 040a 32020000 		.4byte	0x232
 1510 040e 03       		.uleb128 0x3
 1511 040f 91       		.byte	0x91
 1512 0410 FC7E     		.sleb128 -132
 1513 0412 15       		.uleb128 0x15
 1514 0413 26020000 		.4byte	0x226
 1515 0417 03       		.uleb128 0x3
 1516 0418 91       		.byte	0x91
 1517 0419 807F     		.sleb128 -128
 1518 041b 15       		.uleb128 0x15
 1519 041c 1A020000 		.4byte	0x21a
 1520 0420 03       		.uleb128 0x3
 1521 0421 91       		.byte	0x91
 1522 0422 847F     		.sleb128 -124
 1523 0424 15       		.uleb128 0x15
 1524 0425 0E020000 		.4byte	0x20e
 1525 0429 03       		.uleb128 0x3
 1526 042a 91       		.byte	0x91
 1527 042b 887F     		.sleb128 -120
 1528 042d 15       		.uleb128 0x15
 1529 042e 02020000 		.4byte	0x202
 1530 0432 03       		.uleb128 0x3
 1531 0433 91       		.byte	0x91
 1532 0434 8C7F     		.sleb128 -116
 1533 0436 15       		.uleb128 0x15
 1534 0437 F6010000 		.4byte	0x1f6
 1535 043b 03       		.uleb128 0x3
 1536 043c 91       		.byte	0x91
 1537 043d 907F     		.sleb128 -112
 1538 043f 15       		.uleb128 0x15
 1539 0440 EC010000 		.4byte	0x1ec
 1540 0444 03       		.uleb128 0x3
 1541 0445 91       		.byte	0x91
 1542 0446 947F     		.sleb128 -108
 1543 0448 15       		.uleb128 0x15
 1544 0449 E0010000 		.4byte	0x1e0
 1545 044d 03       		.uleb128 0x3
 1546 044e 91       		.byte	0x91
 1547 044f 987F     		.sleb128 -104
 1548 0451 16       		.uleb128 0x16
 1549 0452 1A020000 		.4byte	.LBB13
 1550 0456 A8000000 		.4byte	.LBE13-.LBB13
 1551 045a 17       		.uleb128 0x17
 1552 045b 4A020000 		.4byte	0x24a
 1553 045f 03       		.uleb128 0x3
 1554 0460 91       		.byte	0x91
 1555 0461 F47E     		.sleb128 -140
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 141


 1556 0463 17       		.uleb128 0x17
 1557 0464 54020000 		.4byte	0x254
 1558 0468 03       		.uleb128 0x3
 1559 0469 91       		.byte	0x91
 1560 046a F07E     		.sleb128 -144
 1561 046c 17       		.uleb128 0x17
 1562 046d 60020000 		.4byte	0x260
 1563 0471 03       		.uleb128 0x3
 1564 0472 91       		.byte	0x91
 1565 0473 EC7E     		.sleb128 -148
 1566 0475 00       		.byte	0
 1567 0476 00       		.byte	0
 1568 0477 18       		.uleb128 0x18
 1569 0478 D3010000 		.4byte	0x1d3
 1570 047c D6030000 		.4byte	.LBB14
 1571 0480 68000000 		.4byte	.LBE14-.LBB14
 1572 0484 01       		.byte	0x1
 1573 0485 6901     		.2byte	0x169
 1574 0487 02050000 		.4byte	0x502
 1575 048b 15       		.uleb128 0x15
 1576 048c 3E020000 		.4byte	0x23e
 1577 0490 03       		.uleb128 0x3
 1578 0491 91       		.byte	0x91
 1579 0492 C87E     		.sleb128 -184
 1580 0494 15       		.uleb128 0x15
 1581 0495 32020000 		.4byte	0x232
 1582 0499 03       		.uleb128 0x3
 1583 049a 91       		.byte	0x91
 1584 049b CC7E     		.sleb128 -180
 1585 049d 15       		.uleb128 0x15
 1586 049e 26020000 		.4byte	0x226
 1587 04a2 03       		.uleb128 0x3
 1588 04a3 91       		.byte	0x91
 1589 04a4 D07E     		.sleb128 -176
 1590 04a6 15       		.uleb128 0x15
 1591 04a7 1A020000 		.4byte	0x21a
 1592 04ab 03       		.uleb128 0x3
 1593 04ac 91       		.byte	0x91
 1594 04ad D47E     		.sleb128 -172
 1595 04af 15       		.uleb128 0x15
 1596 04b0 0E020000 		.4byte	0x20e
 1597 04b4 03       		.uleb128 0x3
 1598 04b5 91       		.byte	0x91
 1599 04b6 D87E     		.sleb128 -168
 1600 04b8 15       		.uleb128 0x15
 1601 04b9 02020000 		.4byte	0x202
 1602 04bd 03       		.uleb128 0x3
 1603 04be 91       		.byte	0x91
 1604 04bf DC7E     		.sleb128 -164
 1605 04c1 15       		.uleb128 0x15
 1606 04c2 F6010000 		.4byte	0x1f6
 1607 04c6 03       		.uleb128 0x3
 1608 04c7 91       		.byte	0x91
 1609 04c8 E07E     		.sleb128 -160
 1610 04ca 15       		.uleb128 0x15
 1611 04cb EC010000 		.4byte	0x1ec
 1612 04cf 03       		.uleb128 0x3
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 142


 1613 04d0 91       		.byte	0x91
 1614 04d1 E47E     		.sleb128 -156
 1615 04d3 15       		.uleb128 0x15
 1616 04d4 E0010000 		.4byte	0x1e0
 1617 04d8 03       		.uleb128 0x3
 1618 04d9 91       		.byte	0x91
 1619 04da E87E     		.sleb128 -152
 1620 04dc 16       		.uleb128 0x16
 1621 04dd D6030000 		.4byte	.LBB15
 1622 04e1 68000000 		.4byte	.LBE15-.LBB15
 1623 04e5 17       		.uleb128 0x17
 1624 04e6 4A020000 		.4byte	0x24a
 1625 04ea 03       		.uleb128 0x3
 1626 04eb 91       		.byte	0x91
 1627 04ec C47E     		.sleb128 -188
 1628 04ee 17       		.uleb128 0x17
 1629 04ef 54020000 		.4byte	0x254
 1630 04f3 03       		.uleb128 0x3
 1631 04f4 91       		.byte	0x91
 1632 04f5 C07E     		.sleb128 -192
 1633 04f7 17       		.uleb128 0x17
 1634 04f8 60020000 		.4byte	0x260
 1635 04fc 03       		.uleb128 0x3
 1636 04fd 91       		.byte	0x91
 1637 04fe BC7E     		.sleb128 -196
 1638 0500 00       		.byte	0
 1639 0501 00       		.byte	0
 1640 0502 19       		.uleb128 0x19
 1641 0503 D3010000 		.4byte	0x1d3
 1642 0507 6A050000 		.4byte	.LBB16
 1643 050b 68000000 		.4byte	.LBE16-.LBB16
 1644 050f 01       		.byte	0x1
 1645 0510 9601     		.2byte	0x196
 1646 0512 15       		.uleb128 0x15
 1647 0513 3E020000 		.4byte	0x23e
 1648 0517 03       		.uleb128 0x3
 1649 0518 91       		.byte	0x91
 1650 0519 987E     		.sleb128 -232
 1651 051b 15       		.uleb128 0x15
 1652 051c 32020000 		.4byte	0x232
 1653 0520 03       		.uleb128 0x3
 1654 0521 91       		.byte	0x91
 1655 0522 9C7E     		.sleb128 -228
 1656 0524 15       		.uleb128 0x15
 1657 0525 26020000 		.4byte	0x226
 1658 0529 03       		.uleb128 0x3
 1659 052a 91       		.byte	0x91
 1660 052b A07E     		.sleb128 -224
 1661 052d 15       		.uleb128 0x15
 1662 052e 1A020000 		.4byte	0x21a
 1663 0532 03       		.uleb128 0x3
 1664 0533 91       		.byte	0x91
 1665 0534 A47E     		.sleb128 -220
 1666 0536 15       		.uleb128 0x15
 1667 0537 0E020000 		.4byte	0x20e
 1668 053b 03       		.uleb128 0x3
 1669 053c 91       		.byte	0x91
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 143


 1670 053d A87E     		.sleb128 -216
 1671 053f 15       		.uleb128 0x15
 1672 0540 02020000 		.4byte	0x202
 1673 0544 03       		.uleb128 0x3
 1674 0545 91       		.byte	0x91
 1675 0546 AC7E     		.sleb128 -212
 1676 0548 15       		.uleb128 0x15
 1677 0549 F6010000 		.4byte	0x1f6
 1678 054d 03       		.uleb128 0x3
 1679 054e 91       		.byte	0x91
 1680 054f B07E     		.sleb128 -208
 1681 0551 15       		.uleb128 0x15
 1682 0552 EC010000 		.4byte	0x1ec
 1683 0556 03       		.uleb128 0x3
 1684 0557 91       		.byte	0x91
 1685 0558 B47E     		.sleb128 -204
 1686 055a 15       		.uleb128 0x15
 1687 055b E0010000 		.4byte	0x1e0
 1688 055f 03       		.uleb128 0x3
 1689 0560 91       		.byte	0x91
 1690 0561 B87E     		.sleb128 -200
 1691 0563 16       		.uleb128 0x16
 1692 0564 6A050000 		.4byte	.LBB17
 1693 0568 68000000 		.4byte	.LBE17-.LBB17
 1694 056c 17       		.uleb128 0x17
 1695 056d 4A020000 		.4byte	0x24a
 1696 0571 03       		.uleb128 0x3
 1697 0572 91       		.byte	0x91
 1698 0573 947E     		.sleb128 -236
 1699 0575 17       		.uleb128 0x17
 1700 0576 54020000 		.4byte	0x254
 1701 057a 03       		.uleb128 0x3
 1702 057b 91       		.byte	0x91
 1703 057c 907E     		.sleb128 -240
 1704 057e 17       		.uleb128 0x17
 1705 057f 60020000 		.4byte	0x260
 1706 0583 03       		.uleb128 0x3
 1707 0584 91       		.byte	0x91
 1708 0585 8C7E     		.sleb128 -244
 1709 0587 00       		.byte	0
 1710 0588 00       		.byte	0
 1711 0589 00       		.byte	0
 1712 058a 06       		.uleb128 0x6
 1713 058b 04       		.byte	0x4
 1714 058c 46010000 		.4byte	0x146
 1715 0590 00       		.byte	0
 1716              		.section	.debug_abbrev,"",%progbits
 1717              	.Ldebug_abbrev0:
 1718 0000 01       		.uleb128 0x1
 1719 0001 11       		.uleb128 0x11
 1720 0002 01       		.byte	0x1
 1721 0003 25       		.uleb128 0x25
 1722 0004 0E       		.uleb128 0xe
 1723 0005 13       		.uleb128 0x13
 1724 0006 0B       		.uleb128 0xb
 1725 0007 03       		.uleb128 0x3
 1726 0008 0E       		.uleb128 0xe
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 144


 1727 0009 1B       		.uleb128 0x1b
 1728 000a 0E       		.uleb128 0xe
 1729 000b 55       		.uleb128 0x55
 1730 000c 17       		.uleb128 0x17
 1731 000d 11       		.uleb128 0x11
 1732 000e 01       		.uleb128 0x1
 1733 000f 10       		.uleb128 0x10
 1734 0010 17       		.uleb128 0x17
 1735 0011 00       		.byte	0
 1736 0012 00       		.byte	0
 1737 0013 02       		.uleb128 0x2
 1738 0014 24       		.uleb128 0x24
 1739 0015 00       		.byte	0
 1740 0016 0B       		.uleb128 0xb
 1741 0017 0B       		.uleb128 0xb
 1742 0018 3E       		.uleb128 0x3e
 1743 0019 0B       		.uleb128 0xb
 1744 001a 03       		.uleb128 0x3
 1745 001b 0E       		.uleb128 0xe
 1746 001c 00       		.byte	0
 1747 001d 00       		.byte	0
 1748 001e 03       		.uleb128 0x3
 1749 001f 16       		.uleb128 0x16
 1750 0020 00       		.byte	0
 1751 0021 03       		.uleb128 0x3
 1752 0022 0E       		.uleb128 0xe
 1753 0023 3A       		.uleb128 0x3a
 1754 0024 0B       		.uleb128 0xb
 1755 0025 3B       		.uleb128 0x3b
 1756 0026 0B       		.uleb128 0xb
 1757 0027 49       		.uleb128 0x49
 1758 0028 13       		.uleb128 0x13
 1759 0029 00       		.byte	0
 1760 002a 00       		.byte	0
 1761 002b 04       		.uleb128 0x4
 1762 002c 24       		.uleb128 0x24
 1763 002d 00       		.byte	0
 1764 002e 0B       		.uleb128 0xb
 1765 002f 0B       		.uleb128 0xb
 1766 0030 3E       		.uleb128 0x3e
 1767 0031 0B       		.uleb128 0xb
 1768 0032 03       		.uleb128 0x3
 1769 0033 08       		.uleb128 0x8
 1770 0034 00       		.byte	0
 1771 0035 00       		.byte	0
 1772 0036 05       		.uleb128 0x5
 1773 0037 16       		.uleb128 0x16
 1774 0038 00       		.byte	0
 1775 0039 03       		.uleb128 0x3
 1776 003a 0E       		.uleb128 0xe
 1777 003b 3A       		.uleb128 0x3a
 1778 003c 0B       		.uleb128 0xb
 1779 003d 3B       		.uleb128 0x3b
 1780 003e 05       		.uleb128 0x5
 1781 003f 49       		.uleb128 0x49
 1782 0040 13       		.uleb128 0x13
 1783 0041 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 145


 1784 0042 00       		.byte	0
 1785 0043 06       		.uleb128 0x6
 1786 0044 0F       		.uleb128 0xf
 1787 0045 00       		.byte	0
 1788 0046 0B       		.uleb128 0xb
 1789 0047 0B       		.uleb128 0xb
 1790 0048 49       		.uleb128 0x49
 1791 0049 13       		.uleb128 0x13
 1792 004a 00       		.byte	0
 1793 004b 00       		.byte	0
 1794 004c 07       		.uleb128 0x7
 1795 004d 13       		.uleb128 0x13
 1796 004e 01       		.byte	0x1
 1797 004f 0B       		.uleb128 0xb
 1798 0050 0B       		.uleb128 0xb
 1799 0051 3A       		.uleb128 0x3a
 1800 0052 0B       		.uleb128 0xb
 1801 0053 3B       		.uleb128 0x3b
 1802 0054 05       		.uleb128 0x5
 1803 0055 01       		.uleb128 0x1
 1804 0056 13       		.uleb128 0x13
 1805 0057 00       		.byte	0
 1806 0058 00       		.byte	0
 1807 0059 08       		.uleb128 0x8
 1808 005a 0D       		.uleb128 0xd
 1809 005b 00       		.byte	0
 1810 005c 03       		.uleb128 0x3
 1811 005d 0E       		.uleb128 0xe
 1812 005e 3A       		.uleb128 0x3a
 1813 005f 0B       		.uleb128 0xb
 1814 0060 3B       		.uleb128 0x3b
 1815 0061 05       		.uleb128 0x5
 1816 0062 49       		.uleb128 0x49
 1817 0063 13       		.uleb128 0x13
 1818 0064 38       		.uleb128 0x38
 1819 0065 0B       		.uleb128 0xb
 1820 0066 00       		.byte	0
 1821 0067 00       		.byte	0
 1822 0068 09       		.uleb128 0x9
 1823 0069 2E       		.uleb128 0x2e
 1824 006a 01       		.byte	0x1
 1825 006b 03       		.uleb128 0x3
 1826 006c 0E       		.uleb128 0xe
 1827 006d 3A       		.uleb128 0x3a
 1828 006e 0B       		.uleb128 0xb
 1829 006f 3B       		.uleb128 0x3b
 1830 0070 05       		.uleb128 0x5
 1831 0071 27       		.uleb128 0x27
 1832 0072 19       		.uleb128 0x19
 1833 0073 20       		.uleb128 0x20
 1834 0074 0B       		.uleb128 0xb
 1835 0075 01       		.uleb128 0x1
 1836 0076 13       		.uleb128 0x13
 1837 0077 00       		.byte	0
 1838 0078 00       		.byte	0
 1839 0079 0A       		.uleb128 0xa
 1840 007a 05       		.uleb128 0x5
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 146


 1841 007b 00       		.byte	0
 1842 007c 03       		.uleb128 0x3
 1843 007d 0E       		.uleb128 0xe
 1844 007e 3A       		.uleb128 0x3a
 1845 007f 0B       		.uleb128 0xb
 1846 0080 3B       		.uleb128 0x3b
 1847 0081 05       		.uleb128 0x5
 1848 0082 49       		.uleb128 0x49
 1849 0083 13       		.uleb128 0x13
 1850 0084 00       		.byte	0
 1851 0085 00       		.byte	0
 1852 0086 0B       		.uleb128 0xb
 1853 0087 05       		.uleb128 0x5
 1854 0088 00       		.byte	0
 1855 0089 03       		.uleb128 0x3
 1856 008a 08       		.uleb128 0x8
 1857 008b 3A       		.uleb128 0x3a
 1858 008c 0B       		.uleb128 0xb
 1859 008d 3B       		.uleb128 0x3b
 1860 008e 05       		.uleb128 0x5
 1861 008f 49       		.uleb128 0x49
 1862 0090 13       		.uleb128 0x13
 1863 0091 00       		.byte	0
 1864 0092 00       		.byte	0
 1865 0093 0C       		.uleb128 0xc
 1866 0094 34       		.uleb128 0x34
 1867 0095 00       		.byte	0
 1868 0096 03       		.uleb128 0x3
 1869 0097 08       		.uleb128 0x8
 1870 0098 3A       		.uleb128 0x3a
 1871 0099 0B       		.uleb128 0xb
 1872 009a 3B       		.uleb128 0x3b
 1873 009b 05       		.uleb128 0x5
 1874 009c 49       		.uleb128 0x49
 1875 009d 13       		.uleb128 0x13
 1876 009e 00       		.byte	0
 1877 009f 00       		.byte	0
 1878 00a0 0D       		.uleb128 0xd
 1879 00a1 34       		.uleb128 0x34
 1880 00a2 00       		.byte	0
 1881 00a3 03       		.uleb128 0x3
 1882 00a4 0E       		.uleb128 0xe
 1883 00a5 3A       		.uleb128 0x3a
 1884 00a6 0B       		.uleb128 0xb
 1885 00a7 3B       		.uleb128 0x3b
 1886 00a8 05       		.uleb128 0x5
 1887 00a9 49       		.uleb128 0x49
 1888 00aa 13       		.uleb128 0x13
 1889 00ab 00       		.byte	0
 1890 00ac 00       		.byte	0
 1891 00ad 0E       		.uleb128 0xe
 1892 00ae 26       		.uleb128 0x26
 1893 00af 00       		.byte	0
 1894 00b0 49       		.uleb128 0x49
 1895 00b1 13       		.uleb128 0x13
 1896 00b2 00       		.byte	0
 1897 00b3 00       		.byte	0
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 147


 1898 00b4 0F       		.uleb128 0xf
 1899 00b5 2E       		.uleb128 0x2e
 1900 00b6 01       		.byte	0x1
 1901 00b7 3F       		.uleb128 0x3f
 1902 00b8 19       		.uleb128 0x19
 1903 00b9 03       		.uleb128 0x3
 1904 00ba 0E       		.uleb128 0xe
 1905 00bb 3A       		.uleb128 0x3a
 1906 00bc 0B       		.uleb128 0xb
 1907 00bd 3B       		.uleb128 0x3b
 1908 00be 0B       		.uleb128 0xb
 1909 00bf 27       		.uleb128 0x27
 1910 00c0 19       		.uleb128 0x19
 1911 00c1 11       		.uleb128 0x11
 1912 00c2 01       		.uleb128 0x1
 1913 00c3 12       		.uleb128 0x12
 1914 00c4 06       		.uleb128 0x6
 1915 00c5 40       		.uleb128 0x40
 1916 00c6 18       		.uleb128 0x18
 1917 00c7 9642     		.uleb128 0x2116
 1918 00c9 19       		.uleb128 0x19
 1919 00ca 01       		.uleb128 0x1
 1920 00cb 13       		.uleb128 0x13
 1921 00cc 00       		.byte	0
 1922 00cd 00       		.byte	0
 1923 00ce 10       		.uleb128 0x10
 1924 00cf 05       		.uleb128 0x5
 1925 00d0 00       		.byte	0
 1926 00d1 03       		.uleb128 0x3
 1927 00d2 08       		.uleb128 0x8
 1928 00d3 3A       		.uleb128 0x3a
 1929 00d4 0B       		.uleb128 0xb
 1930 00d5 3B       		.uleb128 0x3b
 1931 00d6 0B       		.uleb128 0xb
 1932 00d7 49       		.uleb128 0x49
 1933 00d8 13       		.uleb128 0x13
 1934 00d9 02       		.uleb128 0x2
 1935 00da 18       		.uleb128 0x18
 1936 00db 00       		.byte	0
 1937 00dc 00       		.byte	0
 1938 00dd 11       		.uleb128 0x11
 1939 00de 05       		.uleb128 0x5
 1940 00df 00       		.byte	0
 1941 00e0 03       		.uleb128 0x3
 1942 00e1 0E       		.uleb128 0xe
 1943 00e2 3A       		.uleb128 0x3a
 1944 00e3 0B       		.uleb128 0xb
 1945 00e4 3B       		.uleb128 0x3b
 1946 00e5 0B       		.uleb128 0xb
 1947 00e6 49       		.uleb128 0x49
 1948 00e7 13       		.uleb128 0x13
 1949 00e8 02       		.uleb128 0x2
 1950 00e9 18       		.uleb128 0x18
 1951 00ea 00       		.byte	0
 1952 00eb 00       		.byte	0
 1953 00ec 12       		.uleb128 0x12
 1954 00ed 34       		.uleb128 0x34
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 148


 1955 00ee 00       		.byte	0
 1956 00ef 03       		.uleb128 0x3
 1957 00f0 0E       		.uleb128 0xe
 1958 00f1 3A       		.uleb128 0x3a
 1959 00f2 0B       		.uleb128 0xb
 1960 00f3 3B       		.uleb128 0x3b
 1961 00f4 0B       		.uleb128 0xb
 1962 00f5 49       		.uleb128 0x49
 1963 00f6 13       		.uleb128 0x13
 1964 00f7 02       		.uleb128 0x2
 1965 00f8 18       		.uleb128 0x18
 1966 00f9 00       		.byte	0
 1967 00fa 00       		.byte	0
 1968 00fb 13       		.uleb128 0x13
 1969 00fc 34       		.uleb128 0x34
 1970 00fd 00       		.byte	0
 1971 00fe 03       		.uleb128 0x3
 1972 00ff 08       		.uleb128 0x8
 1973 0100 3A       		.uleb128 0x3a
 1974 0101 0B       		.uleb128 0xb
 1975 0102 3B       		.uleb128 0x3b
 1976 0103 0B       		.uleb128 0xb
 1977 0104 49       		.uleb128 0x49
 1978 0105 13       		.uleb128 0x13
 1979 0106 02       		.uleb128 0x2
 1980 0107 18       		.uleb128 0x18
 1981 0108 00       		.byte	0
 1982 0109 00       		.byte	0
 1983 010a 14       		.uleb128 0x14
 1984 010b 1D       		.uleb128 0x1d
 1985 010c 01       		.byte	0x1
 1986 010d 31       		.uleb128 0x31
 1987 010e 13       		.uleb128 0x13
 1988 010f 11       		.uleb128 0x11
 1989 0110 01       		.uleb128 0x1
 1990 0111 12       		.uleb128 0x12
 1991 0112 06       		.uleb128 0x6
 1992 0113 58       		.uleb128 0x58
 1993 0114 0B       		.uleb128 0xb
 1994 0115 59       		.uleb128 0x59
 1995 0116 0B       		.uleb128 0xb
 1996 0117 01       		.uleb128 0x1
 1997 0118 13       		.uleb128 0x13
 1998 0119 00       		.byte	0
 1999 011a 00       		.byte	0
 2000 011b 15       		.uleb128 0x15
 2001 011c 05       		.uleb128 0x5
 2002 011d 00       		.byte	0
 2003 011e 31       		.uleb128 0x31
 2004 011f 13       		.uleb128 0x13
 2005 0120 02       		.uleb128 0x2
 2006 0121 18       		.uleb128 0x18
 2007 0122 00       		.byte	0
 2008 0123 00       		.byte	0
 2009 0124 16       		.uleb128 0x16
 2010 0125 0B       		.uleb128 0xb
 2011 0126 01       		.byte	0x1
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 149


 2012 0127 11       		.uleb128 0x11
 2013 0128 01       		.uleb128 0x1
 2014 0129 12       		.uleb128 0x12
 2015 012a 06       		.uleb128 0x6
 2016 012b 00       		.byte	0
 2017 012c 00       		.byte	0
 2018 012d 17       		.uleb128 0x17
 2019 012e 34       		.uleb128 0x34
 2020 012f 00       		.byte	0
 2021 0130 31       		.uleb128 0x31
 2022 0131 13       		.uleb128 0x13
 2023 0132 02       		.uleb128 0x2
 2024 0133 18       		.uleb128 0x18
 2025 0134 00       		.byte	0
 2026 0135 00       		.byte	0
 2027 0136 18       		.uleb128 0x18
 2028 0137 1D       		.uleb128 0x1d
 2029 0138 01       		.byte	0x1
 2030 0139 31       		.uleb128 0x31
 2031 013a 13       		.uleb128 0x13
 2032 013b 11       		.uleb128 0x11
 2033 013c 01       		.uleb128 0x1
 2034 013d 12       		.uleb128 0x12
 2035 013e 06       		.uleb128 0x6
 2036 013f 58       		.uleb128 0x58
 2037 0140 0B       		.uleb128 0xb
 2038 0141 59       		.uleb128 0x59
 2039 0142 05       		.uleb128 0x5
 2040 0143 01       		.uleb128 0x1
 2041 0144 13       		.uleb128 0x13
 2042 0145 00       		.byte	0
 2043 0146 00       		.byte	0
 2044 0147 19       		.uleb128 0x19
 2045 0148 1D       		.uleb128 0x1d
 2046 0149 01       		.byte	0x1
 2047 014a 31       		.uleb128 0x31
 2048 014b 13       		.uleb128 0x13
 2049 014c 11       		.uleb128 0x11
 2050 014d 01       		.uleb128 0x1
 2051 014e 12       		.uleb128 0x12
 2052 014f 06       		.uleb128 0x6
 2053 0150 58       		.uleb128 0x58
 2054 0151 0B       		.uleb128 0xb
 2055 0152 59       		.uleb128 0x59
 2056 0153 05       		.uleb128 0x5
 2057 0154 00       		.byte	0
 2058 0155 00       		.byte	0
 2059 0156 00       		.byte	0
 2060              		.section	.debug_aranges,"",%progbits
 2061 0000 1C000000 		.4byte	0x1c
 2062 0004 0200     		.2byte	0x2
 2063 0006 00000000 		.4byte	.Ldebug_info0
 2064 000a 04       		.byte	0x4
 2065 000b 00       		.byte	0
 2066 000c 0000     		.2byte	0
 2067 000e 0000     		.2byte	0
 2068 0010 00000000 		.4byte	.LFB82
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 150


 2069 0014 50060000 		.4byte	.LFE82-.LFB82
 2070 0018 00000000 		.4byte	0
 2071 001c 00000000 		.4byte	0
 2072              		.section	.debug_ranges,"",%progbits
 2073              	.Ldebug_ranges0:
 2074 0000 00000000 		.4byte	.LFB82
 2075 0004 50060000 		.4byte	.LFE82
 2076 0008 00000000 		.4byte	0
 2077 000c 00000000 		.4byte	0
 2078              		.section	.debug_line,"",%progbits
 2079              	.Ldebug_line0:
 2080 0000 2B020000 		.section	.debug_str,"MS",%progbits,1
 2080      02005501 
 2080      00000201 
 2080      FB0E0D00 
 2080      01010101 
 2081              	.LASF52:
 2082 0000 536F7572 		.ascii	"Source\\FilteringFunctions\\arm_fir_sparse_f32.c\000"
 2082      63655C46 
 2082      696C7465 
 2082      72696E67 
 2082      46756E63 
 2083              	.LASF10:
 2084 002f 6C6F6E67 		.ascii	"long long unsigned int\000"
 2084      206C6F6E 
 2084      6720756E 
 2084      7369676E 
 2084      65642069 
 2085              	.LASF49:
 2086 0046 626C6B43 		.ascii	"blkCnt\000"
 2086      6E7400
 2087              	.LASF28:
 2088 004d 63697263 		.ascii	"circBuffer\000"
 2088      42756666 
 2088      657200
 2089              	.LASF9:
 2090 0058 6C6F6E67 		.ascii	"long long int\000"
 2090      206C6F6E 
 2090      6720696E 
 2090      7400
 2091              	.LASF0:
 2092 0066 7369676E 		.ascii	"signed char\000"
 2092      65642063 
 2092      68617200 
 2093              	.LASF6:
 2094 0072 6C6F6E67 		.ascii	"long int\000"
 2094      20696E74 
 2094      00
 2095              	.LASF43:
 2096 007b 70447374 		.ascii	"pDst\000"
 2096      00
 2097              	.LASF31:
 2098 0080 73726349 		.ascii	"srcInc\000"
 2098      6E6300
 2099              	.LASF12:
 2100 0087 75696E74 		.ascii	"uint16_t\000"
 2100      31365F74 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 151


 2100      00
 2101              	.LASF17:
 2102 0090 646F7562 		.ascii	"double\000"
 2102      6C6500
 2103              	.LASF7:
 2104 0097 5F5F7569 		.ascii	"__uint32_t\000"
 2104      6E743332 
 2104      5F7400
 2105              	.LASF37:
 2106 00a2 6473745F 		.ascii	"dst_base\000"
 2106      62617365 
 2106      00
 2107              	.LASF11:
 2108 00ab 756E7369 		.ascii	"unsigned int\000"
 2108      676E6564 
 2108      20696E74 
 2108      00
 2109              	.LASF54:
 2110 00b8 61726D5F 		.ascii	"arm_fir_sparse_f32\000"
 2110      6669725F 
 2110      73706172 
 2110      73655F66 
 2110      333200
 2111              	.LASF42:
 2112 00cb 70537263 		.ascii	"pSrc\000"
 2112      00
 2113              	.LASF48:
 2114 00d0 74617043 		.ascii	"tapCnt\000"
 2114      6E7400
 2115              	.LASF36:
 2116 00d7 72656164 		.ascii	"readOffset\000"
 2116      4F666673 
 2116      657400
 2117              	.LASF8:
 2118 00e2 6C6F6E67 		.ascii	"long unsigned int\000"
 2118      20756E73 
 2118      69676E65 
 2118      6420696E 
 2118      7400
 2119              	.LASF51:
 2120 00f4 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 2120      4320342E 
 2120      392E3320 
 2120      32303135 
 2120      30333033 
 2121 0127 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0plus -mthumb -"
 2121      20726576 
 2121      6973696F 
 2121      6E203232 
 2121      31323230 
 2122 015a 67202D4F 		.ascii	"g -O0 -ffunction-sections -ffat-lto-objects\000"
 2122      30202D66 
 2122      66756E63 
 2122      74696F6E 
 2122      2D736563 
 2123              	.LASF3:
 2124 0186 73686F72 		.ascii	"short unsigned int\000"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 152


 2124      7420756E 
 2124      7369676E 
 2124      65642069 
 2124      6E7400
 2125              	.LASF40:
 2126 0199 724F6666 		.ascii	"rOffset\000"
 2126      73657400 
 2127              	.LASF45:
 2128 01a1 704F7574 		.ascii	"pOut\000"
 2128      00
 2129              	.LASF30:
 2130 01a6 62756666 		.ascii	"bufferInc\000"
 2130      6572496E 
 2130      6300
 2131              	.LASF15:
 2132 01b0 73697A65 		.ascii	"sizetype\000"
 2132      74797065 
 2132      00
 2133              	.LASF19:
 2134 01b9 6C6F6E67 		.ascii	"long double\000"
 2134      20646F75 
 2134      626C6500 
 2135              	.LASF22:
 2136 01c5 73746174 		.ascii	"stateIndex\000"
 2136      65496E64 
 2136      657800
 2137              	.LASF18:
 2138 01d0 666C6F61 		.ascii	"float\000"
 2138      7400
 2139              	.LASF26:
 2140 01d6 70546170 		.ascii	"pTapDelay\000"
 2140      44656C61 
 2140      7900
 2141              	.LASF29:
 2142 01e0 77726974 		.ascii	"writeOffset\000"
 2142      654F6666 
 2142      73657400 
 2143              	.LASF39:
 2144 01ec 64737449 		.ascii	"dstInc\000"
 2144      6E6300
 2145              	.LASF13:
 2146 01f3 696E7433 		.ascii	"int32_t\000"
 2146      325F7400 
 2147              	.LASF1:
 2148 01fb 756E7369 		.ascii	"unsigned char\000"
 2148      676E6564 
 2148      20636861 
 2148      7200
 2149              	.LASF23:
 2150 0209 70537461 		.ascii	"pState\000"
 2150      746500
 2151              	.LASF2:
 2152 0210 73686F72 		.ascii	"short int\000"
 2152      7420696E 
 2152      7400
 2153              	.LASF25:
 2154 021a 6D617844 		.ascii	"maxDelay\000"
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 153


 2154      656C6179 
 2154      00
 2155              	.LASF53:
 2156 0223 433A5C55 		.ascii	"C:\\Users\\fneves\\Documents\\PSoC Creator\\wp_1\\e"
 2156      73657273 
 2156      5C666E65 
 2156      7665735C 
 2156      446F6375 
 2157 0250 6E67696E 		.ascii	"ngine_speed_sensor.cydsn\000"
 2157      655F7370 
 2157      6565645F 
 2157      73656E73 
 2157      6F722E63 
 2158              	.LASF21:
 2159 0269 6E756D54 		.ascii	"numTaps\000"
 2159      61707300 
 2160              	.LASF27:
 2161 0271 61726D5F 		.ascii	"arm_fir_sparse_instance_f32\000"
 2161      6669725F 
 2161      73706172 
 2161      73655F69 
 2161      6E737461 
 2162              	.LASF14:
 2163 028d 75696E74 		.ascii	"uint32_t\000"
 2163      33325F74 
 2163      00
 2164              	.LASF16:
 2165 0296 63686172 		.ascii	"char\000"
 2165      00
 2166              	.LASF34:
 2167 029b 61726D5F 		.ascii	"arm_circularWrite_f32\000"
 2167      63697263 
 2167      756C6172 
 2167      57726974 
 2167      655F6633 
 2168              	.LASF4:
 2169 02b1 5F5F7569 		.ascii	"__uint16_t\000"
 2169      6E743136 
 2169      5F7400
 2170              	.LASF5:
 2171 02bc 5F5F696E 		.ascii	"__int32_t\000"
 2171      7433325F 
 2171      7400
 2172              	.LASF20:
 2173 02c6 666C6F61 		.ascii	"float32_t\000"
 2173      7433325F 
 2173      7400
 2174              	.LASF47:
 2175 02d0 72656164 		.ascii	"readIndex\000"
 2175      496E6465 
 2175      7800
 2176              	.LASF50:
 2177 02da 636F6566 		.ascii	"coeff\000"
 2177      6600
 2178              	.LASF38:
 2179 02e0 6473745F 		.ascii	"dst_length\000"
 2179      6C656E67 
ARM GAS  C:\Users\fneves\AppData\Local\Temp\cc6JXG81.s 			page 154


 2179      746800
 2180              	.LASF32:
 2181 02eb 626C6F63 		.ascii	"blockSize\000"
 2181      6B53697A 
 2181      6500
 2182              	.LASF41:
 2183 02f5 6473745F 		.ascii	"dst_end\000"
 2183      656E6400 
 2184              	.LASF24:
 2185 02fd 70436F65 		.ascii	"pCoeffs\000"
 2185      66667300 
 2186              	.LASF33:
 2187 0305 774F6666 		.ascii	"wOffset\000"
 2187      73657400 
 2188              	.LASF44:
 2189 030d 70536372 		.ascii	"pScratchIn\000"
 2189      61746368 
 2189      496E00
 2190              	.LASF46:
 2191 0318 64656C61 		.ascii	"delaySize\000"
 2191      7953697A 
 2191      6500
 2192              	.LASF35:
 2193 0322 61726D5F 		.ascii	"arm_circularRead_f32\000"
 2193      63697263 
 2193      756C6172 
 2193      52656164 
 2193      5F663332 
 2194              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
